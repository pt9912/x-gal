# GAL v1.3.0 - Implementierungsplan

**Target Release:** Q2 2026
**Focus:** Import/Migration & Provider Portability
**Estimated Effort:** 10-12 Wochen

---

## 🎯 Mission

**Provider Lock-in brechen:** Ermögliche Migration bestehender Gateway-Konfigurationen zu GAL und damit zu jedem anderen Provider.

### Vision

Unternehmen mit bestehenden Gateway-Deployments (Nginx, HAProxy, Kong, etc.) können ihre Konfigurationen **automatisch zu GAL konvertieren** und damit:
1. **Portabilität gewinnen** - Wechsel zu anderem Provider in Minuten statt Wochen
2. **Vendor Lock-in vermeiden** - Nicht mehr an einen Provider gebunden
3. **Multi-Provider nutzen** - Gleiche Config auf verschiedenen Providern
4. **Migration vereinfachen** - Nginx → HAProxy, Kong → Envoy, etc.

---

## 📋 Feature Overview

| # | Feature | Priority | Status | Effort | Dependencies |
|---|---------|----------|--------|--------|--------------|
| 1 | Config Import (Provider → GAL) | 🔴 High | 🔄 Pending | 8 Wochen | - |
| 2 | Config Validation & Compatibility Checker | 🟡 Medium | 🔄 Pending | 2 Wochen | Feature 1 |
| 3 | Migration Assistant (Interactive CLI) | 🟡 Medium | 🔄 Pending | 2 Wochen | Features 1, 2 |

**Total Estimated Effort:** 12 Wochen
**Progress:** 0/3 Features completed (0%)

---

## 🔄 Feature 1: Config Import (Provider → GAL)

**Status:** 🔄 **PENDING**
**Priority:** 🔴 High
**Effort:** 8 Wochen

### Motivation

Bestehende Gateway-Deployments können nicht einfach zu GAL migriert werden, weil:
- **Manuelle Konvertierung** ist zeitaufwendig und fehleranfällig
- **Feature-Mapping** ist komplex (verschiedene Terminologien)
- **Validierung** ob die Migration funktioniert ist schwierig
- **Migration-Projekte** scheitern oft wegen Aufwand

**Lösung:** Automatischer Import von Provider-Configs → GAL-Config

### Implementation Tasks

#### 1. Provider Interface erweitern

**File:** `gal/provider.py`

```python
from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any

class Provider(ABC):
    """Abstract base class for all gateway providers."""

    @abstractmethod
    def name(self) -> str:
        """Return provider name."""
        pass

    @abstractmethod
    def validate(self, config: Config) -> bool:
        """Validate GAL config."""
        pass

    @abstractmethod
    def generate(self, config: Config) -> str:
        """Generate provider-specific config from GAL (existiert bereits)."""
        pass

    @abstractmethod
    def parse(self, provider_config: str) -> Config:
        """Parse provider-specific config to GAL (NEU!)."""
        pass

    def get_import_warnings(self) -> List[str]:
        """Return warnings from last parse operation (optional)."""
        return []

    def get_import_report(self) -> Dict[str, Any]:
        """Return detailed import report (optional)."""
        return {
            "features_mapped": [],
            "features_skipped": [],
            "warnings": [],
            "provider_specific": {}
        }
```

#### 2. Parser pro Provider implementieren

**Envoy Parser** (`gal/providers/envoy.py`)

```python
class EnvoyProvider(Provider):
    def parse(self, provider_config: str) -> Config:
        """Parse envoy.yaml to GAL config."""
        import yaml

        envoy_config = yaml.safe_load(provider_config)

        # Extract global settings
        global_config = self._parse_global(envoy_config)

        # Extract services from static_resources
        services = self._parse_services(envoy_config)

        return Config(
            version="1.0",
            provider="envoy",
            global_config=global_config,
            services=services
        )

    def _parse_global(self, envoy_config: dict) -> GlobalConfig:
        """Extract global settings from Envoy config."""
        listeners = envoy_config.get("static_resources", {}).get("listeners", [])

        if listeners:
            address = listeners[0].get("address", {}).get("socket_address", {})
            host = address.get("address", "0.0.0.0")
            port = address.get("port_value", 10000)
        else:
            host, port = "0.0.0.0", 10000

        return GlobalConfig(host=host, port=port)

    def _parse_services(self, envoy_config: dict) -> List[Service]:
        """Extract services from Envoy clusters and routes."""
        services = []

        clusters = envoy_config.get("static_resources", {}).get("clusters", [])
        routes = self._extract_routes(envoy_config)

        # Map clusters to services
        for cluster in clusters:
            service = self._cluster_to_service(cluster, routes.get(cluster["name"], []))
            services.append(service)

        return services
```

**Kong Parser** (`gal/providers/kong.py`)

```python
class KongProvider(Provider):
    def parse(self, provider_config: str) -> Config:
        """Parse kong.yaml to GAL config."""
        import yaml

        kong_config = yaml.safe_load(provider_config)

        # Kong format: services, routes, upstreams
        services = self._parse_kong_services(kong_config)

        return Config(
            version="1.0",
            provider="kong",
            services=services
        )

    def _parse_kong_services(self, kong_config: dict) -> List[Service]:
        """Parse Kong services."""
        kong_services = kong_config.get("services", [])
        kong_routes = {r["service"]: r for r in kong_config.get("routes", [])}

        services = []
        for ks in kong_services:
            service = Service(
                name=ks["name"],
                type="rest",
                protocol=ks.get("protocol", "http"),
                upstream=self._parse_upstream(ks),
                routes=self._parse_routes(kong_routes.get(ks["name"]))
            )
            services.append(service)

        return services
```

**Nginx Parser** (`gal/providers/nginx.py`)

```python
class NginxProvider(Provider):
    def parse(self, provider_config: str) -> Config:
        """Parse nginx.conf to GAL config."""
        # Challenge: nginx.conf ist kein structured format!
        # Need custom parser

        from gal.parsers.nginx_parser import NginxConfigParser

        parser = NginxConfigParser()
        nginx_blocks = parser.parse(provider_config)

        # Extract http block
        http_block = nginx_blocks.get("http", {})

        # Parse upstreams
        upstreams = self._parse_upstreams(http_block.get("upstream", []))

        # Parse servers and locations
        services = self._parse_servers(http_block.get("server", []), upstreams)

        return Config(
            version="1.0",
            provider="nginx",
            services=services
        )

    def _parse_upstreams(self, upstream_blocks: List[dict]) -> Dict[str, Upstream]:
        """Parse upstream blocks."""
        upstreams = {}

        for ub in upstream_blocks:
            name = ub["name"]
            targets = []

            for server in ub.get("server", []):
                # Parse: "api-1.local:8080 weight=2"
                parts = server.split()
                host_port = parts[0]

                target = self._parse_server_line(host_port, parts[1:])
                targets.append(target)

            upstreams[name] = Upstream(targets=targets)

        return upstreams
```

**HAProxy Parser** (`gal/providers/haproxy.py`)

```python
class HAProxyProvider(Provider):
    def parse(self, provider_config: str) -> Config:
        """Parse haproxy.cfg to GAL config."""
        from gal.parsers.haproxy_parser import HAProxyConfigParser

        parser = HAProxyConfigParser()
        haproxy_config = parser.parse(provider_config)

        # HAProxy structure: global, defaults, frontend, backend
        frontends = haproxy_config.get("frontend", [])
        backends = haproxy_config.get("backend", [])

        services = self._map_backends_to_services(backends, frontends)

        return Config(
            version="1.0",
            provider="haproxy",
            services=services
        )
```

#### 3. Custom Parsers für Nginx/HAProxy

**File:** `gal/parsers/nginx_parser.py`

```python
class NginxConfigParser:
    """Parse nginx.conf (non-YAML format)."""

    def parse(self, config_text: str) -> dict:
        """Parse nginx config to structured dict."""
        # Use library like: crossplane, nginxparser
        import crossplane

        parsed = crossplane.parse(config_text)
        return self._normalize(parsed)

    def _normalize(self, parsed: dict) -> dict:
        """Normalize crossplane output to our structure."""
        # Convert to our dict structure
        pass
```

**File:** `gal/parsers/haproxy_parser.py`

```python
class HAProxyConfigParser:
    """Parse haproxy.cfg format."""

    def parse(self, config_text: str) -> dict:
        """Parse HAProxy config."""
        # Manual parsing - HAProxy has simple section-based format
        sections = {}
        current_section = None

        for line in config_text.split('\n'):
            line = line.strip()

            # Skip comments and empty lines
            if not line or line.startswith('#'):
                continue

            # Section headers
            if line.startswith(('global', 'defaults', 'frontend', 'backend')):
                section_type, section_name = self._parse_section_header(line)
                current_section = {
                    "type": section_type,
                    "name": section_name,
                    "config": []
                }
                sections.setdefault(section_type, []).append(current_section)

            # Config lines
            elif current_section:
                current_section["config"].append(line)

        return sections
```

#### 4. CLI Command: `gal import`

**File:** `gal-cli.py`

```python
@cli.command()
@click.option('--provider', '-p', required=True, help='Source provider')
@click.option('--input', '-i', required=True, help='Provider config file')
@click.option('--output', '-o', help='Output GAL config file (default: stdout)')
@click.option('--validate-only', is_flag=True, help='Only validate, do not convert')
@click.option('--dry-run', is_flag=True, help='Show what would be imported')
@click.option('--report', help='Save import report to file (JSON)')
def import_config(provider, input, output, validate_only, dry_run, report):
    """Import provider-specific config to GAL format."""
    try:
        manager = Manager()
        # Register all providers
        manager.register_provider(EnvoyProvider())
        manager.register_provider(KongProvider())
        # ... etc

        # Get provider
        provider_obj = manager.providers.get(provider)
        if not provider_obj:
            raise ValueError(f"Provider '{provider}' not supported")

        # Read input config
        with open(input, 'r') as f:
            provider_config = f.read()

        # Parse to GAL
        click.echo(f"Importing {provider} config from: {input}")
        gal_config = provider_obj.parse(provider_config)

        # Get import report
        import_report = provider_obj.get_import_report()

        if dry_run:
            click.echo("\n=== Import Preview ===")
            click.echo(f"Services found: {len(gal_config.services)}")
            click.echo(f"Features mapped: {len(import_report['features_mapped'])}")
            click.echo(f"Features skipped: {len(import_report['features_skipped'])}")
            click.echo(f"Warnings: {len(import_report['warnings'])}")
            return

        if validate_only:
            # Just validate without outputting
            manager.validate(gal_config)
            click.echo("✓ Import validation successful")
            return

        # Generate output
        output_yaml = gal_config.to_yaml()

        if output:
            with open(output, 'w') as f:
                f.write(output_yaml)
            click.echo(f"✓ GAL config written to: {output}")
        else:
            click.echo("\n" + output_yaml)

        # Save report if requested
        if report:
            import json
            with open(report, 'w') as f:
                json.dump(import_report, f, indent=2)
            click.echo(f"✓ Import report saved to: {report}")

        # Show warnings
        if import_report['warnings']:
            click.echo("\n⚠ Warnings:")
            for warning in import_report['warnings']:
                click.echo(f"  - {warning}")

    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)
```

### Feature Mapping

**Unterstützte Features:**

| GAL Feature | Envoy | Kong | APISIX | Traefik | Nginx | HAProxy |
|-------------|-------|------|--------|---------|-------|---------|
| Routing (path_prefix) | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| Methods (GET, POST) | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| Upstream (targets) | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| Load Balancing | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| Rate Limiting | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| Basic Auth | ⚠️ | ✅ | ✅ | ✅ | ✅ | ✅ |
| JWT Auth | ✅ | ✅ | ✅ | ⚠️ | ⚠️ | ⚠️ |
| Headers | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| CORS | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| Health Checks | ✅ | ✅ | ✅ | ✅ | ⚠️ | ✅ |

**Legende:**
- ✅ Full support - vollständig mapbar
- ⚠️ Partial support - teilweise mapbar mit Warnungen
- ❌ Not supported - nicht mapbar (→ `provider_specific`)

### Handling Non-Mappable Features

**Strategie:** `provider_specific` Section in GAL Config

```yaml
version: "1.0"
provider: envoy

services:
  - name: api_service
    upstream:
      host: api.local
      port: 8080
    routes:
      - path_prefix: /api

# Provider-specific config that couldn't be mapped
provider_specific:
  envoy:
    wasm_filters:
      - name: custom_filter
        config: "base64encoded..."

  warnings:
    - "Wasm filter 'custom_filter' is Envoy-specific and may not work on other providers"
```

### Testing Strategy

**Parser Tests** (pro Provider):
```python
# tests/test_import_envoy.py
def test_import_basic_envoy_config():
    """Test importing basic Envoy config."""
    envoy_yaml = """
    static_resources:
      listeners:
        - address:
            socket_address:
              address: 0.0.0.0
              port_value: 10000
      clusters:
        - name: api_cluster
          connect_timeout: 0.25s
          load_assignment:
            endpoints:
              - lb_endpoints:
                  - endpoint:
                      address:
                        socket_address:
                          address: api.local
                          port_value: 8080
    """

    provider = EnvoyProvider()
    config = provider.parse(envoy_yaml)

    assert config.provider == "envoy"
    assert len(config.services) == 1
    assert config.services[0].name == "api_cluster"
    assert config.services[0].upstream.targets[0].host == "api.local"
    assert config.services[0].upstream.targets[0].port == 8080
```

**Round-trip Tests:**
```python
def test_import_export_roundtrip():
    """Test that import → export produces similar config."""
    # Import Nginx config
    nginx_conf = read_file("examples/nginx-prod.conf")
    provider = NginxProvider()
    gal_config = provider.parse(nginx_conf)

    # Export back to Nginx
    nginx_conf_2 = provider.generate(gal_config)

    # Parse again
    gal_config_2 = provider.parse(nginx_conf_2)

    # Should be equivalent
    assert gal_config.services == gal_config_2.services
```

### Example Usage

```bash
# 1. Import Nginx config to GAL
gal import --provider nginx --input /etc/nginx/nginx.conf --output gal-config.yaml

# Output:
# Importing nginx config from: /etc/nginx/nginx.conf
# ✓ GAL config written to: gal-config.yaml
# ⚠ Warnings:
#   - Active health checks not supported in Nginx Open Source
#   - JWT auth requires OpenResty/Lua

# 2. Generate HAProxy config from GAL
gal generate --config gal-config.yaml --provider haproxy --output haproxy.cfg

# 3. DONE! Migrated Nginx → HAProxy
```

---

## ✅ Feature 2: Config Validation & Compatibility Checker

**Status:** 🔄 **PENDING**
**Priority:** 🟡 Medium
**Effort:** 2 Wochen
**Dependencies:** Feature 1

### Motivation

Nach Import oder vor Migration muss der Nutzer wissen:
- Funktioniert die GAL-Config auf dem Ziel-Provider?
- Welche Features werden unterstützt?
- Was muss angepasst werden?

### Implementation

**CLI Command:** `gal validate --target-provider`

```bash
# Check if config works on HAProxy
gal validate --config gal-config.yaml --target-provider haproxy

# Output:
# ✓ Config is compatible with HAProxy
# ⚠ Warnings:
#   - JWT authentication requires Lua scripting
#   - Active health checks are fully supported
#
# Compatibility: 95% (19/20 features supported)
```

**Provider Comparison:**

```bash
# Compare multiple providers
gal compare --config gal-config.yaml --providers envoy,kong,nginx,haproxy

# Output (table):
# Feature           | Envoy | Kong | Nginx | HAProxy
# ------------------|-------|------|-------|--------
# Rate Limiting     | ✅    | ✅   | ✅    | ✅
# JWT Auth          | ✅    | ✅   | ⚠️    | ⚠️
# Active HC         | ✅    | ✅   | ❌    | ✅
# Load Balancing    | ✅    | ✅   | ✅    | ✅
#
# Recommendation: Use Envoy or Kong for full compatibility
```

### Implementation Details

**File:** `gal/compatibility.py`

```python
class CompatibilityChecker:
    """Check config compatibility with providers."""

    def check_provider(self, config: Config, target_provider: str) -> CompatibilityReport:
        """Check if config works on target provider."""
        provider = get_provider(target_provider)

        report = CompatibilityReport(
            provider=target_provider,
            compatible=True,
            features_supported=[],
            features_unsupported=[],
            warnings=[]
        )

        # Check each feature
        for service in config.services:
            for route in service.routes:
                # Rate limiting
                if route.rate_limit and route.rate_limit.enabled:
                    if self._supports_rate_limiting(provider):
                        report.features_supported.append("rate_limiting")
                    else:
                        report.features_unsupported.append("rate_limiting")
                        report.compatible = False

                # Authentication
                if route.authentication and route.authentication.enabled:
                    auth_type = route.authentication.type
                    if self._supports_auth(provider, auth_type):
                        report.features_supported.append(f"auth_{auth_type}")
                    else:
                        report.warnings.append(
                            f"{auth_type} auth requires additional setup on {target_provider}"
                        )

                # ... check other features

        return report

    def compare_providers(self, config: Config, providers: List[str]) -> Dict[str, CompatibilityReport]:
        """Compare config compatibility across providers."""
        results = {}
        for provider_name in providers:
            results[provider_name] = self.check_provider(config, provider_name)
        return results
```

---

## 🔀 Feature 3: Migration Assistant (Interactive)

**Status:** 🔄 **PENDING**
**Priority:** 🟡 Medium
**Effort:** 2 Wochen
**Dependencies:** Features 1, 2

### Motivation

Migration sollte geführt und einfach sein:
- Interaktive Prompts
- Automatische Validierung
- Migration Report
- Recommendations

### Implementation

```bash
gal migrate

# Interactive prompts:
# ? Source Provider: nginx
# ? Source Config: /etc/nginx/nginx.conf
# ? Target Provider: haproxy
# ? Output Directory: ./migration/
#
# [1/5] Reading Nginx config...
# [2/5] Parsing and analyzing...
# [3/5] Converting to GAL format...
# [4/5] Validating compatibility with HAProxy...
# [5/5] Generating HAProxy config...
#
# ✓ Migration complete!
#
# Files created:
#   - ./migration/gal-config.yaml (GAL format)
#   - ./migration/haproxy.cfg (HAProxy config)
#   - ./migration/migration-report.md (Migration report)
#
# Compatibility: 95% (19/20 features)
# Warnings: 2
#   - JWT auth requires Lua (see docs)
#   - Passive health checks use fall/rise thresholds
#
# Next steps:
#   1. Review migration-report.md
#   2. Test haproxy.cfg in staging
#   3. Deploy to production
```

### Migration Report Format

**File:** `migration-report.md`

```markdown
# Migration Report: Nginx → HAProxy

**Date:** 2026-04-15
**Source:** /etc/nginx/nginx.conf
**Target:** HAProxy 2.8

## Summary

- **Compatibility:** 95% (19/20 features)
- **Services Migrated:** 3
- **Routes Migrated:** 12
- **Warnings:** 2

## Features Migrated

✅ **Load Balancing**
- Algorithm: Round Robin → roundrobin
- Targets: 6 backends

✅ **Rate Limiting**
- IP-based: 100 req/s
- Converted to stick-table

✅ **Headers**
- Request headers: 5 mapped
- Response headers: 3 mapped

⚠️ **Authentication**
- Basic Auth: ✅ Supported
- JWT Auth: ⚠️ Requires Lua scripting

## Warnings

1. **JWT Authentication**
   - Nginx uses OpenResty/Lua
   - HAProxy requires Lua scripting or external auth
   - **Recommendation:** Use Kong or Envoy for native JWT

2. **Passive Health Checks**
   - Nginx: max_fails, fail_timeout
   - HAProxy: fall, rise thresholds
   - **Action:** Review and adjust thresholds

## Testing Recommendations

1. **Staging Deployment**
   ```bash
   haproxy -c -f migration/haproxy.cfg
   haproxy -f migration/haproxy.cfg
   ```

2. **Functional Tests**
   - Test all 12 routes
   - Verify load balancing distribution
   - Check rate limiting behavior

3. **Performance Tests**
   - Compare response times
   - Monitor backend health
   - Verify connection pooling

## Next Steps

1. ✅ Review this report
2. ⏳ Test in staging environment
3. ⏳ Adjust JWT authentication
4. ⏳ Deploy to production
5. ⏳ Monitor and validate
```

---

## 📊 Success Metrics

### Coverage Targets

- **Parser Coverage:** 95%+ für Standard-Konfigurationen
- **Feature Mapping:** 90%+ der v1.1.0/v1.2.0 Features
- **Test Coverage:** 500+ Tests für alle Parser
- **Documentation:** 500+ Zeilen pro Provider Guide

### Deliverables

**Code:**
- ✅ 6 Provider Parser (envoy, kong, apisix, traefik, nginx, haproxy)
- ✅ CLI: `gal import`, `gal validate --target-provider`, `gal compare`, `gal migrate`
- ✅ Custom Parsers: nginx_parser.py, haproxy_parser.py
- ✅ Compatibility Checker: compatibility.py
- ✅ Tests: 500+ tests

**Documentation:**
- ✅ docs/guides/IMPORT_MIGRATION.md (500+ lines, German)
- ✅ Migration Guides pro Provider (6 x 100+ lines)
- ✅ Feature Mapping Matrix
- ✅ Troubleshooting Guide

**Examples:**
- ✅ examples/import/ (6 Provider-Configs zum Testen)
- ✅ examples/migration/ (3 Migration Workflows)

---

## 🗓️ Timeline

### Phase 1: Foundation (Weeks 1-2)
- Provider Interface Extension (parse method)
- YAML-based Parsers (Envoy, Kong, APISIX, Traefik)
- Basic Tests

### Phase 2: Complex Parsers (Weeks 3-5)
- Nginx Parser (custom format)
- HAProxy Parser (custom format)
- Feature Mapping Logic
- Comprehensive Tests

### Phase 3: CLI & Validation (Weeks 6-8)
- `gal import` command
- `gal validate --target-provider`
- `gal compare`
- Round-trip tests

### Phase 4: Migration Assistant (Weeks 9-10)
- `gal migrate` interactive command
- Migration reports
- User testing

### Phase 5: Documentation & Polish (Weeks 11-12)
- Complete documentation
- Migration guides
- Examples and tutorials
- Beta testing

---

## 🎯 Use Cases

### Use Case 1: Nginx → HAProxy Migration

**Scenario:** E-Commerce-Unternehmen mit Nginx möchte zu HAProxy wechseln für bessere Health Checks.

```bash
# 1. Import Nginx config
gal import --provider nginx --input /etc/nginx/nginx.conf --output gal-config.yaml

# 2. Check compatibility
gal validate --config gal-config.yaml --target-provider haproxy

# 3. Generate HAProxy config
gal generate --config gal-config.yaml --provider haproxy --output haproxy.cfg

# 4. Test
haproxy -c -f haproxy.cfg
```

### Use Case 2: Kong → Envoy Migration

**Scenario:** Startup mit Kong möchte zu Envoy für Service Mesh Integration.

```bash
# Interactive migration
gal migrate
# > Source: kong
# > Target: envoy
# > Creates migration report
```

### Use Case 3: Multi-Provider Deployment

**Scenario:** Großunternehmen will gleiche Config auf verschiedenen Providern.

```bash
# 1. Import production HAProxy config
gal import --provider haproxy --input haproxy-prod.cfg --output gal-config.yaml

# 2. Generate for all providers
gal generate-all --config gal-config.yaml

# Result: envoy.yaml, kong.yaml, apisix.json, traefik.yaml, nginx.conf, haproxy.cfg
```

---

## 🚀 Next Steps

1. **Review & Approval:** Diskussion über Scope und Prioritäten
2. **Start Implementation:** Begin mit Phase 1 (YAML parsers)
3. **Community Feedback:** RFC für Import Feature
4. **Beta Testing:** Mit Real-World Configs testen

---

**Target Release:** Q2 2026
**Current Status:** Planning Phase
**Next Milestone:** Start Phase 1 Implementation
