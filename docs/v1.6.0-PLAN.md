# v1.6.0 Implementierungsplan

**Status:** 🔄 Geplant
**Zeitplan:** Q1 2027 (geschätzt)
**Fokus:** Web UI / Dashboard, Service Mesh & Multi-Tenancy
**Estimated Effort:** 10-12 Wochen

---

## Mission

**"Enterprise Tooling: Visual Configuration + Service Mesh + Multi-Tenancy"**

Erweitere GAL mit professionellen Enterprise-Features: **Web UI** für visuelle Konfiguration, **Service Mesh Integration** für Cloud-Native Deployments und **Multi-Tenant Support** für mandantenfähige Architekturen.

**Nach v1.6.0 hat GAL:**
- ✅ **8 Provider** (Envoy, Kong, APISIX, Traefik, Nginx, HAProxy, KrakenD, Caddy)
- 🆕 **Web UI / Dashboard** für visuelle Konfiguration
- 🆕 **Service Mesh Integration** (Istio, Linkerd, Consul Connect)
- 🆕 **Multi-Tenant Support** mit Namespace Isolation

---

## Feature-Übersicht

| Feature | Status | Aufwand | Priorität |
|---------|--------|---------|-----------|
| **1. Web UI / Dashboard** | 🔄 Ausstehend | 5 Wochen | 🔴 Hoch |
| **2. Service Mesh Integration** | 🔄 Ausstehend | 4 Wochen | 🔴 Hoch |
| **3. Multi-Tenant Support** | 🔄 Ausstehend | 3 Wochen | 🟡 Mittel |

**Gesamtaufwand:** 10-12 Wochen
**Fortschritt:** 0/3 Features (0%)

---

## Feature 1: Web UI / Dashboard (DETAILLIERT)

**Status:** 🔄 Ausstehend
**Priorität:** 🔴 Hoch
**Aufwand:** 5 Wochen

### Motivation

- **Problem**: Konfiguration via YAML-Dateien ist für nicht-technische Nutzer schwierig
- **Herausforderung**: Komplexe Gateway-Konfigurationen visuell darstellen und editieren
- **Lösung**: Moderne Web UI mit Drag & Drop, Real-time Validation und Provider Comparison

### Warum Web UI?

**Vorteile:**
- ✅ **Visual Configuration Builder**: Konfiguration per Drag & Drop
- ✅ **Real-time Validation**: Sofortiges Feedback bei Konfigurationsfehlern
- ✅ **Provider Comparison**: Visueller Vergleich von Provider-Kompatibilität
- ✅ **Config Export/Import**: YAML/JSON Upload & Download
- ✅ **Multi-Provider Generation**: Gleichzeitige Config-Generierung für alle Provider
- ✅ **Configuration Visualization**: Graphische Darstellung von Routes, Services, Upstreams
- ✅ **Testing Interface**: Integriertes Testing von Routen

**Use Cases:**
- Entwickler: Schnelle Prototyping von Gateway-Configs
- DevOps: Visuelle Validierung vor Deployment
- Non-Technical Users: Einfache Konfiguration ohne YAML-Kenntnisse
- Teams: Kollaborative Konfigurationserstellung
- Training: Lernplattform für Gateway-Konzepte

### Technology Stack

**Frontend:**
- **Framework**: React 18+ mit TypeScript
- **UI Library**: Tailwind CSS + shadcn/ui components
- **State Management**: Redux Toolkit + RTK Query
- **Visualization**: React Flow (für Diagramme), Recharts (für Metriken)
- **Code Editor**: Monaco Editor (YAML/JSON Syntax Highlighting)
- **Form Handling**: React Hook Form + Zod Validation

**Backend:**
- **Framework**: FastAPI (Python) - Reuse existing GAL code!
- **Authentication**: JWT-based (optional)
- **API**: RESTful API + WebSocket (für Live-Updates)
- **Storage**: File-based (YAML configs) + Optional SQLite (für Projekte)

**Deployment:**
- **Containerization**: Docker + Docker Compose
- **Reverse Proxy**: Caddy (für Auto-HTTPS)
- **Static Hosting**: Nginx (für Production)

### UI Komponenten

**1. Dashboard (Landing Page)**
- Provider Overview (8 Provider mit Status)
- Recent Configurations
- Quick Actions (New Config, Import, Compare)
- Documentation Links

**2. Configuration Builder**
- **Left Sidebar**: Provider Selection, Feature Library
- **Canvas**: Drag & Drop Configuration
  - Services (Boxes mit Upstreams)
  - Routes (Verbindungslinien)
  - Features (Icons für Rate Limiting, Auth, etc.)
- **Right Panel**: Property Editor (Forms für ausgewählte Elemente)
- **Bottom Bar**: Validation Messages, Export Buttons

**3. Provider Comparison View**
- Table mit Feature-Support Matrix (wie docs/import/compatibility.md)
- Compatibility Score pro Provider
- Filter: Nur verfügbare Features, Nur fehlende Features
- Export: Screenshot, PDF Report

**4. Code Editor**
- Split View: YAML (links) + JSON (rechts)
- Syntax Highlighting (Monaco Editor)
- Real-time Validation (Inline Errors)
- Format Button (Prettier)
- Import/Export (File Upload/Download)

**5. Testing Interface**
- Route Tester: HTTP Method, Path, Headers
- Mock Responses
- Upstream Health Status
- Live Logs (WebSocket)

**6. Export/Deploy View**
- Multi-Provider Export (Checkboxes für alle 8 Provider)
- Download as ZIP (alle Config-Dateien)
- Copy to Clipboard
- Deploy Buttons (für Kubernetes, Docker Compose)

### API Endpoints (FastAPI Backend)

```python
# gal/api/main.py

from fastapi import FastAPI, HTTPException, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Any
from gal.config import Config
from gal.manager import Manager

app = FastAPI(title="GAL Web UI API", version="1.6.0")

# CORS für Frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # React Dev Server
    allow_methods=["*"],
    allow_headers=["*"],
)

# Schemas
class ConfigRequest(BaseModel):
    config: Dict[str, Any]
    target_provider: str

class CompatibilityRequest(BaseModel):
    config: Dict[str, Any]
    providers: List[str]

# Routes

@app.get("/")
def root():
    return {"message": "GAL Web UI API v1.6.0", "docs": "/docs"}

@app.get("/providers")
def list_providers():
    """Liste alle verfügbaren Provider."""
    return {
        "providers": [
            {"name": "envoy", "version": "1.0.0", "status": "stable"},
            {"name": "kong", "version": "1.1.0", "status": "stable"},
            {"name": "apisix", "version": "1.1.0", "status": "stable"},
            {"name": "traefik", "version": "1.1.0", "status": "stable"},
            {"name": "nginx", "version": "1.3.0", "status": "stable"},
            {"name": "haproxy", "version": "1.3.0", "status": "stable"},
            {"name": "krakend", "version": "1.5.0", "status": "stable"},
            {"name": "caddy", "version": "1.5.0", "status": "stable"},
        ]
    }

@app.post("/generate")
def generate_config(request: ConfigRequest):
    """Generiere Provider-Config aus GAL Config."""
    try:
        config = Config(**request.config)
        manager = Manager()
        output = manager.generate(config, request.target_provider)
        return {"config": output, "provider": request.target_provider}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/generate-all")
def generate_all_configs(config: Dict[str, Any]):
    """Generiere Configs für alle Provider."""
    try:
        gal_config = Config(**config)
        manager = Manager()
        results = {}
        providers = ["envoy", "kong", "apisix", "traefik", "nginx", "haproxy", "krakend", "caddy"]

        for provider in providers:
            try:
                output = manager.generate(gal_config, provider)
                results[provider] = {"config": output, "success": True}
            except Exception as e:
                results[provider] = {"error": str(e), "success": False}

        return {"results": results}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/validate")
def validate_config(config: Dict[str, Any]):
    """Validiere GAL Config."""
    try:
        gal_config = Config(**config)
        # Pydantic validation erfolgt automatisch
        return {"valid": True, "message": "Configuration is valid"}
    except Exception as e:
        return {"valid": False, "errors": str(e)}

@app.post("/compatibility")
def check_compatibility(request: CompatibilityRequest):
    """Prüfe Kompatibilität mit Providern."""
    from gal.compatibility import CompatibilityChecker

    try:
        gal_config = Config(**request.config)
        checker = CompatibilityChecker()
        results = {}

        for provider in request.providers:
            report = checker.check_provider(gal_config, provider)
            results[provider] = {
                "score": checker.calculate_score(report),
                "supported": len(report.supported),
                "partial": len(report.partial_support),
                "unsupported": len(report.unsupported),
            }

        return {"results": results}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/import")
async def import_config(file: UploadFile, provider: str):
    """Importiere Provider-Config → GAL Config."""
    from gal.providers import get_provider

    try:
        content = await file.read()
        provider_instance = get_provider(provider)

        if not hasattr(provider_instance, 'parse'):
            raise HTTPException(status_code=400, detail=f"Provider {provider} does not support import")

        gal_config = provider_instance.parse(content.decode())
        return {"config": gal_config.dict(), "provider": provider}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/templates")
def list_templates():
    """Liste vordefinierte Config-Templates."""
    return {
        "templates": [
            {
                "name": "Simple Reverse Proxy",
                "description": "Basic reverse proxy with load balancing",
                "config": {
                    "version": "1.0",
                    "services": [
                        {
                            "name": "backend",
                            "protocol": "http",
                            "upstream": {
                                "targets": [
                                    {"host": "backend-1", "port": 8080},
                                    {"host": "backend-2", "port": 8080}
                                ],
                                "load_balancer": {"algorithm": "round_robin"}
                            },
                            "routes": [{"path_prefix": "/"}]
                        }
                    ]
                }
            },
            {
                "name": "API Gateway with Rate Limiting",
                "description": "REST API with rate limiting and CORS",
                "config": {
                    "version": "1.0",
                    "services": [
                        {
                            "name": "api",
                            "protocol": "http",
                            "upstream": {
                                "targets": [{"host": "api-server", "port": 3000}]
                            },
                            "routes": [
                                {
                                    "path_prefix": "/api",
                                    "rate_limit": {
                                        "enabled": True,
                                        "requests_per_second": 100
                                    },
                                    "cors": {
                                        "enabled": True,
                                        "allow_origins": ["*"],
                                        "allow_methods": ["GET", "POST", "PUT", "DELETE"]
                                    }
                                }
                            ]
                        }
                    ]
                }
            }
        ]
    }
```

### Frontend Implementierung (React)

**Datei:** `web/src/App.tsx`

```typescript
import React from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Dashboard from './pages/Dashboard';
import ConfigBuilder from './pages/ConfigBuilder';
import ProviderComparison from './pages/ProviderComparison';
import CodeEditor from './pages/CodeEditor';
import TestingInterface from './pages/TestingInterface';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Dashboard />} />
        <Route path="/builder" element={<ConfigBuilder />} />
        <Route path="/compare" element={<ProviderComparison />} />
        <Route path="/editor" element={<CodeEditor />} />
        <Route path="/test" element={<TestingInterface />} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;
```

**Datei:** `web/src/pages/ConfigBuilder.tsx` (Simplified)

```typescript
import React, { useState } from 'react';
import ReactFlow, { Background, Controls } from 'reactflow';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';

const ConfigBuilder: React.FC = () => {
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);

  const handleExport = async (provider: string) => {
    const response = await fetch('/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        config: { /* GAL config from nodes/edges */ },
        target_provider: provider
      })
    });

    const data = await response.json();
    // Download config file
    downloadFile(data.config, `${provider}-config.yaml`);
  };

  return (
    <div className="flex h-screen">
      {/* Left Sidebar */}
      <aside className="w-64 bg-gray-800 p-4">
        <h2 className="text-white text-lg mb-4">Features</h2>
        {/* Drag & Drop Feature Library */}
      </aside>

      {/* Canvas */}
      <main className="flex-1">
        <ReactFlow nodes={nodes} edges={edges}>
          <Background />
          <Controls />
        </ReactFlow>
      </main>

      {/* Right Panel */}
      <aside className="w-80 bg-gray-100 p-4">
        <h2 className="text-lg mb-4">Properties</h2>
        {/* Form for selected node */}
      </aside>

      {/* Bottom Bar */}
      <footer className="fixed bottom-0 w-full bg-white border-t p-4">
        <div className="flex justify-between">
          <div>Validation: ✅ Config is valid</div>
          <div className="space-x-2">
            <button onClick={() => handleExport('envoy')}>Export Envoy</button>
            <button onClick={() => handleExport('kong')}>Export Kong</button>
            {/* ... other providers */}
          </div>
        </div>
      </footer>
    </div>
  );
};

export default ConfigBuilder;
```

### Testing-Strategie

**Backend Tests:** `tests/test_api.py` (20+ Tests)

```python
# Test-Kategorien:
# 1. Provider listing
# 2. Config generation (single provider)
# 3. Config generation (all providers)
# 4. Config validation
# 5. Compatibility checking
# 6. Config import
# 7. Template listing
# 8. Error handling
```

**Frontend Tests:** `web/src/__tests__/` (15+ Tests)

```javascript
// Test-Kategorien:
// 1. Component rendering
// 2. User interactions (Drag & Drop)
// 3. Form validation
// 4. API calls (Mocked)
// 5. Export functionality
```

### Dokumentation

**Datei:** `docs/guides/WEB_UI.md` (800+ Zeilen, Deutsch)

Abschnitte:
- Übersicht & Features
- Installation & Setup
- User Guide (Schritt-für-Schritt)
- Configuration Builder Tutorial
- Provider Comparison Guide
- Code Editor Usage
- Testing Interface
- Deployment (Docker, Kubernetes)
- API Documentation (FastAPI /docs)
- Troubleshooting

**Datei:** `web/README.md` (300+ Zeilen, English)

- Development Setup
- Build & Deploy
- Technology Stack
- Component Structure
- API Integration

### Meilensteine

**Woche 1:** Backend API + Basic Frontend
- FastAPI Backend mit Core Endpoints
- React App Setup mit Routing
- Provider Listing + Config Validation
- 10+ Backend Tests

**Woche 2:** Configuration Builder (Drag & Drop)
- React Flow Integration
- Service/Route Nodes
- Property Editor Forms
- Real-time Validation

**Woche 3:** Code Editor + Import/Export
- Monaco Editor Integration
- YAML/JSON Support
- File Upload/Download
- Multi-Provider Export

**Woche 4:** Provider Comparison + Testing Interface
- Compatibility Checker Integration
- Comparison Table
- Route Tester
- WebSocket Live Logs

**Woche 5:** Documentation + Deployment + Polish
- docs/guides/WEB_UI.md
- Docker + Docker Compose
- Production Build
- UI/UX Polish
- 5+ Frontend Tests

### Akzeptanzkriterien

✅ FastAPI Backend mit 7+ Endpoints
✅ React Frontend mit 5 Pages
✅ Configuration Builder (Drag & Drop)
✅ Code Editor mit Syntax Highlighting
✅ Multi-Provider Export funktioniert
✅ Provider Comparison View
✅ Config Import/Export
✅ Real-time Validation
✅ 20+ Backend Tests bestehen
✅ 15+ Frontend Tests bestehen
✅ 800+ Zeilen deutsche Dokumentation
✅ Docker Deployment-Setup

### Deployment-Beispiel

```bash
# Docker Compose Setup
docker-compose up -d

# Backend: http://localhost:8000
# Frontend: http://localhost:3000

# Oder Production Build
cd web && npm run build
# Deploy dist/ folder to Nginx/Caddy
```

---

## Feature 2: Service Mesh Integration (DETAILLIERT)

**Status:** 🔄 Ausstehend
**Priorität:** 🔴 Hoch
**Aufwand:** 4 Wochen

### Motivation

- **Problem**: Service Meshes (Istio, Linkerd, Consul) haben eigene Konfigurationsformate
- **Herausforderung**: GAL-Configs zu Service Mesh CRDs (Kubernetes Custom Resources) konvertieren
- **Lösung**: GAL generiert Service Mesh Manifests aus einheitlicher YAML-Konfiguration

### Warum Service Mesh Integration?

**Vorteile:**
- ✅ **Unified Configuration**: GAL Config → Istio VirtualService, Linkerd ServiceProfile, Consul Config
- ✅ **Multi-Mesh Support**: Gleiche GAL Config für alle 3 Service Meshes
- ✅ **Cloud-Native**: Kubernetes-native Deployment
- ✅ **mTLS Support**: Automatisches Mutual TLS
- ✅ **Observability**: Tracing, Metrics, Logs integration

**Use Cases:**
- Kubernetes Deployments mit Istio
- Zero-Trust Networks mit Linkerd
- Service-to-Service Auth mit Consul Connect
- Multi-Cloud Deployments

### Supported Service Meshes

#### 1. Istio Support

**GAL Config → Istio Manifests:**

```yaml
# GAL Config
services:
  - name: reviews
    protocol: http
    upstream:
      targets:
        - host: reviews-v1
          port: 9080
          weight: 80
        - host: reviews-v2
          port: 9080
          weight: 20
      load_balancer:
        algorithm: round_robin
    routes:
      - path_prefix: /reviews
        timeout:
          request: 10s
        retry:
          attempts: 3
```

**Generated Istio Manifests:**

```yaml
# VirtualService
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: reviews
spec:
  hosts:
    - reviews
  http:
    - match:
        - uri:
            prefix: /reviews
      route:
        - destination:
            host: reviews-v1
            port:
              number: 9080
          weight: 80
        - destination:
            host: reviews-v2
            port:
              number: 9080
          weight: 20
      timeout: 10s
      retries:
        attempts: 3

---
# DestinationRule
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: reviews
spec:
  host: reviews
  trafficPolicy:
    loadBalancer:
      simple: ROUND_ROBIN
  subsets:
    - name: v1
      labels:
        version: v1
    - name: v2
      labels:
        version: v2
```

#### 2. Linkerd Support

**GAL Config → Linkerd ServiceProfile:**

```yaml
apiVersion: linkerd.io/v1alpha2
kind: ServiceProfile
metadata:
  name: reviews.default.svc.cluster.local
  namespace: default
spec:
  routes:
    - name: GET /reviews
      condition:
        method: GET
        pathRegex: /reviews.*
      timeout: 10s
      retryBudget:
        retryRatio: 0.2
        minRetriesPerSecond: 10
        ttl: 10s
```

#### 3. Consul Connect Support

**GAL Config → Consul Service Config:**

```hcl
Kind = "service-router"
Name = "reviews"
Routes = [
  {
    Match {
      HTTP {
        PathPrefix = "/reviews"
      }
    }
    Destination {
      Service = "reviews"
      RequestTimeout = "10s"
      NumRetries = 3
    }
  }
]
```

### Provider-Implementierung

**Datei:** `gal/providers/istio.py`

```python
from gal.config import Config, Service, Route
from gal.providers.base import Provider
import yaml

class IstioProvider(Provider):
    """Istio Service Mesh Provider für GAL."""

    def __init__(self):
        super().__init__("istio")

    def generate(self, config: Config) -> str:
        """Generiere Istio VirtualService + DestinationRule."""
        manifests = []

        for service in config.services:
            # VirtualService
            vs = self._generate_virtual_service(service)
            manifests.append(vs)

            # DestinationRule
            dr = self._generate_destination_rule(service)
            manifests.append(dr)

        # YAML output with ---
        return "\n---\n".join([yaml.dump(m) for m in manifests])

    def _generate_virtual_service(self, service: Service):
        vs = {
            "apiVersion": "networking.istio.io/v1beta1",
            "kind": "VirtualService",
            "metadata": {"name": service.name},
            "spec": {
                "hosts": [service.name],
                "http": []
            }
        }

        for route in service.routes:
            http_route = {
                "match": [{"uri": {"prefix": route.path_prefix}}],
                "route": []
            }

            # Weighted routing
            if service.upstream and service.upstream.targets:
                for target in service.upstream.targets:
                    destination = {
                        "destination": {
                            "host": target.host,
                            "port": {"number": target.port}
                        }
                    }
                    if target.weight:
                        destination["weight"] = target.weight
                    http_route["route"].append(destination)

            # Timeout
            if route.timeout:
                http_route["timeout"] = route.timeout.request

            # Retry
            if route.retry:
                http_route["retries"] = {
                    "attempts": route.retry.attempts
                }

            vs["spec"]["http"].append(http_route)

        return vs

    def _generate_destination_rule(self, service: Service):
        dr = {
            "apiVersion": "networking.istio.io/v1beta1",
            "kind": "DestinationRule",
            "metadata": {"name": service.name},
            "spec": {
                "host": service.name,
                "trafficPolicy": {}
            }
        }

        # Load Balancing
        if service.upstream and service.upstream.load_balancer:
            lb_algo = service.upstream.load_balancer.algorithm
            lb_map = {
                "round_robin": "ROUND_ROBIN",
                "least_connections": "LEAST_CONN",
                "random": "RANDOM"
            }
            dr["spec"]["trafficPolicy"]["loadBalancer"] = {
                "simple": lb_map.get(lb_algo, "ROUND_ROBIN")
            }

        # Circuit Breaker
        if service.upstream and service.upstream.circuit_breaker:
            cb = service.upstream.circuit_breaker
            dr["spec"]["trafficPolicy"]["connectionPool"] = {
                "http": {
                    "http1MaxPendingRequests": cb.max_requests or 1024,
                    "maxRequestsPerConnection": 1
                }
            }
            dr["spec"]["trafficPolicy"]["outlierDetection"] = {
                "consecutiveErrors": cb.failure_threshold or 5,
                "interval": "30s",
                "baseEjectionTime": "30s"
            }

        return dr
```

**Datei:** `gal/providers/linkerd.py` (Similar structure)

**Datei:** `gal/providers/consul.py` (Similar structure)

### Testing-Strategie

**Datei:** `tests/test_service_mesh.py` (30+ Tests)

```python
# Test-Kategorien:
# Istio (12 tests)
# 1. VirtualService generation (path, methods)
# 2. DestinationRule generation (load balancing)
# 3. Weighted routing
# 4. Timeout configuration
# 5. Retry policies
# 6. Circuit breaker (outlierDetection)

# Linkerd (10 tests)
# 1. ServiceProfile generation
# 2. Route configuration
# 3. Timeout & Retry

# Consul (8 tests)
# 1. Service Router generation
# 2. Service Splitter (weighted routing)
# 3. Service Resolver
```

### Dokumentation

**Datei:** `docs/guides/SERVICE_MESH.md` (1000+ Zeilen, Deutsch)

Abschnitte:
- Übersicht Service Mesh Integration
- Istio Integration (VirtualService, DestinationRule, Gateway, mTLS)
- Linkerd Integration (ServiceProfile, TrafficSplit)
- Consul Connect Integration (Service Router, Splitter, Resolver)
- Kubernetes Deployment Guide
- mTLS Configuration
- Observability (Tracing, Metrics)
- Troubleshooting

**Datei:** `examples/service-mesh/` (12+ YAML Files)

- istio-simple.yaml
- istio-weighted-routing.yaml
- istio-circuit-breaker.yaml
- linkerd-simple.yaml
- consul-simple.hcl

### Meilensteine

**Woche 1:** Istio Provider
- IstioProvider Klasse
- VirtualService Generation
- DestinationRule Generation
- 12+ Tests

**Woche 2:** Linkerd Provider
- LinkerdProvider Klasse
- ServiceProfile Generation
- TrafficSplit Support
- 10+ Tests

**Woche 3:** Consul Provider
- ConsulProvider Klasse
- Service Router, Splitter, Resolver
- 8+ Tests

**Woche 4:** Documentation + Examples + Integration
- docs/guides/SERVICE_MESH.md (1000+ Zeilen)
- examples/service-mesh/* (12+ Files)
- CLI Integration
- Kubernetes Deployment Guides

### Akzeptanzkriterien

✅ IstioProvider generiert valide Manifests
✅ LinkerdProvider generiert valide ServiceProfiles
✅ ConsulProvider generiert valide Consul Configs
✅ Weighted Routing funktioniert
✅ Timeout & Retry Support
✅ Circuit Breaker Support (Istio)
✅ 30+ Tests bestehen (100% passing)
✅ 1000+ Zeilen deutsche Dokumentation
✅ 12+ Beispiel-Manifests
✅ CLI Integration komplett

### Deployment-Beispiel

```bash
# Istio
gal generate --config config.yaml --provider istio --output istio-manifests.yaml
kubectl apply -f istio-manifests.yaml

# Linkerd
gal generate --config config.yaml --provider linkerd --output linkerd-profile.yaml
kubectl apply -f linkerd-profile.yaml

# Consul
gal generate --config config.yaml --provider consul --output consul-config.hcl
consul config write consul-config.hcl
```

---

## Feature 3: Multi-Tenant Support (DETAILLIERT)

**Status:** 🔄 Ausstehend
**Priorität:** 🟡 Mittel
**Aufwand:** 3 Wochen

### Motivation

- **Problem**: SaaS-Anwendungen benötigen mandantenfähige Gateway-Konfigurationen
- **Herausforderung**: Isolation von Tenants mit unterschiedlichen Policies
- **Lösung**: GAL generiert Tenant-spezifische Konfigurationen mit Namespace Isolation

### Warum Multi-Tenant Support?

**Vorteile:**
- ✅ **Namespace Isolation**: Tenants haben separate Konfigurationen
- ✅ **Per-Tenant Rate Limiting**: Unterschiedliche Limits pro Tenant
- ✅ **Tenant Identification**: Header-basiert, Subdomain-basiert, JWT-basiert
- ✅ **Configuration Inheritance**: Globale + Tenant-spezifische Configs
- ✅ **Dynamic Tenant Onboarding**: Neue Tenants ohne Downtime

**Use Cases:**
- SaaS Platforms
- API-as-a-Service
- Multi-Org Deployments
- White-Label Applications

### Tenant Configuration Model

**Datei:** `gal/config.py` (Extension)

```python
from typing import Optional, Dict

class TenantConfig(BaseModel):
    """Tenant-spezifische Konfiguration."""
    tenant_id: str
    identification_method: str  # header, subdomain, jwt
    identification_value: Optional[str] = None  # X-Tenant-ID, *.example.com, claim name

    # Tenant-specific overrides
    rate_limit_override: Optional[RateLimitConfig] = None
    authentication_override: Optional[AuthConfig] = None
    custom_headers: Optional[Dict[str, str]] = None

class MultiTenantConfig(BaseModel):
    """Multi-Tenant Konfiguration."""
    enabled: bool = False
    default_tenant: Optional[str] = None
    tenants: List[TenantConfig] = []

    # Global settings
    namespace_isolation: bool = True  # Separate namespaces per tenant
    shared_upstream: bool = False  # Same upstream for all tenants
```

### Provider-Implementierung

**Datei:** `gal/providers/envoy.py` (Extension)

```python
def generate_multi_tenant(self, config: Config) -> Dict[str, str]:
    """Generiere separate Envoy-Configs pro Tenant."""
    if not config.multi_tenant or not config.multi_tenant.enabled:
        return {"default": self.generate(config)}

    tenant_configs = {}

    for tenant in config.multi_tenant.tenants:
        # Clone config and apply tenant overrides
        tenant_config = config.copy(deep=True)

        # Apply tenant-specific rate limiting
        if tenant.rate_limit_override:
            for service in tenant_config.services:
                for route in service.routes:
                    route.rate_limit = tenant.rate_limit_override

        # Apply tenant identification (via headers)
        if tenant.identification_method == "header":
            for service in tenant_config.services:
                for route in service.routes:
                    if not route.headers:
                        route.headers = HeaderManipulation()
                    route.headers.request_add[tenant.identification_value] = tenant.tenant_id

        # Generate config for this tenant
        tenant_configs[tenant.tenant_id] = self.generate(tenant_config)

    return tenant_configs
```

### Example Configuration

```yaml
version: "1.0"
provider: envoy

# Multi-Tenant Configuration
multi_tenant:
  enabled: true
  namespace_isolation: true
  default_tenant: "tenant-default"

  tenants:
    - tenant_id: "tenant-acme"
      identification_method: "header"
      identification_value: "X-Tenant-ID"
      rate_limit_override:
        enabled: true
        requests_per_second: 1000  # Premium tier
      custom_headers:
        X-Tenant-Name: "ACME Corp"

    - tenant_id: "tenant-startup"
      identification_method: "subdomain"
      identification_value: "startup"
      rate_limit_override:
        enabled: true
        requests_per_second: 100  # Free tier
      custom_headers:
        X-Tenant-Name: "Startup Inc"

services:
  - name: api
    protocol: http
    upstream:
      targets:
        - host: api-server
          port: 8080
    routes:
      - path_prefix: /api
        rate_limit:
          enabled: true
          requests_per_second: 500  # Default tier
```

**Generated Output:**

```bash
gal generate --config multi-tenant.yaml --provider envoy --multi-tenant

# Output:
# - tenant-acme/envoy.yaml (1000 req/s rate limit)
# - tenant-startup/envoy.yaml (100 req/s rate limit)
# - tenant-default/envoy.yaml (500 req/s rate limit)
```

### Testing-Strategie

**Datei:** `tests/test_multi_tenant.py` (15+ Tests)

```python
# Test-Kategorien:
# 1. Multi-tenant config parsing
# 2. Tenant identification (header, subdomain, jwt)
# 3. Tenant-specific rate limiting
# 4. Configuration inheritance
# 5. Namespace isolation
# 6. Dynamic tenant onboarding
```

### Dokumentation

**Datei:** `docs/guides/MULTI_TENANT.md` (600+ Zeilen, Deutsch)

Abschnitte:
- Übersicht Multi-Tenancy
- Tenant Identification Methods
- Per-Tenant Rate Limiting
- Namespace Isolation (Kubernetes)
- Configuration Inheritance
- Dynamic Tenant Onboarding
- Best Practices
- Troubleshooting

### Meilensteine

**Woche 1:** Multi-Tenant Config Model
- TenantConfig, MultiTenantConfig Models
- Tenant Identification Methods (header, subdomain)
- 8+ Tests

**Woche 2:** Provider Extensions
- Envoy Multi-Tenant Support
- Kong Multi-Tenant Support
- Per-Tenant Rate Limiting
- 7+ Tests

**Woche 3:** Documentation + Examples
- docs/guides/MULTI_TENANT.md (600+ Zeilen)
- examples/multi-tenant.yaml
- Kubernetes Deployment Guide

### Akzeptanzkriterien

✅ Multi-Tenant Config Model implementiert
✅ Tenant Identification (header, subdomain, jwt)
✅ Per-Tenant Rate Limiting funktioniert
✅ Namespace Isolation Support
✅ 2+ Provider mit Multi-Tenant Support (Envoy, Kong)
✅ 15+ Tests bestehen (100% passing)
✅ 600+ Zeilen deutsche Dokumentation
✅ Beispiel-Konfigurationen

### Deployment-Beispiel

```bash
# Generate multi-tenant configs
gal generate --config multi-tenant.yaml --provider envoy --multi-tenant

# Output: tenant-*/envoy.yaml files

# Deploy to Kubernetes (separate namespaces)
kubectl create namespace tenant-acme
kubectl apply -f tenant-acme/envoy.yaml -n tenant-acme

kubectl create namespace tenant-startup
kubectl apply -f tenant-startup/envoy.yaml -n tenant-startup
```

---

## Zeitplan

**Wochen 1-5:** Web UI / Dashboard
- Woche 1: Backend API + Basic Frontend
- Woche 2: Configuration Builder (Drag & Drop)
- Woche 3: Code Editor + Import/Export
- Woche 4: Provider Comparison + Testing
- Woche 5: Documentation + Deployment

**Wochen 6-9:** Service Mesh Integration
- Woche 6: Istio Provider
- Woche 7: Linkerd Provider
- Woche 8: Consul Provider
- Woche 9: Documentation + Examples

**Wochen 10-12:** Multi-Tenant Support
- Woche 10: Multi-Tenant Config Model
- Woche 11: Provider Extensions
- Woche 12: Documentation + Examples

**Buffer:** +1 Woche für Final Testing & Polish

**Gesamt:** 10-12 Wochen (Q1 2027)

---

## Abhängigkeiten

### Web UI
- **Node.js 18+** - JavaScript Runtime
- **Python 3.10+** - Backend (FastAPI)
- **React 18+** - Frontend Framework
- **Docker** - Containerization

### Service Mesh
- **Kubernetes 1.24+** - Container Orchestration
- **Istio 1.18+** / **Linkerd 2.13+** / **Consul 1.16+** - Service Mesh

### Multi-Tenant
- Keine zusätzlichen Abhängigkeiten

---

## Nächste Schritte (Nach v1.5.0 Abschluss)

1. Web UI Prototype erstellen (React + FastAPI)
2. Istio Integration testen (Kubernetes Cluster)
3. Multi-Tenant Config Model finalisieren
4. Community Feedback einholen
5. Implementation in Q1 2027 beginnen

---

**Status:** 📝 Planungsdokument - Bereit für v1.6.0 Implementierung nach v1.5.0 Abschluss

---

## Success Metrics

Nach Abschluss von v1.6.0:

**Web UI:**
- ✅ **Web UI / Dashboard** mit 5 Pages
- ✅ **7+ API Endpoints** (FastAPI)
- ✅ **Visual Configuration Builder** (Drag & Drop)
- ✅ **Multi-Provider Export** (alle 8 Provider)
- ✅ **20+ Backend Tests** + **15+ Frontend Tests**

**Service Mesh:**
- ✅ **3 Service Mesh Provider** (Istio, Linkerd, Consul)
- ✅ **Kubernetes-native** Deployment
- ✅ **30+ Tests** für Service Mesh Integration

**Multi-Tenant:**
- ✅ **Multi-Tenant Config Model**
- ✅ **3 Identification Methods** (header, subdomain, jwt)
- ✅ **Per-Tenant Rate Limiting**
- ✅ **15+ Tests** für Multi-Tenant Features

**Tests:**
- ✅ **80+ neue Tests** (35 Web UI + 30 Service Mesh + 15 Multi-Tenant)
- ✅ **629+ Total Tests** (v1.5.0: 549 Tests)
- ✅ **89%+ Code Coverage**

**Dokumentation:**
- ✅ **2400+ Zeilen** neue Dokumentation (Deutsch)
  - docs/guides/WEB_UI.md (800+ Zeilen)
  - docs/guides/SERVICE_MESH.md (1000+ Zeilen)
  - docs/guides/MULTI_TENANT.md (600+ Zeilen)
- ✅ **README.md** mit Web UI Link
