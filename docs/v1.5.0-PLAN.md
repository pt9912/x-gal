# v1.5.0 Implementierungsplan

**Status:** 🔄 Geplant
**Zeitplan:** Q4 2026 (geschätzt)
**Fokus:** Enterprise API Management & High-Performance & Developer Experience Gateways
**Estimated Effort:** 10-13 Wochen

---

## Mission

**"Enterprise & High-Performance Gateways: Apigee Enterprise + KrakenD Ultra-Performance + Caddy Developer Experience"**

Erweitere GAL um drei spezialisierte Gateway-Provider: **Apigee** für Enterprise API Management, **KrakenD** für ultra-hohe Performance (70k req/s) und **Caddy** für perfekte Developer Experience mit Zero-Config HTTPS.

**Nach v1.5.0 hat GAL Support für 12 Provider:**
1. Envoy ✅ (v1.0.0)
2. Kong ✅ (v1.1.0)
3. APISIX ✅ (v1.1.0)
4. Traefik ✅ (v1.1.0)
5. Nginx ✅ (v1.3.0)
6. HAProxy ✅ (v1.3.0)
7. AWS API Gateway ✅ (v1.4.0)
8. Azure API Management ✅ (v1.4.0)
9. GCP API Gateway ✅ (v1.4.0)
10. **Apigee 🆕 (v1.5.0)**
11. **KrakenD 🆕 (v1.5.0)**
12. **Caddy 🆕 (v1.5.0)**

---

## Feature-Übersicht

| Feature | Status | Aufwand | Priorität |
|---------|--------|---------|-----------|
| **1. Apigee Provider** | 🔄 Ausstehend | 4 Wochen | 🔴 Hoch |
| **2. KrakenD Provider** | 🔄 Ausstehend | 3 Wochen | 🔴 Hoch |
| **3. Caddy Provider** | 🔄 Ausstehend | 3 Wochen | 🔴 Hoch |

**Gesamtaufwand:** 10-13 Wochen
**Fortschritt:** 0/3 Features (0%)

---

## Feature 1: Apigee Provider (DETAILLIERT)

**Status:** 🔄 Ausstehend
**Priorität:** 🔴 Hoch
**Aufwand:** 4 Wochen

### Motivation

- **Problem**: Enterprise-Kunden benötigen Google Apigee für vollumfängliches API Management mit Analytics, Monetization und Developer Portal
- **Herausforderung**: Apigee hat eine komplexe XML-basierte Policy-Engine und eigene API-Bundle-Struktur
- **Lösung**: GAL generiert Apigee API Proxies (XML + Policies) aus einheitlicher YAML-Konfiguration und importiert existierende Proxies

### Warum Apigee?

**Vorteile:**
- ✅ **Enterprise API Management**: Vollständigste Lösung im Markt
- ✅ **API Analytics & Monitoring**: Umfangreiche Metriken und Dashboards
- ✅ **API Monetization**: Built-in Billing & Revenue Sharing
- ✅ **Developer Portal**: Automatisch generiert mit OAuth-Integration
- ✅ **Traffic Management**: Native Traffic Splitting, Mirroring, Routing
- ✅ **Policy Framework**: 50+ vordefinierte Policies (XML-basiert)
- ✅ **Multi-Region**: Global Deployment mit Google Cloud
- ✅ **Hybrid/Edge**: On-Premises + Cloud Deployment
- ✅ **OpenAPI Support**: Import/Export von OpenAPI 3.0 Specs

**Apigee vs GCP API Gateway:**
- **GCP API Gateway**: Einfaches Serverless Gateway (OpenAPI 2.0, limitiert)
- **Apigee**: Enterprise Platform (Analytics, Monetization, Developer Portal, Advanced Policies)

**Use Cases:**
- Enterprise API Management (Fortune 500)
- API Monetization (Billing, Rate Plans, Revenue Sharing)
- Developer Ecosystems (Partner APIs mit Portal)
- Multi-Cloud & Hybrid Deployments
- Advanced Traffic Management (A/B, Canary, Blue/Green)
- Regulatory Compliance (GDPR, HIPAA, PCI-DSS)

### Apigee Architecture

```
Apigee API Platform
  ├── API Proxies
  │   ├── ProxyEndpoint (Frontend)
  │   │   ├── PreFlow (Request Policies)
  │   │   ├── Flows (Conditional Routing)
  │   │   └── PostFlow (Response Policies)
  │   ├── TargetEndpoint (Backend)
  │   │   ├── HTTPTargetConnection (Backend URL)
  │   │   ├── LoadBalancer (Multiple Targets)
  │   │   └── HealthMonitor
  │   └── Policies (XML)
  │       ├── Traffic Management (Quota, SpikeArrest, ConcurrentRateLimit)
  │       ├── Security (VerifyAPIKey, VerifyJWT, OAuth, SAML)
  │       ├── Transformation (JSONtoXML, XSLTransform, AssignMessage)
  │       ├── Mediation (ServiceCallout, RaiseFault, ExtractVariables)
  │       └── Extension (JavaScript, Python, Java Callout)
  ├── API Products (Packaging)
  ├── Developer Apps (API Keys)
  ├── Analytics (Metrics, Dashboards)
  └── Developer Portal (Self-Service)
```

### Konfigurationsmodell

```python
# gal/config.py

@dataclass
class ApigeeConfig:
    """Apigee-spezifische Konfiguration."""
    api_proxy_name: str = "GAL-API-Proxy"
    api_proxy_revision: str = "1"
    base_path: str = "/"

    # Deployment
    organization: str = ""
    environment: str = "test"  # test, prod

    # API Product Configuration
    product_name: str = "GAL-Product"
    product_display_name: str = "GAL API Product"
    product_description: str = "API Product managed by GAL"
    product_environments: List[str] = field(default_factory=lambda: ["test", "prod"])

    # Developer Portal
    developer_portal_enabled: bool = False

    # Analytics
    analytics_enabled: bool = True

@dataclass
class GlobalConfig:
    # ... existing fields ...
    apigee: Optional[ApigeeConfig] = None
```

### YAML-Konfigurationsbeispiel

```yaml
version: "1.0"
provider: apigee

# Apigee Global Config
global_config:
  apigee:
    organization: "my-org"
    environment: "prod"
    api_proxy_name: "UserAPI"
    product_name: "UserAPI-Product"
    analytics_enabled: true

services:
  - name: user_api
    protocol: http

    upstream:
      targets:
        - host: api-v1.internal
          port: 8080
        - host: api-v2.internal
          port: 8080
      load_balancer:
        algorithm: round_robin
      health_check:
        active:
          enabled: true
          http_path: /health
          interval: 10s

    routes:
      - path_prefix: /api/users
        http_methods: ["GET", "POST"]

        # Rate Limiting → Quota Policy
        rate_limit:
          enabled: true
          requests_per_second: 100

        # Authentication → VerifyAPIKey Policy
        authentication:
          type: api_key
          api_key:
            key_name: "apikey"
            in_location: query  # query or header

        # Traffic Splitting → RouteRule + TargetServers
        traffic_split:
          enabled: true
          targets:
            - name: v1
              weight: 90
              upstream:
                host: api-v1.internal
                port: 8080
            - name: v2
              weight: 10
              upstream:
                host: api-v2.internal
                port: 8080

        # Request Mirroring → ServiceCallout Policy
        mirroring:
          enabled: true
          targets:
            - name: shadow
              upstream:
                host: shadow-api.internal
                port: 8080
              sample_percentage: 100.0
```

### Provider-Implementierung

**Datei:** `gal/providers/apigee.py` (+800 Zeilen)

**Hauptfunktionen:**

1. **API Proxy Bundle Generation**:
   - `apiproxy/` Verzeichnisstruktur
   - `<APIProxyName>.xml` (Root Descriptor)
   - `proxies/default.xml` (ProxyEndpoint)
   - `targets/default.xml` (TargetEndpoint)
   - `policies/*.xml` (Policy Files)

2. **Policy Generation**:
   - **Quota**: Rate Limiting (requests per minute/hour/day)
   - **SpikeArrest**: Spike protection (requests per second)
   - **VerifyAPIKey**: API Key authentication
   - **VerifyJWT**: JWT validation
   - **AssignMessage**: Header manipulation
   - **RouteRule**: Traffic splitting (weighted targets)
   - **ServiceCallout**: Request mirroring
   - **RaiseFault**: Error handling
   - **StatisticsCollector**: Custom analytics

3. **Import Funktionalität**:
   - Parse API Proxy Bundle (XML)
   - Extract Policies → GAL Config
   - Extract TargetServers → Upstreams
   - Extract RouteRules → Traffic Splitting

### Apigee API Proxy Beispiel

**Generierte Struktur:**
```
apiproxy/
  ├── UserAPI.xml                # Root Descriptor
  ├── proxies/
  │   └── default.xml            # ProxyEndpoint
  ├── targets/
  │   └── default.xml            # TargetEndpoint
  └── policies/
      ├── Quota-RateLimit.xml    # Rate Limiting
      ├── VerifyAPIKey-Auth.xml  # API Key Auth
      ├── AssignMessage-Headers.xml  # Header Manipulation
      └── RouteRule-Split.xml    # Traffic Splitting
```

**UserAPI.xml (Root Descriptor):**
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<APIProxy name="UserAPI">
    <Description>User Management API generated by GAL</Description>
    <Basepaths>/api/users</Basepaths>
    <Policies>
        <Policy>Quota-RateLimit</Policy>
        <Policy>VerifyAPIKey-Auth</Policy>
        <Policy>AssignMessage-Headers</Policy>
    </Policies>
    <ProxyEndpoints>
        <ProxyEndpoint>default</ProxyEndpoint>
    </ProxyEndpoints>
    <TargetEndpoints>
        <TargetEndpoint>default</TargetEndpoint>
    </TargetEndpoints>
</APIProxy>
```

**proxies/default.xml (ProxyEndpoint):**
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ProxyEndpoint name="default">
    <PreFlow name="PreFlow">
        <Request>
            <Step>
                <Name>VerifyAPIKey-Auth</Name>
            </Step>
            <Step>
                <Name>Quota-RateLimit</Name>
            </Step>
        </Request>
        <Response/>
    </PreFlow>
    <Flows>
        <Flow name="GET /api/users">
            <Condition>(proxy.pathsuffix MatchesPath "/api/users") and (request.verb = "GET")</Condition>
            <Request/>
            <Response/>
        </Flow>
    </Flows>
    <HTTPProxyConnection>
        <BasePath>/api/users</BasePath>
    </HTTPProxyConnection>
    <RouteRule name="default">
        <TargetEndpoint>default</TargetEndpoint>
    </RouteRule>
</ProxyEndpoint>
```

**targets/default.xml (TargetEndpoint with Load Balancing):**
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<TargetEndpoint name="default">
    <PreFlow name="PreFlow">
        <Request>
            <Step>
                <Name>AssignMessage-Headers</Name>
            </Step>
        </Request>
        <Response/>
    </PreFlow>
    <HTTPTargetConnection>
        <LoadBalancer>
            <Algorithm>RoundRobin</Algorithm>
            <Server name="api-v1">
                <URL>http://api-v1.internal:8080</URL>
            </Server>
            <Server name="api-v2">
                <URL>http://api-v2.internal:8080</URL>
            </Server>
            <HealthMonitor>
                <Enabled>true</Enabled>
                <Path>/health</Path>
                <IntervalInSec>10</IntervalInSec>
            </HealthMonitor>
        </LoadBalancer>
    </HTTPTargetConnection>
</TargetEndpoint>
```

**policies/Quota-RateLimit.xml:**
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Quota name="Quota-RateLimit">
    <Allow count="6000"/>
    <Interval>1</Interval>
    <TimeUnit>minute</TimeUnit>
    <Distributed>true</Distributed>
    <Synchronous>false</Synchronous>
    <Identifier ref="client_id"/>
</Quota>
```

**policies/VerifyAPIKey-Auth.xml:**
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<VerifyAPIKey name="VerifyAPIKey-Auth">
    <APIKey ref="request.queryparam.apikey"/>
</VerifyAPIKey>
```

### Feature-Support Matrix

| Feature | Apigee Support | GAL Implementation | Hinweise |
|---------|---------------|-------------------|----------|
| Load Balancing | ✅ Vollständig | `LoadBalancer` element | RoundRobin, Weighted, LeastConnection |
| Active Health Checks | ✅ Vollständig | `HealthMonitor` | HTTP/HTTPS endpoints |
| Rate Limiting | ✅ Vollständig | `Quota`, `SpikeArrest` | Per minute/hour/day + per second |
| API Key Auth | ✅ Vollständig | `VerifyAPIKey` policy | Native support |
| JWT Auth | ✅ Vollständig | `VerifyJWT` policy | Full JWT validation |
| OAuth 2.0 | ✅ Vollständig | `OAuthV2` policy | Authorization Server |
| Header Manipulation | ✅ Vollständig | `AssignMessage` policy | Request/Response |
| CORS | ✅ Vollständig | `AssignMessage` | Via headers |
| Timeout | ✅ Vollständig | `HTTPTargetConnection` | Connect, Read, Write timeouts |
| Circuit Breaker | ✅ Vollständig | `CircuitBreaker` policy | Native support |
| **Traffic Splitting** | ✅ **Vollständig** | `RouteRule` + `TargetServers` | **Weight-based routing** |
| **Request Mirroring** | ✅ **Vollständig** | `ServiceCallout` policy | **Async callouts** |
| Body Transformation | ✅ Vollständig | `JSONtoXML`, `XSLTransform` | Native policies |
| **API Analytics** | ✅ **Unique** | Built-in | **Real-time dashboards** |
| **API Monetization** | ✅ **Unique** | Built-in | **Billing & Revenue** |
| **Developer Portal** | ✅ **Unique** | Built-in | **Self-service portal** |

### Testing-Strategie

**Datei:** `tests/test_apigee.py` (25+ Tests)

```python
# Test-Kategorien:
# 1. Provider basics (name, validate)
# 2. API Proxy Bundle generation
# 3. ProxyEndpoint generation (PreFlow, Flows, RouteRule)
# 4. TargetEndpoint generation (LoadBalancer, HealthMonitor)
# 5. Policy generation (Quota, SpikeArrest, VerifyAPIKey, VerifyJWT, AssignMessage)
# 6. Traffic splitting (RouteRule + TargetServers)
# 7. Request mirroring (ServiceCallout)
# 8. Multiple routes/services
# 9. XML output validation
# 10. Import (API Proxy Bundle → GAL Config)
```

### Dokumentation

**Datei:** `docs/guides/APIGEE.md` (1500+ Zeilen, Deutsch)

Abschnitte:
- Übersicht & Apigee's Enterprise Features
- Schnellstart (3 Beispiele)
- Installation & Setup (Apigee CLI, apigeetool)
- Konfigurationsoptionen
- Policy-Typen (50+ Policies)
- Apigee-spezifische Features:
  - API Analytics (Real-time Metrics)
  - API Monetization (Rate Plans, Billing)
  - Developer Portal (OAuth Integration)
  - Traffic Management (Quota, SpikeArrest, ConcurrentRateLimit)
  - Advanced Routing (RouteRules, TargetServers)
  - Hybrid Deployment (On-Prem + Cloud)
- Deployment-Strategien (apigeetool, Maven Plugin, CI/CD)
- Best Practices
- Troubleshooting

**Datei:** `examples/apigee-example.yaml` (10+ Szenarien)

### Meilensteine

**Woche 1:** Provider Implementation + API Proxy Bundle
- ApigeeProvider Klasse
- API Proxy Bundle Generation (XML Structure)
- ProxyEndpoint + TargetEndpoint
- 8+ Tests

**Woche 2:** Policy Generation + Advanced Features
- Quota, SpikeArrest Policies (Rate Limiting)
- VerifyAPIKey, VerifyJWT Policies (Auth)
- AssignMessage Policy (Headers)
- RouteRule (Traffic Splitting)
- ServiceCallout (Request Mirroring)
- 10+ Tests

**Woche 3:** Import + Documentation
- Import from API Proxy Bundle (XML → GAL Config)
- Parse Policies → Extract Config
- docs/guides/APIGEE.md (1000+ Zeilen)
- 7+ Tests

**Woche 4:** Examples + Integration + Polish
- examples/apigee-example.yaml (10 Szenarien)
- CLI Integration (`gal generate --provider apigee`)
- README.md Updates
- docs/guides/APIGEE.md vervollständigen (1500+ Zeilen)

### Akzeptanzkriterien

✅ ApigeeProvider generiert valide API Proxy Bundle
✅ ProxyEndpoint mit PreFlow, Flows, RouteRule korrekt
✅ TargetEndpoint mit LoadBalancer korrekt
✅ Policy XMLs korrekt generiert (Quota, VerifyAPIKey, AssignMessage)
✅ Traffic Splitting via RouteRule + TargetServers
✅ Request Mirroring via ServiceCallout
✅ Config Import (API Proxy Bundle → GAL) funktioniert
✅ 25+ Tests bestehen (100% passing)
✅ 1500+ Zeilen deutsche Dokumentation
✅ 10+ Beispiel-Szenarien
✅ CLI Integration komplett

### Deployment-Beispiel

```bash
# GAL-Config → Apigee API Proxy Bundle generieren
gal generate --config config.yaml --provider apigee --output apiproxy.zip

# Deployment via apigeetool
apigeetool deployproxy \
  -u user@example.com \
  -o my-org \
  -e prod \
  -n UserAPI \
  -d ./apiproxy/

# Import von existierendem Apigee Proxy
apigeetool fetchproxy \
  -u user@example.com \
  -o my-org \
  -n UserAPI \
  -r 1

gal import --provider apigee --input apiproxy.zip --output gal-config.yaml
```

---

## Feature 2: KrakenD Provider (DETAILLIERT)

**Status:** 🔄 Ausstehend
**Priorität:** 🔴 Hoch
**Aufwand:** 3 Wochen

### Motivation

- **Problem**: Höchste Performance für API-Gateways bei hohen Request-Volumina (>10k req/s)
- **Herausforderung**: KrakenD hat eine eigene JSON-basierte Konfiguration mit spezifischen Namenskonventionen
- **Lösung**: GAL generiert und importiert KrakenD JSON-Config aus/zu einheitlicher YAML-Konfiguration

### Warum KrakenD?

**Vorteile:**
- ✅ **Ultra-High Performance**: 70.000 Requests/Sekunde (Go-basiert, stateless)
- ✅ **Stateless Architecture**: Kein Backend (DB, Redis) benötigt
- ✅ **File-Based Configuration**: Single JSON file (`krakend.json`)
- ✅ **Backend Aggregation**: Multiple Backend Calls → Single Response
- ✅ **Low Memory Footprint**: ~100 MB RAM für High-Load Scenarios
- ✅ **Zero Dependencies**: Single Binary (wie Caddy)
- ✅ **API Composition**: Response Merging, Filtering, Grouping
- ✅ **Cloud-Native**: Kubernetes-ready, Docker-optimized
- ✅ **Enterprise Edition**: Advanced features (OpenID, Circuit Breaker, etc.)

**Performance Comparison:**
- KrakenD: ~70k req/s
- Nginx: ~50k req/s
- Envoy: ~45k req/s
- Kong: ~35k req/s
- Traefik: ~30k req/s

**Use Cases:**
- High-Traffic APIs (E-Commerce, Gaming, FinTech)
- Microservices Aggregation (Backend for Frontend Pattern)
- Cloud-Native Architectures (Kubernetes)
- Stateless Deployments (Horizontal Scaling)
- Edge Computing (Low Resource Usage)

### Konfigurationsmodell

KrakenD nutzt die bestehenden GAL Config-Models, keine Änderungen erforderlich!

### KrakenD JSON Beispiel

**GAL Config:**
```yaml
version: "1.0"
provider: krakend

services:
  - name: api_service
    protocol: http
    upstream:
      targets:
        - host: api-1.internal
          port: 8080
          weight: 2
        - host: api-2.internal
          port: 8080
          weight: 1
      load_balancer:
        algorithm: round_robin
      health_check:
        active:
          enabled: true
          http_path: /health
          interval: 10s

    routes:
      - path_prefix: /api/users
        http_methods: ["GET", "POST"]
        rate_limit:
          enabled: true
          requests_per_second: 100
          burst: 200
        timeout:
          request: 30s
        headers:
          request_add:
            X-Gateway: "GAL-KrakenD"
```

**Generierte KrakenD JSON Config:**
```json
{
  "$schema": "https://www.krakend.io/schema/v3.json",
  "version": 3,
  "port": 8080,
  "endpoints": [
    {
      "endpoint": "/api/users",
      "method": "GET",
      "backend": [
        {
          "url_pattern": "/api/users",
          "host": [
            "http://api-1.internal:8080",
            "http://api-2.internal:8080"
          ],
          "sd": "static",
          "extra_config": {
            "qos/ratelimit/proxy": {
              "max_rate": 100,
              "capacity": 200
            }
          }
        }
      ],
      "extra_config": {
        "qos/ratelimit/router": {
          "max_rate": 100,
          "client_max_rate": 10
        }
      },
      "timeout": "30s",
      "headers_to_pass": ["X-Gateway"]
    },
    {
      "endpoint": "/api/users",
      "method": "POST",
      "backend": [
        {
          "url_pattern": "/api/users",
          "host": [
            "http://api-1.internal:8080",
            "http://api-2.internal:8080"
          ]
        }
      ],
      "timeout": "30s"
    }
  ],
  "extra_config": {
    "router": {
      "return_error_msg": true
    },
    "telemetry/metrics": {
      "collection_time": "30s",
      "listen_address": ":8090"
    }
  }
}
```

### Provider-Implementierung

**Datei:** `gal/providers/krakend.py`

```python
import json
from typing import Dict, List, Any
from gal.config import Config, Service, Route
from gal.providers.base import Provider

class KrakenDProvider(Provider):
    """KrakenD Provider für GAL - Ultra-High-Performance API Gateway."""

    def __init__(self):
        super().__init__("krakend")

    def generate(self, config: Config) -> str:
        """Generiere KrakenD JSON-Config."""
        output = {
            "$schema": "https://www.krakend.io/schema/v3.json",
            "version": 3,
            "port": config.global_config.port or 8080,
            "endpoints": [],
            "extra_config": {
                "router": {
                    "return_error_msg": True
                }
            }
        }

        # Generate endpoints für jeden Service
        for service in config.services:
            for route in service.routes:
                # KrakenD hat separate endpoints per HTTP method
                if route.http_methods:
                    for method in route.http_methods:
                        endpoint = self._generate_endpoint(service, route, method)
                        output["endpoints"].append(endpoint)
                else:
                    # Default: GET method
                    endpoint = self._generate_endpoint(service, route, "GET")
                    output["endpoints"].append(endpoint)

        # Global Telemetry
        output["extra_config"]["telemetry/metrics"] = {
            "collection_time": "30s",
            "listen_address": ":8090"
        }

        return json.dumps(output, indent=2)

    def _generate_endpoint(self, service: Service, route: Route, method: str) -> Dict[str, Any]:
        """Generiere einzelnen KrakenD Endpoint."""
        endpoint = {
            "endpoint": route.path_prefix,
            "method": method,
            "backend": [],
            "extra_config": {}
        }

        # Backend (Upstream Targets)
        backend = {
            "url_pattern": route.path_prefix,
            "host": [],
            "sd": "static",  # Service Discovery: static
            "extra_config": {}
        }

        if service.upstream and service.upstream.targets:
            for target in service.upstream.targets:
                host_url = f"http://{target.host}:{target.port}"
                backend["host"].append(host_url)

        # Load Balancing (KrakenD hat Round-Robin als Default)
        # Weighted Load Balancing via target weights
        if service.upstream and service.upstream.load_balancer:
            lb_algo = service.upstream.load_balancer.algorithm
            if lb_algo == "round_robin":
                backend["sd"] = "static"  # Default
            elif lb_algo == "weighted":
                # KrakenD unterstützt weighted via multiple host entries
                # TODO: Implement weighted hosts
                pass

        # Rate Limiting (Backend Level)
        if route.rate_limit and route.rate_limit.enabled:
            backend["extra_config"]["qos/ratelimit/proxy"] = {
                "max_rate": route.rate_limit.requests_per_second,
                "capacity": route.rate_limit.burst or route.rate_limit.requests_per_second * 2
            }

            # Rate Limiting (Router Level)
            endpoint["extra_config"]["qos/ratelimit/router"] = {
                "max_rate": route.rate_limit.requests_per_second,
                "client_max_rate": route.rate_limit.requests_per_second // 10  # per client
            }

        # Timeout
        if route.timeout:
            endpoint["timeout"] = route.timeout.request or "30s"

        # Header Manipulation
        if route.headers and route.headers.request_add:
            endpoint["headers_to_pass"] = list(route.headers.request_add.keys())

        # Circuit Breaker (KrakenD Enterprise)
        if route.circuit_breaker and route.circuit_breaker.enabled:
            backend["extra_config"]["qos/circuit-breaker"] = {
                "interval": 10,
                "timeout": 10,
                "maxErrors": route.circuit_breaker.failure_threshold or 5,
                "logStatusChange": True
            }

        endpoint["backend"].append(backend)
        return endpoint

    def parse(self, krakend_config: str) -> Config:
        """Parse KrakenD JSON Config → GAL Config."""
        data = json.loads(krakend_config)

        config = Config(
            version="1.0",
            provider="krakend",
            services=[]
        )

        # Extract global config
        config.global_config.port = data.get("port", 8080)

        # Group endpoints by path_prefix → Service
        services_map = {}

        for endpoint in data.get("endpoints", []):
            path = endpoint.get("endpoint", "/")
            method = endpoint.get("method", "GET")

            # Create or get service
            if path not in services_map:
                service = Service(
                    name=f"service_{path.replace('/', '_')}",
                    protocol="http",
                    upstream=None,
                    routes=[]
                )
                services_map[path] = service

            service = services_map[path]

            # Parse backend targets
            for backend in endpoint.get("backend", []):
                hosts = backend.get("host", [])
                for host_url in hosts:
                    # Parse http://api-1.internal:8080 → host, port
                    host_url = host_url.replace("http://", "").replace("https://", "")
                    if ":" in host_url:
                        host, port = host_url.split(":")
                        target = {"host": host, "port": int(port)}
                        # Add to service upstream
                        if not service.upstream:
                            service.upstream = {"targets": []}
                        if target not in service.upstream["targets"]:
                            service.upstream["targets"].append(target)

                # Parse rate limiting
                extra_config = backend.get("extra_config", {})
                if "qos/ratelimit/proxy" in extra_config:
                    rl = extra_config["qos/ratelimit/proxy"]
                    # Add rate limit to route (not service)
                    # We'll add this later when creating the route

            # Create route
            route = {
                "path_prefix": path,
                "http_methods": [method]
            }

            # Parse endpoint-level config
            if "timeout" in endpoint:
                route["timeout"] = {
                    "request": endpoint["timeout"]
                }

            # Parse rate limiting (router level)
            endpoint_extra = endpoint.get("extra_config", {})
            if "qos/ratelimit/router" in endpoint_extra:
                rl = endpoint_extra["qos/ratelimit/router"]
                route["rate_limit"] = {
                    "enabled": True,
                    "requests_per_second": rl.get("max_rate", 100)
                }

            # Merge routes with same path but different methods
            existing_route = next((r for r in service.routes if r["path_prefix"] == path), None)
            if existing_route:
                if method not in existing_route["http_methods"]:
                    existing_route["http_methods"].append(method)
            else:
                service.routes.append(route)

        config.services = list(services_map.values())
        return config

    def validate(self, config: Config) -> bool:
        """Validiere KrakenD-Konfiguration."""
        # Warnungen für nicht unterstützte Features
        for service in config.services:
            for route in service.routes:
                # JWT Auth erfordert KrakenD Enterprise
                if route.authentication and route.authentication.type == "jwt":
                    logger.warning(
                        "JWT Authentication in KrakenD erfordert KrakenD Enterprise Edition. "
                        "Siehe: https://www.krakend.io/docs/enterprise/"
                    )

                # Circuit Breaker erfordert KrakenD Enterprise
                if route.circuit_breaker and route.circuit_breaker.enabled:
                    logger.warning(
                        "Circuit Breaker in KrakenD erfordert KrakenD Enterprise Edition. "
                        "Siehe: https://www.krakend.io/docs/enterprise/endpoints/circuit-breaker/"
                    )

                # Body Transformation (Basic support in OSS, Advanced in Enterprise)
                if route.body_transformation and route.body_transformation.enabled:
                    logger.info(
                        "Body Transformation: KrakenD OSS unterstützt basic response manipulation. "
                        "Für advanced transformations: KrakenD Enterprise Edition erforderlich."
                    )

        return True
```

### Import Implementierung

**Datei:** `gal/providers/krakend.py` (parse method - siehe oben)

**Import-Features:**
- ✅ **Endpoints → Routes:** path_prefix, http_methods
- ✅ **Backend hosts → Upstream Targets:** host, port
- ✅ **Rate Limiting:** qos/ratelimit/* → rate_limit config
- ✅ **Timeout:** timeout → timeout.request
- ✅ **Circuit Breaker:** qos/circuit-breaker → circuit_breaker
- ✅ **Load Balancing:** sd (static) → round_robin algorithm
- ⚠️ **Backend Aggregation:** Multiple backends → Multiple services (simplified)

### Feature-Support Matrix

| Feature | KrakenD Support | GAL Implementation | Hinweise |
|---------|----------------|-------------------|----------|
| Load Balancing | ✅ Vollständig | `sd` parameter | round_robin (default), weighted via host duplication |
| Active Health Checks | ⚠️ Enterprise | `health_check` | Requires KrakenD Enterprise |
| Passive Health Checks | ❌ Nicht verfügbar | - | Not supported |
| Rate Limiting | ✅ Vollständig | `qos/ratelimit/*` | Router + Proxy level |
| Basic Auth | ✅ Vollständig | `auth/basic` | Native support |
| JWT Auth | ⚠️ Enterprise | `auth/jwt` | Requires KrakenD Enterprise |
| API Key Auth | ✅ Vollständig | `auth/api-keys` | Native support |
| Header Manipulation | ✅ Vollständig | `headers_to_pass` | Request headers |
| CORS | ✅ Vollständig | `security/cors` | Native support |
| Timeout | ✅ Vollständig | `timeout` | Per-endpoint |
| Retry | ✅ Vollständig | `qos/http-cache` | Via cache + retry |
| Circuit Breaker | ⚠️ Enterprise | `qos/circuit-breaker` | Requires KrakenD Enterprise |
| WebSocket | ❌ Nicht verfügbar | - | Not supported (HTTP/REST only) |
| Body Transformation | ⚠️ Teilweise | `modifier/*` | Basic OSS, Advanced Enterprise |
| **Backend Aggregation** | ✅ **Unique** | `backend` array | **KrakenD's Killer Feature!** |
| **Response Filtering** | ✅ **Unique** | `deny`, `allow` | **JSON filtering** |

### Testing-Strategie

**Datei:** `tests/test_krakend.py` (20+ Tests)

```python
# Test-Kategorien:
# 1. Provider basics (name, validate)
# 2. Endpoint generation (path_prefix, http_methods)
# 3. Backend configuration (host, port, targets)
# 4. Load balancing (round_robin, weighted)
# 5. Rate limiting (router + proxy level)
# 6. Timeout configuration
# 7. Header manipulation
# 8. CORS policies
# 9. Circuit breaker (Enterprise warning)
# 10. Multiple endpoints/routes
# 11. JSON output validation
# 12. Config Import (krakend.json → GAL)
# 13. Backend aggregation (multiple backends)
# 14. Response filtering
```

### Dokumentation

**Datei:** `docs/guides/KRAKEND.md` (1000+ Zeilen, Deutsch)

Abschnitte:
- Übersicht & KrakenD's Unique Features
- Schnellstart (3 Beispiele mit Backend Aggregation)
- Installation & Setup (Binary, Docker, Kubernetes)
- Konfigurationsoptionen
- Feature-Implementierungen (alle 10+ Features)
- KrakenD-spezifische Details:
  - Backend Aggregation (Multiple Backends → Single Response)
  - Response Filtering & Manipulation
  - JSON-only Configuration
  - Stateless Architecture (No DB needed)
  - Performance Tuning (70k req/s)
  - Enterprise vs OSS Features
- Provider-Vergleich (vs anderen Gateways)
- Best Practices
- Troubleshooting

**Datei:** `docs/import/krakend.md` (800+ Zeilen, Deutsch)

Abschnitte:
- Übersicht KrakenD Config Import
- CLI Usage (`gal import-config --provider krakend`)
- Import-Mapping (krakend.json → gal-config.yaml)
- Beispiele (10+ Szenarien)
- Feature Coverage (Import Support Matrix)
- Einschränkungen & Workarounds
- Roundtrip Compatibility (Import → Export → Import)

**Datei:** `examples/krakend/krakend.json` (Simple Config)

**Datei:** `examples/krakend/production-krakend.json` (Complex Config)

### Meilensteine

**Woche 1:** Provider Implementation + Core Features
- KrakenDProvider Klasse
- JSON-Config Generation
- Endpoint Mapping
- Backend Configuration
- Rate Limiting (Router + Proxy)
- 10+ Tests

**Woche 2:** Import + Advanced Features + Documentation
- `parse()` method (Import from krakend.json)
- Circuit Breaker (Enterprise warning)
- CORS Configuration
- Timeout & Retry
- Header Manipulation
- 10+ Tests
- docs/guides/KRAKEND.md (500+ Zeilen)
- docs/import/krakend.md (400+ Zeilen)

**Woche 3:** Examples + Integration + Polish
- examples/krakend/*.json (10+ Szenarien)
- CLI Integration (`gal import-config --provider krakend`)
- README.md Updates
- Provider Feature Coverage Tables
- docs/guides/KRAKEND.md vervollständigen (1000+ Zeilen)
- docs/import/krakend.md vervollständigen (800+ Zeilen)

### Akzeptanzkriterien

✅ KrakenDProvider generiert valide krakend.json
✅ Alle Endpoints mit korrekten HTTP methods
✅ Backend hosts korrekt gemappt
✅ Rate Limiting (Router + Proxy Level)
✅ Timeout konfigurierbar
✅ Header Manipulation
✅ CORS Support
✅ Circuit Breaker (mit Enterprise warning)
✅ Config Import (krakend.json → GAL) funktioniert
✅ 20+ Tests bestehen (100% passing)
✅ 1000+ Zeilen deutsche Dokumentation (guides/KRAKEND.md)
✅ 800+ Zeilen Import-Dokumentation (import/krakend.md)
✅ 10+ Beispiel-Szenarien
✅ CLI Integration komplett

### Deployment-Beispiel

```bash
# GAL-Config → KrakenD generieren
gal generate --config config.yaml --provider krakend --output krakend.json

# KrakenD mit generierter Config starten
krakend run -c krakend.json

# Performance: 70k req/s out of the box!

# Import von existierendem KrakenD
gal import-config --provider krakend --input krakend.json --output gal-config.yaml
```

---

## Feature 2: Caddy Provider (DETAILLIERT)

**Status:** 🔄 Ausstehend
**Priorität:** 🔴 Hoch
**Aufwand:** 3 Wochen

### Motivation

- **Problem**: Entwickler benötigen eine einfach zu konfigurierende Gateway-Lösung mit automatischem HTTPS
- **Herausforderung**: Caddy hat eine eigene JSON-API und Caddyfile-Syntax
- **Lösung**: GAL generiert Caddy JSON-Config aus einheitlicher YAML-Konfiguration

### Warum Caddy?

**Vorteile:**
- ✅ **Automatisches HTTPS**: Let's Encrypt & ZeroSSL ohne Konfiguration
- ✅ **Einfache Syntax**: Caddyfile oder JSON-API
- ✅ **HTTP/3 Ready**: QUIC-Support native
- ✅ **Dynamische Konfiguration**: JSON-API für Live-Updates
- ✅ **Native gRPC**: Reverse-Proxy für gRPC-Services
- ✅ **Plugin-System**: Erweiterbar via Caddy Modules
- ✅ **Zero Dependencies**: Single Binary
- ✅ **Developer-Friendly**: Perfekt für Developer Experience Theme

**Use Cases:**
- Entwicklungsumgebungen (lokales HTTPS ohne Zertifikate)
- Microservices (automatisches Service Discovery)
- Cloud-Native Deployments (Kubernetes)
- Edge Computing (lightweight binary)
- Prototyping (schnelle Einrichtung)

### Konfigurationsmodell

Caddy nutzt die bestehenden GAL Config-Models, keine Änderungen erforderlich!

### Caddy JSON API Beispiel

**GAL Config:**
```yaml
services:
  - name: api_service
    protocol: http
    upstream:
      targets:
        - host: api-1.internal
          port: 8080
        - host: api-2.internal
          port: 8080
      load_balancer:
        algorithm: round_robin
      health_check:
        active:
          enabled: true
          http_path: /health
          interval: 10s

    routes:
      - path_prefix: /api
        rate_limit:
          enabled: true
          requests_per_second: 100
        headers:
          request_add:
            X-Gateway: "GAL-Caddy"
```

**Generierte Caddy JSON Config:**
```json
{
  "apps": {
    "http": {
      "servers": {
        "srv0": {
          "listen": [":443"],
          "routes": [
            {
              "match": [
                {
                  "path": ["/api*"]
                }
              ],
              "handle": [
                {
                  "handler": "reverse_proxy",
                  "upstreams": [
                    {"dial": "api-1.internal:8080"},
                    {"dial": "api-2.internal:8080"}
                  ],
                  "load_balancing": {
                    "selection_policy": {
                      "policy": "round_robin"
                    }
                  },
                  "health_checks": {
                    "active": {
                      "path": "/health",
                      "interval": "10s"
                    }
                  }
                }
              ]
            }
          ],
          "automatic_https": {
            "disable": false
          }
        }
      }
    }
  }
}
```

### Feature-Support Matrix

| Feature | Caddy Support | GAL Implementation | Hinweise |
|---------|---------------|-------------------|----------|
| Load Balancing | ✅ Vollständig | `selection_policy` | round_robin, least_conn, ip_hash, weighted |
| Active Health Checks | ✅ Vollständig | `health_checks.active` | HTTP/HTTPS endpoints |
| Passive Health Checks | ✅ Vollständig | `health_checks.passive` | failure_policy |
| Rate Limiting | ⚠️ Plugin | `rate_limit` handler | Requires caddy-ratelimit plugin |
| Basic Auth | ✅ Vollständig | `basicauth` handler | Native support |
| JWT Auth | ⚠️ Plugin | caddy-security | Requires caddy-security plugin |
| Header Manipulation | ✅ Vollständig | `headers` handler | Native request/response |
| CORS | ✅ Vollständig | `headers` handler | Via Access-Control-* headers |
| Timeout | ✅ Vollständig | `transport` config | dial_timeout, read_timeout, write_timeout |
| Retry | ✅ Vollständig | `lb_try_duration` | Native retry support |
| Circuit Breaker | ⚠️ Plugin | circuit-breaker module | Via plugin |
| WebSocket | ✅ Vollständig | Native | Automatic upgrade |
| Body Transformation | ⚠️ Module | Custom module | Requires development |
| **Automatic HTTPS** | ✅ **Unique** | `automatic_https` | **Caddy's Killer Feature!** |
| **HTTP/3** | ✅ **Unique** | `protocols` | **QUIC native** |

### Testing-Strategie

**Datei:** `tests/test_caddy.py` (15+ Tests)

```python
# Test-Kategorien:
# 1. Provider basics (name, validate)
# 2. Load balancing (round_robin, least_conn, ip_hash, weighted)
# 3. Active health checks
# 4. Basic authentication
# 5. Header manipulation (request, response)
# 6. CORS policies
# 7. Timeout configuration
# 8. Retry policies
# 9. WebSocket support
# 10. Multiple services/routes
# 11. Automatic HTTPS configuration
# 12. JSON output validation
```

### Dokumentation

**Datei:** `docs/guides/CADDY.md` (1000+ Zeilen, Deutsch)

Abschnitte:
- Übersicht & Caddy's Unique Features
- Schnellstart (3 Beispiele mit automatischem HTTPS)
- Installation & Setup (Binary, Docker, Kubernetes)
- Konfigurationsoptionen
- Feature-Implementierungen (alle 10 Features)
- Caddy-spezifische Details:
  - JSON API vs Caddyfile
  - Automatic HTTPS (Let's Encrypt, ZeroSSL)
  - HTTP/3 / QUIC Configuration
  - Admin API für Live-Updates
  - Caddy Modules / Plugin System
- Provider-Vergleich (vs anderen Gateways)
- Best Practices
- Troubleshooting

**Datei:** `examples/caddy-example.yaml` (15+ Szenarien)

### Meilensteine

**Woche 1:** Provider Implementation + Core Features
- CaddyProvider Klasse
- JSON-Config Generation
- Load Balancing
- Health Checks
- 8+ Tests

**Woche 2:** Advanced Features + Documentation
- Rate Limiting (Plugin-Warning)
- Authentication (Basic + JWT Warning)
- Header Manipulation
- CORS
- Timeout & Retry
- WebSocket
- 7+ Tests
- docs/guides/CADDY.md (500+ Zeilen)

**Woche 3:** Examples + Integration + Polish
- examples/caddy-example.yaml (15 Szenarien)
- CLI Integration
- README.md Updates
- docs/guides/CADDY.md vervollständigen (1000+ Zeilen)

### Akzeptanzkriterien

✅ CaddyProvider generiert valide JSON-Config
✅ Alle Load-Balancing-Algorithmen unterstützt
✅ Active Health Checks funktionieren
✅ Header Manipulation (request/response)
✅ CORS via headers handler
✅ Timeout & Retry konfigurierbar
✅ WebSocket native support
✅ Automatic HTTPS konfigurierbar
✅ 15+ Tests bestehen (100% passing)
✅ 1000+ Zeilen deutsche Dokumentation
✅ 15+ Beispiel-Szenarien
✅ CLI Integration komplett

### Deployment-Beispiel

```bash
# GAL-Config generieren
gal generate --config config.yaml --provider caddy --output caddy.json

# Caddy mit generierter Config starten
caddy run --config caddy.json

# Oder Caddy JSON API verwenden (Live-Update)
curl -X POST http://localhost:2019/load \
  -H "Content-Type: application/json" \
  -d @caddy.json

# Automatic HTTPS aktiv
# Caddy lädt automatisch Let's Encrypt Zertifikate für alle Domains!
```

---

## Zeitplan

**Wochen 1-3:** KrakenD Provider
- Woche 1: Core Implementation + Export
- Woche 2: Import + Advanced Features
- Woche 3: Documentation + Examples

**Wochen 4-6:** Caddy Provider
- Woche 4: Core Implementation + Features
- Woche 5: Advanced Features + Documentation
- Woche 6: Examples + Integration + Polish

**Buffer:** +1-2 Wochen für Testing & Integration

**Gesamt:** 6-8 Wochen (Q4 2026)

---

## Abhängigkeiten

### KrakenD Provider
- **KrakenD v2.5+** - KrakenD Server Binary
- Keine zusätzlichen Abhängigkeiten (Single Binary)

### KrakenD Optional (Enterprise Features)
- **KrakenD Enterprise** - Für JWT Auth, Circuit Breaker, Advanced Transformations

### Caddy Provider
- **Caddy v2.7+** - Caddy Server Binary
- Keine zusätzlichen Abhängigkeiten (Single Binary)

### Caddy Optional (für erweiterte Features)
- **caddy-ratelimit** - Rate Limiting Plugin
- **caddy-security** - JWT Authentication Plugin
- **caddy-circuit-breaker** - Circuit Breaker Plugin

---

## Provider-Vergleich (mit Apigee, KrakenD & Caddy)

| Feature | Envoy | Kong | APISIX | Traefik | Nginx | HAProxy | AWS | Azure | GCP | **Apigee** | **KrakenD** | **Caddy** |
|---------|-------|------|--------|---------|-------|---------|-----|-------|-----|------------|-------------|-----------|
| **Performance** | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | **⭐⭐⭐⭐⭐** | ⭐⭐⭐⭐ |
| **Ease of Use** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | **⭐⭐⭐⭐⭐** |
| **Enterprise** | ⚠️ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⚠️ | ⚠️ | ⚠️ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | **⭐⭐⭐⭐⭐** | ⚠️ | ⚠️ |
| **Stateless** | ✅ | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ | **✅** | ✅ |
| **Auto HTTPS** | ⚠️ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⚠️ | ✅ | ✅ | ✅ | ✅ | ⚠️ | **⭐⭐⭐⭐⭐** |
| **Analytics** | ⚠️ | ⚠️ | ⚠️ | ⚠️ | ⚠️ | ⚠️ | ✅ | ✅ | ✅ | **⭐⭐⭐⭐⭐** | ⚠️ | ⚠️ |
| **Monetization** | ❌ | ⚠️ | ❌ | ❌ | ❌ | ❌ | ⚠️ | ⚠️ | ❌ | **⭐⭐⭐⭐⭐** | ❌ | ❌ |
| **Backend Aggregation** | ⚠️ | ⚠️ | ⚠️ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ⚠️ | **⭐⭐⭐⭐⭐** | ❌ |
| **Zero Config** | ❌ | ❌ | ❌ | ⭐⭐⭐ | ❌ | ❌ | ⚠️ | ⚠️ | ⚠️ | ❌ | ⭐⭐⭐ | **⭐⭐⭐⭐⭐** |
| **req/s** | 45k | 35k | 50k | 30k | 50k | 60k | Varies | Varies | Varies | **40k** | **70k** | 40k |

### Apigee's Stärken
- 🥇 **Vollständigste Enterprise Lösung** - API Management, Analytics, Monetization, Portal
- 🥇 **API Monetization** - Built-in Billing & Revenue Sharing
- 🥇 **Developer Portal** - Self-Service with OAuth
- 🥇 **Policy Framework** - 50+ vordefinierte Policies
- ✅ API Analytics (Real-time Dashboards)
- ✅ Multi-Cloud & Hybrid (On-Prem + Cloud)
- ✅ Traffic Management (Splitting, Mirroring, Advanced Routing)

**Beste Wahl für:**
- 🏢 Enterprise API Management (Fortune 500)
- 💰 API Monetization (Billing, Rate Plans)
- 👥 Developer Ecosystems (Partner APIs)
- 🌐 Multi-Cloud & Hybrid Deployments
- 📊 Advanced Analytics & Reporting
- 🔒 Regulatory Compliance (GDPR, HIPAA, PCI-DSS)

### KrakenD's Stärken
- 🥇 **Höchste Performance** - 70.000 req/s
- 🥇 **Stateless Architecture** - Kein Backend (DB, Redis) benötigt
- 🥇 **Backend Aggregation** - Multiple Backends → Single Response
- ✅ Low Memory Footprint (~100 MB)
- ✅ Single Binary (zero dependencies)
- ✅ Cloud-Native (Kubernetes-ready)

**Beste Wahl für:**
- 🚀 High-Traffic APIs (>10k req/s)
- 💰 FinTech, Gaming, E-Commerce
- 🔄 Backend for Frontend Pattern
- ☁️ Cloud-Native Architectures
- 📊 Microservices Aggregation

### Caddy's Stärken
- 🥇 **Beste Developer Experience** - Einfachste Konfiguration
- 🥇 **Bestes Auto-HTTPS** - Zero-Config TLS
- 🥇 **Bestes Zero-Config** - Funktioniert out-of-the-box
- ✅ HTTP/3 / QUIC Native
- ✅ Single Binary (keine Dependencies)
- ✅ JSON API für dynamische Updates
- ✅ Perfekt für Entwicklungsumgebungen

**Beste Wahl für:**
- 🚀 Rapid Prototyping
- 💻 Entwicklungsumgebungen (lokales HTTPS ohne Zertifikate)
- 🏢 Kleine bis mittlere Deployments
- 🌐 Edge Computing (lightweight)
- 📱 Mobile Backend Development

---

## Nächste Schritte (Nach v1.4.0 Abschluss)

1. Apigee Provider Anforderungen mit Enterprise Kunden überprüfen
2. Apigee API Proxy Bundle Struktur analysieren
3. Apigee Policy Framework evaluieren (50+ Policies)
4. Prototype ApigeeProvider erstellen (XML Generation)
5. KrakenD Provider Anforderungen mit Community überprüfen
6. Prototype KrakenDProvider erstellen (JSON Config)
7. Caddy Provider Anforderungen verifizieren
8. Prototype CaddyProvider erstellen (JSON API)
9. Implementation in Q4 2026 beginnen

---

**Status:** 📝 Planungsdokument - Bereit für v1.5.0 Implementierung nach v1.4.0 Abschluss

---

## Success Metrics

Nach Abschluss von v1.5.0:

**Provider Support:**
- ✅ **12 Provider** total (6 self-hosted + 3 cloud + 3 neue)
  - Self-Hosted: Envoy, Kong, APISIX, Traefik, Nginx, HAProxy
  - Cloud: AWS API Gateway, Azure APIM, GCP API Gateway
  - **Neu v1.5.0:** Apigee, KrakenD, Caddy
- ✅ **3 neue Provider** mit Import & Export
- ✅ **100% Provider Coverage** für alle gängigen API Gateways

**Tests:**
- ✅ **60+ neue Tests** (25 Apigee + 20 KrakenD + 15 Caddy)
- ✅ **609+ Total Tests** (v1.4.0: 549 Tests)
- ✅ **89%+ Code Coverage**

**Dokumentation:**
- ✅ **5300+ Zeilen** neue Dokumentation (Deutsch)
  - docs/guides/APIGEE.md (1500+ Zeilen)
  - docs/guides/KRAKEND.md (1000+ Zeilen)
  - docs/import/krakend.md (800+ Zeilen)
  - docs/guides/CADDY.md (1000+ Zeilen)
  - examples/* (1000+ Zeilen)
- ✅ **README.md** mit allen 12 Providern

**Migration:**
- ✅ **132 Provider-Kombinationen** (12×11 ohne self-migration)
- ✅ **Migration Assistant** unterstützt alle 12 Provider
- ✅ **Compatibility Checker** erweitert für Apigee, KrakenD & Caddy
