# v1.5.0 Implementierungsplan

**Status:** ğŸ”„ Geplant
**Zeitplan:** Q4 2026 (geschÃ¤tzt)
**Fokus:** High-Performance & Developer Experience Gateways
**Estimated Effort:** 6-8 Wochen

---

## Mission

**"High-Performance Gateways: KrakenD Ultra-Performance + Caddy Developer Experience"**

Erweitere GAL um zwei spezialisierte Gateway-Provider: **KrakenD** fÃ¼r ultra-hohe Performance (70k req/s) und **Caddy** fÃ¼r perfekte Developer Experience mit Zero-Config HTTPS.

**Nach v1.5.0 hat GAL Support fÃ¼r 8 Provider:**
1. Envoy âœ… (v1.0.0)
2. Kong âœ… (v1.1.0)
3. APISIX âœ… (v1.1.0)
4. Traefik âœ… (v1.1.0)
5. Nginx âœ… (v1.3.0)
6. HAProxy âœ… (v1.3.0)
7. **KrakenD ğŸ†• (v1.5.0)**
8. **Caddy ğŸ†• (v1.5.0)**

---

## Feature-Ãœbersicht

| Feature | Status | Aufwand | PrioritÃ¤t |
|---------|--------|---------|-----------|
| **1. KrakenD Provider** | ğŸ”„ Ausstehend | 3 Wochen | ğŸ”´ Hoch |
| **2. Caddy Provider** | ğŸ”„ Ausstehend | 3 Wochen | ğŸ”´ Hoch |

**Gesamtaufwand:** 6-8 Wochen
**Fortschritt:** 0/2 Features (0%)

---

## Feature 1: KrakenD Provider (DETAILLIERT)

**Status:** ğŸ”„ Ausstehend
**PrioritÃ¤t:** ğŸ”´ Hoch
**Aufwand:** 3 Wochen

### Motivation

- **Problem**: HÃ¶chste Performance fÃ¼r API-Gateways bei hohen Request-Volumina (>10k req/s)
- **Herausforderung**: KrakenD hat eine eigene JSON-basierte Konfiguration mit spezifischen Namenskonventionen
- **LÃ¶sung**: GAL generiert und importiert KrakenD JSON-Config aus/zu einheitlicher YAML-Konfiguration

### Warum KrakenD?

**Vorteile:**
- âœ… **Ultra-High Performance**: 70.000 Requests/Sekunde (Go-basiert, stateless)
- âœ… **Stateless Architecture**: Kein Backend (DB, Redis) benÃ¶tigt
- âœ… **File-Based Configuration**: Single JSON file (`krakend.json`)
- âœ… **Backend Aggregation**: Multiple Backend Calls â†’ Single Response
- âœ… **Low Memory Footprint**: ~100 MB RAM fÃ¼r High-Load Scenarios
- âœ… **Zero Dependencies**: Single Binary (wie Caddy)
- âœ… **API Composition**: Response Merging, Filtering, Grouping
- âœ… **Cloud-Native**: Kubernetes-ready, Docker-optimized
- âœ… **Enterprise Edition**: Advanced features (OpenID, Circuit Breaker, etc.)

**Performance Comparison:**
- KrakenD: ~70k req/s
- Nginx: ~50k req/s
- Envoy: ~45k req/s
- Kong: ~35k req/s
- Traefik: ~30k req/s

**Use Cases:**
- High-Traffic APIs (E-Commerce, Gaming, FinTech)
- Microservices Aggregation (Backend for Frontend Pattern)
- Cloud-Native Architectures (Kubernetes)
- Stateless Deployments (Horizontal Scaling)
- Edge Computing (Low Resource Usage)

### Konfigurationsmodell

KrakenD nutzt die bestehenden GAL Config-Models, keine Ã„nderungen erforderlich!

### KrakenD JSON Beispiel

**GAL Config:**
```yaml
version: "1.0"
provider: krakend

services:
  - name: api_service
    protocol: http
    upstream:
      targets:
        - host: api-1.internal
          port: 8080
          weight: 2
        - host: api-2.internal
          port: 8080
          weight: 1
      load_balancer:
        algorithm: round_robin
      health_check:
        active:
          enabled: true
          http_path: /health
          interval: 10s

    routes:
      - path_prefix: /api/users
        http_methods: ["GET", "POST"]
        rate_limit:
          enabled: true
          requests_per_second: 100
          burst: 200
        timeout:
          request: 30s
        headers:
          request_add:
            X-Gateway: "GAL-KrakenD"
```

**Generierte KrakenD JSON Config:**
```json
{
  "$schema": "https://www.krakend.io/schema/v3.json",
  "version": 3,
  "port": 8080,
  "endpoints": [
    {
      "endpoint": "/api/users",
      "method": "GET",
      "backend": [
        {
          "url_pattern": "/api/users",
          "host": [
            "http://api-1.internal:8080",
            "http://api-2.internal:8080"
          ],
          "sd": "static",
          "extra_config": {
            "qos/ratelimit/proxy": {
              "max_rate": 100,
              "capacity": 200
            }
          }
        }
      ],
      "extra_config": {
        "qos/ratelimit/router": {
          "max_rate": 100,
          "client_max_rate": 10
        }
      },
      "timeout": "30s",
      "headers_to_pass": ["X-Gateway"]
    },
    {
      "endpoint": "/api/users",
      "method": "POST",
      "backend": [
        {
          "url_pattern": "/api/users",
          "host": [
            "http://api-1.internal:8080",
            "http://api-2.internal:8080"
          ]
        }
      ],
      "timeout": "30s"
    }
  ],
  "extra_config": {
    "router": {
      "return_error_msg": true
    },
    "telemetry/metrics": {
      "collection_time": "30s",
      "listen_address": ":8090"
    }
  }
}
```

### Provider-Implementierung

**Datei:** `gal/providers/krakend.py`

```python
import json
from typing import Dict, List, Any
from gal.config import Config, Service, Route
from gal.providers.base import Provider

class KrakenDProvider(Provider):
    """KrakenD Provider fÃ¼r GAL - Ultra-High-Performance API Gateway."""

    def __init__(self):
        super().__init__("krakend")

    def generate(self, config: Config) -> str:
        """Generiere KrakenD JSON-Config."""
        output = {
            "$schema": "https://www.krakend.io/schema/v3.json",
            "version": 3,
            "port": config.global_config.port or 8080,
            "endpoints": [],
            "extra_config": {
                "router": {
                    "return_error_msg": True
                }
            }
        }

        # Generate endpoints fÃ¼r jeden Service
        for service in config.services:
            for route in service.routes:
                # KrakenD hat separate endpoints per HTTP method
                if route.http_methods:
                    for method in route.http_methods:
                        endpoint = self._generate_endpoint(service, route, method)
                        output["endpoints"].append(endpoint)
                else:
                    # Default: GET method
                    endpoint = self._generate_endpoint(service, route, "GET")
                    output["endpoints"].append(endpoint)

        # Global Telemetry
        output["extra_config"]["telemetry/metrics"] = {
            "collection_time": "30s",
            "listen_address": ":8090"
        }

        return json.dumps(output, indent=2)

    def _generate_endpoint(self, service: Service, route: Route, method: str) -> Dict[str, Any]:
        """Generiere einzelnen KrakenD Endpoint."""
        endpoint = {
            "endpoint": route.path_prefix,
            "method": method,
            "backend": [],
            "extra_config": {}
        }

        # Backend (Upstream Targets)
        backend = {
            "url_pattern": route.path_prefix,
            "host": [],
            "sd": "static",  # Service Discovery: static
            "extra_config": {}
        }

        if service.upstream and service.upstream.targets:
            for target in service.upstream.targets:
                host_url = f"http://{target.host}:{target.port}"
                backend["host"].append(host_url)

        # Load Balancing (KrakenD hat Round-Robin als Default)
        # Weighted Load Balancing via target weights
        if service.upstream and service.upstream.load_balancer:
            lb_algo = service.upstream.load_balancer.algorithm
            if lb_algo == "round_robin":
                backend["sd"] = "static"  # Default
            elif lb_algo == "weighted":
                # KrakenD unterstÃ¼tzt weighted via multiple host entries
                # TODO: Implement weighted hosts
                pass

        # Rate Limiting (Backend Level)
        if route.rate_limit and route.rate_limit.enabled:
            backend["extra_config"]["qos/ratelimit/proxy"] = {
                "max_rate": route.rate_limit.requests_per_second,
                "capacity": route.rate_limit.burst or route.rate_limit.requests_per_second * 2
            }

            # Rate Limiting (Router Level)
            endpoint["extra_config"]["qos/ratelimit/router"] = {
                "max_rate": route.rate_limit.requests_per_second,
                "client_max_rate": route.rate_limit.requests_per_second // 10  # per client
            }

        # Timeout
        if route.timeout:
            endpoint["timeout"] = route.timeout.request or "30s"

        # Header Manipulation
        if route.headers and route.headers.request_add:
            endpoint["headers_to_pass"] = list(route.headers.request_add.keys())

        # Circuit Breaker (KrakenD Enterprise)
        if route.circuit_breaker and route.circuit_breaker.enabled:
            backend["extra_config"]["qos/circuit-breaker"] = {
                "interval": 10,
                "timeout": 10,
                "maxErrors": route.circuit_breaker.failure_threshold or 5,
                "logStatusChange": True
            }

        endpoint["backend"].append(backend)
        return endpoint

    def parse(self, krakend_config: str) -> Config:
        """Parse KrakenD JSON Config â†’ GAL Config."""
        data = json.loads(krakend_config)

        config = Config(
            version="1.0",
            provider="krakend",
            services=[]
        )

        # Extract global config
        config.global_config.port = data.get("port", 8080)

        # Group endpoints by path_prefix â†’ Service
        services_map = {}

        for endpoint in data.get("endpoints", []):
            path = endpoint.get("endpoint", "/")
            method = endpoint.get("method", "GET")

            # Create or get service
            if path not in services_map:
                service = Service(
                    name=f"service_{path.replace('/', '_')}",
                    protocol="http",
                    upstream=None,
                    routes=[]
                )
                services_map[path] = service

            service = services_map[path]

            # Parse backend targets
            for backend in endpoint.get("backend", []):
                hosts = backend.get("host", [])
                for host_url in hosts:
                    # Parse http://api-1.internal:8080 â†’ host, port
                    host_url = host_url.replace("http://", "").replace("https://", "")
                    if ":" in host_url:
                        host, port = host_url.split(":")
                        target = {"host": host, "port": int(port)}
                        # Add to service upstream
                        if not service.upstream:
                            service.upstream = {"targets": []}
                        if target not in service.upstream["targets"]:
                            service.upstream["targets"].append(target)

                # Parse rate limiting
                extra_config = backend.get("extra_config", {})
                if "qos/ratelimit/proxy" in extra_config:
                    rl = extra_config["qos/ratelimit/proxy"]
                    # Add rate limit to route (not service)
                    # We'll add this later when creating the route

            # Create route
            route = {
                "path_prefix": path,
                "http_methods": [method]
            }

            # Parse endpoint-level config
            if "timeout" in endpoint:
                route["timeout"] = {
                    "request": endpoint["timeout"]
                }

            # Parse rate limiting (router level)
            endpoint_extra = endpoint.get("extra_config", {})
            if "qos/ratelimit/router" in endpoint_extra:
                rl = endpoint_extra["qos/ratelimit/router"]
                route["rate_limit"] = {
                    "enabled": True,
                    "requests_per_second": rl.get("max_rate", 100)
                }

            # Merge routes with same path but different methods
            existing_route = next((r for r in service.routes if r["path_prefix"] == path), None)
            if existing_route:
                if method not in existing_route["http_methods"]:
                    existing_route["http_methods"].append(method)
            else:
                service.routes.append(route)

        config.services = list(services_map.values())
        return config

    def validate(self, config: Config) -> bool:
        """Validiere KrakenD-Konfiguration."""
        # Warnungen fÃ¼r nicht unterstÃ¼tzte Features
        for service in config.services:
            for route in service.routes:
                # JWT Auth erfordert KrakenD Enterprise
                if route.authentication and route.authentication.type == "jwt":
                    logger.warning(
                        "JWT Authentication in KrakenD erfordert KrakenD Enterprise Edition. "
                        "Siehe: https://www.krakend.io/docs/enterprise/"
                    )

                # Circuit Breaker erfordert KrakenD Enterprise
                if route.circuit_breaker and route.circuit_breaker.enabled:
                    logger.warning(
                        "Circuit Breaker in KrakenD erfordert KrakenD Enterprise Edition. "
                        "Siehe: https://www.krakend.io/docs/enterprise/endpoints/circuit-breaker/"
                    )

                # Body Transformation (Basic support in OSS, Advanced in Enterprise)
                if route.body_transformation and route.body_transformation.enabled:
                    logger.info(
                        "Body Transformation: KrakenD OSS unterstÃ¼tzt basic response manipulation. "
                        "FÃ¼r advanced transformations: KrakenD Enterprise Edition erforderlich."
                    )

        return True
```

### Import Implementierung

**Datei:** `gal/providers/krakend.py` (parse method - siehe oben)

**Import-Features:**
- âœ… **Endpoints â†’ Routes:** path_prefix, http_methods
- âœ… **Backend hosts â†’ Upstream Targets:** host, port
- âœ… **Rate Limiting:** qos/ratelimit/* â†’ rate_limit config
- âœ… **Timeout:** timeout â†’ timeout.request
- âœ… **Circuit Breaker:** qos/circuit-breaker â†’ circuit_breaker
- âœ… **Load Balancing:** sd (static) â†’ round_robin algorithm
- âš ï¸ **Backend Aggregation:** Multiple backends â†’ Multiple services (simplified)

### Feature-Support Matrix

| Feature | KrakenD Support | GAL Implementation | Hinweise |
|---------|----------------|-------------------|----------|
| Load Balancing | âœ… VollstÃ¤ndig | `sd` parameter | round_robin (default), weighted via host duplication |
| Active Health Checks | âš ï¸ Enterprise | `health_check` | Requires KrakenD Enterprise |
| Passive Health Checks | âŒ Nicht verfÃ¼gbar | - | Not supported |
| Rate Limiting | âœ… VollstÃ¤ndig | `qos/ratelimit/*` | Router + Proxy level |
| Basic Auth | âœ… VollstÃ¤ndig | `auth/basic` | Native support |
| JWT Auth | âš ï¸ Enterprise | `auth/jwt` | Requires KrakenD Enterprise |
| API Key Auth | âœ… VollstÃ¤ndig | `auth/api-keys` | Native support |
| Header Manipulation | âœ… VollstÃ¤ndig | `headers_to_pass` | Request headers |
| CORS | âœ… VollstÃ¤ndig | `security/cors` | Native support |
| Timeout | âœ… VollstÃ¤ndig | `timeout` | Per-endpoint |
| Retry | âœ… VollstÃ¤ndig | `qos/http-cache` | Via cache + retry |
| Circuit Breaker | âš ï¸ Enterprise | `qos/circuit-breaker` | Requires KrakenD Enterprise |
| WebSocket | âŒ Nicht verfÃ¼gbar | - | Not supported (HTTP/REST only) |
| Body Transformation | âš ï¸ Teilweise | `modifier/*` | Basic OSS, Advanced Enterprise |
| **Backend Aggregation** | âœ… **Unique** | `backend` array | **KrakenD's Killer Feature!** |
| **Response Filtering** | âœ… **Unique** | `deny`, `allow` | **JSON filtering** |

### Testing-Strategie

**Datei:** `tests/test_krakend.py` (20+ Tests)

```python
# Test-Kategorien:
# 1. Provider basics (name, validate)
# 2. Endpoint generation (path_prefix, http_methods)
# 3. Backend configuration (host, port, targets)
# 4. Load balancing (round_robin, weighted)
# 5. Rate limiting (router + proxy level)
# 6. Timeout configuration
# 7. Header manipulation
# 8. CORS policies
# 9. Circuit breaker (Enterprise warning)
# 10. Multiple endpoints/routes
# 11. JSON output validation
# 12. Config Import (krakend.json â†’ GAL)
# 13. Backend aggregation (multiple backends)
# 14. Response filtering
```

### Dokumentation

**Datei:** `docs/guides/KRAKEND.md` (1000+ Zeilen, Deutsch)

Abschnitte:
- Ãœbersicht & KrakenD's Unique Features
- Schnellstart (3 Beispiele mit Backend Aggregation)
- Installation & Setup (Binary, Docker, Kubernetes)
- Konfigurationsoptionen
- Feature-Implementierungen (alle 10+ Features)
- KrakenD-spezifische Details:
  - Backend Aggregation (Multiple Backends â†’ Single Response)
  - Response Filtering & Manipulation
  - JSON-only Configuration
  - Stateless Architecture (No DB needed)
  - Performance Tuning (70k req/s)
  - Enterprise vs OSS Features
- Provider-Vergleich (vs anderen Gateways)
- Best Practices
- Troubleshooting

**Datei:** `docs/import/krakend.md` (800+ Zeilen, Deutsch)

Abschnitte:
- Ãœbersicht KrakenD Config Import
- CLI Usage (`gal import-config --provider krakend`)
- Import-Mapping (krakend.json â†’ gal-config.yaml)
- Beispiele (10+ Szenarien)
- Feature Coverage (Import Support Matrix)
- EinschrÃ¤nkungen & Workarounds
- Roundtrip Compatibility (Import â†’ Export â†’ Import)

**Datei:** `examples/krakend/krakend.json` (Simple Config)

**Datei:** `examples/krakend/production-krakend.json` (Complex Config)

### Meilensteine

**Woche 1:** Provider Implementation + Core Features
- KrakenDProvider Klasse
- JSON-Config Generation
- Endpoint Mapping
- Backend Configuration
- Rate Limiting (Router + Proxy)
- 10+ Tests

**Woche 2:** Import + Advanced Features + Documentation
- `parse()` method (Import from krakend.json)
- Circuit Breaker (Enterprise warning)
- CORS Configuration
- Timeout & Retry
- Header Manipulation
- 10+ Tests
- docs/guides/KRAKEND.md (500+ Zeilen)
- docs/import/krakend.md (400+ Zeilen)

**Woche 3:** Examples + Integration + Polish
- examples/krakend/*.json (10+ Szenarien)
- CLI Integration (`gal import-config --provider krakend`)
- README.md Updates
- Provider Feature Coverage Tables
- docs/guides/KRAKEND.md vervollstÃ¤ndigen (1000+ Zeilen)
- docs/import/krakend.md vervollstÃ¤ndigen (800+ Zeilen)

### Akzeptanzkriterien

âœ… KrakenDProvider generiert valide krakend.json
âœ… Alle Endpoints mit korrekten HTTP methods
âœ… Backend hosts korrekt gemappt
âœ… Rate Limiting (Router + Proxy Level)
âœ… Timeout konfigurierbar
âœ… Header Manipulation
âœ… CORS Support
âœ… Circuit Breaker (mit Enterprise warning)
âœ… Config Import (krakend.json â†’ GAL) funktioniert
âœ… 20+ Tests bestehen (100% passing)
âœ… 1000+ Zeilen deutsche Dokumentation (guides/KRAKEND.md)
âœ… 800+ Zeilen Import-Dokumentation (import/krakend.md)
âœ… 10+ Beispiel-Szenarien
âœ… CLI Integration komplett

### Deployment-Beispiel

```bash
# GAL-Config â†’ KrakenD generieren
gal generate --config config.yaml --provider krakend --output krakend.json

# KrakenD mit generierter Config starten
krakend run -c krakend.json

# Performance: 70k req/s out of the box!

# Import von existierendem KrakenD
gal import-config --provider krakend --input krakend.json --output gal-config.yaml
```

---

## Feature 2: Caddy Provider (DETAILLIERT)

**Status:** ğŸ”„ Ausstehend
**PrioritÃ¤t:** ğŸ”´ Hoch
**Aufwand:** 3 Wochen

### Motivation

- **Problem**: Entwickler benÃ¶tigen eine einfach zu konfigurierende Gateway-LÃ¶sung mit automatischem HTTPS
- **Herausforderung**: Caddy hat eine eigene JSON-API und Caddyfile-Syntax
- **LÃ¶sung**: GAL generiert Caddy JSON-Config aus einheitlicher YAML-Konfiguration

### Warum Caddy?

**Vorteile:**
- âœ… **Automatisches HTTPS**: Let's Encrypt & ZeroSSL ohne Konfiguration
- âœ… **Einfache Syntax**: Caddyfile oder JSON-API
- âœ… **HTTP/3 Ready**: QUIC-Support native
- âœ… **Dynamische Konfiguration**: JSON-API fÃ¼r Live-Updates
- âœ… **Native gRPC**: Reverse-Proxy fÃ¼r gRPC-Services
- âœ… **Plugin-System**: Erweiterbar via Caddy Modules
- âœ… **Zero Dependencies**: Single Binary
- âœ… **Developer-Friendly**: Perfekt fÃ¼r Developer Experience Theme

**Use Cases:**
- Entwicklungsumgebungen (lokales HTTPS ohne Zertifikate)
- Microservices (automatisches Service Discovery)
- Cloud-Native Deployments (Kubernetes)
- Edge Computing (lightweight binary)
- Prototyping (schnelle Einrichtung)

### Konfigurationsmodell

Caddy nutzt die bestehenden GAL Config-Models, keine Ã„nderungen erforderlich!

### Caddy JSON API Beispiel

**GAL Config:**
```yaml
services:
  - name: api_service
    protocol: http
    upstream:
      targets:
        - host: api-1.internal
          port: 8080
        - host: api-2.internal
          port: 8080
      load_balancer:
        algorithm: round_robin
      health_check:
        active:
          enabled: true
          http_path: /health
          interval: 10s

    routes:
      - path_prefix: /api
        rate_limit:
          enabled: true
          requests_per_second: 100
        headers:
          request_add:
            X-Gateway: "GAL-Caddy"
```

**Generierte Caddy JSON Config:**
```json
{
  "apps": {
    "http": {
      "servers": {
        "srv0": {
          "listen": [":443"],
          "routes": [
            {
              "match": [
                {
                  "path": ["/api*"]
                }
              ],
              "handle": [
                {
                  "handler": "reverse_proxy",
                  "upstreams": [
                    {"dial": "api-1.internal:8080"},
                    {"dial": "api-2.internal:8080"}
                  ],
                  "load_balancing": {
                    "selection_policy": {
                      "policy": "round_robin"
                    }
                  },
                  "health_checks": {
                    "active": {
                      "path": "/health",
                      "interval": "10s"
                    }
                  }
                }
              ]
            }
          ],
          "automatic_https": {
            "disable": false
          }
        }
      }
    }
  }
}
```

### Feature-Support Matrix

| Feature | Caddy Support | GAL Implementation | Hinweise |
|---------|---------------|-------------------|----------|
| Load Balancing | âœ… VollstÃ¤ndig | `selection_policy` | round_robin, least_conn, ip_hash, weighted |
| Active Health Checks | âœ… VollstÃ¤ndig | `health_checks.active` | HTTP/HTTPS endpoints |
| Passive Health Checks | âœ… VollstÃ¤ndig | `health_checks.passive` | failure_policy |
| Rate Limiting | âš ï¸ Plugin | `rate_limit` handler | Requires caddy-ratelimit plugin |
| Basic Auth | âœ… VollstÃ¤ndig | `basicauth` handler | Native support |
| JWT Auth | âš ï¸ Plugin | caddy-security | Requires caddy-security plugin |
| Header Manipulation | âœ… VollstÃ¤ndig | `headers` handler | Native request/response |
| CORS | âœ… VollstÃ¤ndig | `headers` handler | Via Access-Control-* headers |
| Timeout | âœ… VollstÃ¤ndig | `transport` config | dial_timeout, read_timeout, write_timeout |
| Retry | âœ… VollstÃ¤ndig | `lb_try_duration` | Native retry support |
| Circuit Breaker | âš ï¸ Plugin | circuit-breaker module | Via plugin |
| WebSocket | âœ… VollstÃ¤ndig | Native | Automatic upgrade |
| Body Transformation | âš ï¸ Module | Custom module | Requires development |
| **Automatic HTTPS** | âœ… **Unique** | `automatic_https` | **Caddy's Killer Feature!** |
| **HTTP/3** | âœ… **Unique** | `protocols` | **QUIC native** |

### Testing-Strategie

**Datei:** `tests/test_caddy.py` (15+ Tests)

```python
# Test-Kategorien:
# 1. Provider basics (name, validate)
# 2. Load balancing (round_robin, least_conn, ip_hash, weighted)
# 3. Active health checks
# 4. Basic authentication
# 5. Header manipulation (request, response)
# 6. CORS policies
# 7. Timeout configuration
# 8. Retry policies
# 9. WebSocket support
# 10. Multiple services/routes
# 11. Automatic HTTPS configuration
# 12. JSON output validation
```

### Dokumentation

**Datei:** `docs/guides/CADDY.md` (1000+ Zeilen, Deutsch)

Abschnitte:
- Ãœbersicht & Caddy's Unique Features
- Schnellstart (3 Beispiele mit automatischem HTTPS)
- Installation & Setup (Binary, Docker, Kubernetes)
- Konfigurationsoptionen
- Feature-Implementierungen (alle 10 Features)
- Caddy-spezifische Details:
  - JSON API vs Caddyfile
  - Automatic HTTPS (Let's Encrypt, ZeroSSL)
  - HTTP/3 / QUIC Configuration
  - Admin API fÃ¼r Live-Updates
  - Caddy Modules / Plugin System
- Provider-Vergleich (vs anderen Gateways)
- Best Practices
- Troubleshooting

**Datei:** `examples/caddy-example.yaml` (15+ Szenarien)

### Meilensteine

**Woche 1:** Provider Implementation + Core Features
- CaddyProvider Klasse
- JSON-Config Generation
- Load Balancing
- Health Checks
- 8+ Tests

**Woche 2:** Advanced Features + Documentation
- Rate Limiting (Plugin-Warning)
- Authentication (Basic + JWT Warning)
- Header Manipulation
- CORS
- Timeout & Retry
- WebSocket
- 7+ Tests
- docs/guides/CADDY.md (500+ Zeilen)

**Woche 3:** Examples + Integration + Polish
- examples/caddy-example.yaml (15 Szenarien)
- CLI Integration
- README.md Updates
- docs/guides/CADDY.md vervollstÃ¤ndigen (1000+ Zeilen)

### Akzeptanzkriterien

âœ… CaddyProvider generiert valide JSON-Config
âœ… Alle Load-Balancing-Algorithmen unterstÃ¼tzt
âœ… Active Health Checks funktionieren
âœ… Header Manipulation (request/response)
âœ… CORS via headers handler
âœ… Timeout & Retry konfigurierbar
âœ… WebSocket native support
âœ… Automatic HTTPS konfigurierbar
âœ… 15+ Tests bestehen (100% passing)
âœ… 1000+ Zeilen deutsche Dokumentation
âœ… 15+ Beispiel-Szenarien
âœ… CLI Integration komplett

### Deployment-Beispiel

```bash
# GAL-Config generieren
gal generate --config config.yaml --provider caddy --output caddy.json

# Caddy mit generierter Config starten
caddy run --config caddy.json

# Oder Caddy JSON API verwenden (Live-Update)
curl -X POST http://localhost:2019/load \
  -H "Content-Type: application/json" \
  -d @caddy.json

# Automatic HTTPS aktiv
# Caddy lÃ¤dt automatisch Let's Encrypt Zertifikate fÃ¼r alle Domains!
```

---

## Zeitplan

**Wochen 1-3:** KrakenD Provider
- Woche 1: Core Implementation + Export
- Woche 2: Import + Advanced Features
- Woche 3: Documentation + Examples

**Wochen 4-6:** Caddy Provider
- Woche 4: Core Implementation + Features
- Woche 5: Advanced Features + Documentation
- Woche 6: Examples + Integration + Polish

**Buffer:** +1-2 Wochen fÃ¼r Testing & Integration

**Gesamt:** 6-8 Wochen (Q4 2026)

---

## AbhÃ¤ngigkeiten

### KrakenD Provider
- **KrakenD v2.5+** - KrakenD Server Binary
- Keine zusÃ¤tzlichen AbhÃ¤ngigkeiten (Single Binary)

### KrakenD Optional (Enterprise Features)
- **KrakenD Enterprise** - FÃ¼r JWT Auth, Circuit Breaker, Advanced Transformations

### Caddy Provider
- **Caddy v2.7+** - Caddy Server Binary
- Keine zusÃ¤tzlichen AbhÃ¤ngigkeiten (Single Binary)

### Caddy Optional (fÃ¼r erweiterte Features)
- **caddy-ratelimit** - Rate Limiting Plugin
- **caddy-security** - JWT Authentication Plugin
- **caddy-circuit-breaker** - Circuit Breaker Plugin

---

## Provider-Vergleich (mit KrakenD & Caddy)

| Feature | Envoy | Kong | APISIX | Traefik | Nginx | HAProxy | **KrakenD** | **Caddy** |
|---------|-------|------|--------|---------|-------|---------|-------------|-----------|
| **Performance** | â­â­â­â­ | â­â­â­ | â­â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ | **â­â­â­â­â­** | â­â­â­â­ |
| **Ease of Use** | â­â­ | â­â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ | â­â­â­ | â­â­â­ | â­â­â­â­ | **â­â­â­â­â­** |
| **Stateless** | âœ… | âŒ | âŒ | âœ… | âœ… | âœ… | **âœ…** | âœ… |
| **Auto HTTPS** | âš ï¸ | â­â­â­ | â­â­â­ | â­â­â­â­â­ | â­â­â­ | âš ï¸ | âš ï¸ | **â­â­â­â­â­** |
| **HTTP/3** | âœ… | âš ï¸ | âœ… | âœ… | âš ï¸ | âš ï¸ | âš ï¸ | **âœ…** |
| **Backend Aggregation** | âš ï¸ | âš ï¸ | âš ï¸ | âŒ | âŒ | âŒ | **â­â­â­â­â­** | âŒ |
| **Zero Config** | âŒ | âŒ | âŒ | â­â­â­ | âŒ | âŒ | â­â­â­ | **â­â­â­â­â­** |
| **req/s** | 45k | 35k | 50k | 30k | 50k | 60k | **70k** | 40k |

### KrakenD's StÃ¤rken
- ğŸ¥‡ **HÃ¶chste Performance** - 70.000 req/s
- ğŸ¥‡ **Stateless Architecture** - Kein Backend (DB, Redis) benÃ¶tigt
- ğŸ¥‡ **Backend Aggregation** - Multiple Backends â†’ Single Response
- âœ… Low Memory Footprint (~100 MB)
- âœ… Single Binary (zero dependencies)
- âœ… Cloud-Native (Kubernetes-ready)

**Beste Wahl fÃ¼r:**
- ğŸš€ High-Traffic APIs (>10k req/s)
- ğŸ’° FinTech, Gaming, E-Commerce
- ğŸ”„ Backend for Frontend Pattern
- â˜ï¸ Cloud-Native Architectures
- ğŸ“Š Microservices Aggregation

### Caddy's StÃ¤rken
- ğŸ¥‡ **Beste Developer Experience** - Einfachste Konfiguration
- ğŸ¥‡ **Bestes Auto-HTTPS** - Zero-Config TLS
- ğŸ¥‡ **Bestes Zero-Config** - Funktioniert out-of-the-box
- âœ… HTTP/3 / QUIC Native
- âœ… Single Binary (keine Dependencies)
- âœ… JSON API fÃ¼r dynamische Updates
- âœ… Perfekt fÃ¼r Entwicklungsumgebungen

**Beste Wahl fÃ¼r:**
- ğŸš€ Rapid Prototyping
- ğŸ’» Entwicklungsumgebungen (lokales HTTPS ohne Zertifikate)
- ğŸ¢ Kleine bis mittlere Deployments
- ğŸŒ Edge Computing (lightweight)
- ğŸ“± Mobile Backend Development

---

## NÃ¤chste Schritte (Nach v1.4.0 Abschluss)

1. KrakenD Provider Anforderungen mit Community Ã¼berprÃ¼fen
2. Prototype KrakenDProvider erstellen
3. JSON-Config Generation testen
4. KrakenD Enterprise vs OSS Features evaluieren
5. Caddy Provider Anforderungen verifizieren
6. Prototype CaddyProvider erstellen
7. Caddy Plugins evaluieren (rate-limit, security)
8. Implementation in Q4 2026 beginnen

---

**Status:** ğŸ“ Planungsdokument - Bereit fÃ¼r v1.5.0 Implementierung nach v1.4.0 Abschluss

---

## Success Metrics

Nach Abschluss von v1.5.0:

**Provider Support:**
- âœ… **8 Provider** total (Envoy, Kong, APISIX, Traefik, Nginx, HAProxy, KrakenD, Caddy)
- âœ… **2 neue Provider** mit Import & Export
- âœ… **100% Provider Coverage** fÃ¼r alle gÃ¤ngigen API Gateways

**Tests:**
- âœ… **35+ neue Tests** (20 KrakenD + 15 Caddy)
- âœ… **584+ Total Tests** (v1.4.0: 549 Tests)
- âœ… **89%+ Code Coverage**

**Dokumentation:**
- âœ… **3800+ Zeilen** neue Dokumentation (Deutsch)
  - docs/guides/KRAKEND.md (1000+ Zeilen)
  - docs/import/krakend.md (800+ Zeilen)
  - docs/guides/CADDY.md (1000+ Zeilen)
  - examples/* (1000+ Zeilen)
- âœ… **README.md** mit allen 8 Providern

**Migration:**
- âœ… **56 Provider-Kombinationen** (8Ã—7 ohne self-migration)
- âœ… **Migration Assistant** unterstÃ¼tzt alle 8 Provider
- âœ… **Compatibility Checker** erweitert fÃ¼r KrakenD & Caddy
