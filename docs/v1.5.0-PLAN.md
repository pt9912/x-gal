# v1.5.0 Implementierungsplan

**Status:** 🔄 Geplant
**Zeitplan:** Q4 2026 (geschätzt)
**Fokus:** High-Performance & Developer Experience Gateways
**Estimated Effort:** 6-8 Wochen

---

## Mission

**"High-Performance Gateways: KrakenD Ultra-Performance + Caddy Developer Experience"**

Erweitere GAL um zwei spezialisierte Gateway-Provider: **KrakenD** für ultra-hohe Performance (70k req/s) und **Caddy** für perfekte Developer Experience mit Zero-Config HTTPS.

**Nach v1.5.0 hat GAL Support für 8 Provider:**
1. Envoy ✅ (v1.0.0)
2. Kong ✅ (v1.1.0)
3. APISIX ✅ (v1.1.0)
4. Traefik ✅ (v1.1.0)
5. Nginx ✅ (v1.3.0)
6. HAProxy ✅ (v1.3.0)
7. **KrakenD 🆕 (v1.5.0)**
8. **Caddy 🆕 (v1.5.0)**

---

## Feature-Übersicht

| Feature | Status | Aufwand | Priorität |
|---------|--------|---------|-----------|
| **1. KrakenD Provider** | 🔄 Ausstehend | 3 Wochen | 🔴 Hoch |
| **2. Caddy Provider** | 🔄 Ausstehend | 3 Wochen | 🔴 Hoch |

**Gesamtaufwand:** 6-8 Wochen
**Fortschritt:** 0/2 Features (0%)

---

## Feature 1: KrakenD Provider (DETAILLIERT)

**Status:** 🔄 Ausstehend
**Priorität:** 🔴 Hoch
**Aufwand:** 3 Wochen

### Motivation

- **Problem**: Höchste Performance für API-Gateways bei hohen Request-Volumina (>10k req/s)
- **Herausforderung**: KrakenD hat eine eigene JSON-basierte Konfiguration mit spezifischen Namenskonventionen
- **Lösung**: GAL generiert und importiert KrakenD JSON-Config aus/zu einheitlicher YAML-Konfiguration

### Warum KrakenD?

**Vorteile:**
- ✅ **Ultra-High Performance**: 70.000 Requests/Sekunde (Go-basiert, stateless)
- ✅ **Stateless Architecture**: Kein Backend (DB, Redis) benötigt
- ✅ **File-Based Configuration**: Single JSON file (`krakend.json`)
- ✅ **Backend Aggregation**: Multiple Backend Calls → Single Response
- ✅ **Low Memory Footprint**: ~100 MB RAM für High-Load Scenarios
- ✅ **Zero Dependencies**: Single Binary (wie Caddy)
- ✅ **API Composition**: Response Merging, Filtering, Grouping
- ✅ **Cloud-Native**: Kubernetes-ready, Docker-optimized
- ✅ **Enterprise Edition**: Advanced features (OpenID, Circuit Breaker, etc.)

**Performance Comparison:**
- KrakenD: ~70k req/s
- Nginx: ~50k req/s
- Envoy: ~45k req/s
- Kong: ~35k req/s
- Traefik: ~30k req/s

**Use Cases:**
- High-Traffic APIs (E-Commerce, Gaming, FinTech)
- Microservices Aggregation (Backend for Frontend Pattern)
- Cloud-Native Architectures (Kubernetes)
- Stateless Deployments (Horizontal Scaling)
- Edge Computing (Low Resource Usage)

### Konfigurationsmodell

KrakenD nutzt die bestehenden GAL Config-Models, keine Änderungen erforderlich!

### KrakenD JSON Beispiel

**GAL Config:**
```yaml
version: "1.0"
provider: krakend

services:
  - name: api_service
    protocol: http
    upstream:
      targets:
        - host: api-1.internal
          port: 8080
          weight: 2
        - host: api-2.internal
          port: 8080
          weight: 1
      load_balancer:
        algorithm: round_robin
      health_check:
        active:
          enabled: true
          http_path: /health
          interval: 10s

    routes:
      - path_prefix: /api/users
        http_methods: ["GET", "POST"]
        rate_limit:
          enabled: true
          requests_per_second: 100
          burst: 200
        timeout:
          request: 30s
        headers:
          request_add:
            X-Gateway: "GAL-KrakenD"
```

**Generierte KrakenD JSON Config:**
```json
{
  "$schema": "https://www.krakend.io/schema/v3.json",
  "version": 3,
  "port": 8080,
  "endpoints": [
    {
      "endpoint": "/api/users",
      "method": "GET",
      "backend": [
        {
          "url_pattern": "/api/users",
          "host": [
            "http://api-1.internal:8080",
            "http://api-2.internal:8080"
          ],
          "sd": "static",
          "extra_config": {
            "qos/ratelimit/proxy": {
              "max_rate": 100,
              "capacity": 200
            }
          }
        }
      ],
      "extra_config": {
        "qos/ratelimit/router": {
          "max_rate": 100,
          "client_max_rate": 10
        }
      },
      "timeout": "30s",
      "headers_to_pass": ["X-Gateway"]
    },
    {
      "endpoint": "/api/users",
      "method": "POST",
      "backend": [
        {
          "url_pattern": "/api/users",
          "host": [
            "http://api-1.internal:8080",
            "http://api-2.internal:8080"
          ]
        }
      ],
      "timeout": "30s"
    }
  ],
  "extra_config": {
    "router": {
      "return_error_msg": true
    },
    "telemetry/metrics": {
      "collection_time": "30s",
      "listen_address": ":8090"
    }
  }
}
```

### Provider-Implementierung

**Datei:** `gal/providers/krakend.py`

```python
import json
from typing import Dict, List, Any
from gal.config import Config, Service, Route
from gal.providers.base import Provider

class KrakenDProvider(Provider):
    """KrakenD Provider für GAL - Ultra-High-Performance API Gateway."""

    def __init__(self):
        super().__init__("krakend")

    def generate(self, config: Config) -> str:
        """Generiere KrakenD JSON-Config."""
        output = {
            "$schema": "https://www.krakend.io/schema/v3.json",
            "version": 3,
            "port": config.global_config.port or 8080,
            "endpoints": [],
            "extra_config": {
                "router": {
                    "return_error_msg": True
                }
            }
        }

        # Generate endpoints für jeden Service
        for service in config.services:
            for route in service.routes:
                # KrakenD hat separate endpoints per HTTP method
                if route.http_methods:
                    for method in route.http_methods:
                        endpoint = self._generate_endpoint(service, route, method)
                        output["endpoints"].append(endpoint)
                else:
                    # Default: GET method
                    endpoint = self._generate_endpoint(service, route, "GET")
                    output["endpoints"].append(endpoint)

        # Global Telemetry
        output["extra_config"]["telemetry/metrics"] = {
            "collection_time": "30s",
            "listen_address": ":8090"
        }

        return json.dumps(output, indent=2)

    def _generate_endpoint(self, service: Service, route: Route, method: str) -> Dict[str, Any]:
        """Generiere einzelnen KrakenD Endpoint."""
        endpoint = {
            "endpoint": route.path_prefix,
            "method": method,
            "backend": [],
            "extra_config": {}
        }

        # Backend (Upstream Targets)
        backend = {
            "url_pattern": route.path_prefix,
            "host": [],
            "sd": "static",  # Service Discovery: static
            "extra_config": {}
        }

        if service.upstream and service.upstream.targets:
            for target in service.upstream.targets:
                host_url = f"http://{target.host}:{target.port}"
                backend["host"].append(host_url)

        # Load Balancing (KrakenD hat Round-Robin als Default)
        # Weighted Load Balancing via target weights
        if service.upstream and service.upstream.load_balancer:
            lb_algo = service.upstream.load_balancer.algorithm
            if lb_algo == "round_robin":
                backend["sd"] = "static"  # Default
            elif lb_algo == "weighted":
                # KrakenD unterstützt weighted via multiple host entries
                # TODO: Implement weighted hosts
                pass

        # Rate Limiting (Backend Level)
        if route.rate_limit and route.rate_limit.enabled:
            backend["extra_config"]["qos/ratelimit/proxy"] = {
                "max_rate": route.rate_limit.requests_per_second,
                "capacity": route.rate_limit.burst or route.rate_limit.requests_per_second * 2
            }

            # Rate Limiting (Router Level)
            endpoint["extra_config"]["qos/ratelimit/router"] = {
                "max_rate": route.rate_limit.requests_per_second,
                "client_max_rate": route.rate_limit.requests_per_second // 10  # per client
            }

        # Timeout
        if route.timeout:
            endpoint["timeout"] = route.timeout.request or "30s"

        # Header Manipulation
        if route.headers and route.headers.request_add:
            endpoint["headers_to_pass"] = list(route.headers.request_add.keys())

        # Circuit Breaker (KrakenD Enterprise)
        if route.circuit_breaker and route.circuit_breaker.enabled:
            backend["extra_config"]["qos/circuit-breaker"] = {
                "interval": 10,
                "timeout": 10,
                "maxErrors": route.circuit_breaker.failure_threshold or 5,
                "logStatusChange": True
            }

        endpoint["backend"].append(backend)
        return endpoint

    def parse(self, krakend_config: str) -> Config:
        """Parse KrakenD JSON Config → GAL Config."""
        data = json.loads(krakend_config)

        config = Config(
            version="1.0",
            provider="krakend",
            services=[]
        )

        # Extract global config
        config.global_config.port = data.get("port", 8080)

        # Group endpoints by path_prefix → Service
        services_map = {}

        for endpoint in data.get("endpoints", []):
            path = endpoint.get("endpoint", "/")
            method = endpoint.get("method", "GET")

            # Create or get service
            if path not in services_map:
                service = Service(
                    name=f"service_{path.replace('/', '_')}",
                    protocol="http",
                    upstream=None,
                    routes=[]
                )
                services_map[path] = service

            service = services_map[path]

            # Parse backend targets
            for backend in endpoint.get("backend", []):
                hosts = backend.get("host", [])
                for host_url in hosts:
                    # Parse http://api-1.internal:8080 → host, port
                    host_url = host_url.replace("http://", "").replace("https://", "")
                    if ":" in host_url:
                        host, port = host_url.split(":")
                        target = {"host": host, "port": int(port)}
                        # Add to service upstream
                        if not service.upstream:
                            service.upstream = {"targets": []}
                        if target not in service.upstream["targets"]:
                            service.upstream["targets"].append(target)

                # Parse rate limiting
                extra_config = backend.get("extra_config", {})
                if "qos/ratelimit/proxy" in extra_config:
                    rl = extra_config["qos/ratelimit/proxy"]
                    # Add rate limit to route (not service)
                    # We'll add this later when creating the route

            # Create route
            route = {
                "path_prefix": path,
                "http_methods": [method]
            }

            # Parse endpoint-level config
            if "timeout" in endpoint:
                route["timeout"] = {
                    "request": endpoint["timeout"]
                }

            # Parse rate limiting (router level)
            endpoint_extra = endpoint.get("extra_config", {})
            if "qos/ratelimit/router" in endpoint_extra:
                rl = endpoint_extra["qos/ratelimit/router"]
                route["rate_limit"] = {
                    "enabled": True,
                    "requests_per_second": rl.get("max_rate", 100)
                }

            # Merge routes with same path but different methods
            existing_route = next((r for r in service.routes if r["path_prefix"] == path), None)
            if existing_route:
                if method not in existing_route["http_methods"]:
                    existing_route["http_methods"].append(method)
            else:
                service.routes.append(route)

        config.services = list(services_map.values())
        return config

    def validate(self, config: Config) -> bool:
        """Validiere KrakenD-Konfiguration."""
        # Warnungen für nicht unterstützte Features
        for service in config.services:
            for route in service.routes:
                # JWT Auth erfordert KrakenD Enterprise
                if route.authentication and route.authentication.type == "jwt":
                    logger.warning(
                        "JWT Authentication in KrakenD erfordert KrakenD Enterprise Edition. "
                        "Siehe: https://www.krakend.io/docs/enterprise/"
                    )

                # Circuit Breaker erfordert KrakenD Enterprise
                if route.circuit_breaker and route.circuit_breaker.enabled:
                    logger.warning(
                        "Circuit Breaker in KrakenD erfordert KrakenD Enterprise Edition. "
                        "Siehe: https://www.krakend.io/docs/enterprise/endpoints/circuit-breaker/"
                    )

                # Body Transformation (Basic support in OSS, Advanced in Enterprise)
                if route.body_transformation and route.body_transformation.enabled:
                    logger.info(
                        "Body Transformation: KrakenD OSS unterstützt basic response manipulation. "
                        "Für advanced transformations: KrakenD Enterprise Edition erforderlich."
                    )

        return True
```

### Import Implementierung

**Datei:** `gal/providers/krakend.py` (parse method - siehe oben)

**Import-Features:**
- ✅ **Endpoints → Routes:** path_prefix, http_methods
- ✅ **Backend hosts → Upstream Targets:** host, port
- ✅ **Rate Limiting:** qos/ratelimit/* → rate_limit config
- ✅ **Timeout:** timeout → timeout.request
- ✅ **Circuit Breaker:** qos/circuit-breaker → circuit_breaker
- ✅ **Load Balancing:** sd (static) → round_robin algorithm
- ⚠️ **Backend Aggregation:** Multiple backends → Multiple services (simplified)

### Feature-Support Matrix

| Feature | KrakenD Support | GAL Implementation | Hinweise |
|---------|----------------|-------------------|----------|
| Load Balancing | ✅ Vollständig | `sd` parameter | round_robin (default), weighted via host duplication |
| Active Health Checks | ⚠️ Enterprise | `health_check` | Requires KrakenD Enterprise |
| Passive Health Checks | ❌ Nicht verfügbar | - | Not supported |
| Rate Limiting | ✅ Vollständig | `qos/ratelimit/*` | Router + Proxy level |
| Basic Auth | ✅ Vollständig | `auth/basic` | Native support |
| JWT Auth | ⚠️ Enterprise | `auth/jwt` | Requires KrakenD Enterprise |
| API Key Auth | ✅ Vollständig | `auth/api-keys` | Native support |
| Header Manipulation | ✅ Vollständig | `headers_to_pass` | Request headers |
| CORS | ✅ Vollständig | `security/cors` | Native support |
| Timeout | ✅ Vollständig | `timeout` | Per-endpoint |
| Retry | ✅ Vollständig | `qos/http-cache` | Via cache + retry |
| Circuit Breaker | ⚠️ Enterprise | `qos/circuit-breaker` | Requires KrakenD Enterprise |
| WebSocket | ❌ Nicht verfügbar | - | Not supported (HTTP/REST only) |
| Body Transformation | ⚠️ Teilweise | `modifier/*` | Basic OSS, Advanced Enterprise |
| **Backend Aggregation** | ✅ **Unique** | `backend` array | **KrakenD's Killer Feature!** |
| **Response Filtering** | ✅ **Unique** | `deny`, `allow` | **JSON filtering** |

### Testing-Strategie

**Datei:** `tests/test_krakend.py` (20+ Tests)

```python
# Test-Kategorien:
# 1. Provider basics (name, validate)
# 2. Endpoint generation (path_prefix, http_methods)
# 3. Backend configuration (host, port, targets)
# 4. Load balancing (round_robin, weighted)
# 5. Rate limiting (router + proxy level)
# 6. Timeout configuration
# 7. Header manipulation
# 8. CORS policies
# 9. Circuit breaker (Enterprise warning)
# 10. Multiple endpoints/routes
# 11. JSON output validation
# 12. Config Import (krakend.json → GAL)
# 13. Backend aggregation (multiple backends)
# 14. Response filtering
```

### Dokumentation

**Datei:** `docs/guides/KRAKEND.md` (1000+ Zeilen, Deutsch)

Abschnitte:
- Übersicht & KrakenD's Unique Features
- Schnellstart (3 Beispiele mit Backend Aggregation)
- Installation & Setup (Binary, Docker, Kubernetes)
- Konfigurationsoptionen
- Feature-Implementierungen (alle 10+ Features)
- KrakenD-spezifische Details:
  - Backend Aggregation (Multiple Backends → Single Response)
  - Response Filtering & Manipulation
  - JSON-only Configuration
  - Stateless Architecture (No DB needed)
  - Performance Tuning (70k req/s)
  - Enterprise vs OSS Features
- Provider-Vergleich (vs anderen Gateways)
- Best Practices
- Troubleshooting

**Datei:** `docs/import/krakend.md` (800+ Zeilen, Deutsch)

Abschnitte:
- Übersicht KrakenD Config Import
- CLI Usage (`gal import-config --provider krakend`)
- Import-Mapping (krakend.json → gal-config.yaml)
- Beispiele (10+ Szenarien)
- Feature Coverage (Import Support Matrix)
- Einschränkungen & Workarounds
- Roundtrip Compatibility (Import → Export → Import)

**Datei:** `examples/krakend/krakend.json` (Simple Config)

**Datei:** `examples/krakend/production-krakend.json` (Complex Config)

### Meilensteine

**Woche 1:** Provider Implementation + Core Features
- KrakenDProvider Klasse
- JSON-Config Generation
- Endpoint Mapping
- Backend Configuration
- Rate Limiting (Router + Proxy)
- 10+ Tests

**Woche 2:** Import + Advanced Features + Documentation
- `parse()` method (Import from krakend.json)
- Circuit Breaker (Enterprise warning)
- CORS Configuration
- Timeout & Retry
- Header Manipulation
- 10+ Tests
- docs/guides/KRAKEND.md (500+ Zeilen)
- docs/import/krakend.md (400+ Zeilen)

**Woche 3:** Examples + Integration + Polish
- examples/krakend/*.json (10+ Szenarien)
- CLI Integration (`gal import-config --provider krakend`)
- README.md Updates
- Provider Feature Coverage Tables
- docs/guides/KRAKEND.md vervollständigen (1000+ Zeilen)
- docs/import/krakend.md vervollständigen (800+ Zeilen)

### Akzeptanzkriterien

✅ KrakenDProvider generiert valide krakend.json
✅ Alle Endpoints mit korrekten HTTP methods
✅ Backend hosts korrekt gemappt
✅ Rate Limiting (Router + Proxy Level)
✅ Timeout konfigurierbar
✅ Header Manipulation
✅ CORS Support
✅ Circuit Breaker (mit Enterprise warning)
✅ Config Import (krakend.json → GAL) funktioniert
✅ 20+ Tests bestehen (100% passing)
✅ 1000+ Zeilen deutsche Dokumentation (guides/KRAKEND.md)
✅ 800+ Zeilen Import-Dokumentation (import/krakend.md)
✅ 10+ Beispiel-Szenarien
✅ CLI Integration komplett

### Deployment-Beispiel

```bash
# GAL-Config → KrakenD generieren
gal generate --config config.yaml --provider krakend --output krakend.json

# KrakenD mit generierter Config starten
krakend run -c krakend.json

# Performance: 70k req/s out of the box!

# Import von existierendem KrakenD
gal import-config --provider krakend --input krakend.json --output gal-config.yaml
```

---

## Feature 2: Caddy Provider (DETAILLIERT)

**Status:** 🔄 Ausstehend
**Priorität:** 🔴 Hoch
**Aufwand:** 3 Wochen

### Motivation

- **Problem**: Entwickler benötigen eine einfach zu konfigurierende Gateway-Lösung mit automatischem HTTPS
- **Herausforderung**: Caddy hat eine eigene JSON-API und Caddyfile-Syntax
- **Lösung**: GAL generiert Caddy JSON-Config aus einheitlicher YAML-Konfiguration

### Warum Caddy?

**Vorteile:**
- ✅ **Automatisches HTTPS**: Let's Encrypt & ZeroSSL ohne Konfiguration
- ✅ **Einfache Syntax**: Caddyfile oder JSON-API
- ✅ **HTTP/3 Ready**: QUIC-Support native
- ✅ **Dynamische Konfiguration**: JSON-API für Live-Updates
- ✅ **Native gRPC**: Reverse-Proxy für gRPC-Services
- ✅ **Plugin-System**: Erweiterbar via Caddy Modules
- ✅ **Zero Dependencies**: Single Binary
- ✅ **Developer-Friendly**: Perfekt für Developer Experience Theme

**Use Cases:**
- Entwicklungsumgebungen (lokales HTTPS ohne Zertifikate)
- Microservices (automatisches Service Discovery)
- Cloud-Native Deployments (Kubernetes)
- Edge Computing (lightweight binary)
- Prototyping (schnelle Einrichtung)

### Konfigurationsmodell

Caddy nutzt die bestehenden GAL Config-Models, keine Änderungen erforderlich!

### Caddy JSON API Beispiel

**GAL Config:**
```yaml
services:
  - name: api_service
    protocol: http
    upstream:
      targets:
        - host: api-1.internal
          port: 8080
        - host: api-2.internal
          port: 8080
      load_balancer:
        algorithm: round_robin
      health_check:
        active:
          enabled: true
          http_path: /health
          interval: 10s

    routes:
      - path_prefix: /api
        rate_limit:
          enabled: true
          requests_per_second: 100
        headers:
          request_add:
            X-Gateway: "GAL-Caddy"
```

**Generierte Caddy JSON Config:**
```json
{
  "apps": {
    "http": {
      "servers": {
        "srv0": {
          "listen": [":443"],
          "routes": [
            {
              "match": [
                {
                  "path": ["/api*"]
                }
              ],
              "handle": [
                {
                  "handler": "reverse_proxy",
                  "upstreams": [
                    {"dial": "api-1.internal:8080"},
                    {"dial": "api-2.internal:8080"}
                  ],
                  "load_balancing": {
                    "selection_policy": {
                      "policy": "round_robin"
                    }
                  },
                  "health_checks": {
                    "active": {
                      "path": "/health",
                      "interval": "10s"
                    }
                  }
                }
              ]
            }
          ],
          "automatic_https": {
            "disable": false
          }
        }
      }
    }
  }
}
```

### Feature-Support Matrix

| Feature | Caddy Support | GAL Implementation | Hinweise |
|---------|---------------|-------------------|----------|
| Load Balancing | ✅ Vollständig | `selection_policy` | round_robin, least_conn, ip_hash, weighted |
| Active Health Checks | ✅ Vollständig | `health_checks.active` | HTTP/HTTPS endpoints |
| Passive Health Checks | ✅ Vollständig | `health_checks.passive` | failure_policy |
| Rate Limiting | ⚠️ Plugin | `rate_limit` handler | Requires caddy-ratelimit plugin |
| Basic Auth | ✅ Vollständig | `basicauth` handler | Native support |
| JWT Auth | ⚠️ Plugin | caddy-security | Requires caddy-security plugin |
| Header Manipulation | ✅ Vollständig | `headers` handler | Native request/response |
| CORS | ✅ Vollständig | `headers` handler | Via Access-Control-* headers |
| Timeout | ✅ Vollständig | `transport` config | dial_timeout, read_timeout, write_timeout |
| Retry | ✅ Vollständig | `lb_try_duration` | Native retry support |
| Circuit Breaker | ⚠️ Plugin | circuit-breaker module | Via plugin |
| WebSocket | ✅ Vollständig | Native | Automatic upgrade |
| Body Transformation | ⚠️ Module | Custom module | Requires development |
| **Automatic HTTPS** | ✅ **Unique** | `automatic_https` | **Caddy's Killer Feature!** |
| **HTTP/3** | ✅ **Unique** | `protocols` | **QUIC native** |

### Testing-Strategie

**Datei:** `tests/test_caddy.py` (15+ Tests)

```python
# Test-Kategorien:
# 1. Provider basics (name, validate)
# 2. Load balancing (round_robin, least_conn, ip_hash, weighted)
# 3. Active health checks
# 4. Basic authentication
# 5. Header manipulation (request, response)
# 6. CORS policies
# 7. Timeout configuration
# 8. Retry policies
# 9. WebSocket support
# 10. Multiple services/routes
# 11. Automatic HTTPS configuration
# 12. JSON output validation
```

### Dokumentation

**Datei:** `docs/guides/CADDY.md` (1000+ Zeilen, Deutsch)

Abschnitte:
- Übersicht & Caddy's Unique Features
- Schnellstart (3 Beispiele mit automatischem HTTPS)
- Installation & Setup (Binary, Docker, Kubernetes)
- Konfigurationsoptionen
- Feature-Implementierungen (alle 10 Features)
- Caddy-spezifische Details:
  - JSON API vs Caddyfile
  - Automatic HTTPS (Let's Encrypt, ZeroSSL)
  - HTTP/3 / QUIC Configuration
  - Admin API für Live-Updates
  - Caddy Modules / Plugin System
- Provider-Vergleich (vs anderen Gateways)
- Best Practices
- Troubleshooting

**Datei:** `examples/caddy-example.yaml` (15+ Szenarien)

### Meilensteine

**Woche 1:** Provider Implementation + Core Features
- CaddyProvider Klasse
- JSON-Config Generation
- Load Balancing
- Health Checks
- 8+ Tests

**Woche 2:** Advanced Features + Documentation
- Rate Limiting (Plugin-Warning)
- Authentication (Basic + JWT Warning)
- Header Manipulation
- CORS
- Timeout & Retry
- WebSocket
- 7+ Tests
- docs/guides/CADDY.md (500+ Zeilen)

**Woche 3:** Examples + Integration + Polish
- examples/caddy-example.yaml (15 Szenarien)
- CLI Integration
- README.md Updates
- docs/guides/CADDY.md vervollständigen (1000+ Zeilen)

### Akzeptanzkriterien

✅ CaddyProvider generiert valide JSON-Config
✅ Alle Load-Balancing-Algorithmen unterstützt
✅ Active Health Checks funktionieren
✅ Header Manipulation (request/response)
✅ CORS via headers handler
✅ Timeout & Retry konfigurierbar
✅ WebSocket native support
✅ Automatic HTTPS konfigurierbar
✅ 15+ Tests bestehen (100% passing)
✅ 1000+ Zeilen deutsche Dokumentation
✅ 15+ Beispiel-Szenarien
✅ CLI Integration komplett

### Deployment-Beispiel

```bash
# GAL-Config generieren
gal generate --config config.yaml --provider caddy --output caddy.json

# Caddy mit generierter Config starten
caddy run --config caddy.json

# Oder Caddy JSON API verwenden (Live-Update)
curl -X POST http://localhost:2019/load \
  -H "Content-Type: application/json" \
  -d @caddy.json

# Automatic HTTPS aktiv
# Caddy lädt automatisch Let's Encrypt Zertifikate für alle Domains!
```

---

## Zeitplan

**Wochen 1-3:** KrakenD Provider
- Woche 1: Core Implementation + Export
- Woche 2: Import + Advanced Features
- Woche 3: Documentation + Examples

**Wochen 4-6:** Caddy Provider
- Woche 4: Core Implementation + Features
- Woche 5: Advanced Features + Documentation
- Woche 6: Examples + Integration + Polish

**Buffer:** +1-2 Wochen für Testing & Integration

**Gesamt:** 6-8 Wochen (Q4 2026)

---

## Abhängigkeiten

### KrakenD Provider
- **KrakenD v2.5+** - KrakenD Server Binary
- Keine zusätzlichen Abhängigkeiten (Single Binary)

### KrakenD Optional (Enterprise Features)
- **KrakenD Enterprise** - Für JWT Auth, Circuit Breaker, Advanced Transformations

### Caddy Provider
- **Caddy v2.7+** - Caddy Server Binary
- Keine zusätzlichen Abhängigkeiten (Single Binary)

### Caddy Optional (für erweiterte Features)
- **caddy-ratelimit** - Rate Limiting Plugin
- **caddy-security** - JWT Authentication Plugin
- **caddy-circuit-breaker** - Circuit Breaker Plugin

---

## Provider-Vergleich (mit KrakenD & Caddy)

| Feature | Envoy | Kong | APISIX | Traefik | Nginx | HAProxy | **KrakenD** | **Caddy** |
|---------|-------|------|--------|---------|-------|---------|-------------|-----------|
| **Performance** | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | **⭐⭐⭐⭐⭐** | ⭐⭐⭐⭐ |
| **Ease of Use** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | **⭐⭐⭐⭐⭐** |
| **Stateless** | ✅ | ❌ | ❌ | ✅ | ✅ | ✅ | **✅** | ✅ |
| **Auto HTTPS** | ⚠️ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⚠️ | ⚠️ | **⭐⭐⭐⭐⭐** |
| **HTTP/3** | ✅ | ⚠️ | ✅ | ✅ | ⚠️ | ⚠️ | ⚠️ | **✅** |
| **Backend Aggregation** | ⚠️ | ⚠️ | ⚠️ | ❌ | ❌ | ❌ | **⭐⭐⭐⭐⭐** | ❌ |
| **Zero Config** | ❌ | ❌ | ❌ | ⭐⭐⭐ | ❌ | ❌ | ⭐⭐⭐ | **⭐⭐⭐⭐⭐** |
| **req/s** | 45k | 35k | 50k | 30k | 50k | 60k | **70k** | 40k |

### KrakenD's Stärken
- 🥇 **Höchste Performance** - 70.000 req/s
- 🥇 **Stateless Architecture** - Kein Backend (DB, Redis) benötigt
- 🥇 **Backend Aggregation** - Multiple Backends → Single Response
- ✅ Low Memory Footprint (~100 MB)
- ✅ Single Binary (zero dependencies)
- ✅ Cloud-Native (Kubernetes-ready)

**Beste Wahl für:**
- 🚀 High-Traffic APIs (>10k req/s)
- 💰 FinTech, Gaming, E-Commerce
- 🔄 Backend for Frontend Pattern
- ☁️ Cloud-Native Architectures
- 📊 Microservices Aggregation

### Caddy's Stärken
- 🥇 **Beste Developer Experience** - Einfachste Konfiguration
- 🥇 **Bestes Auto-HTTPS** - Zero-Config TLS
- 🥇 **Bestes Zero-Config** - Funktioniert out-of-the-box
- ✅ HTTP/3 / QUIC Native
- ✅ Single Binary (keine Dependencies)
- ✅ JSON API für dynamische Updates
- ✅ Perfekt für Entwicklungsumgebungen

**Beste Wahl für:**
- 🚀 Rapid Prototyping
- 💻 Entwicklungsumgebungen (lokales HTTPS ohne Zertifikate)
- 🏢 Kleine bis mittlere Deployments
- 🌐 Edge Computing (lightweight)
- 📱 Mobile Backend Development

---

## Nächste Schritte (Nach v1.4.0 Abschluss)

1. KrakenD Provider Anforderungen mit Community überprüfen
2. Prototype KrakenDProvider erstellen
3. JSON-Config Generation testen
4. KrakenD Enterprise vs OSS Features evaluieren
5. Caddy Provider Anforderungen verifizieren
6. Prototype CaddyProvider erstellen
7. Caddy Plugins evaluieren (rate-limit, security)
8. Implementation in Q4 2026 beginnen

---

**Status:** 📝 Planungsdokument - Bereit für v1.5.0 Implementierung nach v1.4.0 Abschluss

---

## Success Metrics

Nach Abschluss von v1.5.0:

**Provider Support:**
- ✅ **8 Provider** total (Envoy, Kong, APISIX, Traefik, Nginx, HAProxy, KrakenD, Caddy)
- ✅ **2 neue Provider** mit Import & Export
- ✅ **100% Provider Coverage** für alle gängigen API Gateways

**Tests:**
- ✅ **35+ neue Tests** (20 KrakenD + 15 Caddy)
- ✅ **584+ Total Tests** (v1.4.0: 549 Tests)
- ✅ **89%+ Code Coverage**

**Dokumentation:**
- ✅ **3800+ Zeilen** neue Dokumentation (Deutsch)
  - docs/guides/KRAKEND.md (1000+ Zeilen)
  - docs/import/krakend.md (800+ Zeilen)
  - docs/guides/CADDY.md (1000+ Zeilen)
  - examples/* (1000+ Zeilen)
- ✅ **README.md** mit allen 8 Providern

**Migration:**
- ✅ **56 Provider-Kombinationen** (8×7 ohne self-migration)
- ✅ **Migration Assistant** unterstützt alle 8 Provider
- ✅ **Compatibility Checker** erweitert für KrakenD & Caddy
