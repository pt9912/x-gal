{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gateway Abstraction Layer (GAL)","text":"<p>Provider-agnostisches Konfigurationssystem f\u00fcr API-Gateways</p> <p>GAL erm\u00f6glicht es Ihnen, API-Gateway-Konfigurationen einmal zu definieren und f\u00fcr verschiedene Provider (Nginx, Envoy, Kong, APISIX, Traefik, HAProxy) zu generieren.</p>"},{"location":"#schnelleinstieg","title":"Schnelleinstieg","text":"config.yaml<pre><code>version: \"1.0\"\nprovider: envoy\n\nservices:\n  - name: my_service\n    type: rest\n    protocol: http\n    upstream:\n      host: my-app\n      port: 8080\n    routes:\n      - path_prefix: /api\n</code></pre> <pre><code># F\u00fcr beliebigen Provider generieren\ngal generate -c config.yaml -p nginx\ngal generate -c config.yaml -p envoy\ngal generate -c config.yaml -p kong\n</code></pre> <p>Zur Schnellstart-Anleitung \u2192</p>"},{"location":"#hauptfeatures","title":"Hauptfeatures","text":"<ul> <li> <p> Provider-agnostisch</p> <p>Keine Vendor Lock-in. Wechseln Sie zwischen Gateways ohne Config-Neuschreibung.</p> </li> <li> <p> Umfangreiche Features</p> <p>Authentication, Rate Limiting, CORS, Circuit Breaker, Health Checks und mehr.</p> </li> <li> <p> Automatische Transformationen</p> <p>Defaults, UUID-Generierung, Timestamps - alles automatisch.</p> </li> <li> <p> Docker-Ready</p> <p>Container-basierte Workflows mit docker-compose Integration.</p> </li> <li> <p> CI/CD-freundlich</p> <p>Einfache Integration in Ihre Deployment-Pipeline.</p> </li> <li> <p> Import/Export</p> <p>Importieren Sie bestehende Provider-Configs und exportieren Sie zu GAL.</p> </li> </ul>"},{"location":"#unterstutzte-provider","title":"Unterst\u00fctzte Provider","text":"Provider Status Output-Format Transformations Import/Export Nginx nginx.conf Lua/njs  /  Envoy YAML Lua Filters  /  Kong YAML Plugins  /  APISIX JSON/YAML Lua Serverless  /  Traefik YAML/TOML Middleware  /  HAProxy haproxy.cfg Lua  /"},{"location":"#dokumentations-navigation","title":"Dokumentations-Navigation","text":""},{"location":"#guides","title":"Guides","text":"<p>Praktische Anleitungen f\u00fcr h\u00e4ufige Aufgaben:</p> <ul> <li>Schnellstart - Installation und erste Schritte in 5 Minuten</li> <li>Provider-\u00dcbersicht - Vergleich aller Gateway-Provider</li> <li>Provider-spezifisch: Nginx | Envoy | Kong | APISIX | Traefik | HAProxy</li> <li>Transformationen - Request-Transformationen und Best Practices</li> <li>Entwicklung - Zum Projekt beitragen</li> </ul>"},{"location":"#features","title":"Features","text":"<p>Detaillierte Feature-Dokumentation:</p> <ul> <li>Authentication - JWT, API Keys, Basic Auth</li> <li>Rate Limiting - Request-Limitierung</li> <li>CORS - Cross-Origin Resource Sharing</li> <li>Circuit Breaker - Fehlerbehandlung</li> <li>Health Checks - Upstream-Monitoring</li> <li>Headers - Header-Manipulation</li> <li>Logging &amp; Observability - Monitoring &amp; Logging</li> <li>Body Transformation - Request/Response Transformation</li> <li>WebSocket - WebSocket-Unterst\u00fctzung</li> <li>Timeout &amp; Retry - Timeout- &amp; Retry-Strategien</li> </ul>"},{"location":"#api-referenz","title":"API-Referenz","text":"<p>Vollst\u00e4ndige technische Referenz:</p> <ul> <li>CLI-Referenz - Alle Befehle und Optionen</li> <li>Konfigurationsreferenz - YAML-Schema und alle Optionen</li> </ul>"},{"location":"#architektur","title":"Architektur","text":"<p>Technische Details und Design:</p> <ul> <li>Architektur-\u00dcbersicht - System-Design, Komponenten, Datenfluss</li> </ul>"},{"location":"#schnell-links-fur-verschiedene-zielgruppen","title":"Schnell-Links f\u00fcr verschiedene Zielgruppen","text":"EinsteigerEntwicklerDevOps <ol> <li>Schnellstart-Guide - Erste Schritte</li> <li>Konfigurationsbeispiele - Vollst\u00e4ndige Beispiele</li> <li>CLI-Referenz - Befehls\u00fcbersicht</li> </ol> <ol> <li>Entwickler-Guide - Setup und Contribution</li> <li>Architektur - System-Design</li> <li>Python-API-Referenz - Klassen und Docstrings</li> <li>Tests schreiben - Test-Best-Practices</li> </ol> <ol> <li>Provider-Vergleich - Welcher Provider passt?</li> <li>Docker-Integration - Container-Deployment</li> <li>CI/CD-Integration - Automation</li> </ol>"},{"location":"#neuigkeiten","title":"Neuigkeiten","text":""},{"location":"#version-130","title":"Version 1.3.0","text":"<p>Neu in v1.3.0:</p> <ul> <li> Nginx Import-Unterst\u00fctzung (Custom Parser f\u00fcr nginx.conf)</li> <li> Traefik Import-Unterst\u00fctzung (YAML Parser)</li> <li> APISIX Import-Unterst\u00fctzung (JSON/YAML Parser)</li> <li> Kong Import-Unterst\u00fctzung (Erweitert)</li> <li> Envoy Import-Unterst\u00fctzung (Erweitert)</li> <li> Umfassende Feature Coverage Analyse f\u00fcr alle 6 Provider</li> <li> Provider-spezifische Dokumentationsguides</li> </ul> <p>Zum Changelog \u2192</p>"},{"location":"#community-support","title":"Community &amp; Support","text":""},{"location":"#hilfe-bekommen","title":"Hilfe bekommen","text":"<ul> <li>GitHub Issues: Bug Reports &amp; Feature Requests</li> <li>GitHub Discussions: Fragen &amp; Diskussionen</li> </ul>"},{"location":"#beitragen","title":"Beitragen","text":"<p>Interessiert daran beizutragen? Siehe:</p> <ul> <li>Entwickler-Guide</li> <li>Contribution-Checklist</li> </ul>"},{"location":"#lizenz","title":"Lizenz","text":"<p>MIT License - siehe LICENSE</p> <p>Viel Erfolg mit GAL!</p>"},{"location":"PYPI_PUBLISHING/","title":"PyPI Publishing Guide","text":"<p>Dieser Guide beschreibt, wie GAL (Gateway Abstraction Layer) auf PyPI ver\u00f6ffentlicht wird.</p>"},{"location":"PYPI_PUBLISHING/#ubersicht","title":"\u00dcbersicht","text":"<p>GAL wird auf PyPI unter dem Namen <code>gal-gateway</code> ver\u00f6ffentlicht.</p> <ul> <li>Package Name: <code>gal-gateway</code></li> <li>Import Name: <code>gal</code></li> <li>CLI Command: <code>gal</code></li> <li>PyPI URL: https://pypi.org/project/gal-gateway/</li> <li>TestPyPI URL: https://test.pypi.org/project/gal-gateway/</li> </ul>"},{"location":"PYPI_PUBLISHING/#installation-fur-nutzer","title":"Installation f\u00fcr Nutzer","text":""},{"location":"PYPI_PUBLISHING/#von-pypi-empfohlen","title":"Von PyPI (Empfohlen)","text":"<pre><code>pip install gal-gateway\n</code></pre>"},{"location":"PYPI_PUBLISHING/#von-testpypi-pre-release-versionen","title":"Von TestPyPI (Pre-Release Versionen)","text":"<pre><code>pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ gal-gateway\n</code></pre>"},{"location":"PYPI_PUBLISHING/#von-github-development","title":"Von GitHub (Development)","text":"<pre><code>pip install git+https://github.com/pt9912/x-gal.git@develop\n</code></pre>"},{"location":"PYPI_PUBLISHING/#von-source","title":"Von Source","text":"<pre><code>git clone https://github.com/pt9912/x-gal.git\ncd x-gal\npip install -e \".[dev]\"\n</code></pre>"},{"location":"PYPI_PUBLISHING/#pypi-account-setup-fur-maintainer","title":"PyPI Account Setup (F\u00fcr Maintainer)","text":""},{"location":"PYPI_PUBLISHING/#1-pypi-account-erstellen","title":"1. PyPI Account erstellen","text":"<ol> <li>Gehe zu https://pypi.org/account/register/</li> <li>Erstelle einen Account</li> <li>Verifiziere deine E-Mail-Adresse</li> </ol>"},{"location":"PYPI_PUBLISHING/#2-testpypi-account-erstellen","title":"2. TestPyPI Account erstellen","text":"<ol> <li>Gehe zu https://test.pypi.org/account/register/</li> <li>Erstelle einen separaten Account (TestPyPI ist eine separate Instanz!)</li> <li>Verifiziere deine E-Mail-Adresse</li> </ol>"},{"location":"PYPI_PUBLISHING/#3-two-factor-authentication-2fa-aktivieren","title":"3. Two-Factor Authentication (2FA) aktivieren","text":"<p>PyPI: 1. Gehe zu https://pypi.org/manage/account/ 2. Klicke auf \"Account security\" \u2192 \"Add 2FA\" 3. W\u00e4hle eine Methode (TOTP App empfohlen) 4. Folge den Anweisungen</p> <p>TestPyPI: 1. Wiederhole die Schritte f\u00fcr https://test.pypi.org/manage/account/</p> <p>\u26a0\ufe0f WICHTIG: 2FA ist f\u00fcr alle PyPI-Accounts verpflichtend!</p>"},{"location":"PYPI_PUBLISHING/#4-api-tokens-generieren","title":"4. API Tokens generieren","text":"<p>PyPI Token: 1. Gehe zu https://pypi.org/manage/account/token/ 2. Klicke auf \"Add API token\" 3. Name: <code>gal-gateway-github-actions</code> 4. Scope: \"Entire account\" (sp\u00e4ter auf Project beschr\u00e4nken) 5. Kopiere den Token (nur einmal sichtbar!)</p> <p>TestPyPI Token: 1. Gehe zu https://test.pypi.org/manage/account/token/ 2. Klicke auf \"Add API token\" 3. Name: <code>gal-gateway-github-actions-test</code> 4. Scope: \"Entire account\" 5. Kopiere den Token</p>"},{"location":"PYPI_PUBLISHING/#5-github-secrets-konfigurieren","title":"5. GitHub Secrets konfigurieren","text":"<ol> <li>Gehe zu https://github.com/pt9912/x-gal/settings/secrets/actions</li> <li>Klicke auf \"New repository secret\"</li> </ol> <p>Secret 1: PYPI_API_TOKEN - Name: <code>PYPI_API_TOKEN</code> - Value: <code>&lt;dein PyPI Token&gt;</code></p> <p>Secret 2: TEST_PYPI_API_TOKEN - Name: <code>TEST_PYPI_API_TOKEN</code> - Value: <code>&lt;dein TestPyPI Token&gt;</code></p>"},{"location":"PYPI_PUBLISHING/#release-prozess","title":"Release Prozess","text":""},{"location":"PYPI_PUBLISHING/#1-pre-release-testpypi","title":"1. Pre-Release (TestPyPI)","text":"<p>Use Case: Testen vor dem finalen Release</p> <pre><code># 1. Stelle sicher, dass alle Tests passen\npytest -v --cov=gal\n\n# 2. Erstelle Pre-Release Tag\ngit tag -a v1.1.0-rc1 -m \"Release Candidate 1 f\u00fcr v1.1.0\"\ngit push origin v1.1.0-rc1\n\n# 3. GitHub Actions ver\u00f6ffentlicht automatisch auf TestPyPI\n# (Check: https://github.com/pt9912/x-gal/actions)\n\n# 4. Teste Installation von TestPyPI\npip install --index-url https://test.pypi.org/simple/ \\\n            --extra-index-url https://pypi.org/simple/ \\\n            gal-gateway==1.1.0rc1\n\n# 5. Teste das Package\ngal --version\ngal generate examples/rate-limiting-example.yaml\n</code></pre> <p>Pre-Release Tags: - <code>v1.1.0-alpha1</code> - Alpha Release (fr\u00fche Testversion) - <code>v1.1.0-beta1</code> - Beta Release (Feature-Complete, aber Bugs m\u00f6glich) - <code>v1.1.0-rc1</code> - Release Candidate (fast fertig)</p>"},{"location":"PYPI_PUBLISHING/#2-stable-release-pypi","title":"2. Stable Release (PyPI)","text":"<p>Use Case: Offizieller Release</p> <pre><code># 1. Stelle sicher, dass alle Tests passen\npytest -v --cov=gal\n\n# 2. Update VERSION Datei\necho \"1.1.0\" &gt; VERSION\n\n# 3. Update CHANGELOG.md\n# - Verschiebe \"Unreleased\" nach \"[1.1.0] - 2025-10-XX\"\n# - F\u00fcge Release-Datum hinzu\n\n# 4. Commit Version Bump\ngit add VERSION CHANGELOG.md\ngit commit -m \"chore: Bump version to 1.1.0\"\ngit push origin main\n\n# 5. Erstelle Release Tag\ngit tag -a v1.1.0 -m \"Release v1.1.0 - Traffic Management &amp; Security\"\ngit push origin v1.1.0\n\n# 6. GitHub Actions ver\u00f6ffentlicht automatisch auf PyPI\n# (Check: https://github.com/pt9912/x-gal/actions)\n\n# 7. Verifiziere PyPI Release\n# - Gehe zu https://pypi.org/project/gal-gateway/\n# - Pr\u00fcfe Version 1.1.0\n\n# 8. Teste Installation von PyPI\npip install gal-gateway==1.1.0\n\n# 9. Teste das Package\ngal --version\n</code></pre>"},{"location":"PYPI_PUBLISHING/#manuelle-veroffentlichung-falls-github-actions-nicht-funktioniert","title":"Manuelle Ver\u00f6ffentlichung (Falls GitHub Actions nicht funktioniert)","text":""},{"location":"PYPI_PUBLISHING/#testpypi","title":"TestPyPI","text":"<pre><code># 1. Build Package\npython -m build\n\n# 2. Check Package\ntwine check dist/*\n\n# 3. Upload to TestPyPI\ntwine upload --repository testpypi dist/*\n# Username: __token__\n# Password: &lt;TEST_PYPI_API_TOKEN&gt;\n</code></pre>"},{"location":"PYPI_PUBLISHING/#pypi","title":"PyPI","text":"<pre><code># 1. Build Package\npython -m build\n\n# 2. Check Package\ntwine check dist/*\n\n# 3. Upload to PyPI\ntwine upload dist/*\n# Username: __token__\n# Password: &lt;PYPI_API_TOKEN&gt;\n</code></pre>"},{"location":"PYPI_PUBLISHING/#workflow-details","title":"Workflow Details","text":"<p>Der Release Workflow (<code>.github/workflows/release.yml</code>) besteht aus 4 Jobs:</p>"},{"location":"PYPI_PUBLISHING/#1-create-release","title":"1. <code>create-release</code>","text":"<ul> <li>Erstellt GitHub Release</li> <li>Nutzt <code>RELEASE_NOTES.md</code> als Body</li> </ul>"},{"location":"PYPI_PUBLISHING/#2-build-artifacts","title":"2. <code>build-artifacts</code>","text":"<ul> <li>Baut Python Wheel (<code>.whl</code>) und Source Distribution (<code>.tar.gz</code>)</li> <li>Erstellt Archiv mit Source Code</li> <li>Hochladen zu GitHub Release</li> </ul>"},{"location":"PYPI_PUBLISHING/#3-publish-testpypi","title":"3. <code>publish-testpypi</code>","text":"<ul> <li>Bedingung: Tag enth\u00e4lt <code>-alpha</code>, <code>-beta</code>, oder <code>-rc</code></li> <li>Ver\u00f6ffentlicht auf TestPyPI</li> <li>Nutzt <code>TEST_PYPI_API_TOKEN</code> Secret</li> </ul>"},{"location":"PYPI_PUBLISHING/#4-publish-pypi","title":"4. <code>publish-pypi</code>","text":"<ul> <li>Bedingung: Tag enth\u00e4lt KEINE Pre-Release Suffixe</li> <li>Ver\u00f6ffentlicht auf PyPI</li> <li>Nutzt <code>PYPI_API_TOKEN</code> Secret</li> </ul>"},{"location":"PYPI_PUBLISHING/#package-metadaten","title":"Package Metadaten","text":""},{"location":"PYPI_PUBLISHING/#pyprojecttoml","title":"pyproject.toml","text":"<pre><code>[project]\nname = \"gal-gateway\"\nversion = \"1.1.0\"  # Dynamisch aus VERSION Datei\ndescription = \"Gateway Abstraction Layer - Provider-agnostic API Gateway configuration\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.10\"\nlicense = {text = \"MIT\"}\nauthors = [{name = \"Dietmar Burkard\"}]\n\nkeywords = [\n    \"api-gateway\", \"envoy\", \"kong\", \"apisix\", \"traefik\",\n    \"rate-limiting\", \"authentication\", \"cors\", \"circuit-breaker\",\n    \"health-checks\", \"load-balancing\", \"jwt\", \"security\"\n]\n\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Intended Audience :: Developers\",\n    \"Topic :: Software Development :: Code Generators\",\n    \"Topic :: System :: Networking\",\n    \"Topic :: Internet :: WWW/HTTP :: HTTP Servers\",\n    \"Topic :: Security\",\n    # ...\n]\n\ndependencies = [\n    \"click&gt;=8.1.0\",\n    \"pyyaml&gt;=6.0\",\n    \"requests&gt;=2.31.0\",\n]\n\n[project.scripts]\ngal = \"gal.cli:cli\"\n</code></pre>"},{"location":"PYPI_PUBLISHING/#wichtige-felder","title":"Wichtige Felder","text":"<ul> <li>name: PyPI Package Name (<code>gal-gateway</code>)</li> <li>version: Aus <code>VERSION</code> Datei gelesen (Semantic Versioning)</li> <li>description: Kurzbeschreibung (max 200 Zeichen)</li> <li>readme: README.md als Long Description</li> <li>requires-python: Mindest-Python-Version (3.10+)</li> <li>keywords: Suchbegriffe f\u00fcr PyPI</li> <li>classifiers: PyPI Kategorien/Tags</li> <li>dependencies: Runtime-Abh\u00e4ngigkeiten</li> <li>scripts: CLI Entry Point (<code>gal</code> Command)</li> </ul>"},{"location":"PYPI_PUBLISHING/#troubleshooting","title":"Troubleshooting","text":""},{"location":"PYPI_PUBLISHING/#problem-twine-upload-schlagt-fehl-mit-403-forbidden","title":"Problem: <code>twine upload</code> schl\u00e4gt fehl mit 403 Forbidden","text":"<p>Ursache: Ung\u00fcltiger API Token oder fehlende Permissions</p> <p>L\u00f6sung: 1. Pr\u00fcfe, ob Token korrekt ist 2. Pr\u00fcfe, ob Token Scope \"Entire account\" oder \"Project: gal-gateway\" hat 3. Erstelle neuen Token falls n\u00f6tig</p>"},{"location":"PYPI_PUBLISHING/#problem-package-bereits-auf-pypi-vorhanden","title":"Problem: Package bereits auf PyPI vorhanden","text":"<p>Ursache: Version bereits ver\u00f6ffentlicht (PyPI erlaubt kein \u00dcberschreiben)</p> <p>L\u00f6sung: 1. Bumpe Version in <code>VERSION</code> Datei 2. Erstelle neuen Tag 3. Ver\u00f6ffentliche erneut</p>"},{"location":"PYPI_PUBLISHING/#problem-modulenotfounderror-nach-installation","title":"Problem: <code>ModuleNotFoundError</code> nach Installation","text":"<p>Ursache: Package-Struktur falsch oder <code>__init__.py</code> fehlt</p> <p>L\u00f6sung: 1. Pr\u00fcfe, ob <code>gal/__init__.py</code> existiert 2. Pr\u00fcfe <code>setup.py</code> <code>packages=find_packages()</code> 3. Teste lokal: <code>pip install -e .</code></p>"},{"location":"PYPI_PUBLISHING/#problem-cli-command-gal-nicht-gefunden","title":"Problem: CLI Command <code>gal</code> nicht gefunden","text":"<p>Ursache: Entry Point nicht korrekt konfiguriert</p> <p>L\u00f6sung: 1. Pr\u00fcfe <code>pyproject.toml</code> <code>[project.scripts]</code> 2. Pr\u00fcfe <code>setup.py</code> <code>entry_points</code> 3. Reinstalliere: <code>pip uninstall gal-gateway &amp;&amp; pip install gal-gateway</code></p>"},{"location":"PYPI_PUBLISHING/#problem-dependencies-nicht-installiert","title":"Problem: Dependencies nicht installiert","text":"<p>Ursache: <code>install_requires</code> fehlt oder falsch</p> <p>L\u00f6sung: 1. Pr\u00fcfe <code>pyproject.toml</code> <code>dependencies</code> 2. Pr\u00fcfe <code>setup.py</code> <code>install_requires</code> 3. Teste: <code>pip install gal-gateway[dev]</code></p>"},{"location":"PYPI_PUBLISHING/#best-practices","title":"Best Practices","text":""},{"location":"PYPI_PUBLISHING/#1-semantic-versioning","title":"1. Semantic Versioning","text":"<ul> <li>Major (1.0.0 \u2192 2.0.0): Breaking Changes</li> <li>Minor (1.0.0 \u2192 1.1.0): Neue Features, backwards compatible</li> <li>Patch (1.0.0 \u2192 1.0.1): Bugfixes, backwards compatible</li> </ul>"},{"location":"PYPI_PUBLISHING/#2-pre-release-versionen","title":"2. Pre-Release Versionen","text":"<ul> <li>Alpha (1.1.0-alpha1): Fr\u00fche Entwicklungsversion, instabil</li> <li>Beta (1.1.0-beta1): Feature-complete, aber Bugs m\u00f6glich</li> <li>RC (1.1.0-rc1): Release Candidate, fast fertig</li> </ul>"},{"location":"PYPI_PUBLISHING/#3-changelog-pflege","title":"3. Changelog Pflege","text":"<ul> <li>Nutze <code>CHANGELOG.md</code> nach Keep a Changelog</li> <li>Kategorien: Added, Changed, Deprecated, Removed, Fixed, Security</li> </ul>"},{"location":"PYPI_PUBLISHING/#4-testing-vor-release","title":"4. Testing vor Release","text":"<pre><code># Lokal testen\npytest -v --cov=gal\n\n# Build testen\npython -m build\ntwine check dist/*\n\n# TestPyPI testen (Pre-Release)\ntwine upload --repository testpypi dist/*\npip install --index-url https://test.pypi.org/simple/ gal-gateway\n</code></pre>"},{"location":"PYPI_PUBLISHING/#5-release-notes","title":"5. Release Notes","text":"<ul> <li>Nutze <code>RELEASE_NOTES.md</code> f\u00fcr jedes Release</li> <li>Beschreibe neue Features, Breaking Changes, Bugfixes</li> <li>F\u00fcge Beispiele und Migration-Guides hinzu</li> </ul>"},{"location":"PYPI_PUBLISHING/#security","title":"Security","text":""},{"location":"PYPI_PUBLISHING/#api-tokens","title":"API Tokens","text":"<ul> <li>\u26a0\ufe0f Niemals API Tokens in Git committen!</li> <li>\u26a0\ufe0f Niemals API Tokens in Logs/Issues teilen!</li> <li>\u2705 Nutze GitHub Secrets f\u00fcr CI/CD</li> <li>\u2705 Beschr\u00e4nke Token Scope auf Projekt (nach erstem Release)</li> </ul>"},{"location":"PYPI_PUBLISHING/#2fa","title":"2FA","text":"<ul> <li>\u2705 2FA ist verpflichtend f\u00fcr PyPI</li> <li>\u2705 Nutze TOTP App (Google Authenticator, Authy, etc.)</li> <li>\u2705 Bewahre Recovery Codes sicher auf</li> </ul>"},{"location":"PYPI_PUBLISHING/#package-signing","title":"Package Signing","text":"<ul> <li>Optional: GPG-Signierung von Releases</li> <li>PyPI unterst\u00fctzt PGP-Signaturen (nicht verpflichtend)</li> </ul>"},{"location":"PYPI_PUBLISHING/#weiterfuhrende-links","title":"Weiterf\u00fchrende Links","text":"<ul> <li>PyPI: https://pypi.org/project/gal-gateway/</li> <li>TestPyPI: https://test.pypi.org/project/gal-gateway/</li> <li>Python Packaging Guide: https://packaging.python.org/</li> <li>Twine Docs: https://twine.readthedocs.io/</li> <li>GitHub Actions: https://github.com/pt9912/x-gal/actions</li> <li>Semantic Versioning: https://semver.org/</li> </ul> <p>Letzte Aktualisierung: 2025-10-18</p>"},{"location":"v1.1.0-PLAN/","title":"GAL v1.1.0 - Implementierungsplan","text":"<p>Target Release: Q4 2025 Focus: Traffic Management &amp; Security Basics Estimated Effort: 6-8 Wochen</p>"},{"location":"v1.1.0-PLAN/#feature-overview","title":"\ud83d\udccb Feature Overview","text":"# Feature Priority Status Effort Dependencies 1 Rate Limiting \ud83d\udd34 High \u2705 Done 2 Wochen - 2 Authentication (Basic/API Key/JWT) \ud83d\udd34 High \u2705 Done 2 Wochen - 3 Request/Response Headers \ud83d\udd34 High \u2705 Done 1.5 Wochen - 4 CORS Policies \ud83d\udd34 High \u2705 Done 1 Woche - 5 PyPI Publication \ud83d\udd34 High \u2705 Done 1 Woche - 6 Circuit Breaker \ud83d\udfe1 Medium \u2705 Done 1.5 Wochen Optional 7 Health Checks &amp; Load Balancing \ud83d\udfe1 Medium \u2705 Done 2 Wochen Optional <p>Total Estimated Effort: 10.5 Wochen (mit optionalen Features) Progress: 7/7 Features completed (100% - 10.5 von 10.5 Wochen) \ud83c\udf89</p>"},{"location":"v1.1.0-PLAN/#feature-1-rate-limiting","title":"\ud83c\udfaf Feature 1: Rate Limiting \u2705","text":"<p>Status: \u2705 IMPLEMENTIERT (Commit: <code>6a67803</code>) Branch: <code>feature/v1.1.0-rate-limiting</code> Completed: 2025-10-17</p>"},{"location":"v1.1.0-PLAN/#implementation-summary","title":"Implementation Summary","text":"<p>\u2705 Config Model - RateLimitConfig mit allen Optionen \u2705 Kong Provider - rate-limiting Plugin \u2705 APISIX Provider - limit-count Plugin \u2705 Traefik Provider - rateLimit Middleware \u2705 Envoy Provider - local_ratelimit Filter \u2705 Tests - 15 neue Tests, 117 total (alle bestehen) \u2705 Documentation - Umfassender RATE_LIMITING.md Guide \u2705 Coverage - 90% (erh\u00f6ht von 89%)</p>"},{"location":"v1.1.0-PLAN/#motivation","title":"Motivation","text":"<ul> <li>Schutz vor API-\u00dcberlastung</li> <li>DDoS-Mitigation</li> <li>Fairness zwischen Clients</li> <li>SLA-Enforcement</li> </ul>"},{"location":"v1.1.0-PLAN/#configuration-schema","title":"Configuration Schema","text":"<pre><code>routes:\n  - path: /api/users\n    method: GET\n    upstream: user_service\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n      burst: 200\n      key_type: ip_address  # ip_address, header, jwt_claim\n      key_header: X-API-Key  # Optional: wenn key_type=header\n      response:\n        status_code: 429\n        message: \"Rate limit exceeded\"\n</code></pre>"},{"location":"v1.1.0-PLAN/#implementation-tasks","title":"Implementation Tasks","text":""},{"location":"v1.1.0-PLAN/#config-model-galconfigpy","title":"Config Model (<code>gal/config.py</code>)","text":"<pre><code>class RateLimitConfig:\n    enabled: bool = True\n    requests_per_second: int\n    burst: int = 0\n    key_type: str = \"ip_address\"  # ip_address, header, jwt_claim\n    key_header: Optional[str] = None\n    key_claim: Optional[str] = None\n    response_status: int = 429\n    response_message: str = \"Rate limit exceeded\"\n</code></pre>"},{"location":"v1.1.0-PLAN/#provider-implementations","title":"Provider Implementations","text":"<p>Envoy (<code>gal/providers/envoy.py</code>) <pre><code>def _generate_rate_limit(self, route_config):\n    \"\"\"\n    Uses Envoy's rate limit filter\n    Requires external rate limit service (Redis-based)\n    \"\"\"\n    return {\n        \"typed_config\": {\n            \"@type\": \"type.googleapis.com/envoy.extensions.filters.http.ratelimit.v3.RateLimit\",\n            \"domain\": \"api_gateway\",\n            \"rate_limit_service\": {\n                \"grpc_service\": {\n                    \"envoy_grpc\": {\n                        \"cluster_name\": \"rate_limit_cluster\"\n                    }\n                }\n            }\n        }\n    }\n</code></pre></p> <p>Kong (<code>gal/providers/kong.py</code>) <pre><code>def _generate_rate_limit(self, route_config):\n    \"\"\"\n    Uses Kong's rate-limiting plugin\n    \"\"\"\n    return {\n        \"name\": \"rate-limiting\",\n        \"config\": {\n            \"second\": route_config.rate_limit.requests_per_second,\n            \"policy\": \"local\",  # or 'cluster', 'redis'\n            \"fault_tolerant\": True,\n            \"hide_client_headers\": False\n        }\n    }\n</code></pre></p> <p>APISIX (<code>gal/providers/apisix.py</code>) <pre><code>def _generate_rate_limit(self, route_config):\n    \"\"\"\n    Uses APISIX's limit-count plugin\n    \"\"\"\n    return {\n        \"limit-count\": {\n            \"count\": route_config.rate_limit.requests_per_second,\n            \"time_window\": 1,\n            \"rejected_code\": 429,\n            \"key\": \"remote_addr\"  # or 'consumer_name', 'server_addr'\n        }\n    }\n</code></pre></p> <p>Traefik (<code>gal/providers/traefik.py</code>) <pre><code>def _generate_rate_limit(self, route_config):\n    \"\"\"\n    Uses Traefik's RateLimit middleware\n    \"\"\"\n    return {\n        \"rateLimit\": {\n            \"average\": route_config.rate_limit.requests_per_second,\n            \"burst\": route_config.rate_limit.burst,\n            \"sourceCriterion\": {\n                \"requestHost\": True  # or ipStrategy\n            }\n        }\n    }\n</code></pre></p>"},{"location":"v1.1.0-PLAN/#testing","title":"Testing","text":"<ul> <li>Unit Tests f\u00fcr Config-Parsing</li> <li>Provider-spezifische Tests</li> <li>Integration Tests mit Mock-Gateways</li> <li>Load Tests (optional)</li> </ul>"},{"location":"v1.1.0-PLAN/#documentation","title":"Documentation","text":"<ul> <li>Configuration Guide</li> <li>Provider-specific Notes</li> <li>Best Practices</li> <li>Migration Guide from custom configs</li> </ul>"},{"location":"v1.1.0-PLAN/#feature-2-authentication-authorization","title":"\ud83d\udd10 Feature 2: Authentication &amp; Authorization \u2705","text":"<p>Status: \u2705 IMPLEMENTIERT Branch: <code>feature/v1.1.0-authentication</code> Completed: 2025-10-17</p>"},{"location":"v1.1.0-PLAN/#implementation-summary_1","title":"Implementation Summary","text":"<p>\u2705 Config Models - BasicAuthConfig, ApiKeyConfig, JwtConfig, AuthenticationConfig \u2705 Kong Provider - basic-auth, key-auth, jwt plugins \u2705 APISIX Provider - basic-auth, key-auth, jwt-auth plugins \u2705 Traefik Provider - basicAuth, forwardAuth middleware \u2705 Envoy Provider - jwt_authn filter, Lua filter f\u00fcr Basic Auth/API Key \u2705 Tests - 33 neue Tests (21 authentication + 12 config), 145 total (alle bestehen) \u2705 Documentation - Umfassender AUTHENTICATION.md Guide (600+ Zeilen) \u2705 Example Config - examples/authentication-test.yaml mit 9 Szenarien \u2705 Coverage - 91% (erh\u00f6ht von 90%)</p>"},{"location":"v1.1.0-PLAN/#motivation_1","title":"Motivation","text":"<ul> <li>API-Zugriffskontrolle</li> <li>User Identity Management</li> <li>Token-basierte Auth</li> <li>Standards-Konformit\u00e4t (JWT, OAuth2)</li> </ul>"},{"location":"v1.1.0-PLAN/#configuration-schema_1","title":"Configuration Schema","text":"<pre><code>routes:\n  - path: /api/protected\n    method: GET\n    upstream: protected_service\n    authentication:\n      type: jwt  # basic, api_key, jwt, oauth2\n\n      # Basic Auth Config\n      basic:\n        users:\n          - username: admin\n            password_hash: \"$2b$12$...\"\n\n      # API Key Config\n      api_key:\n        header_name: X-API-Key\n        query_param: api_key\n        keys:\n          - key: \"abc123...\"\n            name: \"client_1\"\n\n      # JWT Config\n      jwt:\n        issuer: https://auth.example.com\n        audiences: [\"api\"]\n        jwks_uri: https://auth.example.com/.well-known/jwks.json\n        header_name: Authorization\n        header_prefix: \"Bearer \"\n        claims_to_headers:\n          - claim: sub\n            header: X-User-ID\n          - claim: email\n            header: X-User-Email\n</code></pre>"},{"location":"v1.1.0-PLAN/#implementation-tasks_1","title":"Implementation Tasks","text":""},{"location":"v1.1.0-PLAN/#config-model","title":"Config Model","text":"<pre><code>class AuthenticationConfig:\n    type: str  # basic, api_key, jwt, oauth2\n    basic: Optional[BasicAuthConfig] = None\n    api_key: Optional[ApiKeyConfig] = None\n    jwt: Optional[JwtConfig] = None\n    oauth2: Optional[OAuth2Config] = None\n\nclass JwtConfig:\n    issuer: str\n    audiences: List[str]\n    jwks_uri: str\n    algorithms: List[str] = [\"RS256\"]\n    header_name: str = \"Authorization\"\n    header_prefix: str = \"Bearer \"\n    claims_to_headers: List[ClaimMapping] = []\n</code></pre>"},{"location":"v1.1.0-PLAN/#provider-implementations_1","title":"Provider Implementations","text":"<p>Envoy - JWT Auth <pre><code>def _generate_jwt_auth(self, auth_config):\n    return {\n        \"name\": \"envoy.filters.http.jwt_authn\",\n        \"typed_config\": {\n            \"@type\": \"type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication\",\n            \"providers\": {\n                \"auth_provider\": {\n                    \"issuer\": auth_config.jwt.issuer,\n                    \"audiences\": auth_config.jwt.audiences,\n                    \"remote_jwks\": {\n                        \"http_uri\": {\n                            \"uri\": auth_config.jwt.jwks_uri,\n                            \"cluster\": \"jwks_cluster\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n</code></pre></p> <p>Kong - Multiple Auth Plugins <pre><code>def _generate_authentication(self, auth_config):\n    if auth_config.type == \"jwt\":\n        return {\n            \"name\": \"jwt\",\n            \"config\": {\n                \"uri_param_names\": [\"jwt\"],\n                \"claims_to_verify\": [\"exp\"],\n                \"key_claim_name\": \"iss\"\n            }\n        }\n    elif auth_config.type == \"api_key\":\n        return {\n            \"name\": \"key-auth\",\n            \"config\": {\n                \"key_names\": [auth_config.api_key.header_name],\n                \"hide_credentials\": True\n            }\n        }\n</code></pre></p>"},{"location":"v1.1.0-PLAN/#testing_1","title":"Testing","text":"<ul> <li>JWT Token Generation f\u00fcr Tests</li> <li>Mock JWKS Endpoint</li> <li>Auth Success/Failure Scenarios</li> <li>Token Expiration Tests</li> <li>Multiple Auth Methods Tests</li> </ul>"},{"location":"v1.1.0-PLAN/#feature-3-requestresponse-headers","title":"\ud83d\udd04 Feature 3: Request/Response Headers \u2705","text":"<p>Status: \u2705 IMPLEMENTIERT Branch: <code>feature/v1.1.0-headers</code> Completed: 2025-10-17</p>"},{"location":"v1.1.0-PLAN/#implementation-summary_2","title":"Implementation Summary","text":"<p>\u2705 Config Model - HeaderManipulation mit allen Operationen (add/set/remove) \u2705 Kong Provider - request-transformer, response-transformer plugins \u2705 APISIX Provider - proxy-rewrite, response-rewrite plugins \u2705 Traefik Provider - headers middleware \u2705 Envoy Provider - Native route-level header manipulation \u2705 Route-Level Config - Per-Route Header-Konfiguration \u2705 Service-Level Config - Service-weite Header-Konfiguration in Transformation \u2705 Tests - 30 neue Tests (16 headers + 14 config), 175 total (alle bestehen) \u2705 Documentation - Umfassender HEADERS.md Guide (700+ Zeilen) \u2705 Example Config - examples/headers-test.yaml mit 10 Szenarien \u2705 Coverage - 85% (reduziert durch zus\u00e4tzlichen Code, aber alle neuen Features getestet)</p>"},{"location":"v1.1.0-PLAN/#configuration-schema_2","title":"Configuration Schema","text":"<pre><code>routes:\n  - path: /api/service\n    headers:\n      # Request headers\n      request_add:\n        X-Request-ID: \"req-{{uuid}}\"\n        X-Gateway: \"GAL\"\n      request_set:\n        User-Agent: \"GAL-Gateway/1.0\"\n      request_remove:\n        - X-Internal-Token\n        - X-Debug-Info\n\n      # Response headers\n      response_add:\n        X-Frame-Options: \"DENY\"\n        X-Content-Type-Options: \"nosniff\"\n      response_set:\n        Server: \"GAL-Gateway\"\n      response_remove:\n        - X-Powered-By\n\n# Alternative: Service-Level Configuration\nservices:\n  - name: backend_service\n    transformation:\n      enabled: true\n      headers:\n        request_add:\n          X-Service-Name: \"backend_service\"\n        response_add:\n          X-API-Version: \"1.0\"\n</code></pre>"},{"location":"v1.1.0-PLAN/#implementation-details","title":"Implementation Details","text":""},{"location":"v1.1.0-PLAN/#config-model-galconfigpy_1","title":"Config Model (<code>gal/config.py</code>)","text":"<pre><code>@dataclass\nclass HeaderManipulation:\n    \"\"\"HTTP header manipulation configuration.\"\"\"\n    request_add: Dict[str, str] = field(default_factory=dict)\n    request_set: Dict[str, str] = field(default_factory=dict)\n    request_remove: List[str] = field(default_factory=list)\n    response_add: Dict[str, str] = field(default_factory=dict)\n    response_set: Dict[str, str] = field(default_factory=dict)\n    response_remove: List[str] = field(default_factory=list)\n\n@dataclass\nclass Route:\n    path_prefix: str\n    methods: Optional[List[str]] = None\n    rate_limit: Optional[RateLimitConfig] = None\n    authentication: Optional[AuthenticationConfig] = None\n    headers: Optional[HeaderManipulation] = None  # NEW!\n\n@dataclass\nclass Transformation:\n    enabled: bool = True\n    defaults: Dict[str, Any] = field(default_factory=dict)\n    computed_fields: List[ComputedField] = field(default_factory=list)\n    metadata: Dict[str, str] = field(default_factory=dict)\n    validation: Optional[Validation] = None\n    headers: Optional[HeaderManipulation] = None  # NEW!\n</code></pre>"},{"location":"v1.1.0-PLAN/#use-cases","title":"Use Cases","text":"<ul> <li>Security Headers: X-Frame-Options, X-Content-Type-Options, CSP</li> <li>CORS: Access-Control-* headers</li> <li>Request Identification: X-Request-ID, X-Correlation-ID</li> <li>Backend Communication: X-Forwarded-*, X-Real-IP</li> <li>Information Hiding: Remove Server, X-Powered-By</li> </ul>"},{"location":"v1.1.0-PLAN/#feature-4-cors-policies","title":"\ud83c\udf10 Feature 4: CORS Policies \u2705","text":"<p>Status: \u2705 IMPLEMENTIERT Branch: <code>feature/v1.1.0-cors</code> Completed: 2025-10-18</p>"},{"location":"v1.1.0-PLAN/#implementation-summary_3","title":"Implementation Summary","text":"<p>\u2705 Config Model - CORSPolicy mit vollst\u00e4ndiger CORS-Unterst\u00fctzung \u2705 Kong Provider - Native cors plugin \u2705 APISIX Provider - Native cors plugin (komma-separiert) \u2705 Traefik Provider - headers middleware mit accessControl* Feldern \u2705 Envoy Provider - Native route-level CORS policy \u2705 Route-Level Config - Per-Route CORS-Konfiguration \u2705 Tests - 28 CORS Tests + 8 Config Tests, 211 total (alle bestehen) \u2705 Documentation - Umfassender CORS.md Guide (1000+ Zeilen auf Deutsch) \u2705 Example Config - examples/cors-example.yaml mit 15 Szenarien</p>"},{"location":"v1.1.0-PLAN/#motivation_2","title":"Motivation","text":"<ul> <li>Cross-Origin API-Zugriff f\u00fcr SPAs</li> <li>Browser-Sicherheit (Same-Origin-Policy)</li> <li>Mobile App-Integration</li> <li>Preflight-Request-Optimierung</li> </ul>"},{"location":"v1.1.0-PLAN/#configuration-schema_3","title":"Configuration Schema","text":"<pre><code>routes:\n  - path_prefix: /api/public\n    methods: [GET, POST, OPTIONS]  # OPTIONS wichtig!\n    cors:\n      enabled: true\n      # Allowed origins (spezifisch oder Wildcard)\n      allowed_origins:\n        - \"https://app.example.com\"\n        - \"https://www.example.com\"\n      # Allowed HTTP methods\n      allowed_methods:\n        - GET\n        - POST\n        - PUT\n        - DELETE\n        - OPTIONS\n      # Allowed request headers\n      allowed_headers:\n        - Content-Type\n        - Authorization\n        - X-API-Key\n      # Headers exposed to browser\n      expose_headers:\n        - X-Request-ID\n        - X-RateLimit-Remaining\n      # Allow credentials (cookies, auth)\n      allow_credentials: true\n      # Preflight cache duration (seconds)\n      max_age: 86400  # 24 hours\n</code></pre>"},{"location":"v1.1.0-PLAN/#implementation-details_1","title":"Implementation Details","text":""},{"location":"v1.1.0-PLAN/#config-model-galconfigpy_2","title":"Config Model (<code>gal/config.py</code>)","text":"<pre><code>@dataclass\nclass CORSPolicy:\n    \"\"\"CORS (Cross-Origin Resource Sharing) policy configuration.\"\"\"\n    enabled: bool = True\n    allowed_origins: List[str] = field(default_factory=lambda: [\"*\"])\n    allowed_methods: List[str] = field(default_factory=lambda: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"])\n    allowed_headers: List[str] = field(default_factory=lambda: [\"Content-Type\", \"Authorization\"])\n    expose_headers: List[str] = field(default_factory=list)\n    allow_credentials: bool = False\n    max_age: int = 86400  # 24 hours\n\n@dataclass\nclass Route:\n    path_prefix: str\n    methods: Optional[List[str]] = None\n    rate_limit: Optional[RateLimitConfig] = None\n    authentication: Optional[AuthenticationConfig] = None\n    headers: Optional[HeaderManipulation] = None\n    cors: Optional[CORSPolicy] = None  # NEW!\n</code></pre>"},{"location":"v1.1.0-PLAN/#provider-implementations_2","title":"Provider Implementations","text":"<p>Kong (<code>gal/providers/kong.py</code>) <pre><code># Native cors plugin\nif route.cors and route.cors.enabled:\n    cors = route.cors\n    cors_config = {\n        \"origins\": cors.allowed_origins,\n        \"methods\": cors.allowed_methods,\n        \"headers\": cors.allowed_headers,\n        \"credentials\": cors.allow_credentials,\n        \"max_age\": cors.max_age\n    }\n    if cors.expose_headers:\n        cors_config[\"exposed_headers\"] = cors.expose_headers\n    route_plugins.append({\n        \"name\": \"cors\",\n        \"config\": cors_config\n    })\n</code></pre></p> <p>APISIX (<code>gal/providers/apisix.py</code>) <pre><code># Native cors plugin (comma-separated format)\nif route.cors and route.cors.enabled:\n    cors = route.cors\n    cors_config = {\n        \"allow_origins\": \",\".join(cors.allowed_origins),\n        \"allow_methods\": \",\".join(cors.allowed_methods),\n        \"allow_headers\": \",\".join(cors.allowed_headers),\n        \"allow_credential\": cors.allow_credentials,  # Note: singular!\n        \"max_age\": cors.max_age\n    }\n    if cors.expose_headers:\n        cors_config[\"expose_headers\"] = \",\".join(cors.expose_headers)\n    route_config[\"plugins\"][\"cors\"] = cors_config\n</code></pre></p> <p>Traefik (<code>gal/providers/traefik.py</code>) <pre><code># CORS via headers middleware\nif route.cors and route.cors.enabled:\n    cors = route.cors\n    output.append(f\"    {router_name}_cors:\")\n    output.append(\"      headers:\")\n    output.append(\"        accessControlAllowMethods:\")\n    for method in cors.allowed_methods:\n        output.append(f\"          - {method}\")\n    output.append(\"        accessControlAllowOriginList:\")\n    for origin in cors.allowed_origins:\n        output.append(f\"          - '{origin}'\")\n    if cors.allowed_headers:\n        output.append(\"        accessControlAllowHeaders:\")\n        for header in cors.allowed_headers:\n            output.append(f\"          - {header}\")\n    output.append(f\"        accessControlAllowCredentials: {str(cors.allow_credentials).lower()}\")\n    output.append(f\"        accessControlMaxAge: {cors.max_age}\")\n</code></pre></p> <p>Envoy (<code>gal/providers/envoy.py</code>) <pre><code># Native CORS policy on route level\nif route.cors and route.cors.enabled:\n    cors = route.cors\n    output.append(\"                cors:\")\n    output.append(\"                  allow_origin_string_match:\")\n    for origin in cors.allowed_origins:\n        if origin == \"*\":\n            output.append(\"                  - safe_regex:\")\n            output.append(\"                      regex: '.*'\")\n        else:\n            output.append(f\"                  - exact: '{origin}'\")\n    output.append(f\"                  allow_methods: '{', '.join(cors.allowed_methods)}'\")\n    output.append(f\"                  allow_headers: '{', '.join(cors.allowed_headers)}'\")\n    if cors.expose_headers:\n        output.append(f\"                  expose_headers: '{', '.join(cors.expose_headers)}'\")\n    output.append(f\"                  allow_credentials: {str(cors.allow_credentials).lower()}\")\n    output.append(f\"                  max_age: '{cors.max_age}'\")\n</code></pre></p>"},{"location":"v1.1.0-PLAN/#use-cases_1","title":"Use Cases","text":"<ul> <li>Single-Page Applications (SPA): Frontend auf anderem Domain als Backend</li> <li>Mobile Apps: Capacitor/Cordova/React Native Origins</li> <li>Multi-Domain: Mehrere Frontend-Domains erlauben</li> <li>Public APIs: Wildcard-Origins f\u00fcr \u00f6ffentliche APIs</li> <li>GraphQL: CORS f\u00fcr GraphQL-Endpoints</li> <li>WebSocket: CORS f\u00fcr WebSocket-Verbindungen</li> </ul>"},{"location":"v1.1.0-PLAN/#feature-6-circuit-breaker","title":"\u26a1 Feature 6: Circuit Breaker \u2705","text":"<p>Status: \u2705 IMPLEMENTIERT Branch: <code>feature/v1.1.0-circuit-breaker</code> Completed: 2025-10-18</p>"},{"location":"v1.1.0-PLAN/#implementation-summary_4","title":"Implementation Summary","text":"<p>\u2705 Config Model - CircuitBreakerConfig mit allen Optionen \u2705 Kong Provider - Third-party Plugin (warning in docs) \u2705 APISIX Provider - Native api-breaker plugin \u2705 Traefik Provider - Native CircuitBreaker middleware \u2705 Envoy Provider - Native Outlier Detection \u2705 Tests - 30+ Circuit Breaker Tests (357 total tests) \u2705 Documentation - Umfassender CIRCUIT_BREAKER.md Guide (1000+ Zeilen) \u2705 Example Config - examples/circuit-breaker-example.yaml mit 10+ Szenarien</p>"},{"location":"v1.1.0-PLAN/#motivation_3","title":"Motivation","text":"<ul> <li>Fehler-Isolation (Cascading Failures verhindern)</li> <li>Schnelle Fehlerbehandlung (sofortige R\u00fcckmeldung)</li> <li>Automatische Erholung (Service-Health Testing)</li> <li>Resource-Schonung (keine verschwendeten Requests)</li> </ul>"},{"location":"v1.1.0-PLAN/#configuration-schema_4","title":"Configuration Schema","text":"<pre><code>routes:\n  - path_prefix: /api/payments\n    methods: [GET, POST]\n    circuit_breaker:\n      enabled: true\n      # Schwellwert: Nach wie vielen Fehlern \u00f6ffnet Circuit Breaker?\n      max_failures: 5\n      # Timeout: Wie lange wartet CB bis HALF_OPEN Test?\n      timeout: \"30s\"\n      # Half-Open Requests: Wie viele Test-Requests in HALF_OPEN?\n      half_open_requests: 3\n      # Welche HTTP Status Codes gelten als Fehler?\n      unhealthy_status_codes: [500, 502, 503, 504]\n      # Custom Response wenn Circuit OPEN\n      response:\n        status_code: 503\n        message: \"Service temporarily unavailable\"\n</code></pre>"},{"location":"v1.1.0-PLAN/#implementation-details_2","title":"Implementation Details","text":""},{"location":"v1.1.0-PLAN/#circuit-breaker-states","title":"Circuit Breaker States","text":"<pre><code>CLOSED (Normal) \u2192 OPEN (Broken) \u2192 HALF_OPEN (Testing) \u2192 CLOSED\n</code></pre> <ol> <li>CLOSED: Normal operation, alle Requests durchgelassen</li> <li>OPEN: Circuit \"gebrochen\", Requests sofort abgelehnt</li> <li>HALF_OPEN: Testet mit wenigen Requests ob Service wieder OK</li> </ol>"},{"location":"v1.1.0-PLAN/#config-model-galconfigpy_3","title":"Config Model (<code>gal/config.py</code>)","text":"<pre><code>@dataclass\nclass CircuitBreakerConfig:\n    \"\"\"Circuit Breaker configuration for resilience.\"\"\"\n    enabled: bool = True\n    max_failures: int = 5\n    timeout: str = \"30s\"\n    half_open_requests: int = 3\n    unhealthy_status_codes: List[int] = field(\n        default_factory=lambda: [500, 502, 503, 504]\n    )\n    response_status_code: int = 503\n    response_message: str = \"Service temporarily unavailable\"\n\n@dataclass\nclass Route:\n    path_prefix: str\n    methods: Optional[List[str]] = None\n    rate_limit: Optional[RateLimitConfig] = None\n    authentication: Optional[AuthenticationConfig] = None\n    headers: Optional[HeaderManipulation] = None\n    cors: Optional[CORSPolicy] = None\n    circuit_breaker: Optional[CircuitBreakerConfig] = None  # NEW!\n</code></pre>"},{"location":"v1.1.0-PLAN/#provider-implementations_3","title":"Provider Implementations","text":"<p>APISIX (<code>gal/providers/apisix.py</code>) <pre><code># Native api-breaker plugin\nif route.circuit_breaker and route.circuit_breaker.enabled:\n    cb = route.circuit_breaker\n    route_config[\"plugins\"][\"api-breaker\"] = {\n        \"break_response_code\": cb.response_status_code,\n        \"max_breaker_sec\": int(cb.timeout.rstrip('s')),\n        \"unhealthy_status_codes\": cb.unhealthy_status_codes,\n        \"healthy_status_codes\": [200, 201, 204]\n    }\n</code></pre></p> <p>Traefik (<code>gal/providers/traefik.py</code>) <pre><code># Native CircuitBreaker middleware\nif route.circuit_breaker and route.circuit_breaker.enabled:\n    cb = route.circuit_breaker\n    output.append(f\"    {router_name}_circuit_breaker:\")\n    output.append(\"      circuitBreaker:\")\n    output.append(f\"        expression: 'ResponseCodeRatio(500, 600, 0, 600) &gt; 0.30'\")\n</code></pre></p> <p>Envoy (<code>gal/providers/envoy.py</code>) <pre><code># Native Outlier Detection\nif route.circuit_breaker and route.circuit_breaker.enabled:\n    cb = route.circuit_breaker\n    output.append(\"            outlier_detection:\")\n    output.append(f\"              consecutive_5xx: {cb.max_failures}\")\n    output.append(f\"              interval: {cb.timeout}\")\n    output.append(f\"              base_ejection_time: {cb.timeout}\")\n    output.append(\"              max_ejection_percent: 100\")\n</code></pre></p> <p>Kong (<code>gal/providers/kong.py</code>) <pre><code># Kong hat kein natives Circuit Breaker Plugin\n# Warnung wird in Dokumentation ausgegeben\nif route.circuit_breaker and route.circuit_breaker.enabled:\n    # Warning: Kong requires third-party plugin\n    pass\n</code></pre></p>"},{"location":"v1.1.0-PLAN/#use-cases_2","title":"Use Cases","text":"<ul> <li>Payment Services: Schutz vor fehlerhaften Payment-Providern</li> <li>Third-Party APIs: Externe APIs die tempor\u00e4r down sein k\u00f6nnen</li> <li>Microservices: Service-to-Service Resilience</li> <li>Database Services: Schutz vor DB-\u00dcberlastung</li> <li>Legacy Systems: Isolation alter, instabiler Services</li> </ul>"},{"location":"v1.1.0-PLAN/#provider-coverage","title":"Provider Coverage","text":"<ul> <li>\u2705 75% Native Support (3 von 4 Providern)</li> <li>\u26a0\ufe0f Kong ben\u00f6tigt Third-Party Plugin</li> </ul>"},{"location":"v1.1.0-PLAN/#feature-7-health-checks-load-balancing","title":"\ud83c\udfe5 Feature 7: Health Checks &amp; Load Balancing \u2705","text":"<p>Status: \u2705 IMPLEMENTIERT Branch: <code>feature/v1.1.0-health-checks</code> Completed: 2025-10-18</p>"},{"location":"v1.1.0-PLAN/#implementation-summary_5","title":"Implementation Summary","text":"<p>\u2705 Config Models - UpstreamTarget, ActiveHealthCheck, PassiveHealthCheck, HealthCheckConfig, LoadBalancerConfig \u2705 APISIX Provider - Native checks with active/passive support, all LB algorithms \u2705 Kong Provider - Upstream healthchecks, targets with weights, all LB algorithms \u2705 Traefik Provider - LoadBalancer healthCheck, multiple servers, weighted LB, sticky sessions \u2705 Envoy Provider - health_checks, outlier_detection, all LB policies \u2705 Tests - 50+ Health Check &amp; Load Balancing Tests \u2705 Documentation - Umfassender HEALTH_CHECKS.md Guide (1000+ Zeilen) \u2705 Example Config - examples/health-checks-example.yaml mit 15 Szenarien</p>"},{"location":"v1.1.0-PLAN/#motivation_4","title":"Motivation","text":"<ul> <li>Hochverf\u00fcgbarkeit (automatisches Failover)</li> <li>Performance-Optimierung (Lastverteilung)</li> <li>Horizontale Skalierbarkeit (mehrere Backend-Server)</li> <li>Service Health Monitoring (Active &amp; Passive)</li> </ul>"},{"location":"v1.1.0-PLAN/#configuration-schema_5","title":"Configuration Schema","text":"<pre><code>upstream:\n  # Multiple Backend Servers (Load Balancing)\n  targets:\n    - host: api-1.internal\n      port: 8080\n      weight: 2              # Gewichtung f\u00fcr Load Balancing\n    - host: api-2.internal\n      port: 8080\n      weight: 1\n\n  # Health Checks\n  health_check:\n    # Active Health Checks (Periodic Probing)\n    active:\n      enabled: true\n      http_path: /health\n      interval: \"10s\"\n      timeout: \"5s\"\n      healthy_threshold: 2\n      unhealthy_threshold: 3\n      healthy_status_codes: [200, 201, 204]\n\n    # Passive Health Checks (Traffic Monitoring)\n    passive:\n      enabled: true\n      max_failures: 5\n      unhealthy_status_codes: [500, 502, 503, 504]\n\n  # Load Balancing\n  load_balancer:\n    algorithm: round_robin   # round_robin, least_conn, ip_hash, weighted\n    sticky_sessions: false\n    cookie_name: galSession\n</code></pre>"},{"location":"v1.1.0-PLAN/#implementation-details_3","title":"Implementation Details","text":""},{"location":"v1.1.0-PLAN/#config-models-galconfigpy","title":"Config Models (<code>gal/config.py</code>)","text":"<pre><code>@dataclass\nclass UpstreamTarget:\n    \"\"\"Individual backend server with host, port, weight.\"\"\"\n    host: str\n    port: int\n    weight: int = 1\n\n@dataclass\nclass ActiveHealthCheck:\n    \"\"\"Periodic HTTP/HTTPS/TCP probing configuration.\"\"\"\n    enabled: bool = True\n    http_path: str = \"/health\"\n    interval: str = \"10s\"\n    timeout: str = \"5s\"\n    healthy_threshold: int = 2\n    unhealthy_threshold: int = 3\n    healthy_status_codes: List[int] = field(default_factory=lambda: [200, 201, 204])\n\n@dataclass\nclass PassiveHealthCheck:\n    \"\"\"Traffic monitoring / circuit breaker configuration.\"\"\"\n    enabled: bool = True\n    max_failures: int = 5\n    unhealthy_status_codes: List[int] = field(default_factory=lambda: [500, 502, 503, 504])\n\n@dataclass\nclass HealthCheckConfig:\n    \"\"\"Combined active + passive health checks.\"\"\"\n    active: Optional[ActiveHealthCheck] = None\n    passive: Optional[PassiveHealthCheck] = None\n\n@dataclass\nclass LoadBalancerConfig:\n    \"\"\"Load balancing algorithm and sticky session config.\"\"\"\n    algorithm: str = \"round_robin\"\n    sticky_sessions: bool = False\n    cookie_name: str = \"galSession\"\n\n@dataclass\nclass Upstream:\n    \"\"\"Extended to support multiple targets with health checks and load balancing.\"\"\"\n    host: str = \"\"\n    port: int = 0\n    targets: List[UpstreamTarget] = field(default_factory=list)\n    health_check: Optional[HealthCheckConfig] = None\n    load_balancer: Optional[LoadBalancerConfig] = None\n</code></pre>"},{"location":"v1.1.0-PLAN/#provider-implementations_4","title":"Provider Implementations","text":"<p>APISIX (<code>gal/providers/apisix.py</code>) <pre><code># Upstream with health checks and load balancing\nupstream = {\n    \"id\": f\"{service.name}_upstream\",\n    \"type\": \"roundrobin\",  # oder: least_conn, chash\n    \"nodes\": {\n        \"api-1.internal:8080\": 2,  # weight\n        \"api-2.internal:8080\": 1\n    },\n    \"checks\": {\n        \"active\": {\n            \"type\": \"http\",\n            \"http_path\": \"/health\",\n            \"timeout\": 5,\n            \"healthy\": {\"interval\": 10, \"successes\": 2},\n            \"unhealthy\": {\"interval\": 10, \"http_failures\": 3}\n        },\n        \"passive\": {\n            \"unhealthy\": {\"http_failures\": 5, \"http_statuses\": [500, 502, 503, 504]}\n        }\n    }\n}\n</code></pre></p> <p>Kong (<code>gal/providers/kong.py</code>) <pre><code># Separate upstream with targets and healthchecks\nupstreams:\n- name: api_service_upstream\n  algorithm: round-robin  # oder: least-connections, consistent-hashing\n  healthchecks:\n    active:\n      http_path: /health\n      interval: 10\n      healthy:\n        successes: 2\n    passive:\n      unhealthy:\n        http_failures: 5\n  targets:\n  - target: api-1.internal:8080\n    weight: 200  # Kong: 0-1000 scale\n</code></pre></p> <p>Traefik (<code>gal/providers/traefik.py</code>) <pre><code># LoadBalancer service with health check\nservices:\n  api_service_service:\n    loadBalancer:\n      servers:\n      - url: 'http://api-1.internal:8080'\n        weight: 2\n      - url: 'http://api-2.internal:8080'\n        weight: 1\n      healthCheck:\n        path: /health\n        interval: 10s\n        timeout: 5s\n      sticky:\n        cookie:\n          name: galSession\n</code></pre></p> <p>Envoy (<code>gal/providers/envoy.py</code>) <pre><code># Cluster with health_checks and outlier_detection\nclusters:\n- name: api_service_cluster\n  lb_policy: ROUND_ROBIN  # oder: LEAST_REQUEST, RING_HASH\n  health_checks:\n  - timeout: 5s\n    interval: 10s\n    unhealthy_threshold: 3\n    healthy_threshold: 2\n    http_health_check:\n      path: /health\n  outlier_detection:\n    consecutive_5xx: 5\n  load_assignment:\n    endpoints:\n    - lb_endpoints:\n      - endpoint:\n          socket_address:\n            address: api-1.internal\n            port_value: 8080\n        load_balancing_weight:\n          value: 2\n</code></pre></p>"},{"location":"v1.1.0-PLAN/#load-balancing-algorithms","title":"Load Balancing Algorithms","text":"<p>Round Robin: - Gleichm\u00e4\u00dfige zirkul\u00e4re Verteilung - Use Case: Homogene Backend-Server</p> <p>Least Connections: - Server mit wenigsten aktiven Verbindungen - Use Case: WebSockets, lange Verbindungen</p> <p>IP Hash: - Basierend auf Client-IP (Consistent Hashing) - Use Case: Session Persistence, Stateful Apps</p> <p>Weighted: - Verteilung basierend auf Server-Gewichtung - Use Case: Heterogene Server, Canary Deployments</p>"},{"location":"v1.1.0-PLAN/#use-cases_3","title":"Use Cases","text":"<ul> <li>Hochverf\u00fcgbare REST APIs: Round-Robin + Active Health Checks</li> <li>WebSocket Services: IP Hash oder Sticky Sessions</li> <li>Canary Deployments: Weighted (90% old, 10% new)</li> <li>Heterogene Server: Weighted (nach CPU-Kapazit\u00e4t)</li> <li>Graceful Degradation: Active + Passive Health Checks</li> </ul>"},{"location":"v1.1.0-PLAN/#provider-coverage_1","title":"Provider Coverage","text":"<ul> <li>\u2705 100% Active Health Check Support (4 von 4 Providern)</li> <li>\u2705 75% Passive Health Check Support (3 von 4 Providern, Traefik nutzt K8s Probes)</li> <li>\u2705 100% Load Balancing Support (4 von 4 Providern)</li> <li>\u2705 50+ Tests (alle Provider, alle Algorithmen)</li> </ul>"},{"location":"v1.1.0-PLAN/#feature-5-pypi-publication","title":"\ud83d\udce6 Feature 5: PyPI Publication \u2705","text":"<p>Status: \u2705 IMPLEMENTIERT Branch: <code>develop</code> Completed: 2025-10-18</p>"},{"location":"v1.1.0-PLAN/#implementation-summary_6","title":"Implementation Summary","text":"<p>\u2705 Package Configuration - pyproject.toml, setup.py mit v1.1.0 Keywords/Classifiers \u2705 Release Workflow - Automatisches Publishing zu PyPI &amp; TestPyPI \u2705 TestPyPI Integration - Pre-Release Tags (alpha/beta/rc) \u2192 TestPyPI \u2705 PyPI Integration - Stable Tags (v1.x.x) \u2192 PyPI \u2705 Documentation - Umfassender PyPI Publishing Guide (docs/PYPI_PUBLISHING.md) \u2705 README Updates - PyPI Badges, Installation Instructions, Links \u2705 Security - API Tokens als GitHub Secrets konfiguriert</p>"},{"location":"v1.1.0-PLAN/#package-details","title":"Package Details","text":"<p>PyPI Package Name: <code>gal-gateway</code> Import Name: <code>gal</code> CLI Command: <code>gal</code> Python Versions: 3.10, 3.11, 3.12</p>"},{"location":"v1.1.0-PLAN/#tasks-completed","title":"Tasks Completed","text":"<ol> <li>Package Preparation</li> <li>\u2705 pyproject.toml updated with v1.1.0 keywords &amp; classifiers</li> <li>\u2705 setup.py updated with v1.1.0 keywords &amp; classifiers</li> <li>\u2705 MANIFEST.in configured (includes VERSION, docs, examples)</li> <li>\u2705 Keywords: rate-limiting, authentication, cors, circuit-breaker, health-checks, jwt, security</li> <li> <p>\u2705 Classifiers: HTTP Servers, Security, AsyncIO</p> </li> <li> <p>Release Workflow Implementation</p> </li> <li>\u2705 <code>.github/workflows/release.yml</code> updated</li> <li>\u2705 <code>publish-testpypi</code> Job: Pre-Release Tags (alpha/beta/rc) \u2192 TestPyPI</li> <li>\u2705 <code>publish-pypi</code> Job: Stable Tags (vX.Y.Z) \u2192 PyPI</li> <li>\u2705 <code>twine check</code> Integration f\u00fcr Package-Validierung</li> <li> <p>\u2705 Conditional Publishing basierend auf Tag-Format</p> </li> <li> <p>GitHub Secrets Setup (Maintainer)</p> </li> <li>\u26a0\ufe0f <code>PYPI_API_TOKEN</code> - Muss von PyPI Account generiert werden</li> <li>\u26a0\ufe0f <code>TEST_PYPI_API_TOKEN</code> - Muss von TestPyPI Account generiert werden</li> <li> <p>\ud83d\udcdd Siehe docs/PYPI_PUBLISHING.md f\u00fcr Setup-Anleitung</p> </li> <li> <p>Testing Workflow <pre><code># Pre-Release Testing (TestPyPI)\ngit tag -a v1.1.0-rc1 -m \"Release Candidate 1\"\ngit push origin v1.1.0-rc1\n# \u2192 Publishes to TestPyPI\n\n# Stable Release (PyPI)\ngit tag -a v1.1.0 -m \"Release v1.1.0\"\ngit push origin v1.1.0\n# \u2192 Publishes to PyPI\n</code></pre></p> </li> <li> <p>Documentation</p> </li> <li>\u2705 <code>docs/PYPI_PUBLISHING.md</code> - Vollst\u00e4ndiger Publishing Guide<ul> <li>PyPI/TestPyPI Account Setup</li> <li>2FA Konfiguration</li> <li>API Token Generation</li> <li>Release Prozess (Pre-Release &amp; Stable)</li> <li>Manuelle Publishing-Anweisungen</li> <li>Troubleshooting Guide</li> <li>Best Practices</li> </ul> </li> <li>\u2705 <code>README.md</code> Updates:<ul> <li>PyPI Badges (version, python versions, downloads)</li> <li>Installation Instructions</li> <li>PyPI Links (PyPI, TestPyPI, Docs)</li> </ul> </li> </ol>"},{"location":"v1.1.0-PLAN/#installation","title":"Installation","text":"<pre><code># Von PyPI (Stable)\npip install gal-gateway\n\n# Von TestPyPI (Pre-Release)\npip install --index-url https://test.pypi.org/simple/ \\\n            --extra-index-url https://pypi.org/simple/ \\\n            gal-gateway\n\n# CLI verwenden\ngal --version\ngal generate examples/rate-limiting-example.yaml\n</code></pre>"},{"location":"v1.1.0-PLAN/#release-workflow-details","title":"Release Workflow Details","text":"<p>Trigger: Git Tags (vX.Y.Z format)</p> <p>Jobs: 1. <code>create-release</code> - GitHub Release erstellen 2. <code>build-artifacts</code> - Python Wheel &amp; Source Distribution bauen 3. <code>publish-testpypi</code> - Pre-Release auf TestPyPI (if tag contains -alpha/-beta/-rc) 4. <code>publish-pypi</code> - Stable Release auf PyPI (if tag does NOT contain pre-release suffixes)</p> <p>Pre-Release Tags: - <code>v1.1.0-alpha1</code> \u2192 TestPyPI - <code>v1.1.0-beta1</code> \u2192 TestPyPI - <code>v1.1.0-rc1</code> \u2192 TestPyPI</p> <p>Stable Tags: - <code>v1.1.0</code> \u2192 PyPI</p>"},{"location":"v1.1.0-PLAN/#next-steps-fur-maintainer","title":"Next Steps (F\u00fcr Maintainer)","text":"<ol> <li>PyPI Account Setup:</li> <li>Erstelle PyPI Account auf https://pypi.org/account/register/</li> <li>Aktiviere 2FA (verpflichtend!)</li> <li>Generiere API Token</li> <li> <p>F\u00fcge Token als <code>PYPI_API_TOKEN</code> in GitHub Secrets hinzu</p> </li> <li> <p>TestPyPI Account Setup:</p> </li> <li>Erstelle TestPyPI Account auf https://test.pypi.org/account/register/</li> <li>Aktiviere 2FA</li> <li>Generiere API Token</li> <li> <p>F\u00fcge Token als <code>TEST_PYPI_API_TOKEN</code> in GitHub Secrets hinzu</p> </li> <li> <p>First Release Test: <pre><code># Test mit Pre-Release Tag\ngit tag -a v1.1.0-rc1 -m \"Release Candidate 1 for v1.1.0\"\ngit push origin v1.1.0-rc1\n\n# Verifiziere auf TestPyPI\n# https://test.pypi.org/project/gal-gateway/\n\n# Install &amp; Test\npip install --index-url https://test.pypi.org/simple/ \\\n            --extra-index-url https://pypi.org/simple/ \\\n            gal-gateway==1.1.0rc1\ngal --version\n</code></pre></p> </li> <li> <p>Official v1.1.0 Release: <pre><code># Wenn alles funktioniert, stable Release\ngit tag -a v1.1.0 -m \"Release v1.1.0 - Traffic Management &amp; Security\"\ngit push origin v1.1.0\n\n# Verifiziere auf PyPI\n# https://pypi.org/project/gal-gateway/\n</code></pre></p> </li> </ol>"},{"location":"v1.1.0-PLAN/#links","title":"Links","text":"<ul> <li>PyPI Package: https://pypi.org/project/gal-gateway/</li> <li>TestPyPI Package: https://test.pypi.org/project/gal-gateway/</li> <li>Publishing Guide: docs/PYPI_PUBLISHING.md</li> <li>Release Workflow: .github/workflows/release.yml</li> </ul>"},{"location":"v1.1.0-PLAN/#testing-strategy","title":"\ud83d\udcca Testing Strategy","text":""},{"location":"v1.1.0-PLAN/#test-coverage-goals","title":"Test Coverage Goals","text":"<ul> <li>Unit Tests: 95%+ coverage</li> <li>Integration Tests: All provider combinations</li> <li>E2E Tests: Real gateway deployments (optional)</li> </ul>"},{"location":"v1.1.0-PLAN/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 unit/\n\u2502   \u251c\u2500\u2500 test_rate_limiting.py\n\u2502   \u251c\u2500\u2500 test_authentication.py\n\u2502   \u251c\u2500\u2500 test_headers.py\n\u2502   \u2514\u2500\u2500 test_cors.py\n\u251c\u2500\u2500 integration/\n\u2502   \u251c\u2500\u2500 test_envoy_rate_limit.py\n\u2502   \u251c\u2500\u2500 test_kong_jwt_auth.py\n\u2502   \u2514\u2500\u2500 test_apisix_cors.py\n\u2514\u2500\u2500 e2e/\n    \u2514\u2500\u2500 test_complete_workflow.py\n</code></pre>"},{"location":"v1.1.0-PLAN/#test-fixtures","title":"Test Fixtures","text":"<pre><code>@pytest.fixture\ndef rate_limit_config():\n    return RateLimitConfig(\n        requests_per_second=100,\n        burst=200,\n        key_type=\"ip_address\"\n    )\n\n@pytest.fixture\ndef jwt_auth_config():\n    return JwtConfig(\n        issuer=\"https://auth.test\",\n        audiences=[\"api\"],\n        jwks_uri=\"https://auth.test/.well-known/jwks.json\"\n    )\n</code></pre>"},{"location":"v1.1.0-PLAN/#documentation-plan","title":"\ud83d\udcda Documentation Plan","text":""},{"location":"v1.1.0-PLAN/#new-documentation-files","title":"New Documentation Files","text":"<ol> <li><code>docs/guides/RATE_LIMITING.md</code></li> <li>Configuration examples</li> <li>Provider-specific notes</li> <li>Best practices</li> <li> <p>Troubleshooting</p> </li> <li> <p><code>docs/guides/AUTHENTICATION.md</code></p> </li> <li>All auth types explained</li> <li>JWT setup guide</li> <li>API key management</li> <li> <p>Security considerations</p> </li> <li> <p><code>docs/guides/HEADERS.md</code></p> </li> <li>Header manipulation patterns</li> <li>Template syntax</li> <li> <p>Use cases</p> </li> <li> <p><code>docs/guides/CORS.md</code></p> </li> <li>CORS explained</li> <li>Configuration examples</li> <li> <p>Browser compatibility</p> </li> <li> <p><code>docs/guides/MIGRATION.md</code></p> </li> <li>v1.0 \u2192 v1.1 migration guide</li> <li>Breaking changes</li> <li>New features adoption</li> </ol>"},{"location":"v1.1.0-PLAN/#readme-updates","title":"README Updates","text":"<ul> <li>Add v1.1.0 features to feature list</li> <li>Update Quick Start with new examples</li> <li>Add PyPI installation section</li> </ul>"},{"location":"v1.1.0-PLAN/#release-plan","title":"\ud83d\ude80 Release Plan","text":""},{"location":"v1.1.0-PLAN/#pre-release-checklist","title":"Pre-Release Checklist","text":"<ul> <li> All features implemented</li> <li> Tests passing (95%+ coverage)</li> <li> Documentation complete</li> <li> CHANGELOG.md updated</li> <li> RELEASE_NOTES updated</li> <li> Migration guide written</li> <li> PyPI package tested on TestPyPI</li> <li> Docker images built and tested</li> <li> GitHub release notes prepared</li> </ul>"},{"location":"v1.1.0-PLAN/#release-steps","title":"Release Steps","text":"<ol> <li> <p>Create Release Branch <pre><code>git checkout -b release/v1.1.0\n</code></pre></p> </li> <li> <p>Update Version</p> </li> <li>Update <code>VERSION</code> file to <code>1.1.0</code></li> <li> <p>Update all version references</p> </li> <li> <p>Final Testing</p> </li> <li>Run full test suite</li> <li>Manual testing on all providers</li> <li> <p>Performance benchmarks</p> </li> <li> <p>Merge to Main <pre><code>git checkout main\ngit merge release/v1.1.0\n</code></pre></p> </li> <li> <p>Create Tag <pre><code>git tag -a v1.1.0 -m \"Release v1.1.0\"\ngit push origin v1.1.0\n</code></pre></p> </li> <li> <p>Verify Automated Workflows</p> </li> <li>GitHub Release created</li> <li>Docker images pushed</li> <li> <p>PyPI package published</p> </li> <li> <p>Announce Release</p> </li> <li>GitHub Discussions</li> <li>Update documentation site</li> <li>Social media (if applicable)</li> </ol>"},{"location":"v1.1.0-PLAN/#success-metrics","title":"\ud83c\udfaf Success Metrics","text":""},{"location":"v1.1.0-PLAN/#feature-adoption","title":"Feature Adoption","text":"<ul> <li>PyPI download count</li> <li>Docker image pulls</li> <li>GitHub Stars/Forks</li> <li>Issue/Discussion activity</li> </ul>"},{"location":"v1.1.0-PLAN/#code-quality","title":"Code Quality","text":"<ul> <li>Test coverage \u2265 95%</li> <li>No critical bugs in first week</li> <li>Documentation completeness</li> <li>Performance benchmarks</li> </ul>"},{"location":"v1.1.0-PLAN/#community","title":"Community","text":"<ul> <li>Contributor count</li> <li>Feature requests addressed</li> <li>Response time to issues</li> <li>Documentation quality feedback</li> </ul>"},{"location":"v1.1.0-PLAN/#next-steps","title":"\ud83d\udcde Next Steps","text":"<ol> <li>Review this plan - Team/Community feedback</li> <li>Break down into Issues - Create GitHub issues for each feature</li> <li>Assign milestones - Set target dates</li> <li>Start Implementation - Begin with highest priority features</li> <li>Weekly Status Updates - Track progress</li> </ol> <p>Document Status: Draft v1 Last Updated: 2025-10-18 Author: GAL Development Team</p>"},{"location":"v1.2.0-PLAN/","title":"GAL v1.2.0 - Implementierungsplan","text":"<p>Target Release: Q1 2026 Focus: Neue Gateway-Provider &amp; Erweiterte Features Estimated Effort: 8-10 Wochen</p>"},{"location":"v1.2.0-PLAN/#feature-overview","title":"\ud83d\udccb Feature Overview","text":"# Feature Priority Status Effort Dependencies 1 Nginx Provider (Open Source) \ud83d\udd34 High \u2705 Done 3 Wochen - 2 HAProxy Provider \ud83d\udd34 High \u2705 Done 2.5 Wochen - 3 WebSocket Support \ud83d\udfe1 Medium \u2705 Done 2 Wochen Nginx, HAProxy 4 Request/Response Body Transformation \ud83d\udfe1 Medium \u2705 Done 1.5 Wochen - 5 Timeout &amp; Retry Policies \ud83d\udfe1 Medium \u2705 Done 1 Woche - 6 Enhanced Logging &amp; Observability \ud83d\udfe2 Low \u2705 Done 1.5 Wochen Optional <p>Total Estimated Effort: 11.5 Wochen (mit optionalen Features) Progress: 6/6 Features completed (100%) \ud83c\udf89</p>"},{"location":"v1.2.0-PLAN/#feature-1-nginx-provider-open-source","title":"\ud83d\ude80 Feature 1: Nginx Provider (Open Source)","text":"<p>Status: \u2705 IMPLEMENTED (Commits: 3fbd1e0, 5982ee5) Priority: \ud83d\udd34 High Effort: 3 Wochen</p>"},{"location":"v1.2.0-PLAN/#implementation-summary","title":"\u2705 Implementation Summary","text":"<p>Provider: <code>gal/providers/nginx.py</code> (223 lines, 99% coverage) - Complete nginx.conf generation - Support for all load balancing algorithms (round_robin, least_conn, ip_hash, weighted) - Rate limiting (limit_req_zone, limit_req) - Basic authentication (auth_basic, htpasswd) - Header manipulation (request/response) - CORS policies (add_header directives) - Passive health checks (max_fails, fail_timeout) - Template variable conversion ({{uuid}} \u2192 $request_id, {{now}} \u2192 $time_iso8601)</p> <p>Tests: <code>tests/test_nginx.py</code> (25 tests, all passing) - Provider basics, validation warnings - Load balancing (all 4 algorithms) - Passive health checks - Rate limiting (IP-based, header-based) - Authentication (basic, API key, JWT) - Header manipulation - CORS policies - Multiple services/routes - All features combined</p> <p>Documentation: <code>docs/guides/NGINX.md</code> (1000+ lines, German) - \u00dcbersicht &amp; Feature-Matrix - Installation &amp; Setup - Feature-by-Feature Anleitungen - Provider-Vergleich - Nginx-spezifische Details - OpenResty Integration (JWT, API Key) - Best Practices &amp; Troubleshooting</p> <p>Examples: <code>examples/nginx-example.yaml</code> (15 production-ready scenarios) - Basic Reverse Proxy - Load Balancing (Round Robin, Least Conn, IP Hash, Weighted) - Passive Health Checks - Rate Limiting (IP-based, Header-based) - Basic Authentication - Request/Response Headers - CORS Configuration - Combined Features (Production API) - Microservices Architecture - Static Content + API Hybrid</p> <p>CLI Integration: \u2705 Complete - Added NginxProvider to all commands - Extension map: nginx \u2192 .conf - Verified config generation works</p> <p>Limitations: - \u274c No Active Health Checks (Nginx Plus only) - \u26a0\ufe0f JWT Auth requires OpenResty/Lua - \u26a0\ufe0f Circuit Breaker requires Lua</p>"},{"location":"v1.2.0-PLAN/#motivation","title":"Motivation","text":"<ul> <li>Nginx ist der #1 Web Server weltweit (&gt;30% Marktanteil)</li> <li>Weit verbreitet als Reverse Proxy und Load Balancer</li> <li>Leichtgewichtig und performant</li> <li>Gro\u00dfe Community und umfangreiche Dokumentation</li> <li>Gute Basis f\u00fcr sp\u00e4ter: Nginx Plus Support (v1.3.0)</li> </ul>"},{"location":"v1.2.0-PLAN/#nginx-capabilities-open-source","title":"Nginx Capabilities (Open Source)","text":"<p>Unterst\u00fctzte Features: - \u2705 Reverse Proxy - \u2705 Load Balancing (Round Robin, Least Connections, IP Hash, Weighted) - \u2705 HTTP/HTTPS/HTTP2 - \u2705 SSL/TLS Termination - \u2705 Rate Limiting (ngx_http_limit_req_module) - \u2705 Basic Authentication (ngx_http_auth_basic_module) - \u2705 Header Manipulation (add_header, proxy_set_header) - \u2705 CORS (via add_header directives) - \u2705 Health Checks (passive via proxy_next_upstream) - \u2705 Upstream Targets mit Gewichtung - \u26a0\ufe0f JWT Auth (nur mit OpenResty/Lua) - \u26a0\ufe0f Circuit Breaker (limitiert, via Lua)</p> <p>Einschr\u00e4nkungen: - \u274c Keine nativen Active Health Checks (nur Nginx Plus) - \u274c Keine native JWT Validation (ben\u00f6tigt Lua/OpenResty) - \u274c Keine Dynamic Configuration (ohne Plus) - \u274c Limitierte Observability (ohne Plus)</p>"},{"location":"v1.2.0-PLAN/#implementation-tasks","title":"Implementation Tasks","text":""},{"location":"v1.2.0-PLAN/#1-provider-klasse-galprovidersnginxpy","title":"1. Provider Klasse (<code>gal/providers/nginx.py</code>)","text":"<pre><code>class NginxProvider(Provider):\n    \"\"\"Nginx Open Source Gateway Provider.\n\n    Generates nginx.conf configuration for Nginx reverse proxy.\n    Supports: routing, load balancing, rate limiting, basic auth,\n    headers, CORS, passive health checks.\n\n    Limitations:\n    - No active health checks (Nginx Plus only)\n    - JWT auth requires OpenResty/Lua\n    - Circuit breaker requires Lua\n    \"\"\"\n\n    def generate(self, config: GatewayConfig) -&gt; str:\n        \"\"\"Generate nginx.conf configuration.\"\"\"\n        pass\n\n    def _generate_upstream(self, service: Service) -&gt; str:\n        \"\"\"Generate upstream block with load balancing.\"\"\"\n        pass\n\n    def _generate_server(self, service: Service) -&gt; str:\n        \"\"\"Generate server block for service.\"\"\"\n        pass\n\n    def _generate_location(self, route: Route, service: Service) -&gt; str:\n        \"\"\"Generate location block for route.\"\"\"\n        pass\n\n    def _generate_rate_limit(self, route: Route) -&gt; str:\n        \"\"\"Generate limit_req_zone and limit_req directives.\"\"\"\n        pass\n\n    def _generate_headers(self, headers: HeaderManipulation) -&gt; str:\n        \"\"\"Generate proxy_set_header and add_header directives.\"\"\"\n        pass\n\n    def _generate_cors(self, cors: CORSPolicy) -&gt; str:\n        \"\"\"Generate CORS headers via add_header.\"\"\"\n        pass\n</code></pre>"},{"location":"v1.2.0-PLAN/#2-nginx-configuration-schema","title":"2. Nginx Configuration Schema","text":"<p>Upstream Block (Load Balancing): <pre><code>upstream backend_service {\n    # Load Balancing Algorithm\n    least_conn;  # oder: ip_hash, hash $request_uri consistent\n\n    # Backend Servers mit Gewichtung\n    server api-1.internal:8080 weight=2 max_fails=3 fail_timeout=30s;\n    server api-2.internal:8080 weight=1 max_fails=3 fail_timeout=30s;\n\n    # Passive Health Check\n    # max_fails: Nach wie vielen Fehlern wird Server als down markiert\n    # fail_timeout: Wie lange wird Server als down betrachtet\n}\n</code></pre></p> <p>Server Block: <pre><code>server {\n    listen 80;\n    server_name api.example.com;\n\n    # Rate Limiting Zone (global definition)\n    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=100r/s;\n\n    location /api/v1 {\n        # Rate Limiting\n        limit_req zone=api_limit burst=200 nodelay;\n        limit_req_status 429;\n\n        # Basic Auth\n        auth_basic \"Protected Area\";\n        auth_basic_user_file /etc/nginx/.htpasswd;\n\n        # Request Headers\n        proxy_set_header X-Request-ID $request_id;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n        # CORS\n        add_header Access-Control-Allow-Origin \"https://app.example.com\" always;\n        add_header Access-Control-Allow-Methods \"GET, POST, PUT, DELETE, OPTIONS\" always;\n        add_header Access-Control-Allow-Headers \"Content-Type, Authorization\" always;\n        add_header Access-Control-Max-Age 86400 always;\n\n        # OPTIONS Preflight\n        if ($request_method = 'OPTIONS') {\n            return 204;\n        }\n\n        # Response Headers\n        add_header X-Frame-Options \"DENY\" always;\n        add_header X-Content-Type-Options \"nosniff\" always;\n\n        # Proxy to Upstream\n        proxy_pass http://backend_service;\n        proxy_http_version 1.1;\n        proxy_set_header Connection \"\";\n\n        # Timeouts\n        proxy_connect_timeout 5s;\n        proxy_send_timeout 60s;\n        proxy_read_timeout 60s;\n    }\n}\n</code></pre></p>"},{"location":"v1.2.0-PLAN/#3-feature-mapping","title":"3. Feature Mapping","text":"GAL Feature Nginx Implementation Support Level Rate Limiting limit_req_zone, limit_req \u2705 Full Load Balancing upstream (round_robin, least_conn, ip_hash) \u2705 Full Basic Auth auth_basic \u2705 Full API Key Auth Custom Lua module \u26a0\ufe0f Limited (requires OpenResty) JWT Auth lua-resty-jwt \u26a0\ufe0f Limited (requires OpenResty) Headers (Request) proxy_set_header \u2705 Full Headers (Response) add_header \u2705 Full CORS add_header directives \u2705 Full Health Checks (Passive) max_fails, fail_timeout \u2705 Full Health Checks (Active) N/A \u274c Nginx Plus only Circuit Breaker Custom Lua \u26a0\ufe0f Limited (requires Lua) Sticky Sessions ip_hash or hash \u2705 Full"},{"location":"v1.2.0-PLAN/#4-testing-strategy","title":"4. Testing Strategy","text":"<p>Unit Tests (<code>tests/test_nginx.py</code>): - Config generation for all features - Upstream/Server/Location block generation - Rate limiting directives - Headers manipulation - CORS configuration - Load balancing algorithms</p> <p>Integration Tests: - nginx -t (config validation) - Real Nginx deployment tests - Feature compatibility matrix</p> <p>Coverage Goal: 90%+</p>"},{"location":"v1.2.0-PLAN/#5-documentation","title":"5. Documentation","text":"<p>Guide: <code>docs/guides/NGINX.md</code> - Nginx Setup &amp; Installation - GAL Configuration \u2192 Nginx Config Mapping - Feature-by-Feature Examples - OpenResty Integration (f\u00fcr JWT/Circuit Breaker) - Best Practices - Troubleshooting</p> <p>Example Config: <code>examples/nginx-example.yaml</code> - 10+ Szenarien f\u00fcr verschiedene Use Cases - Mit und ohne OpenResty - Production-ready Beispiele</p>"},{"location":"v1.2.0-PLAN/#provider-comparison-matrix-updated","title":"Provider Comparison Matrix (Updated)","text":"Feature Envoy Kong APISIX Traefik Nginx Rate Limiting \u2705 \u2705 \u2705 \u2705 \u2705 Basic Auth \u26a0\ufe0f Lua \u2705 \u2705 \u2705 \u2705 API Key Auth \u26a0\ufe0f Lua \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f OpenResty JWT Auth \u2705 \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f OpenResty Headers \u2705 \u2705 \u2705 \u2705 \u2705 CORS \u2705 \u2705 \u2705 \u2705 \u2705 Circuit Breaker \u2705 \u26a0\ufe0f \u2705 \u2705 \u26a0\ufe0f Lua Active Health Checks \u2705 \u2705 \u2705 \u2705 \u274c (Plus only) Passive Health Checks \u2705 \u2705 \u2705 \u26a0\ufe0f \u2705 Load Balancing \u2705 \u2705 \u2705 \u2705 \u2705"},{"location":"v1.2.0-PLAN/#feature-2-haproxy-provider","title":"\ud83d\udd00 Feature 2: HAProxy Provider","text":"<p>Status: \u2705 IMPLEMENTED (Commits: f758eb8, 2961850, d964b82) Priority: \ud83d\udd34 High Effort: 2.5 Wochen</p>"},{"location":"v1.2.0-PLAN/#implementation-summary_1","title":"\u2705 Implementation Summary","text":"<p>Provider: <code>gal/providers/haproxy.py</code> (187 lines, 86% coverage) - Complete haproxy.cfg generation - Support for load balancing algorithms (roundrobin, leastconn, source, weighted) - Active health checks (httpchk, fall/rise thresholds, expected status codes) - Passive health checks (max_failures) - Rate limiting (stick-table based, IP and header tracking) - Header manipulation (http-request/http-response directives) - ACLs (path_beg, method, header matching) - Sticky sessions (cookie-based and source-based) - CORS (via Access-Control-* headers) - Template variable conversion ({{uuid}} \u2192 %[uuid()], {{now}} \u2192 %[date()])</p> <p>Tests: <code>tests/test_haproxy.py</code> (10 tests, all passing) - Provider name, basic config generation - Load balancing (roundrobin, leastconn, weighted) - Active health checks - Rate limiting (IP-based) - Request headers - CORS configuration - Sticky sessions</p> <p>Documentation: <code>docs/guides/HAPROXY.md</code> (1100+ lines, German) - \u00dcbersicht &amp; Feature-Matrix - Installation &amp; Setup - Feature-by-Feature Anleitungen - HAProxy-spezifische Details (haproxy.cfg, ACLs, Stats Page, Logging) - Provider-Vergleich (vs Envoy, Kong, APISIX, Traefik, Nginx) - Best Practices &amp; Troubleshooting</p> <p>Examples: <code>examples/haproxy-example.yaml</code> (16 production scenarios) - Basic Load Balancing (Round Robin, Least Conn, Source IP Hash, Weighted) - Active &amp; Passive Health Checks - Rate Limiting (IP-based, Header-based) - Request/Response Header Manipulation - CORS Configuration - Sticky Sessions (Cookie-based) - Combined Features (Production API, HA Payment Service) - Microservices Architecture</p> <p>CLI Integration: \u2705 Complete - Added HAProxyProvider to all commands - Extension map: haproxy \u2192 .cfg - Verified config generation works - Fixed validate() return type (None \u2192 bool)</p> <p>Limitations: - \u26a0\ufe0f JWT Auth requires Lua scripting - \u26a0\ufe0f Circuit Breaker requires Lua (basic via fall/rise)</p>"},{"location":"v1.2.0-PLAN/#motivation_1","title":"Motivation","text":"<ul> <li>HAProxy ist der de-facto Standard f\u00fcr High-Performance Load Balancing</li> <li>Extrem performant (100k+ RPS)</li> <li>Enterprise-grade Reliability</li> <li>Umfangreiche Load Balancing Algorithmen</li> <li>Ausgezeichnete Health Checks &amp; Observability</li> <li>Weit verbreitet in Production</li> </ul>"},{"location":"v1.2.0-PLAN/#haproxy-capabilities","title":"HAProxy Capabilities","text":"<p>Unterst\u00fctzte Features: - \u2705 Advanced Load Balancing (roundrobin, leastconn, source, weighted) - \u2705 Active &amp; Passive Health Checks (httpchk, fall/rise) - \u2705 HTTP/HTTPS/TCP Load Balancing - \u2705 SSL/TLS Termination - \u2705 Rate Limiting (stick-table based) - \u2705 Basic Authentication (auth realm) - \u2705 Header Manipulation (http-request/http-response) - \u2705 ACLs (Access Control Lists) - \u2705 Sticky Sessions (cookie-based, source-based) - \u2705 Connection Pooling - \u2705 CORS (via Access-Control-* headers) - \u26a0\ufe0f JWT Auth (via Lua oder externe Auth) - \u26a0\ufe0f Circuit Breaker (basic via fall/rise)</p>"},{"location":"v1.2.0-PLAN/#feature-3-websocket-support","title":"\ud83c\udf10 Feature 3: WebSocket Support","text":"<p>Status: \u2705 IMPLEMENTED (Commit: e249bb9) Priority: \ud83d\udfe1 Medium Effort: 2 Wochen Dependencies: Nginx, HAProxy</p>"},{"location":"v1.2.0-PLAN/#implementation-summary_2","title":"\u2705 Implementation Summary","text":"<p>Config Model: <code>WebSocketConfig</code> in <code>gal/config.py</code> (lines 508-544) <pre><code>@dataclass\nclass WebSocketConfig:\n    enabled: bool = True\n    idle_timeout: str = \"300s\"      # 5 minutes\n    ping_interval: str = \"30s\"      # Keep-alive\n    max_message_size: int = 1048576 # 1MB\n    compression: bool = False       # Per-Message Deflate\n</code></pre></p> <p>Provider Implementations: All 6 providers updated - \u2705 Envoy: upgrade_configs + idle_timeout (gal/providers/envoy.py:162-168, 270-278) - \u2705 Kong: read_timeout/write_timeout (gal/providers/kong.py:151-159) - \u2705 APISIX: enable_websocket flag (gal/providers/apisix.py:291-294) - \u2705 Traefik: passHostHeader + flushInterval (gal/providers/traefik.py:418-428) - \u2705 Nginx: proxy_http_version 1.1 + Upgrade headers (gal/providers/nginx.py:380-398) - \u2705 HAProxy: timeout tunnel (gal/providers/haproxy.py:321-333)</p> <p>Tests: <code>tests/test_websocket.py</code> (20 tests, all passing) - Envoy: 5 tests (basic, timeout, disabled, compression, + JWT auth) - Kong: 2 tests (basic, custom timeouts) - APISIX: 4 tests (basic, disabled, timeout, + load balancing) - Traefik: 2 tests (basic, flush interval) - Nginx: 4 tests (basic, timeout, disabled, + rate limiting) - HAProxy: 3 tests (basic, timeout, disabled)</p> <p>Documentation: <code>docs/guides/WEBSOCKET.md</code> (1100+ lines, German) - Overview: WebSocket vs HTTP comparison - Schnellstart: 3 quick examples - Provider-specific implementations for all 6 providers - 5 use cases: Chat, Dashboard, IoT, Gaming, File Upload - Best practices &amp; troubleshooting - Client examples (JavaScript, Python, Go)</p> <p>Examples: <code>examples/websocket-example.yaml</code> (6 production scenarios) 1. Basic WebSocket 2. Chat Application (JWT + Sticky Sessions) 3. Live Dashboard (Compression + Rate Limiting) 4. IoT Sensor Data (API Key + Long Timeouts) 5. Gaming Server (Ultra-short ping intervals) 6. File Upload Streaming (16MB message size)</p> <p>Coverage: 38% \u2192 increased with WebSocket tests</p>"},{"location":"v1.2.0-PLAN/#motivation_2","title":"Motivation","text":"<ul> <li>Real-time Kommunikation f\u00fcr Chat, Dashboards, Live Updates</li> <li>WebSocket ist Standard f\u00fcr bidirektionale Kommunikation</li> <li>Viele moderne Apps ben\u00f6tigen WebSocket Support</li> <li>Unterst\u00fctzt Chat-Apps (Slack, Discord), Live-Dashboards, IoT, Gaming</li> </ul>"},{"location":"v1.2.0-PLAN/#feature-4-requestresponse-body-transformation","title":"\ud83d\udd04 Feature 4: Request/Response Body Transformation","text":"<p>Status: \u2705 IMPLEMENTED (Commits: b753c0f, 37bb1aa) Priority: \ud83d\udfe1 Medium Effort: 1.5 Wochen</p>"},{"location":"v1.2.0-PLAN/#implementation-summary_3","title":"\u2705 Implementation Summary","text":"<p>Config Model: <code>gal/config.py</code> (lines 550-629) - RequestBodyTransformation: add_fields, remove_fields, rename_fields - ResponseBodyTransformation: filter_fields, add_fields - BodyTransformationConfig: enabled, request, response</p> <p>Provider Implementations: All 6 providers updated - \u2705 Envoy: Complete Lua filter (lines 416-613)   - Helper functions: generate_uuid(), get_timestamp()   - Request transformation: transform_request_body() + envoy_on_request()   - Response transformation: transform_response_body() + envoy_on_response()   - Template variables: {{uuid}}, {{now}}, {{timestamp}}   - 100% feature support</p> <ul> <li>\u2705 Kong: Plugins (lines 269-337)</li> <li>request-transformer plugin for request body</li> <li>response-transformer plugin for response body</li> <li>Template variables: $(uuid()), $(date())</li> <li>Warning for rename_fields (requires custom Lua plugin)</li> <li> <p>95% feature support</p> </li> <li> <p>\u2705 APISIX: Serverless Lua (lines 296-317, 512-620)</p> </li> <li>serverless-pre-function (phase: rewrite) for requests</li> <li>serverless-post-function (phase: body_filter) for responses</li> <li>Complete Lua implementation with cjson</li> <li>Template variables: core.utils.uuid(), os.date()</li> <li> <p>100% feature support</p> </li> <li> <p>\u26a0\ufe0f Traefik: Warning only (lines 151-160)</p> </li> <li>No native body transformation support</li> <li>Suggests alternatives: ForwardAuth, Custom Plugin, Alternative Provider</li> <li> <p>Config generation continues without error</p> </li> <li> <p>\u2705 Nginx: OpenResty Lua (lines 374-376, 591-681)</p> </li> <li>access_by_lua_block for request transformation</li> <li>body_filter_by_lua_block for response transformation</li> <li>Requires OpenResty for Lua support</li> <li>Template variables: ngx.var.request_id, ngx.utctime()</li> <li> <p>100% feature support</p> </li> <li> <p>\u26a0\ufe0f HAProxy: Lua function references (lines 264-289)</p> </li> <li>http-request lua.transform_request_{service}_route{idx}</li> <li>http-response lua.transform_response_{service}_route{idx}</li> <li>Warning: Requires Lua scripts loaded in global section</li> <li>Manual Lua implementation required</li> <li>90% feature support</li> </ul> <p>Tests: <code>tests/test_body_transformation.py</code> (12 tests, all passing) 1. test_config_model - BodyTransformationConfig dataclass 2. test_envoy_request_body_transformation - Lua filter, add/remove/rename 3. test_envoy_response_body_transformation - Response filtering 4. test_kong_request_body_transformation - Plugin configuration 5. test_kong_response_body_transformation - Response filtering 6. test_apisix_request_body_transformation - Serverless Lua 7. test_apisix_response_body_transformation - Response Lua 8. test_traefik_body_transformation_warning - Limitation warning 9. test_nginx_request_body_transformation - OpenResty blocks 10. test_nginx_response_body_transformation - Response filtering 11. test_haproxy_body_transformation_lua_reference - Lua refs 12. test_all_transformation_features_combined - All features</p> <p>Documentation: <code>docs/guides/BODY_TRANSFORMATION.md</code> (1000+ lines, German) - \u00dcbersicht &amp; Use Cases (15 Szenarien) - Schnellstart (3 Beispiele) - Konfigurationsoptionen (alle Parameter) - Provider-Implementierungen (alle 6) - Best Practices (7 Empfehlungen) - Troubleshooting (6 Probleme) - Provider-Vergleich</p> <p>Examples: <code>examples/body-transformation-example.yaml</code> (15 scenarios) 1. Basic Trace ID addition 2. Security - Remove sensitive fields 3. Response Filtering - Remove PII 4. Field Renaming - Legacy integration 5. API Versioning - Add metadata 6. Combined transformations 7. Audit Logging 8. Canary Deployment marking 9. Multi-Tenant context 10. Data Enrichment 11. Payment Service (PCI compliance) 12. Microservices - Service Mesh 13. IoT Device Data 14. GraphQL Gateway 15. Production API (all features combined)</p> <p>Feature Matrix: | Feature | Envoy | Kong | APISIX | Traefik | Nginx | HAProxy | |---------|-------|------|--------|---------|-------|---------| | Request: Add Fields | \u2705 Lua | \u2705 Plugin | \u2705 Lua | \u274c | \u2705 Lua | \u26a0\ufe0f Lua | | Request: Remove Fields | \u2705 Lua | \u2705 Plugin | \u2705 Lua | \u274c | \u2705 Lua | \u26a0\ufe0f Lua | | Request: Rename Fields | \u2705 Lua | \u26a0\ufe0f Lua | \u2705 Lua | \u274c | \u2705 Lua | \u26a0\ufe0f Lua | | Response: Filter Fields | \u2705 Lua | \u2705 Plugin | \u2705 Lua | \u274c | \u2705 Lua | \u26a0\ufe0f Lua | | Response: Add Fields | \u2705 Lua | \u2705 Plugin | \u2705 Lua | \u274c | \u2705 Lua | \u26a0\ufe0f Lua | | Template Variables | \u2705 | \u26a0\ufe0f | \u2705 | \u274c | \u2705 | \u26a0\ufe0f |</p> <p>Coverage: Test coverage increased from 13% to 43% for body transformation</p> <p>Config Example: <pre><code>routes:\n  - path_prefix: /api/users\n    body_transformation:\n      enabled: true\n      request:\n        add_fields:\n          trace_id: \"{{uuid}}\"\n          timestamp: \"{{now}}\"\n          api_version: \"v1\"\n        remove_fields:\n          - internal_id\n          - secret_key\n        rename_fields:\n          user_id: id\n      response:\n        filter_fields:\n          - password\n          - ssn\n        add_fields:\n          server_time: \"{{timestamp}}\"\n</code></pre></p>"},{"location":"v1.2.0-PLAN/#feature-5-timeout-retry-policies","title":"\u23f1\ufe0f Feature 5: Timeout &amp; Retry Policies","text":"<p>Status: \u2705 IMPLEMENTED (Commits: 98131c0, 630676e, ee28fe8) Priority: \ud83d\udfe1 Medium Effort: 1 Woche</p>"},{"location":"v1.2.0-PLAN/#implementation-summary_4","title":"\u2705 Implementation Summary","text":"<p>Config Models: <code>gal/config.py:704-792</code> - TimeoutConfig (lines 704-740): connect, send, read, idle timeouts - RetryConfig (lines 742-792): enabled, attempts, backoff (exponential/linear), base_interval, max_interval, retry_on</p> <p>Provider Implementations: - Envoy (<code>envoy.py:929-1036</code>): cluster.connect_timeout, retry_policy with num_retries, retry_on - Kong (<code>kong.py:527-565</code>): Service-level timeouts in milliseconds, retries field - APISIX (<code>apisix.py:433-505</code>): timeout object + proxy-retry plugin - Traefik (<code>traefik.py:482-537</code>): serversTransport (timeouts), retry middleware - Nginx (<code>nginx.py:682-738</code>): proxy_connect_timeout, proxy_read_timeout, proxy_next_upstream - HAProxy (<code>haproxy.py:572-641</code>): timeout connect/client/server, retry-on directive</p> <p>Tests: <code>tests/test_timeout_retry.py</code> (22 tests, all passing) 1. Config model tests (9 tests) 2. Envoy timeout &amp; retry (3 tests) 3. Kong timeout &amp; retry (2 tests) 4. APISIX timeout &amp; retry (2 tests) 5. Traefik timeout &amp; retry (2 tests) 6. Nginx timeout &amp; retry (2 tests) 7. HAProxy timeout &amp; retry (2 tests)</p> <p>Documentation: <code>docs/guides/TIMEOUT_RETRY.md</code> (1000+ lines, German) - \u00dcbersicht &amp; Konzepte (Timeouts, Retries, Backoff) - Schnellstart (3 Beispiele) - Konfigurationsoptionen (alle Parameter) - Provider-Implementierungen (alle 6) - 10 h\u00e4ufige Anwendungsf\u00e4lle - Best Practices (7 Empfehlungen) - Troubleshooting (6 Probleme)</p> <p>Examples: <code>examples/timeout-retry-example.yaml</code> (12 scenarios) 1. Basic Timeout 2. Basic Retry (Exponential Backoff) 3. Timeout &amp; Retry Combined (RECOMMENDED) 4. Payment API (Aggressive Retries) 5. Long-Running Operations 6. Microservice mit Circuit Breaker 7. gRPC Service 8. External API 9. Multi-Datacenter (Linear Backoff) 10. WebSocket 11. Idempotent API (Many Retries) 12. Non-Idempotent API (No Retry)</p> <p>Config Example: <pre><code>routes:\n  - path_prefix: /api\n    timeout:\n      connect: 5s\n      send: 30s\n      read: 60s\n      idle: 300s\n    retry:\n      enabled: true\n      attempts: 3\n      backoff: exponential\n      base_interval: 25ms\n      max_interval: 250ms\n      retry_on:\n        - connect_timeout\n        - http_5xx\n</code></pre></p>"},{"location":"v1.2.0-PLAN/#feature-6-enhanced-logging-observability","title":"\ud83d\udcca Feature 6: Enhanced Logging &amp; Observability","text":"<p>Status: \u2705 IMPLEMENTED (Commits: c57467d, 7df7a11, 9d799b3, 4bab7f6) Priority: \ud83d\udfe2 Low Effort: 1.5 Wochen</p>"},{"location":"v1.2.0-PLAN/#implementation-summary_5","title":"\u2705 Implementation Summary","text":"<p>Config Models: <code>gal/config.py:798-849</code> - LoggingConfig (lines 798-825): enabled, format (json/text), level, access_log_path, error_log_path, sample_rate, include_request_body, include_response_body, include_headers, exclude_paths, custom_fields - MetricsConfig (lines 828-849): enabled, exporter (prometheus/opentelemetry/both), prometheus_port, prometheus_path, opentelemetry_endpoint, include_histograms, include_counters, custom_labels</p> <p>Provider Implementations: - Envoy (<code>envoy.py:841-927</code>):   - JSON access logs with custom fields   - Log sampling (sample_rate &lt; 1.0)   - Prometheus metrics via admin interface (/stats/prometheus)   - OpenTelemetry stats_sinks - Kong (<code>kong.py:481-525</code>):   - file-log plugin for access logs   - prometheus plugin (Kong Admin API /metrics endpoint) - APISIX (<code>apisix.py:389-431</code>):   - file-logger plugin with include_req_body/include_resp_body   - prometheus plugin (endpoint: :9091/apisix/prometheus/metrics) - Traefik (<code>traefik.py:439-480</code>):   - accessLog configuration (JSON or common format)   - prometheus metrics via entryPoint - Nginx (<code>nginx.py:220-258</code>):   - log_format with JSON support   - Configurable log levels (debug, info, warn, error)   - access_log and error_log directives   - Note: Prometheus requires nginx-prometheus-exporter - HAProxy (<code>haproxy.py:538-570</code>):   - syslog logging configuration   - Log level mapping (debug, info, notice, err)   - Note: Prometheus requires external haproxy_exporter</p> <p>Tests: <code>tests/test_logging_observability.py</code> (19 tests, all passing) 1. Config Model Tests (4 tests): LoggingConfig defaults/custom, MetricsConfig defaults/custom 2. Envoy Tests (4 tests): JSON logging, sampling, Prometheus, OpenTelemetry 3. Kong Tests (2 tests): file-log plugin, prometheus plugin 4. APISIX Tests (2 tests): file-logger plugin, prometheus plugin 5. Traefik Tests (2 tests): accessLog, prometheus entryPoint 6. Nginx Tests (2 tests): JSON logging, text logging 7. HAProxy Tests (3 tests): syslog config, JSON note, metrics note</p> <p>Documentation: <code>docs/guides/LOGGING_OBSERVABILITY.md</code> (1000+ lines, German) - \u00dcbersicht &amp; Feature-Matrix (alle 6 Provider) - Schnellstart (3 Beispiele: JSON logging, Prometheus, combined) - Konfigurationsoptionen (LoggingConfig, MetricsConfig) - Provider-Implementierungen (alle 6 mit Code-Beispielen) - 6 h\u00e4ufige Anwendungsf\u00e4lle (Production API, High-Traffic, Microservices, Dev, Security Audit, Multi-Tenant) - Best Practices (7 Empfehlungen) - Troubleshooting (6 Szenarien)</p> <p>Examples: <code>examples/logging-observability-example.yaml</code> (15 scenarios, 600+ lines) 1. Basic JSON Logging 2. Prometheus Metrics 3. OpenTelemetry Integration 4. Log Sampling (High Traffic) 5. Custom Fields 6. Include Specific Headers (Distributed Tracing) 7. Production API (Complete Setup) 8. Development Environment (Debug Logging) 9. Security Audit Logging 10. Multi-Tenant SaaS 11. Microservices mit Correlation IDs 12. Exclude Health Check Endpoints 13. HAProxy with Syslog 14. Nginx with JSON Format 15. APISIX with File Logger</p> <p>Feature Matrix: | Feature | Envoy | Kong | APISIX | Traefik | Nginx | HAProxy | |---------|-------|------|--------|---------|-------|---------| | JSON Logs | \u2705 | \u2705 | \u2705 | \u2705 | \u2705 | \u26a0\ufe0f | | Custom Fields | \u2705 | \u2705 | \u2705 | \u2705 | \u2705 | \u26a0\ufe0f | | Log Sampling | \u2705 | \u26a0\ufe0f | \u26a0\ufe0f | \u26a0\ufe0f | \u26a0\ufe0f | \u26a0\ufe0f | | Prometheus | \u2705 | \u2705 | \u2705 | \u2705 | \u26a0\ufe0f | \u26a0\ufe0f | | OpenTelemetry | \u2705 | \u26a0\ufe0f | \u26a0\ufe0f | \u2705 | \u274c | \u274c |</p> <p>Coverage: Test coverage increased from 13% to 32% for logging &amp; observability</p> <p>Config Example: <pre><code>global:\n  logging:\n    enabled: true\n    format: json\n    level: info\n    access_log_path: /var/log/gateway/access.log\n    sample_rate: 0.5  # 50% sampling for high traffic\n    include_headers:\n      - X-Request-ID\n      - X-Correlation-ID\n    exclude_paths:\n      - /health\n      - /metrics\n    custom_fields:\n      environment: production\n      cluster: eu-west-1\n\n  metrics:\n    enabled: true\n    exporter: both\n    prometheus_port: 9090\n    opentelemetry_endpoint: http://otel-collector:4317\n    custom_labels:\n      environment: production\n</code></pre></p>"},{"location":"v1.2.0-PLAN/#documentation-plan","title":"\ud83d\udcda Documentation Plan","text":""},{"location":"v1.2.0-PLAN/#new-guides","title":"New Guides","text":"<ol> <li><code>docs/guides/NGINX.md</code> - Nginx Provider Guide</li> <li><code>docs/guides/HAPROXY.md</code> - HAProxy Provider Guide</li> <li><code>docs/guides/WEBSOCKETS.md</code> - WebSocket Support</li> <li><code>docs/guides/BODY_TRANSFORMATION.md</code> - Request/Response Body Transformation</li> <li><code>docs/guides/TIMEOUTS_RETRIES.md</code> - Timeout &amp; Retry Policies</li> </ol>"},{"location":"v1.2.0-PLAN/#updated-guides","title":"Updated Guides","text":"<ul> <li><code>README.md</code> - Add Nginx &amp; HAProxy to provider list</li> <li><code>ROADMAP.md</code> - Update v1.2.0 status</li> </ul>"},{"location":"v1.2.0-PLAN/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"v1.2.0-PLAN/#test-coverage-goals","title":"Test Coverage Goals","text":"<ul> <li>Unit Tests: 95%+ coverage</li> <li>Integration Tests: All 6 providers (Envoy, Kong, APISIX, Traefik, Nginx, HAProxy)</li> <li>E2E Tests: Real gateway deployments</li> </ul>"},{"location":"v1.2.0-PLAN/#new-test-files","title":"New Test Files","text":"<ul> <li><code>tests/test_nginx.py</code> - Nginx provider tests (25 tests)</li> <li><code>tests/test_haproxy.py</code> - HAProxy provider tests (10 tests)</li> <li><code>tests/test_websocket.py</code> - WebSocket feature tests (20 tests)</li> <li><code>tests/test_body_transformation.py</code> - Body transformation tests (12 tests)</li> <li><code>tests/test_timeout_retry.py</code> - Timeout/Retry tests (22 tests)</li> <li><code>tests/test_logging_observability.py</code> - Logging &amp; Observability tests (19 tests)</li> </ul>"},{"location":"v1.2.0-PLAN/#release-plan","title":"\ud83d\ude80 Release Plan","text":""},{"location":"v1.2.0-PLAN/#milestone-1-nginx-provider-woche-1-3","title":"Milestone 1: Nginx Provider (Woche 1-3)","text":"<ul> <li>\u2705 Nginx Provider Klasse</li> <li>\u2705 Feature Mapping (Rate Limit, Auth, Headers, CORS, LB)</li> <li>\u2705 Tests (100+)</li> <li>\u2705 Dokumentation</li> </ul>"},{"location":"v1.2.0-PLAN/#milestone-2-haproxy-provider-woche-4-6","title":"Milestone 2: HAProxy Provider (Woche 4-6)","text":"<ul> <li>\u2705 HAProxy Provider Klasse</li> <li>\u2705 Advanced Load Balancing</li> <li>\u2705 Health Checks</li> <li>\u2705 Tests (100+)</li> <li>\u2705 Dokumentation</li> </ul>"},{"location":"v1.2.0-PLAN/#milestone-3-websocket-support-woche-7-8","title":"Milestone 3: WebSocket Support (Woche 7-8) \u2705","text":"<ul> <li>\u2705 WebSocket Config Model (WebSocketConfig in gal/config.py)</li> <li>\u2705 Provider Implementations (All 6 providers)</li> <li>\u2705 Tests (20 tests, all passing)</li> <li>\u2705 Dokumentation (1100+ lines, German)</li> <li>\u2705 Beispiele (6 production scenarios)</li> </ul>"},{"location":"v1.2.0-PLAN/#milestone-4-body-transformation-woche-9","title":"Milestone 4: Body Transformation (Woche 9) \u2705","text":"<ul> <li>\u2705 Body Transformation Config Model (BodyTransformationConfig in gal/config.py)</li> <li>\u2705 Provider Implementations (All 6 providers: Envoy, Kong, APISIX, Traefik, Nginx, HAProxy)</li> <li>\u2705 Tests (12 tests, all passing)</li> <li>\u2705 Dokumentation (1000+ lines, German)</li> <li>\u2705 Beispiele (15 production scenarios)</li> </ul>"},{"location":"v1.2.0-PLAN/#milestone-5-timeout-retry-policies-woche-10","title":"Milestone 5: Timeout &amp; Retry Policies (Woche 10) \u2705","text":"<ul> <li>\u2705 Timeout &amp; Retry Config Models (TimeoutConfig, RetryConfig in gal/config.py:704-792)</li> <li>\u2705 Provider Implementations (All 6 providers)</li> <li>\u2705 Envoy: cluster.connect_timeout, retry_policy</li> <li>\u2705 Kong: Service-level timeouts (milliseconds), retries field</li> <li>\u2705 APISIX: timeout + proxy-retry plugins</li> <li>\u2705 Traefik: serversTransport, retry middleware</li> <li>\u2705 Nginx: proxy_*_timeout, proxy_next_upstream</li> <li>\u2705 HAProxy: timeout directives, retry-on</li> <li>\u2705 Tests (22 tests, all passing)</li> <li>\u2705 Dokumentation (1000+ lines, German)</li> <li>\u2705 Beispiele (12 production scenarios)</li> </ul>"},{"location":"v1.2.0-PLAN/#milestone-6-logging-observability-release-woche-11","title":"Milestone 6: Logging &amp; Observability + Release (Woche 11) \u2705","text":"<ul> <li>\u2705 Logging &amp; Observability Config Models (LoggingConfig, MetricsConfig in gal/config.py:798-849)</li> <li>\u2705 Provider Implementations (All 6 providers)</li> <li>\u2705 Envoy: JSON logs, sampling, Prometheus, OpenTelemetry stats_sinks</li> <li>\u2705 Kong: file-log, prometheus plugins</li> <li>\u2705 APISIX: file-logger, prometheus global plugins</li> <li>\u2705 Traefik: accessLog, prometheus entryPoint</li> <li>\u2705 Nginx: log_format JSON, nginx-prometheus-exporter note</li> <li>\u2705 HAProxy: syslog logging, haproxy_exporter note</li> <li>\u2705 Tests (19 tests, all passing)</li> <li>\u2705 Dokumentation (1000+ lines, German)</li> <li>\u2705 Beispiele (15 production scenarios)</li> <li>\u2705 Final Testing</li> <li>\u2705 Documentation Review</li> <li>\u2705 README.md &amp; ROADMAP.md &amp; v1.2.0-PLAN.md Updates</li> <li>\u2705 Release v1.2.0</li> </ul>"},{"location":"v1.2.0-PLAN/#success-metrics","title":"\ud83d\udcdd Success Metrics","text":"<p>\u2705 ALLE ZIELE ERREICHT!</p> <ul> <li>6 Gateway Providers (Envoy, Kong, APISIX, Traefik, Nginx, HAProxy) \u2705</li> <li>364 Tests mit 89% Code Coverage \u2705 (erh\u00f6ht von 291 Tests)</li> <li>10.000+ Zeilen Dokumentation \u2705 (6 Provider-Guides + 6 Feature-Guides)</li> <li>WebSocket Support f\u00fcr moderne Real-time Apps \u2705</li> <li>Body Transformation f\u00fcr API Versioning &amp; Legacy Integration \u2705</li> <li>Timeout &amp; Retry f\u00fcr Resilienz \u2705</li> <li>Logging &amp; Observability f\u00fcr Production Monitoring \u2705</li> </ul> <p>v1.2.0 ist PRODUCTION-READY! \ud83d\ude80</p> <p>Document Status: \u2705 COMPLETE (v1.2.0 Released) Last Updated: 2025-10-18 Author: GAL Development Team</p> <p>\ud83c\udf89 v1.2.0 ist vollst\u00e4ndig implementiert und dokumentiert!</p>"},{"location":"v1.3.0-PLAN/","title":"GAL v1.3.0 - Implementierungsplan","text":"<p>Target Release: Q2 2026 Focus: Import/Migration &amp; Provider Portability Estimated Effort: 12 Wochen</p>"},{"location":"v1.3.0-PLAN/#mission","title":"\ud83c\udfaf Mission","text":"<p>Provider Lock-in brechen: Erm\u00f6gliche Migration bestehender Gateway-Konfigurationen zu GAL und damit zu jedem anderen Provider.</p>"},{"location":"v1.3.0-PLAN/#vision","title":"Vision","text":"<p>Unternehmen mit bestehenden Gateway-Deployments (Nginx, HAProxy, Kong, etc.) k\u00f6nnen ihre Konfigurationen automatisch zu GAL konvertieren und damit: 1. Portabilit\u00e4t gewinnen - Wechsel zu anderem Provider in Minuten statt Wochen 2. Vendor Lock-in vermeiden - Nicht mehr an einen Provider gebunden 3. Multi-Provider nutzen - Gleiche Config auf verschiedenen Providern 4. Migration vereinfachen - Nginx \u2192 HAProxy, Kong \u2192 Envoy, etc.</p>"},{"location":"v1.3.0-PLAN/#feature-overview","title":"\ud83d\udccb Feature Overview","text":"# Feature Priority Status Effort Dependencies 1 Envoy Import (YAML Parser) \ud83d\udd34 High \u2705 Done 1 Woche - 2 Kong Import (YAML Parser) \ud83d\udd34 High \u2705 Done 1 Woche Feature 1 3 APISIX Import (JSON/YAML Parser) \ud83d\udd34 High \u2705 Done 1 Woche Features 1-2 4 Traefik Import (YAML Parser) \ud83d\udd34 High \u2705 Done 1 Woche Features 1-3 5 Nginx Import (Custom Parser) \ud83d\udd34 High \u2705 Done 2 Wochen Features 1-4 6 HAProxy Import (Custom Parser) \ud83d\udd34 High \ud83d\udd04 Pending 2 Wochen Features 1-5 7 Compatibility Checker &amp; Comparison \ud83d\udfe1 Medium \ud83d\udd04 Pending 2 Wochen Features 1-6 8 Migration Assistant (Interactive CLI) \ud83d\udfe1 Medium \ud83d\udd04 Pending 2 Wochen Features 1-7 <p>Total Estimated Effort: 12 Wochen Progress: \u215d Features completed (62.5%)</p> <p>Release Strategy: - v1.3.0-alpha1 (Week 2): Envoy + Kong Import \u2705 - v1.3.0-alpha2 (Week 4): + APISIX + Traefik Import \u2705 COMPLETE - v1.3.0-beta1 (Week 6): + Nginx Import \u2705 COMPLETE - v1.3.0-beta2 (Week 8): + HAProxy Import \ud83d\udd04 - v1.3.0-rc1 (Week 10): + Compatibility Checker \ud83d\udd04 - v1.3.0 Final (Week 12): + Migration Assistant \ud83d\udd04</p>"},{"location":"v1.3.0-PLAN/#shared-infrastructure-all-features","title":"\ud83c\udfaf Shared Infrastructure (All Features)","text":""},{"location":"v1.3.0-PLAN/#provider-interface-extension","title":"Provider Interface Extension","text":"<p>File: <code>gal/provider.py</code></p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import List, Dict, Any\n\nclass Provider(ABC):\n    \"\"\"Abstract base class for all gateway providers.\"\"\"\n\n    @abstractmethod\n    def parse(self, provider_config: str) -&gt; Config:\n        \"\"\"Parse provider-specific config to GAL (NEU!).\"\"\"\n        pass\n\n    def get_import_warnings(self) -&gt; List[str]:\n        \"\"\"Return warnings from last parse operation.\"\"\"\n        return []\n\n    def get_import_report(self) -&gt; Dict[str, Any]:\n        \"\"\"Return detailed import report.\"\"\"\n        return {\n            \"features_mapped\": [],\n            \"features_skipped\": [],\n            \"warnings\": [],\n            \"provider_specific\": {}\n        }\n</code></pre>"},{"location":"v1.3.0-PLAN/#cli-command-gal-import","title":"CLI Command: <code>gal import</code>","text":"<pre><code># Import provider config to GAL\ngal import --provider nginx --input nginx.conf --output gal-config.yaml\n\n# Dry-run to preview\ngal import --provider envoy --input envoy.yaml --dry-run\n\n# With import report\ngal import --provider haproxy --input haproxy.cfg --output gal.yaml --report import-report.json\n</code></pre>"},{"location":"v1.3.0-PLAN/#feature-mapping-matrix","title":"Feature Mapping Matrix","text":"GAL Feature Envoy Kong APISIX Traefik Nginx HAProxy Routing (path_prefix) \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Methods (GET, POST) \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Upstream (targets) \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Load Balancing \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Rate Limiting \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Basic Auth \u26a0\ufe0f \u2705 \u2705 \u2705 \u2705 \u2705 JWT Auth \u2705 \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f Headers \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 CORS \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Health Checks \u2705 \u2705 \u2705 \u2705 \u26a0\ufe0f \u2705"},{"location":"v1.3.0-PLAN/#feature-1-envoy-import-yaml-parser","title":"\ud83d\udce6 Feature 1: Envoy Import (YAML Parser)","text":"<p>Status: \u2705 IMPLEMENTED | Effort: 1 Woche | Release: v1.3.0-alpha1 | Commits: 652a78d, 067c197</p>"},{"location":"v1.3.0-PLAN/#implementation-summary","title":"\u2705 Implementation Summary","text":"<p>Provider Implementation: <code>gal/providers/envoy.py:1159-1381</code> <pre><code>class EnvoyProvider(Provider):\n    def parse(self, provider_config: str) -&gt; Config:\n        \"\"\"Parse Envoy YAML configuration to GAL format.\n\n        Converts static_resources configuration into GAL Config model.\n        Extracts clusters, listeners, routes, health checks, and load balancing.\n        \"\"\"\n        envoy_config = yaml.safe_load(provider_config)\n\n        # Parse clusters \u2192 Services\n        services = []\n        cluster_map = {}\n        for cluster in clusters:\n            service = self._parse_cluster(cluster)\n            services.append(service)\n            cluster_map[cluster.get(\"name\")] = service\n\n        # Parse listeners/routes\n        for listener in listeners:\n            self._parse_listener_routes(listener, cluster_map)\n\n        return Config(version=\"1.0\", provider=\"envoy\", services=services)\n</code></pre></p> <p>Helper Methods: - <code>_parse_cluster()</code>: Cluster \u2192 Service conversion with targets, health checks, load balancing - <code>_map_envoy_lb_policy()</code>: Maps Envoy LB policies to GAL algorithms - <code>_parse_listener_routes()</code>: Extracts routes from HTTP connection manager</p> <p>CLI Command: <code>gal/gal-cli.py:225-368</code> (<code>import-config</code>) <pre><code>gal import-config --provider envoy \\\n                  --input envoy.yaml \\\n                  --output gal-config.yaml\n</code></pre></p> <p>Manager Extension: <code>gal/manager.py:217-239</code> (<code>get_provider()</code>)</p> <p>Tests: <code>tests/test_import_envoy.py</code> - 15 tests, all passing \u2705 - Basic Import (3 tests): Simple cluster, weighted targets, routes - Health Checks (3 tests): Active, passive, combined - Load Balancing (5 tests): All algorithms (ROUND_ROBIN, LEAST_REQUEST, RING_HASH, etc.) - Multi-Service (1 test): Multiple clusters - Error Handling (3 tests): Invalid YAML, empty config, no endpoints</p> <p>Supported Features: - \u2705 Clusters \u2192 Services (name extraction: <code>api_cluster</code> \u2192 <code>api</code>) - \u2705 Load assignment endpoints \u2192 UpstreamTargets (with weights) - \u2705 Health checks \u2192 ActiveHealthCheck (HTTP probes with interval/timeout/thresholds) - \u2705 Outlier detection \u2192 PassiveHealthCheck (consecutive_5xx \u2192 max_failures) - \u2705 Load balancing policies \u2192 LoadBalancerConfig (all algorithms mapped) - \u2705 Listeners + route_config \u2192 Routes (path prefix extraction) - \u2705 Multiple clusters \u2192 Multiple services</p> <p>Example: <pre><code># Input: envoy.yaml\nstatic_resources:\n  clusters:\n  - name: api_cluster\n    lb_policy: ROUND_ROBIN\n    load_assignment:\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address: {socket_address: {address: api.internal, port_value: 8080}}\n          load_balancing_weight: {value: 2}\n\n# Output: gal-config.yaml\nservices:\n- name: api\n  type: rest\n  upstream:\n    targets:\n    - {host: api.internal, port: 8080, weight: 2}\n    load_balancer: {algorithm: round_robin}\n  routes:\n  - path_prefix: /api\n</code></pre></p> <p>Coverage: 16% (new parsing code covered by tests)</p> <p>\ud83d\udcd6 Detail-Dokumentation: docs/import/envoy.md</p>"},{"location":"v1.3.0-PLAN/#feature-2-kong-import-yamljson-parser","title":"\ud83d\udce6 Feature 2: Kong Import (YAML/JSON Parser)","text":"<p>Status: \u2705 IMPLEMENTED | Effort: 1 Woche | Release: v1.3.0-alpha1 | Commit: 93845e7</p>"},{"location":"v1.3.0-PLAN/#implementation-summary_1","title":"\u2705 Implementation Summary","text":"<p>Provider Implementation: <code>gal/providers/kong.py:765-1210</code> (~470 lines, 15 helper methods)</p> <pre><code>class KongProvider(Provider):\n    def parse(self, provider_config: str) -&gt; Config:\n        \"\"\"Parse Kong declarative config (YAML/JSON) to GAL format.\n\n        Supports Kong 3.0 declarative config with services, routes,\n        upstreams, targets, and plugins.\n        \"\"\"\n        # Try YAML first, then JSON\n        kong_config = yaml.safe_load(provider_config) or json.loads(provider_config)\n\n        # Create default global config (Kong proxy port 8000)\n        global_config = GlobalConfig(host=\"0.0.0.0\", port=8000, timeout=\"60s\")\n\n        return Config(\n            version=\"1.0\",\n            provider=\"kong\",\n            global_config=global_config,\n            services=self._parse_services(kong_config)\n        )\n</code></pre> <p>Helper Methods (15 methods):</p> <p>Service &amp; Upstream Parsing: - <code>_parse_services()</code>: Orchestrates service parsing from Kong config - <code>_parse_service()</code>: Converts Kong service \u2192 GAL Service (with type=\"rest\", protocol=\"http\") - <code>_parse_upstream()</code>: Parses Kong upstream with targets and health checks - <code>_parse_targets()</code>: Extracts UpstreamTarget list with weights - <code>_map_lb_algorithm()</code>: Maps Kong LB algorithms to GAL   - <code>round-robin</code> \u2192 <code>round_robin</code>   - <code>least-connections</code> \u2192 <code>least_conn</code>   - <code>consistent-hashing</code> \u2192 <code>ip_hash</code>   - <code>latency</code> \u2192 <code>least_conn</code></p> <p>Health Checks: - <code>_parse_health_check()</code>: Parses active + passive health checks   - Active: http_path, interval, timeout, healthy/unhealthy thresholds   - Passive: max_failures from unhealthy.http_failures</p> <p>Route &amp; Plugin Parsing: - <code>_parse_route()</code>: Converts Kong routes with path/methods and applies plugins</p> <p>Rate Limiting: - <code>_parse_rate_limiting_plugin()</code>: Converts rate-limiting plugin config   - Supports: second, minute, hour, day, month, year   - Converts to requests_per_second (e.g., minute: 600 \u2192 10 req/s)   - Maps limit_by to key_type (ip, header, consumer)</p> <p>Authentication (with import warnings): - <code>_parse_key_auth_plugin()</code>: API Key authentication   - Extracts key_names (defaults to \"apikey\")   - Sets in_location=\"header\"   - \u26a0\ufe0f Warning: API keys not imported for security</p> <ul> <li><code>_parse_basic_auth_plugin()</code>: Basic authentication</li> <li>Creates BasicAuthConfig with empty users dict</li> <li> <p>\u26a0\ufe0f Warning: User credentials not imported for security</p> </li> <li> <p><code>_parse_jwt_plugin()</code>: JWT authentication</p> </li> <li>Maps algorithm to algorithms list</li> <li>Sets issuer/audience to \"CONFIGURE_MANUALLY\"</li> <li>\u26a0\ufe0f Warning: JWT secrets not imported for security</li> </ul> <p>Header Manipulation: - <code>_parse_request_transformer_plugin()</code>: Request header add/remove   - Parses \"Header:Value\" format to dict - <code>_parse_response_transformer_plugin()</code>: Response header add/remove - <code>_enrich_response_headers()</code>: Merges response headers from multiple plugins</p> <p>CORS: - <code>_parse_cors_plugin()</code>: Parses CORS config   - origins, methods, headers, credentials, max_age</p> <p>Utilities: - <code>get_import_warnings()</code>: Returns list of import warnings for user review</p> <p>CLI Command: <code>gal-cli.py:225-368</code> (already implemented) <pre><code>gal import-config --provider kong \\\n                  --input kong.yaml \\\n                  --output gal-config.yaml\n</code></pre></p> <p>Tests: <code>tests/test_import_kong.py</code> - 21 tests, all passing \u2705</p> <p>Test Coverage: - TestKongImportBasic (3 tests): Simple service, service+route, JSON format - TestKongImportUpstream (2 tests): Targets with weights, all LB algorithms - TestKongImportHealthChecks (3 tests): Active, passive, combined - TestKongImportRateLimiting (2 tests): Second-based, minute-based (with conversion) - TestKongImportAuthentication (3 tests): Key-auth, basic-auth, JWT (all with warning checks) - TestKongImportHeaders (2 tests): Request transformer, response transformer - TestKongImportCORS (1 test): CORS plugin with all options - TestKongImportMultiService (1 test): 3 services with routes - TestKongImportErrors (3 tests): Invalid YAML, empty config, service without name - TestKongImportCombined (1 test): Production config with all features</p> <p>Supported Features: - \u2705 Services &amp; Upstreams (URL parsing: http://host:port) - \u2705 Targets with weights - \u2705 Load Balancing (4 algorithms: round-robin, least-connections, consistent-hashing, latency) - \u2705 Active Health Checks (http_path, interval, timeout, healthy/unhealthy thresholds) - \u2705 Passive Health Checks (max_failures from traffic monitoring) - \u2705 Rate Limiting (second/minute/hour/day conversion to req/s) - \u2705 API Key Authentication (key_names extraction) - \u2705 Basic Authentication (with security warning) - \u2705 JWT Authentication (algorithm mapping, with security warning) - \u2705 Request Header Transformation (add/remove with \"Header:Value\" parsing) - \u2705 Response Header Transformation (add/remove) - \u2705 CORS (origins, methods, headers, credentials, max_age) - \u2705 Multiple Services &amp; Routes - \u2705 YAML &amp; JSON format support</p> <p>Import Warnings (Security): - \u26a0\ufe0f API keys not imported (security) - user must configure manually - \u26a0\ufe0f Basic auth user credentials not imported (security) - \u26a0\ufe0f JWT secrets not imported (security) - issuer/audience set to \"CONFIGURE_MANUALLY\"</p> <p>Example: <pre><code># Input: kong.yaml\n_format_version: \"3.0\"\nservices:\n  - name: api_service\n    url: http://api_upstream\nupstreams:\n  - name: api_upstream\n    algorithm: round-robin\n    healthchecks:\n      active:\n        http_path: /health\n        healthy: {interval: 10, successes: 2}\n        unhealthy: {http_failures: 3}\ntargets:\n  - upstream: api_upstream\n    target: api-1:8080\n    weight: 100\nroutes:\n  - name: api_route\n    service: api_service\n    paths: [/api/v1]\n    methods: [GET, POST]\nplugins:\n  - name: rate-limiting\n    route: api_route\n    config: {second: 100, limit_by: ip}\n  - name: key-auth\n    route: api_route\n    config: {key_names: [apikey]}\n  - name: cors\n    route: api_route\n    config: {origins: [\"https://app.example.com\"], credentials: true}\n\n# Output: gal-config.yaml (simplified)\nservices:\n- name: api_service\n  type: rest\n  protocol: http\n  upstream:\n    targets:\n    - {host: api-1, port: 8080, weight: 100}\n    load_balancer: {algorithm: round_robin}\n    health_check:\n      active: {enabled: true, http_path: /health, interval: \"10s\", healthy_threshold: 2, unhealthy_threshold: 3}\n  routes:\n  - path_prefix: /api/v1\n    methods: [GET, POST]\n    rate_limit: {enabled: true, requests_per_second: 100, key_type: ip_address}\n    authentication: {enabled: true, type: api_key, api_key: {key_name: apikey}}\n    cors: {enabled: true, allowed_origins: [\"https://app.example.com\"], allow_credentials: true}\n</code></pre></p> <p>Coverage: kong.py: 8% \u2192 37% (improved by 29%)</p> <p>\ud83d\udcd6 Detail-Dokumentation: docs/import/kong.md</p>"},{"location":"v1.3.0-PLAN/#feature-3-apisix-import-jsonyaml-parser","title":"\ud83d\udce6 Feature 3: APISIX Import (JSON/YAML Parser)","text":"<p>Status: \u2705 IMPLEMENTED | Effort: 1 Woche | Release: v1.3.0-alpha2 | Commit: 4378d95</p>"},{"location":"v1.3.0-PLAN/#implementation-summary_2","title":"\u2705 Implementation Summary","text":"<p>Provider Implementation: <code>gal/providers/apisix.py:904-1292</code> (~390 lines, 15 helper methods)</p> <pre><code>class APISIXProvider(Provider):\n    def parse(self, provider_config: str) -&gt; Config:\n        \"\"\"Parse APISIX JSON/YAML configuration to GAL format.\n\n        APISIX supports both etcd and standalone (config file) mode.\n        This parser handles standalone config files.\n        \"\"\"\n        # Try YAML first, then JSON\n        apisix_config = yaml.safe_load(provider_config) or json.loads(provider_config)\n\n        # Create default global config (APISIX HTTP port 9080)\n        global_config = GlobalConfig(host=\"0.0.0.0\", port=9080, timeout=\"60s\")\n\n        return Config(\n            version=\"1.0\",\n            provider=\"apisix\",\n            global_config=global_config,\n            services=self._parse_services(apisix_config)\n        )\n</code></pre> <p>Helper Methods (15 methods):</p> <p>Service &amp; Upstream Parsing: - <code>_parse_services()</code>: Orchestrates service parsing from APISIX config - <code>_parse_service()</code>: Converts APISIX service \u2192 GAL Service (ID-based linking) - <code>_parse_upstream()</code>: Parses APISIX upstream with nodes (dict format: <code>{\"host:port\": weight}</code>) - <code>_map_lb_algorithm()</code>: Maps APISIX LB algorithms to GAL   - <code>roundrobin</code> \u2192 <code>round_robin</code>   - <code>chash</code> (consistent hash) \u2192 <code>ip_hash</code>   - <code>ewma</code> (exponentially weighted moving average) \u2192 <code>least_conn</code>   - <code>least_conn</code> \u2192 <code>least_conn</code></p> <p>Health Checks: - <code>_parse_health_check()</code>: Parses active + passive health checks   - Active: http_path, interval, timeout, healthy/unhealthy thresholds   - Passive: outlier detection monitoring</p> <p>Route &amp; Plugin Parsing: - <code>_parse_route()</code>: Converts APISIX routes with URI and plugins</p> <p>Rate Limiting (2 plugins): - <code>_parse_limit_req_plugin()</code>: Leaky bucket rate limiting   - rate (requests per second), burst - <code>_parse_limit_count_plugin()</code>: Fixed window rate limiting   - count/time_window \u2192 requests_per_second conversion</p> <p>Authentication (with import warnings): - <code>_parse_key_auth_plugin()</code>: API Key authentication (header-based)   - \u26a0\ufe0f Warning: API keys not imported for security - <code>_parse_basic_auth_plugin()</code>: Basic authentication   - \u26a0\ufe0f Warning: User credentials not imported for security - <code>_parse_jwt_auth_plugin()</code>: JWT authentication   - \u26a0\ufe0f Warning: JWT secrets not imported for security</p> <p>Header Manipulation: - <code>_parse_proxy_rewrite_plugin()</code>: Request header manipulation - <code>_parse_response_rewrite_plugin()</code>: Response header manipulation - <code>_enrich_response_headers()</code>: Merges response headers from multiple plugins</p> <p>CORS: - <code>_parse_cors_plugin()</code>: Parses CORS config   - origins, methods, headers, credentials, max_age   - Handles comma-separated strings and wildcards</p> <p>Utilities: - <code>get_import_warnings()</code>: Returns list of import warnings for user review</p> <p>CLI Command: <code>gal-cli.py:225-368</code> (already implemented) <pre><code>gal import-config --provider apisix \\\n                  --input apisix.yaml \\\n                  --output gal-config.yaml\n</code></pre></p> <p>Tests: <code>tests/test_import_apisix.py</code> - 22 tests, all passing \u2705</p> <p>Test Coverage: - Basic Import (3 tests): Simple service, service+route, JSON format - Upstream (2 tests): Nodes with weights, all LB algorithms (parametrized) - Health Checks (3 tests): Active, passive, combined - Rate Limiting (2 tests): limit-req plugin, limit-count plugin with conversion - Authentication (3 tests): key-auth, basic-auth, JWT (all with warning checks) - Headers (2 tests): proxy-rewrite, response-rewrite plugins - CORS (1 test): Full CORS configuration - Multi-Service (1 test): 3 services with routes - Errors (3 tests): Invalid YAML, empty config, service without name - Combined (1 test): Production config with all features - Circuit Breaker (1 test): api-breaker warning generation</p> <p>Supported Features: - \u2705 Services &amp; Upstreams (ID-based linking: service.upstream_id \u2192 upstream.id) - \u2705 Nodes with weights (<code>{\"host:port\": weight}</code> dict format with rsplit parsing) - \u2705 Load Balancing (4 algorithms: roundrobin, chash, ewma, least_conn) - \u2705 Active Health Checks (http_path, interval, timeout, healthy/unhealthy successes/failures) - \u2705 Passive Health Checks (outlier detection via checks.passive) - \u2705 Rate Limiting (limit-req leaky bucket, limit-count fixed window with count/time_window \u2192 req/s) - \u2705 API Key Authentication (header-based, with security warning) - \u2705 Basic Authentication (with security warning for user credentials) - \u2705 JWT Authentication (with security warning for secrets) - \u2705 Request Header Transformation (proxy-rewrite plugin) - \u2705 Response Header Transformation (response-rewrite plugin) - \u2705 CORS (origins, methods, headers, credentials, max_age with wildcard support) - \u2705 Circuit Breaker warning (api-breaker plugin detection) - \u2705 Multiple Services &amp; Routes - \u2705 YAML &amp; JSON format support</p> <p>Import Warnings: - \u26a0\ufe0f API keys not imported (security) - configure in APISIX consumers - \u26a0\ufe0f Basic auth user credentials not imported (security) - configure in consumers - \u26a0\ufe0f JWT secrets not imported (security) - configure manually - \u26a0\ufe0f Circuit breaker plugin requires manual review</p> <p>Example Input/Output: <pre><code># Input: apisix.yaml\nservices:\n  - id: api_service\n    name: api_service\n    upstream_id: api_upstream\n\nupstreams:\n  - id: api_upstream\n    type: roundrobin\n    nodes:\n      \"api-1:8080\": 100\n      \"api-2:8080\": 100\n    checks:\n      active:\n        http_path: /health\n        interval: 10\n        healthy:\n          successes: 2\n        unhealthy:\n          http_failures: 3\n\nroutes:\n  - id: api_route\n    uri: /api/v1\n    methods: [GET, POST]\n    service_id: api_service\n    plugins:\n      limit-req:\n        rate: 100\n        burst: 200\n      key-auth:\n        header: apikey\n\n# Output: gal-config.yaml\nservices:\n- name: api_service\n  type: rest\n  protocol: http\n  upstream:\n    targets:\n    - {host: api-1, port: 8080, weight: 100}\n    - {host: api-2, port: 8080, weight: 100}\n    load_balancer: {algorithm: round_robin}\n    health_check:\n      active:\n        enabled: true\n        http_path: /health\n        interval: 10s\n        unhealthy_threshold: 3\n        healthy_threshold: 2\n  routes:\n  - path_prefix: /api/v1\n    methods: [GET, POST]\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n      burst: 200\n      key_type: ip_address\n    authentication:\n      enabled: true\n      type: api_key\n      api_key: {keys: [], key_name: apikey, in_location: header}\n</code></pre></p> <p>Coverage: apisix.py: 8% \u2192 33% (improved by 25%)</p> <p>\ud83d\udcd6 Detail-Dokumentation: docs/import/apisix.md</p>"},{"location":"v1.3.0-PLAN/#feature-4-traefik-import-yaml-parser","title":"\ud83d\udce6 Feature 4: Traefik Import (YAML Parser)","text":"<p>Status: \u2705 IMPLEMENTED | Effort: 1 Woche | Release: v1.3.0-alpha2 | Commit: TBD</p>"},{"location":"v1.3.0-PLAN/#implementation-summary_3","title":"\u2705 Implementation Summary","text":"<p>Provider Implementation: <code>gal/providers/traefik.py:662-978</code> (~312 lines, 10 helper methods)</p> <pre><code>class TraefikProvider(Provider):\n    def parse(self, provider_config: str) -&gt; Config:\n        \"\"\"Parse Traefik YAML configuration to GAL format.\n\n        Traefik has static config (entrypoints, providers) and\n        dynamic config (routers, services, middlewares). This parser\n        handles dynamic config files.\n        \"\"\"\n        traefik_config = yaml.safe_load(provider_config)\n\n        # Traefik structure: http.routers, http.services, http.middlewares\n        http_config = traefik_config.get(\"http\", {})\n\n        # Create default global config\n        global_config = GlobalConfig(host=\"0.0.0.0\", port=80, timeout=\"30s\")\n\n        return Config(\n            version=\"1.0\",\n            provider=\"traefik\",\n            global_config=global_config,\n            services=self._parse_services(traefik_config)\n        )\n</code></pre> <p>Helper Methods (10 methods):</p> <p>Service Parsing: - <code>_parse_services()</code>: Orchestrates service parsing from Traefik config - <code>_parse_service()</code>: Converts Traefik service \u2192 GAL Service (from loadBalancer.servers) - <code>_parse_health_check()</code>: Extracts passive health checks (Traefik OSS limitation)   - \u26a0\ufe0f Warning: Traefik OSS only supports passive health checks</p> <p>Router &amp; Route Parsing: - <code>_parse_router()</code>: Converts Traefik router to GAL route with middleware parsing - <code>_extract_path_from_rule()</code>: Extracts path from Traefik rule matchers   - Supports: <code>PathPrefix(\\</code>/api`)<code>,</code>Path(`/exact`)<code>,</code>Host(`...`) &amp;&amp; PathPrefix(`...`)`</p> <p>Middleware Parsing: - <code>_parse_rate_limit_middleware()</code>: Converts rateLimit middleware   - average (per second) \u2192 requests_per_second   - burst \u2192 burst - <code>_parse_basic_auth_middleware()</code>: Basic auth middleware   - \u26a0\ufe0f Warning: Users are hashed - configure manually in GAL - <code>_parse_headers_middleware()</code>: Request/response header manipulation   - customRequestHeaders \u2192 request_add   - customResponseHeaders \u2192 response_add</p> <p>CORS Extraction: - <code>_extract_cors_from_headers()</code>: Extracts CORS config from Access-Control-* response headers   - Parses: Allow-Origin, Allow-Methods, Allow-Headers, Allow-Credentials, Max-Age   - Removes CORS headers from response_add after extraction</p> <p>Utilities: - <code>get_import_warnings()</code>: Returns list of import warnings for user review</p> <p>CLI Command: <code>gal-cli.py:225-368</code> (already implemented) <pre><code>gal import-config --provider traefik \\\n                  --input traefik.yaml \\\n                  --output gal-config.yaml\n</code></pre></p> <p>Tests: <code>tests/test_import_traefik.py</code> - 24 tests, all passing \u2705</p> <p>Test Coverage: - TestTraefikImportBasic (3 tests): Simple service, service+router, multiple servers - TestTraefikImportRouters (3 tests): PathPrefix, exact Path, complex rules with Host - TestTraefikImportHealthChecks (1 test): Health check with OSS limitation warning - TestTraefikImportStickySession (2 tests): Sticky sessions with custom/default cookie name - TestTraefikImportRateLimiting (1 test): rateLimit middleware - TestTraefikImportAuthentication (1 test): basicAuth middleware with warning - TestTraefikImportHeaders (2 tests): Request headers, response headers - TestTraefikImportCORS (2 tests): CORS extraction from headers, wildcard origins - TestTraefikImportMultiService (1 test): 3 services with routers - TestTraefikImportMultipleMiddlewares (1 test): Multiple middlewares on one route - TestTraefikImportErrors (5 tests): Invalid YAML, empty config, no services, incomplete service/router - TestTraefikImportWarnings (1 test): Path manipulation middleware warning - TestTraefikImportCombined (1 test): Production config with all features</p> <p>Supported Features: - \u2705 Services &amp; Routers (http.services.loadBalancer.servers \u2192 GAL services) - \u2705 Load Balancer (servers with URL parsing: http://host:port) - \u2705 Health Checks (passive only - Traefik OSS limitation) - \u2705 Sticky Sessions (cookie-based with custom names) - \u2705 Load Balancing (round_robin default) - \u2705 Rate Limiting (rateLimit middleware: average, burst) - \u2705 Basic Authentication (basicAuth middleware with hashed users warning) - \u2705 Request Header Manipulation (customRequestHeaders) - \u2705 Response Header Manipulation (customResponseHeaders) - \u2705 CORS (extracted from Access-Control-* response headers) - \u2705 Multiple Services &amp; Routes - \u2705 Router Rule Parsing (PathPrefix, Path, Host combinations) - \u2705 Multiple Middlewares per Route</p> <p>Import Warnings: - \u26a0\ufe0f Traefik OSS only supports passive health checks - config may be simplified - \u26a0\ufe0f Basic auth users are hashed - configure manually in GAL - \u26a0\ufe0f Path manipulation middleware not imported (addPrefix, stripPrefix)</p> <p>Example Input/Output: <pre><code># Input: traefik.yaml\nhttp:\n  routers:\n    api-router:\n      rule: PathPrefix(`/api/v1`)\n      service: api-service\n      middlewares:\n        - rate-limit\n        - cors-headers\n\n  services:\n    api-service:\n      loadBalancer:\n        servers:\n          - url: http://api-1:8080\n          - url: http://api-2:8080\n        healthCheck:\n          path: /health\n          interval: 10s\n          timeout: 5s\n        sticky:\n          cookie:\n            name: lb\n\n  middlewares:\n    rate-limit:\n      rateLimit:\n        average: 100\n        burst: 200\n    cors-headers:\n      headers:\n        customResponseHeaders:\n          Access-Control-Allow-Origin: \"https://app.example.com\"\n          Access-Control-Allow-Methods: \"GET,POST,PUT,DELETE\"\n          Access-Control-Allow-Credentials: \"true\"\n          Access-Control-Max-Age: \"86400\"\n\n# Output: gal-config.yaml\nservices:\n- name: api-service\n  type: rest\n  protocol: http\n  upstream:\n    targets:\n    - {host: api-1, port: 8080}\n    - {host: api-2, port: 8080}\n    load_balancer:\n      algorithm: round_robin\n      sticky_sessions: true\n      cookie_name: lb\n    health_check:\n      passive:\n        enabled: true\n        max_failures: 3\n  routes:\n  - path_prefix: /api/v1\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n      burst: 200\n      key_type: ip_address\n    cors:\n      enabled: true\n      allowed_origins: [\"https://app.example.com\"]\n      allowed_methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n      allow_credentials: true\n      max_age: \"86400\"\n</code></pre></p> <p>Coverage: traefik.py: 6% \u2192 32% (improved by 26%)</p> <p>\ud83d\udcd6 Detail-Dokumentation: docs/import/traefik.md</p>"},{"location":"v1.3.0-PLAN/#feature-5-nginx-import-custom-parser","title":"\ud83d\udce6 Feature 5: Nginx Import (Custom Parser)","text":"<p>Status: \u2705 IMPLEMENTED | Effort: 2 Wochen | Release: v1.3.0-beta1 | Commit: TBD</p>"},{"location":"v1.3.0-PLAN/#implementation-summary_4","title":"\u2705 Implementation Summary","text":"<p>Provider Implementation: <code>gal/providers/nginx.py:829-1280</code> (~450 lines, 11 helper methods)</p> <pre><code>class NginxProvider(Provider):\n    def parse(self, provider_config: str) -&gt; Config:\n        \"\"\"Parse Nginx configuration to GAL format.\n\n        Parses nginx.conf format with custom regex-based parser.\n        Extracts upstreams, servers, locations, and directives.\n        \"\"\"\n        # Remove comments\n        config_text = self._remove_comments(provider_config)\n\n        # Extract http block\n        http_block = self._extract_http_block(config_text)\n\n        # Parse upstreams\n        upstreams = self._parse_upstreams(http_block)\n\n        # Parse rate limiting zones\n        rate_limit_zones = self._parse_rate_limit_zones(http_block)\n\n        # Parse servers with locations\n        services = self._parse_servers(http_block, upstreams, rate_limit_zones)\n\n        return Config(\n            version=\"1.0\",\n            provider=\"nginx\",\n            global_config=GlobalConfig(host=\"0.0.0.0\", port=80, timeout=\"60s\"),\n            services=services,\n        )\n</code></pre> <p>Helper Methods (11 methods):</p> <p>Parsing Infrastructure: - <code>_remove_comments()</code>: Removes # comments from nginx.conf - <code>_extract_http_block()</code>: Extracts http {} block using brace counting - <code>_extract_blocks()</code>: Generic block extraction with brace counting - <code>_extract_location_blocks()</code>: Extracts location blocks with paths</p> <p>Upstream &amp; Server Parsing: - <code>_parse_upstreams()</code>: Parses upstream blocks \u2192 targets, algorithms   - Algorithms: round_robin (default), least_conn, ip_hash   - Server weights and passive health check parameters (max_fails, fail_timeout) - <code>_parse_rate_limit_zones()</code>: Parses limit_req_zone directives   - Converts r/s, r/m, r/h, r/d to requests_per_second - <code>_parse_servers()</code>: Orchestrates server block parsing - <code>_parse_server_block()</code>: Parses single server with locations</p> <p>Route &amp; Feature Parsing: - <code>_parse_location_block()</code>: Parses location \u2192 Route with features   - Rate limiting: limit_req zone + burst   - Basic auth: auth_basic (htpasswd warning)   - Headers: proxy_set_header, add_header   - CORS: Extracted from Access-Control-* headers - <code>_parse_headers()</code>: Parses proxy_set_header and add_header directives - <code>_extract_cors_from_headers()</code>: Extracts CORS config from response headers</p> <p>CLI Command: <code>gal-cli.py:225-368</code> (already implemented) <pre><code>gal import-config --provider nginx \\\n                  --input nginx.conf \\\n                  --output gal-config.yaml\n</code></pre></p> <p>Tests: <code>tests/test_import_nginx.py</code> - 18 tests, all passing \u2705</p> <p>Test Coverage: - TestNginxImportBasic (3 tests): Simple upstream, multiple servers, comments - TestNginxImportLoadBalancing (3 tests): round_robin, least_conn, ip_hash - TestNginxImportHealthChecks (1 test): Passive health check parameters - TestNginxImportRateLimiting (2 tests): Per second, per minute conversion - TestNginxImportAuthentication (1 test): Basic auth with htpasswd warning - TestNginxImportHeaders (2 tests): Request headers (proxy_set_header), response headers (add_header) - TestNginxImportCORS (2 tests): CORS extraction from headers, wildcard origins - TestNginxImportMultipleLocations (1 test): Multiple location blocks in server - TestNginxImportErrors (2 tests): Empty config, no http block - TestNginxImportCombined (1 test): Production config with all features</p> <p>Supported Features: - \u2705 Upstream Blocks (servers with host:port) - \u2705 Load Balancing (round_robin, least_conn, ip_hash, weighted) - \u2705 Passive Health Checks (max_fails, fail_timeout) - \u2705 Rate Limiting (limit_req_zone with r/s, r/m, r/h, r/d conversion) - \u2705 Basic Authentication (auth_basic with htpasswd warning) - \u2705 Request Header Manipulation (proxy_set_header) - \u2705 Response Header Manipulation (add_header) - \u2705 CORS (extracted from Access-Control-* response headers) - \u2705 Multiple Location Blocks per Server - \u2705 Comment Removal - \u2705 Nested Block Parsing (brace counting)</p> <p>Import Warnings: - \u26a0\ufe0f Basic auth detected - htpasswd file not imported (configure manually)</p> <p>Example Input/Output: <pre><code># Input: nginx.conf\nevents {}\n\nhttp {\n    limit_req_zone $binary_remote_addr zone=api_rate:10m rate=100r/s;\n\n    upstream upstream_api {\n        least_conn;\n        server api-1:8080 weight=2 max_fails=3 fail_timeout=30s;\n        server api-2:8080;\n    }\n\n    server {\n        listen 80;\n\n        location /api/v1 {\n            limit_req zone=api_rate burst=200;\n\n            proxy_set_header X-Real-IP $remote_addr;\n            add_header Access-Control-Allow-Origin \"https://app.example.com\";\n            add_header Access-Control-Allow-Credentials \"true\";\n\n            proxy_pass http://upstream_api;\n        }\n    }\n}\n</code></pre></p> <pre><code># Output: gal-config.yaml\nservices:\n- name: api\n  type: rest\n  protocol: http\n  upstream:\n    targets:\n    - {host: api-1, port: 8080, weight: 2}\n    - {host: api-2, port: 8080}\n    load_balancer:\n      algorithm: least_conn\n    health_check:\n      passive:\n        enabled: true\n        max_failures: 3\n  routes:\n  - path_prefix: /api/v1\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n      burst: 200\n      key_type: ip_address\n    headers:\n      request_add:\n        X-Real-IP: $remote_addr\n    cors:\n      enabled: true\n      allowed_origins: [\"https://app.example.com\"]\n      allow_credentials: true\n</code></pre> <p>Coverage: nginx.py: 6% \u2192 38% (improved by 32%)</p> <p>\ud83d\udcd6 Detail-Dokumentation: docs/import/nginx.md</p>"},{"location":"v1.3.0-PLAN/#feature-6-haproxy-import-custom-parser","title":"\ud83d\udce6 Feature 6: HAProxy Import (Custom Parser)","text":"<p>Status: \ud83d\udd04 Pending | Effort: 2 Wochen | Release: v1.3.0-beta2</p>"},{"location":"v1.3.0-PLAN/#scope","title":"Scope","text":"<p>Parse HAProxy <code>haproxy.cfg</code> (non-YAML!) \u2192 GAL <code>Config</code></p> <p>Challenge: HAProxy config ist section-based format!</p> <p>L\u00f6sung: Custom Parser (simpler als Nginx - section-basiert)</p> <p>Mapping: - <code>frontend</code> \u2192 Routing ACLs \u2192 GAL <code>routes[]</code> - <code>backend</code> \u2192 Servers \u2192 GAL <code>services[]</code>, <code>upstream.targets[]</code> - <code>stick-table</code> \u2192 GAL <code>rate_limit</code> - <code>http-request set-header</code> \u2192 GAL <code>headers</code></p> <p>Implementation: <pre><code>from gal.parsers.haproxy_parser import HAProxyConfigParser\n\nclass HAProxyProvider(Provider):\n    def parse(self, provider_config: str) -&gt; Config:\n        parser = HAProxyConfigParser()\n        haproxy_config = parser.parse(provider_config)\n\n        return Config(\n            version=\"1.0\",\n            provider=\"haproxy\",\n            services=self._parse_haproxy_services(haproxy_config)\n        )\n</code></pre></p> <p>Custom Parser: <code>gal/parsers/haproxy_parser.py</code> <pre><code>class HAProxyConfigParser:\n    \"\"\"Parse haproxy.cfg section-based format.\"\"\"\n\n    def parse(self, config_text: str) -&gt; dict:\n        sections = {}\n        for line in config_text.split('\\n'):\n            # Parse global, defaults, frontend, backend sections\n            pass\n        return sections\n</code></pre></p> <p>Tests: 55+ tests f\u00fcr haproxy.cfg Format, Frontends, Backends, ACLs</p> <p>\ud83d\udcd6 Detail-Dokumentation: docs/import/haproxy.md</p>"},{"location":"v1.3.0-PLAN/#feature-7-compatibility-checker-comparison","title":"\u2705 Feature 7: Compatibility Checker &amp; Comparison","text":"<p>Status: \ud83d\udd04 Pending | Effort: 2 Wochen | Release: v1.3.0-rc1 | Dependencies: Features 1-6</p>"},{"location":"v1.3.0-PLAN/#motivation","title":"Motivation","text":"<p>Nach Import muss der Nutzer wissen: - Funktioniert die GAL-Config auf dem Ziel-Provider? - Welche Features werden unterst\u00fctzt? - Welcher Provider ist am besten geeignet?</p>"},{"location":"v1.3.0-PLAN/#cli-commands","title":"CLI Commands","text":"<p>Check Compatibility: <pre><code>gal validate --config gal-config.yaml --target-provider haproxy\n\n# Output:\n# \u2713 Config is compatible with HAProxy\n# \u26a0 Warnings:\n#   - JWT authentication requires Lua scripting\n#   - Active health checks fully supported\n#\n# Compatibility: 95% (19/20 features supported)\n</code></pre></p> <p>Compare Providers: <pre><code>gal compare --config gal-config.yaml --providers envoy,kong,nginx,haproxy\n\n# Output (table):\n# Feature           | Envoy | Kong | Nginx | HAProxy\n# ------------------|-------|------|-------|--------\n# Rate Limiting     | \u2705    | \u2705   | \u2705    | \u2705\n# JWT Auth          | \u2705    | \u2705   | \u26a0\ufe0f    | \u26a0\ufe0f\n# Active HC         | \u2705    | \u2705   | \u274c    | \u2705\n# Load Balancing    | \u2705    | \u2705   | \u2705    | \u2705\n#\n# Recommendation: Use Envoy or Kong for full compatibility\n</code></pre></p>"},{"location":"v1.3.0-PLAN/#implementation","title":"Implementation","text":"<p>File: <code>gal/compatibility.py</code></p> <pre><code>class CompatibilityChecker:\n    \"\"\"Check config compatibility with providers.\"\"\"\n\n    def check_provider(self, config: Config, target_provider: str) -&gt; CompatibilityReport:\n        \"\"\"Check if config works on target provider.\"\"\"\n        provider = get_provider(target_provider)\n\n        report = CompatibilityReport(\n            provider=target_provider,\n            compatible=True,\n            features_supported=[],\n            features_unsupported=[],\n            warnings=[]\n        )\n\n        # Check each feature\n        for service in config.services:\n            self._check_service_features(service, provider, report)\n\n        return report\n\n    def compare_providers(self, config: Config, providers: List[str]) -&gt; Dict[str, CompatibilityReport]:\n        \"\"\"Compare config compatibility across providers.\"\"\"\n        results = {}\n        for provider_name in providers:\n            results[provider_name] = self.check_provider(config, provider_name)\n        return results\n</code></pre> <p>Tests: 40+ tests f\u00fcr Compatibility Checking, Provider Comparison</p> <p>\ud83d\udcd6 Detail-Dokumentation: docs/import/compatibility.md</p>"},{"location":"v1.3.0-PLAN/#feature-8-migration-assistant-interactive-cli","title":"\ud83d\udd00 Feature 8: Migration Assistant (Interactive CLI)","text":"<p>Status: \ud83d\udd04 Pending | Effort: 2 Wochen | Release: v1.3.0 Final | Dependencies: Features 1-7</p>"},{"location":"v1.3.0-PLAN/#motivation_1","title":"Motivation","text":"<p>Migration sollte gef\u00fchrt, einfach und sicher sein: - Interaktive Prompts - Automatische Validierung - Migration Report (Markdown) - Recommendations &amp; Next Steps</p>"},{"location":"v1.3.0-PLAN/#interactive-workflow","title":"Interactive Workflow","text":"<pre><code>gal migrate\n\n# Interactive prompts:\n? Source Provider: nginx\n? Source Config: /etc/nginx/nginx.conf\n? Target Provider: haproxy\n? Output Directory: ./migration/\n\n[1/5] Reading Nginx config...\n[2/5] Parsing and analyzing...\n[3/5] Converting to GAL format...\n[4/5] Validating compatibility with HAProxy...\n[5/5] Generating HAProxy config...\n\n\u2713 Migration complete!\n\nFiles created:\n  - ./migration/gal-config.yaml (GAL format)\n  - ./migration/haproxy.cfg (HAProxy config)\n  - ./migration/migration-report.md (Migration report)\n\nCompatibility: 95% (19/20 features)\nWarnings: 2\n  - JWT auth requires Lua (see docs)\n  - Passive health checks use fall/rise thresholds\n\nNext steps:\n  1. Review migration-report.md\n  2. Test haproxy.cfg in staging\n  3. Deploy to production\n</code></pre>"},{"location":"v1.3.0-PLAN/#migration-report-format","title":"Migration Report Format","text":"<p>File: <code>migration/migration-report.md</code></p> <pre><code># Migration Report: Nginx \u2192 HAProxy\n\n**Date:** 2026-04-15\n**Source:** /etc/nginx/nginx.conf\n**Target:** HAProxy 2.8\n\n## Summary\n\n- **Compatibility:** 95% (19/20 features)\n- **Services Migrated:** 3\n- **Routes Migrated:** 12\n- **Warnings:** 2\n\n## Features Migrated\n\n\u2705 **Load Balancing**\n- Algorithm: Round Robin \u2192 roundrobin\n- Targets: 6 backends\n\n\u2705 **Rate Limiting**\n- IP-based: 100 req/s\n- Converted to stick-table\n\n\u26a0\ufe0f **Authentication**\n- Basic Auth: \u2705 Supported\n- JWT Auth: \u26a0\ufe0f Requires Lua scripting\n\n## Warnings &amp; Recommendations\n\n1. **JWT Authentication**\n   - Nginx uses OpenResty/Lua\n   - HAProxy requires Lua scripting or external auth\n   - **Recommendation:** Use Kong or Envoy for native JWT\n\n2. **Passive Health Checks**\n   - Nginx: max_fails, fail_timeout\n   - HAProxy: fall, rise thresholds\n   - **Action:** Review and adjust thresholds\n\n## Testing Checklist\n\n- [ ] Test in staging environment\n- [ ] Verify all 12 routes\n- [ ] Check load balancing distribution\n- [ ] Validate rate limiting behavior\n- [ ] Monitor backend health\n- [ ] Performance comparison\n\n## Next Steps\n\n1. \u2705 Review this report\n2. \u23f3 Test in staging\n3. \u23f3 Adjust JWT authentication\n4. \u23f3 Deploy to production\n5. \u23f3 Monitor and validate\n</code></pre> <p>Tests: 30+ tests f\u00fcr Interactive Workflow, Report Generation</p> <p>\ud83d\udcd6 Detail-Dokumentation: docs/import/migration.md</p>"},{"location":"v1.3.0-PLAN/#timeline-12-wochen","title":"\ud83d\uddd3\ufe0f Timeline (12 Wochen)","text":""},{"location":"v1.3.0-PLAN/#phase-1-yaml-parsers-weeks-1-4-v130-alpha1-alpha2","title":"Phase 1: YAML Parsers (Weeks 1-4) \u2192 v1.3.0-alpha1, alpha2","text":"<ul> <li>Week 1: Feature 1 - Envoy Import + Shared Infrastructure</li> <li>Week 2: Feature 2 - Kong Import \u2192 Release v1.3.0-alpha1</li> <li>Week 3: Feature 3 - APISIX Import</li> <li>Week 4: Feature 4 - Traefik Import \u2192 Release v1.3.0-alpha2</li> </ul>"},{"location":"v1.3.0-PLAN/#phase-2-custom-parsers-weeks-5-8-v130-beta1-beta2","title":"Phase 2: Custom Parsers (Weeks 5-8) \u2192 v1.3.0-beta1, beta2","text":"<ul> <li>Weeks 5-6: Feature 5 - Nginx Import (Custom Parser) \u2192 Release v1.3.0-beta1</li> <li>Weeks 7-8: Feature 6 - HAProxy Import (Custom Parser) \u2192 Release v1.3.0-beta2</li> </ul>"},{"location":"v1.3.0-PLAN/#phase-3-compatibility-migration-weeks-9-12-v130-rc1-final","title":"Phase 3: Compatibility &amp; Migration (Weeks 9-12) \u2192 v1.3.0-rc1, Final","text":"<ul> <li>Weeks 9-10: Feature 7 - Compatibility Checker \u2192 Release v1.3.0-rc1</li> <li>Weeks 11-12: Feature 8 - Migration Assistant \u2192 Release v1.3.0 Final</li> </ul>"},{"location":"v1.3.0-PLAN/#use-cases","title":"\ud83c\udfaf Use Cases","text":""},{"location":"v1.3.0-PLAN/#use-case-1-nginx-haproxy-migration","title":"Use Case 1: Nginx \u2192 HAProxy Migration","text":"<p>Scenario: E-Commerce mit Nginx m\u00f6chte zu HAProxy wechseln.</p> <pre><code># 1. Import Nginx config\ngal import --provider nginx --input /etc/nginx/nginx.conf --output gal-config.yaml\n\n# 2. Check compatibility\ngal validate --config gal-config.yaml --target-provider haproxy\n\n# 3. Generate HAProxy config\ngal generate --config gal-config.yaml --provider haproxy --output haproxy.cfg\n</code></pre>"},{"location":"v1.3.0-PLAN/#use-case-2-kong-envoy-migration","title":"Use Case 2: Kong \u2192 Envoy Migration","text":"<p>Scenario: Startup mit Kong m\u00f6chte zu Envoy f\u00fcr Service Mesh.</p> <pre><code># Interactive migration\ngal migrate\n# &gt; Source: kong\n# &gt; Target: envoy\n# &gt; Creates migration report\n</code></pre>"},{"location":"v1.3.0-PLAN/#use-case-3-multi-provider-deployment","title":"Use Case 3: Multi-Provider Deployment","text":"<p>Scenario: Gro\u00dfunternehmen will gleiche Config auf verschiedenen Providern.</p> <pre><code># 1. Import production HAProxy config\ngal import --provider haproxy --input haproxy-prod.cfg --output gal-config.yaml\n\n# 2. Generate for all providers\ngal generate-all --config gal-config.yaml\n\n# Result: envoy.yaml, kong.yaml, apisix.json, traefik.yaml, nginx.conf, haproxy.cfg\n</code></pre>"},{"location":"v1.3.0-PLAN/#success-metrics","title":"\ud83d\udcca Success Metrics","text":""},{"location":"v1.3.0-PLAN/#deliverables","title":"Deliverables","text":"<p>Code: - \u2705 Provider Interface Extension (parse method) - \u2705 6 Provider Parser (envoy, kong, apisix, traefik, nginx, haproxy) - \u2705 2 Custom Parsers (nginx_parser.py, haproxy_parser.py) - \u2705 CLI Commands: <code>import</code>, <code>validate --target-provider</code>, <code>compare</code>, <code>migrate</code> - \u2705 Compatibility Checker (compatibility.py) - \u2705 Tests: 350+ tests (50+50+45+40+60+55+40+30)</p> <p>Documentation: - \u2705 docs/guides/IMPORT_MIGRATION.md (500+ lines, German) - \u2705 Migration Guides pro Provider (6 x 100+ lines) - \u2705 Feature Mapping Matrix - \u2705 Troubleshooting Guide</p> <p>Examples: - \u2705 examples/import/ (6 Provider-Configs) - \u2705 examples/migration/ (3 Migration Workflows)</p>"},{"location":"v1.3.0-PLAN/#coverage-targets","title":"Coverage Targets","text":"<ul> <li>Parser Coverage: 95%+ f\u00fcr Standard-Konfigurationen</li> <li>Feature Mapping: 90%+ der v1.1.0/v1.2.0 Features</li> <li>Test Coverage: 350+ Tests f\u00fcr alle Parser</li> </ul>"},{"location":"v1.3.0-PLAN/#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ol> <li>Review &amp; Approval: Diskussion \u00fcber Feature-Aufteilung</li> <li>Start Phase 1: Envoy + Kong Import (Weeks 1-2)</li> <li>Alpha Release: v1.3.0-alpha1 mit Envoy + Kong</li> <li>Community Feedback: Beta Testing mit Real-World Configs</li> </ol> <p>Target Release: Q2 2026 Current Status: Planning Phase Next Milestone: Start Feature 1 (Envoy Import)</p>"},{"location":"v1.4.0-PLAN/","title":"v1.4.0 Implementierungsplan","text":"<p>Status: \ud83d\udd04 Konzept Zeitplan: Q3 2026 (gesch\u00e4tzt) Fokus: Advanced Traffic Management &amp; Multi-Cloud + gRPC Transformations</p>"},{"location":"v1.4.0-PLAN/#mission","title":"Mission","text":"<p>\"Bringe gRPC zu GAL mit nahtlosen Protobuf-Transformationen \u00fcber alle Provider hinweg.\"</p> <p>Erm\u00f6gliche Benutzern die Transformation von gRPC Request/Response-Nachrichten mithilfe von Protobuf-Descriptors und mache gRPC-Services genauso einfach verwaltbar wie REST-APIs mit GALs provider-agnostischer Konfiguration.</p>"},{"location":"v1.4.0-PLAN/#feature-ubersicht","title":"Feature-\u00dcbersicht","text":"Feature Status Aufwand Priorit\u00e4t 1. gRPC Transformations \ud83d\udd04 Ausstehend 3-4 Wochen \ud83d\udd34 Hoch 2. Cloud Provider Support (AWS) \ud83d\udd04 Ausstehend 4 Wochen \ud83d\udfe1 Mittel 3. Cloud Provider Support (Azure) \ud83d\udd04 Ausstehend 3 Wochen \ud83d\udfe1 Mittel 4. Cloud Provider Support (GCP) \ud83d\udd04 Ausstehend 3 Wochen \ud83d\udfe1 Mittel 5. A/B Testing &amp; Traffic Splitting \ud83d\udd04 Ausstehend 2 Wochen \ud83d\udfe1 Mittel 6. Request Mirroring/Shadowing \ud83d\udd04 Ausstehend 2 Wochen \ud83d\udfe2 Niedrig 7. Advanced Routing \ud83d\udd04 Ausstehend 2 Wochen \ud83d\udfe2 Niedrig 8. GraphQL Support \ud83d\udd04 Ausstehend 3 Wochen \ud83d\udfe2 Niedrig <p>Gesamtaufwand: ~22-24 Wochen (5-6 Monate) Fortschritt: 0/8 Features (0%)</p>"},{"location":"v1.4.0-PLAN/#feature-1-grpc-transformations-detailliert","title":"Feature 1: gRPC Transformations (DETAILLIERT)","text":"<p>Status: \ud83d\udd04 Ausstehend Priorit\u00e4t: \ud83d\udd34 Hoch Aufwand: 3-4 Wochen</p>"},{"location":"v1.4.0-PLAN/#motivation","title":"Motivation","text":"<ul> <li>Problem: gRPC-Services ben\u00f6tigen Body-Transformationen (Trace-IDs hinzuf\u00fcgen, Secrets entfernen, Felder umbenennen) genau wie REST-APIs</li> <li>Herausforderung: Jeder Provider hat unterschiedliche Mechanismen f\u00fcr Protobuf-Handling</li> <li>L\u00f6sung: GAL bietet eine einheitliche Konfiguration f\u00fcr gRPC-Transformationen mit Proto-Descriptor-Management</li> </ul>"},{"location":"v1.4.0-PLAN/#konfigurationsmodell","title":"Konfigurationsmodell","text":"<pre><code># gal/config.py\n\n@dataclass\nclass ProtoDescriptor:\n    \"\"\"Protobuf-Descriptor-Konfiguration.\"\"\"\n    name: str                    # Descriptor-Name (z.B. \"user_service\")\n    source: str                  # \"file\", \"inline\", \"url\"\n    path: str = \"\"               # Pfad zur .proto oder .desc Datei\n    content: str = \"\"            # Inline Proto-Definition\n    url: str = \"\"                # URL zum Download der Proto-Datei\n\n@dataclass\nclass GrpcTransformation:\n    \"\"\"gRPC Transformation Konfiguration.\"\"\"\n    enabled: bool = True\n    proto_descriptor: str = \"\"   # Referenz zum ProtoDescriptor-Namen\n    package: str = \"\"            # Protobuf-Package (z.B. \"user.v1\")\n    service: str = \"\"            # Service-Name (z.B. \"UserService\")\n    request_type: str = \"\"       # Message-Type (z.B. \"CreateUserRequest\")\n    response_type: str = \"\"      # Message-Type (z.B. \"CreateUserResponse\")\n\n    # Transformationsregeln (wiederverwenden der bestehenden Body Transformation)\n    request_transform: Optional[RequestBodyTransformation] = None\n    response_transform: Optional[ResponseBodyTransformation] = None\n\n@dataclass\nclass Route:\n    # ... bestehende Felder ...\n    grpc_transformation: Optional[GrpcTransformation] = None\n\n@dataclass\nclass Config:\n    # ... bestehende Felder ...\n    proto_descriptors: List[ProtoDescriptor] = field(default_factory=list)\n</code></pre>"},{"location":"v1.4.0-PLAN/#yaml-konfigurationsbeispiel","title":"YAML-Konfigurationsbeispiel","text":"<pre><code># Proto Descriptors (global)\nproto_descriptors:\n  - name: user_service_proto\n    source: file\n    path: /etc/gal/protos/user.desc\n\n  - name: order_service_proto\n    source: inline\n    content: |\n      syntax = \"proto3\";\n      package order.v1;\n\n      service OrderService {\n        rpc CreateOrder(CreateOrderRequest) returns (CreateOrderResponse);\n      }\n\n      message CreateOrderRequest {\n        string user_id = 1;\n        repeated string product_ids = 2;\n      }\n\n# Services\nservices:\n  - name: user_grpc_service\n    protocol: grpc\n    upstream:\n      host: user-grpc-backend\n      port: 50051\n\n    routes:\n      - path_prefix: /user.v1.UserService/CreateUser\n        grpc_transformation:\n          enabled: true\n          proto_descriptor: user_service_proto\n          package: user.v1\n          service: UserService\n          request_type: CreateUserRequest\n          response_type: CreateUserResponse\n\n          request_transform:\n            add_fields:\n              trace_id: \"{{uuid}}\"\n              timestamp: \"{{timestamp}}\"\n              gateway_version: \"GAL-v1.4.0\"\n            remove_fields:\n              - internal_secret\n              - debug_info\n            rename_fields:\n              user_id: userId\n              email_address: email\n\n          response_transform:\n            filter_fields:\n              - password_hash\n              - internal_id\n            add_fields:\n              server_time: \"{{timestamp}}\"\n              server_id: \"gateway-01\"\n</code></pre>"},{"location":"v1.4.0-PLAN/#provider-implementierungen","title":"Provider-Implementierungen","text":""},{"location":"v1.4.0-PLAN/#envoy-lua-filter","title":"Envoy (Lua Filter)","text":"<p>Datei: <code>gal/providers/envoy.py</code></p> <pre><code>def _generate_grpc_transformation_envoy(self, route):\n    \"\"\"Generiere Envoy Lua Filter f\u00fcr gRPC Transformation.\"\"\"\n    if not route.grpc_transformation or not route.grpc_transformation.enabled:\n        return None\n\n    grpc = route.grpc_transformation\n    proto_desc = self._get_proto_descriptor(grpc.proto_descriptor)\n\n    lua_code = f'''\nfunction envoy_on_request(request_handle)\n    local pb = require(\"pb\")\n\n    -- Proto Descriptor laden (einmal pro Worker)\n    if not _proto_loaded then\n        pb.loadfile(\"{proto_desc.path}\")\n        _proto_loaded = true\n    end\n\n    -- gRPC Message Body abrufen\n    local body = request_handle:body()\n    if not body then\n        return\n    end\n\n    -- Protobuf Message dekodieren\n    local msg = pb.decode(\"{grpc.request_type}\", body:getBytes(0, body:length()))\n\n    -- Transformationen anwenden\n    {self._generate_grpc_request_transform_lua(grpc.request_transform)}\n\n    -- Zur\u00fcck zu Protobuf enkodieren\n    local new_body = pb.encode(\"{grpc.request_type}\", msg)\n    body:setBytes(new_body)\nend\n\nfunction envoy_on_response(response_handle)\n    local pb = require(\"pb\")\n\n    local body = response_handle:body()\n    if not body then\n        return\n    end\n\n    local msg = pb.decode(\"{grpc.response_type}\", body:getBytes(0, body:length()))\n\n    -- Response-Transformationen anwenden\n    {self._generate_grpc_response_transform_lua(grpc.response_transform)}\n\n    local new_body = pb.encode(\"{grpc.response_type}\", msg)\n    body:setBytes(new_body)\nend\n'''\n\n    return {\n        \"name\": \"envoy.filters.http.lua\",\n        \"typed_config\": {\n            \"@type\": \"type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua\",\n            \"inline_code\": lua_code\n        }\n    }\n</code></pre>"},{"location":"v1.4.0-PLAN/#nginx-openresty-lua","title":"Nginx (OpenResty Lua)","text":"<p>Datei: <code>gal/providers/nginx.py</code></p> <pre><code>def _generate_grpc_transformation_nginx(self, route):\n    \"\"\"Generiere Nginx/OpenResty Lua-Bl\u00f6cke f\u00fcr gRPC Transformation.\"\"\"\n    if not route.grpc_transformation or not route.grpc_transformation.enabled:\n        return []\n\n    grpc = route.grpc_transformation\n    proto_desc = self._get_proto_descriptor(grpc.proto_descriptor)\n\n    output = []\n    output.append(\"# gRPC Transformation (OpenResty)\")\n    output.append(\"\")\n\n    # Request-Transformation\n    output.append(\"access_by_lua_block {\")\n    output.append(\"    local pb = require('pb')\")\n    output.append(f\"    pb.loadfile('{proto_desc.path}')\")\n    output.append(\"\")\n    output.append(\"    -- gRPC Message Body lesen\")\n    output.append(\"    ngx.req.read_body()\")\n    output.append(\"    local body = ngx.req.get_body_data()\")\n    output.append(\"\")\n    output.append(f\"    -- Protobuf Message dekodieren\")\n    output.append(f\"    local msg = pb.decode('{grpc.request_type}', body)\")\n    output.append(\"\")\n\n    # Felder hinzuf\u00fcgen\n    if grpc.request_transform and grpc.request_transform.add_fields:\n        output.append(\"    -- Felder hinzuf\u00fcgen\")\n        for key, value in grpc.request_transform.add_fields.items():\n            if value == \"{{uuid}}\":\n                output.append(f\"    msg['{key}'] = ngx.var.request_id\")\n            elif value in [\"{{timestamp}}\", \"{{now}}\"]:\n                output.append(f\"    msg['{key}'] = ngx.utctime()\")\n            else:\n                output.append(f\"    msg['{key}'] = '{value}'\")\n        output.append(\"\")\n\n    # Felder entfernen\n    if grpc.request_transform and grpc.request_transform.remove_fields:\n        output.append(\"    -- Felder entfernen\")\n        for field in grpc.request_transform.remove_fields:\n            output.append(f\"    msg['{field}'] = nil\")\n        output.append(\"\")\n\n    # Felder umbenennen\n    if grpc.request_transform and grpc.request_transform.rename_fields:\n        output.append(\"    -- Felder umbenennen\")\n        for old_name, new_name in grpc.request_transform.rename_fields.items():\n            output.append(f\"    msg['{new_name}'] = msg['{old_name}']\")\n            output.append(f\"    msg['{old_name}'] = nil\")\n        output.append(\"\")\n\n    output.append(f\"    -- Zur\u00fcck zu Protobuf enkodieren\")\n    output.append(f\"    local new_body = pb.encode('{grpc.request_type}', msg)\")\n    output.append(\"    ngx.req.set_body_data(new_body)\")\n    output.append(\"}\")\n    output.append(\"\")\n\n    # Response-Transformation\n    if grpc.response_transform:\n        output.append(\"body_filter_by_lua_block {\")\n        output.append(\"    local pb = require('pb')\")\n        output.append(\"\")\n        output.append(\"    local chunk = ngx.arg[1]\")\n        output.append(\"    local eof = ngx.arg[2]\")\n        output.append(\"\")\n        output.append(\"    if eof then\")\n        output.append(f\"        local msg = pb.decode('{grpc.response_type}', chunk)\")\n        output.append(\"\")\n\n        # Felder filtern\n        if grpc.response_transform.filter_fields:\n            output.append(\"        -- Sensible Felder filtern\")\n            for field in grpc.response_transform.filter_fields:\n                output.append(f\"        msg['{field}'] = nil\")\n            output.append(\"\")\n\n        # Felder hinzuf\u00fcgen\n        if grpc.response_transform.add_fields:\n            output.append(\"        -- Metadaten-Felder hinzuf\u00fcgen\")\n            for key, value in grpc.response_transform.add_fields.items():\n                if value == \"{{timestamp}}\":\n                    output.append(f\"        msg['{key}'] = ngx.utctime()\")\n                else:\n                    output.append(f\"        msg['{key}'] = '{value}'\")\n            output.append(\"\")\n\n        output.append(f\"        ngx.arg[1] = pb.encode('{grpc.response_type}', msg)\")\n        output.append(\"    end\")\n        output.append(\"}\")\n\n    return \"\\n\".join(output)\n</code></pre>"},{"location":"v1.4.0-PLAN/#kong-custom-plugin","title":"Kong (Custom Plugin)","text":"<p>Datei: <code>gal/providers/kong.py</code></p> <pre><code>def _generate_grpc_transformation_kong(self, route):\n    \"\"\"Generiere Kong Plugin Config f\u00fcr gRPC Transformation.\"\"\"\n    if not route.grpc_transformation or not route.grpc_transformation.enabled:\n        return None\n\n    grpc = route.grpc_transformation\n\n    logger.warning(\n        \"gRPC Transformation in Kong erfordert ein Custom Plugin oder grpc-gateway. \"\n        \"Optionen:\\n\"\n        \"  1. Nutze Kongs grpc-gateway Plugin: https://docs.konghq.com/hub/kong-inc/grpc-gateway/\\n\"\n        \"  2. Entwickle ein Custom Kong Plugin mit lua-protobuf\\n\"\n        \"  3. Deploye einen externen Transformation Service mit Kongs request-transformer-advanced\"\n    )\n\n    # Basis grpc-gateway Config\n    return {\n        \"name\": \"grpc-gateway\",\n        \"config\": {\n            \"proto\": grpc.proto_descriptor,\n            \"service\": grpc.service,\n        }\n    }\n</code></pre>"},{"location":"v1.4.0-PLAN/#apisix-grpc-transcode-plugin","title":"APISIX (grpc-transcode Plugin)","text":"<p>Datei: <code>gal/providers/apisix.py</code></p> <pre><code>def _generate_grpc_transformation_apisix(self, route):\n    \"\"\"Generiere APISIX grpc-transcode Plugin Config.\"\"\"\n    if not route.grpc_transformation or not route.grpc_transformation.enabled:\n        return {}\n\n    grpc = route.grpc_transformation\n    proto_desc = self._get_proto_descriptor(grpc.proto_descriptor)\n\n    # APISIX grpc-transcode f\u00fcr gRPC \u2194 REST\n    # F\u00fcr reine gRPC Transformation: serverless-pre-function verwenden\n    return {\n        \"serverless-pre-function\": {\n            \"phase\": \"rewrite\",\n            \"functions\": [\n                f\"\"\"\n                return function(conf, ctx)\n                    local pb = require(\"pb\")\n                    local core = require(\"apisix.core\")\n\n                    -- Proto Descriptor laden\n                    pb.loadfile(\"{proto_desc.path}\")\n\n                    -- Request Body abrufen\n                    local body = core.request.get_body()\n                    local msg = pb.decode(\"{grpc.request_type}\", body)\n\n                    -- Transformationen anwenden\n                    {self._generate_grpc_transform_lua(grpc.request_transform)}\n\n                    -- Zur\u00fcck enkodieren\n                    local new_body = pb.encode(\"{grpc.request_type}\", msg)\n                    ngx.req.set_body_data(new_body)\n                end\n                \"\"\"\n            ]\n        }\n    }\n</code></pre>"},{"location":"v1.4.0-PLAN/#haproxy-lua-script","title":"HAProxy (Lua Script)","text":"<p>Datei: <code>gal/providers/haproxy.py</code></p> <pre><code>def _generate_grpc_transformation_haproxy(self, route):\n    \"\"\"Generiere HAProxy Lua Script Referenz f\u00fcr gRPC Transformation.\"\"\"\n    if not route.grpc_transformation or not route.grpc_transformation.enabled:\n        return []\n\n    grpc = route.grpc_transformation\n\n    logger.warning(\n        \"gRPC Transformation in HAProxy erfordert externe Lua-Scripts. \"\n        \"Schritte:\\n\"\n        \"  1. lua-protobuf installieren: luarocks install lua-protobuf\\n\"\n        \"  2. Lua-Script erstellen: /etc/haproxy/lua/grpc_transform.lua\\n\"\n        \"  3. In global section laden: lua-load /etc/haproxy/lua/grpc_transform.lua\\n\"\n        \"  4. Im Backend referenzieren: http-request lua.grpc_transform\"\n    )\n\n    output = []\n    output.append(f\"    # gRPC Transformation (erfordert Lua-Script)\")\n    output.append(f\"    http-request lua.grpc_transform_{grpc.service}\")\n    output.append(f\"    http-response lua.grpc_transform_response_{grpc.service}\")\n\n    return output\n</code></pre>"},{"location":"v1.4.0-PLAN/#traefik-middleware-warning","title":"Traefik (Middleware Warning)","text":"<p>Datei: <code>gal/providers/traefik.py</code></p> <pre><code>def _generate_grpc_transformation_traefik(self, route):\n    \"\"\"Traefik gRPC Transformation Warnung.\"\"\"\n    if not route.grpc_transformation or not route.grpc_transformation.enabled:\n        return None\n\n    logger.warning(\n        \"gRPC Transformation wird von Traefik nicht nativ unterst\u00fctzt. \"\n        \"Alternativen:\\n\"\n        \"  1. ForwardAuth Middleware mit externem gRPC Transformation Service\\n\"\n        \"  2. Custom Traefik Plugin (Go-Entwicklung erforderlich)\\n\"\n        \"  3. Alternativen Provider verwenden: Envoy, Kong, APISIX, Nginx, HAProxy\"\n    )\n\n    return None\n</code></pre>"},{"location":"v1.4.0-PLAN/#proto-descriptor-management","title":"Proto Descriptor Management","text":"<p>Datei: <code>gal/proto_manager.py</code> (NEU)</p> <pre><code>import os\nimport subprocess\nfrom typing import Dict, Optional\nfrom gal.config import ProtoDescriptor\n\nclass ProtoManager:\n    \"\"\"Verwaltet Protobuf-Descriptors f\u00fcr gRPC-Transformationen.\"\"\"\n\n    def __init__(self, proto_dir: str = \"/etc/gal/protos\"):\n        self.proto_dir = proto_dir\n        self.descriptors: Dict[str, ProtoDescriptor] = {}\n        os.makedirs(proto_dir, exist_ok=True)\n\n    def register_descriptor(self, descriptor: ProtoDescriptor):\n        \"\"\"Registriere einen Proto-Descriptor.\"\"\"\n        self.descriptors[descriptor.name] = descriptor\n\n        if descriptor.source == \"file\":\n            # Datei existiert bereits, validieren\n            if not os.path.exists(descriptor.path):\n                raise FileNotFoundError(f\"Proto Descriptor nicht gefunden: {descriptor.path}\")\n\n        elif descriptor.source == \"inline\":\n            # Inline Proto-Content in Datei schreiben\n            proto_file = os.path.join(self.proto_dir, f\"{descriptor.name}.proto\")\n            with open(proto_file, 'w') as f:\n                f.write(descriptor.content)\n\n            # Zu .desc kompilieren\n            descriptor.path = self._compile_proto(proto_file)\n\n        elif descriptor.source == \"url\":\n            # Proto-Datei von URL herunterladen\n            proto_file = self._download_proto(descriptor.url, descriptor.name)\n            descriptor.path = self._compile_proto(proto_file)\n\n    def _compile_proto(self, proto_file: str) -&gt; str:\n        \"\"\"Kompiliere .proto zu .desc mit protoc.\"\"\"\n        desc_file = proto_file.replace(\".proto\", \".desc\")\n\n        result = subprocess.run([\n            \"protoc\",\n            f\"--descriptor_set_out={desc_file}\",\n            f\"--proto_path={self.proto_dir}\",\n            proto_file\n        ], capture_output=True, text=True)\n\n        if result.returncode != 0:\n            raise RuntimeError(f\"protoc Kompilierung fehlgeschlagen: {result.stderr}\")\n\n        return desc_file\n\n    def _download_proto(self, url: str, name: str) -&gt; str:\n        \"\"\"Proto-Datei von URL herunterladen.\"\"\"\n        import requests\n\n        proto_file = os.path.join(self.proto_dir, f\"{name}.proto\")\n        response = requests.get(url)\n        response.raise_for_status()\n\n        with open(proto_file, 'wb') as f:\n            f.write(response.content)\n\n        return proto_file\n\n    def get_descriptor(self, name: str) -&gt; Optional[ProtoDescriptor]:\n        \"\"\"Registrierten Proto-Descriptor nach Namen abrufen.\"\"\"\n        return self.descriptors.get(name)\n</code></pre>"},{"location":"v1.4.0-PLAN/#test-strategie","title":"Test-Strategie","text":"<p>Datei: <code>tests/test_grpc_transformation.py</code> (15+ Tests)</p> <pre><code># Test-Kategorien:\n# 1. Config-Model-Tests (GrpcTransformation, ProtoDescriptor)\n# 2. YAML-Parsing-Tests\n# 3. Proto-Descriptor-Management-Tests\n# 4. Provider-spezifische Tests (Envoy, Kong, APISIX, Nginx, HAProxy, Traefik)\n# 5. Integrationstests mit echten Proto-Dateien\n</code></pre>"},{"location":"v1.4.0-PLAN/#dokumentation","title":"Dokumentation","text":"<p>Datei: <code>docs/guides/GRPC_TRANSFORMATIONS.md</code> (1000+ Zeilen, Deutsch)</p> <p>Abschnitte: - \u00dcbersicht &amp; Anwendungsf\u00e4lle - Schnellstart (3 Beispiele) - Proto Descriptor Management - Konfigurationsoptionen - Provider-Implementierungen (alle 6) - Deployment-Strategien (Volume Mounts, ConfigMaps) - Best Practices - Troubleshooting</p> <p>Datei: <code>examples/grpc-transformation-example.yaml</code> (10+ Szenarien)</p>"},{"location":"v1.4.0-PLAN/#meilensteine","title":"Meilensteine","text":"<p>Woche 1-2: Config Model + Proto Manager - GrpcTransformation, ProtoDescriptor Models - ProtoManager Implementierung - YAML-Parsing - 5+ Config-Tests</p> <p>Woche 2-3: Provider-Implementierungen - Envoy (Lua Filter) - Nginx (OpenResty Lua) - APISIX (Serverless Lua) - Kong (Plugin-Warnung) - HAProxy (Lua-Referenz) - Traefik (Einschr\u00e4nkungs-Warnung) - 10+ Provider-Tests</p> <p>Woche 3-4: Dokumentation &amp; Beispiele - docs/guides/GRPC_TRANSFORMATIONS.md - examples/grpc-transformation-example.yaml - README.md Updates - ROADMAP.md Updates</p>"},{"location":"v1.4.0-PLAN/#akzeptanzkriterien","title":"Akzeptanzkriterien","text":"<p>\u2705 GrpcTransformation Config-Model implementiert \u2705 ProtoManager kann .proto-Dateien laden/kompilieren \u2705 Envoy generiert validen Lua-Filter f\u00fcr gRPC \u2705 Nginx generiert valide OpenResty Lua-Bl\u00f6cke \u2705 APISIX generiert serverless-pre-function Config \u2705 Kong zeigt hilfreiche Warnung + Alternativen \u2705 HAProxy zeigt Lua-Script-Setup-Anweisungen \u2705 Traefik zeigt Einschr\u00e4nkungs-Warnung + Alternativen \u2705 15+ Tests bestehen \u2705 1000+ Zeilen deutsche Dokumentation \u2705 10+ Beispiel-Szenarien</p>"},{"location":"v1.4.0-PLAN/#feature-2-8-weitere-v140-features","title":"Feature 2-8: Weitere v1.4.0 Features","text":"<p>(Werden in zuk\u00fcnftigen Updates detailliert)</p> <p>Cloud Provider Support: - AWS API Gateway - Azure API Management - Google Cloud API Gateway</p> <p>Advanced Traffic Management: - A/B Testing &amp; Traffic Splitting - Request Mirroring/Shadowing - Advanced Routing (Headers, JWT, Geo)</p> <p>GraphQL Support: - Schema-Validierung - Query Complexity Limits</p>"},{"location":"v1.4.0-PLAN/#zeitplan","title":"Zeitplan","text":"<ul> <li>Monat 1 (Wochen 1-4): gRPC Transformations Feature</li> <li>Monat 2 (Wochen 5-8): AWS API Gateway Provider</li> <li>Monat 3 (Wochen 9-12): Azure API Management Provider</li> <li>Monat 4 (Wochen 13-16): Google Cloud API Gateway + A/B Testing</li> <li>Monat 5 (Wochen 17-20): Request Mirroring + Advanced Routing</li> <li>Monat 6 (Wochen 21-24): GraphQL Support + Testing + Dokumentation</li> </ul> <p>Gesamt: 6 Monate (Q3 2026)</p>"},{"location":"v1.4.0-PLAN/#abhangigkeiten","title":"Abh\u00e4ngigkeiten","text":"<ul> <li>protoc (Protobuf Compiler) - f\u00fcr .proto \u2192 .desc Kompilierung</li> <li>lua-protobuf (Envoy, Nginx, APISIX, HAProxy) - Lua Protobuf-Bibliothek</li> <li>requests (Python) - zum Herunterladen von Proto-Dateien von URLs</li> </ul>"},{"location":"v1.4.0-PLAN/#nachste-schritte-nach-v130-abschluss","title":"N\u00e4chste Schritte (Nach v1.3.0 Abschluss)","text":"<ol> <li>gRPC Transformations Anforderungen mit Benutzern \u00fcberpr\u00fcfen</li> <li>Config Model Design finalisieren</li> <li>Envoy + Nginx Implementierungen prototypen</li> <li>Implementation in Q2 2026 beginnen</li> </ol> <p>Status: \ud83d\udcdd Planungsdokument - Bereit f\u00fcr v1.4.0 Implementierung</p>"},{"location":"v1.5.0-PLAN/","title":"v1.5.0 Implementierungsplan","text":"<p>Status: \ud83d\udd04 Konzept Zeitplan: Q4 2026 (gesch\u00e4tzt) Fokus: Enterprise Features &amp; Developer Experience + Caddy Provider</p>"},{"location":"v1.5.0-PLAN/#mission","title":"Mission","text":"<p>\"Perfekte Developer Experience mit Caddy Provider und Enterprise-Features.\"</p> <p>Erm\u00f6gliche Entwicklern die einfachste API-Gateway-Konfiguration mit Caddy's automatischem HTTPS und erweitere GAL mit Enterprise-Features f\u00fcr produktive Umgebungen.</p>"},{"location":"v1.5.0-PLAN/#feature-ubersicht","title":"Feature-\u00dcbersicht","text":"Feature Status Aufwand Priorit\u00e4t 1. Caddy Provider \ud83d\udd04 Ausstehend 3 Wochen \ud83d\udd34 Hoch 2. Web UI / Dashboard \ud83d\udd04 Ausstehend 8 Wochen \ud83d\udfe1 Mittel 3. Service Mesh Integration \ud83d\udd04 Ausstehend 6 Wochen \ud83d\udfe1 Mittel 4. Advanced Observability \ud83d\udd04 Ausstehend 4 Wochen \ud83d\udfe1 Mittel 5. Multi-Tenant Support \ud83d\udd04 Ausstehend 3 Wochen \ud83d\udfe2 Niedrig 6. API Versioning \ud83d\udd04 Ausstehend 2 Wochen \ud83d\udfe2 Niedrig <p>Gesamtaufwand: ~26 Wochen (6 Monate) Fortschritt: 0/6 Features (0%)</p>"},{"location":"v1.5.0-PLAN/#feature-1-caddy-provider-detailliert","title":"Feature 1: Caddy Provider (DETAILLIERT)","text":"<p>Status: \ud83d\udd04 Ausstehend Priorit\u00e4t: \ud83d\udd34 Hoch Aufwand: 3 Wochen</p>"},{"location":"v1.5.0-PLAN/#motivation","title":"Motivation","text":"<ul> <li>Problem: Entwickler ben\u00f6tigen eine einfach zu konfigurierende Gateway-L\u00f6sung mit automatischem HTTPS</li> <li>Herausforderung: Caddy hat eine eigene JSON-API und Caddyfile-Syntax</li> <li>L\u00f6sung: GAL generiert Caddy JSON-Config aus einheitlicher YAML-Konfiguration</li> </ul>"},{"location":"v1.5.0-PLAN/#warum-caddy","title":"Warum Caddy?","text":"<p>Vorteile: - \u2705 Automatisches HTTPS: Let's Encrypt &amp; ZeroSSL ohne Konfiguration - \u2705 Einfache Syntax: Caddyfile oder JSON-API - \u2705 HTTP/3 Ready: QUIC-Support native - \u2705 Dynamische Konfiguration: JSON-API f\u00fcr Live-Updates - \u2705 Native gRPC: Reverse-Proxy f\u00fcr gRPC-Services - \u2705 Plugin-System: Erweiterbar via Caddy Modules - \u2705 Zero Dependencies: Single Binary - \u2705 Developer-Friendly: Perfekt f\u00fcr Developer Experience Theme</p> <p>Use Cases: - Entwicklungsumgebungen (lokales HTTPS ohne Zertifikate) - Microservices (automatisches Service Discovery) - Cloud-Native Deployments (Kubernetes) - Edge Computing (lightweight binary) - Prototyping (schnelle Einrichtung)</p>"},{"location":"v1.5.0-PLAN/#konfigurationsmodell","title":"Konfigurationsmodell","text":"<p>Caddy nutzt die bestehenden GAL Config-Models, keine \u00c4nderungen erforderlich!</p>"},{"location":"v1.5.0-PLAN/#caddy-json-api-beispiel","title":"Caddy JSON API Beispiel","text":"<p>GAL Config: <pre><code>services:\n  - name: api_service\n    protocol: http\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n        - host: api-2.internal\n          port: 8080\n      load_balancer:\n        algorithm: round_robin\n      health_check:\n        active:\n          enabled: true\n          path: /health\n          interval: 10s\n\n    routes:\n      - path_prefix: /api\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n        headers:\n          request:\n            add:\n              X-Gateway: \"GAL-Caddy\"\n</code></pre></p> <p>Generierte Caddy JSON Config: <pre><code>{\n  \"apps\": {\n    \"http\": {\n      \"servers\": {\n        \"srv0\": {\n          \"listen\": [\":443\"],\n          \"routes\": [\n            {\n              \"match\": [\n                {\n                  \"path\": [\"/api*\"]\n                }\n              ],\n              \"handle\": [\n                {\n                  \"handler\": \"reverse_proxy\",\n                  \"upstreams\": [\n                    {\"dial\": \"api-1.internal:8080\"},\n                    {\"dial\": \"api-2.internal:8080\"}\n                  ],\n                  \"load_balancing\": {\n                    \"selection_policy\": {\n                      \"policy\": \"round_robin\"\n                    }\n                  },\n                  \"health_checks\": {\n                    \"active\": {\n                      \"path\": \"/health\",\n                      \"interval\": \"10s\"\n                    }\n                  }\n                }\n              ]\n            }\n          ],\n          \"automatic_https\": {\n            \"disable\": false\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"v1.5.0-PLAN/#provider-implementierung","title":"Provider-Implementierung","text":"<p>Datei: <code>gal/providers/caddy.py</code></p> <pre><code>class CaddyProvider(Provider):\n    \"\"\"Caddy Provider f\u00fcr GAL.\"\"\"\n\n    def __init__(self):\n        super().__init__(\"caddy\")\n\n    def generate(self, config: Config) -&gt; str:\n        \"\"\"Generiere Caddy JSON-Config.\"\"\"\n        output = {\n            \"apps\": {\n                \"http\": {\n                    \"servers\": {\n                        \"srv0\": {\n                            \"listen\": [f\":{config.global_config.port}\"],\n                            \"routes\": []\n                        }\n                    }\n                }\n            }\n        }\n\n        # Generate routes f\u00fcr jeden Service\n        for service in config.services:\n            for route in service.routes:\n                caddy_route = self._generate_route(service, route)\n                output[\"apps\"][\"http\"][\"servers\"][\"srv0\"][\"routes\"].append(caddy_route)\n\n        # Automatic HTTPS\n        if config.global_config.port == 443:\n            output[\"apps\"][\"http\"][\"servers\"][\"srv0\"][\"automatic_https\"] = {\n                \"disable\": False\n            }\n\n        return json.dumps(output, indent=2)\n\n    def _generate_route(self, service, route):\n        \"\"\"Generiere einzelne Caddy Route.\"\"\"\n        caddy_route = {\n            \"match\": [{\"path\": [f\"{route.path_prefix}*\"]}],\n            \"handle\": []\n        }\n\n        # Rate Limiting (via rate limit handler)\n        if route.rate_limit and route.rate_limit.enabled:\n            caddy_route[\"handle\"].append({\n                \"handler\": \"rate_limit\",\n                \"rate_limit\": {\n                    \"requests_per_second\": route.rate_limit.requests_per_second,\n                    \"burst\": route.rate_limit.burst or route.rate_limit.requests_per_second * 2\n                }\n            })\n\n        # Header Manipulation\n        if route.headers:\n            header_handler = {\"handler\": \"headers\"}\n            if route.headers.request and route.headers.request.add:\n                header_handler[\"request\"] = {\n                    \"add\": route.headers.request.add\n                }\n            caddy_route[\"handle\"].append(header_handler)\n\n        # Reverse Proxy\n        reverse_proxy = {\n            \"handler\": \"reverse_proxy\",\n            \"upstreams\": []\n        }\n\n        # Upstreams\n        if service.upstream:\n            if service.upstream.targets:\n                for target in service.upstream.targets:\n                    reverse_proxy[\"upstreams\"].append({\n                        \"dial\": f\"{target.host}:{target.port}\"\n                    })\n\n            # Load Balancing\n            if service.upstream.load_balancer:\n                lb_algo = service.upstream.load_balancer.algorithm\n                policy_map = {\n                    \"round_robin\": \"round_robin\",\n                    \"least_conn\": \"least_conn\",\n                    \"ip_hash\": \"ip_hash\",\n                    \"weighted\": \"weighted_round_robin\"\n                }\n                reverse_proxy[\"load_balancing\"] = {\n                    \"selection_policy\": {\n                        \"policy\": policy_map.get(lb_algo, \"round_robin\")\n                    }\n                }\n\n            # Health Checks\n            if service.upstream.health_check:\n                hc = service.upstream.health_check\n                if hc.active and hc.active.enabled:\n                    reverse_proxy[\"health_checks\"] = {\n                        \"active\": {\n                            \"path\": hc.active.path,\n                            \"interval\": hc.active.interval,\n                            \"timeout\": hc.active.timeout\n                        }\n                    }\n\n        # Timeout Configuration\n        if route.timeout:\n            reverse_proxy[\"transport\"] = {\n                \"dial_timeout\": route.timeout.connect,\n                \"read_timeout\": route.timeout.read,\n                \"write_timeout\": route.timeout.send\n            }\n\n        caddy_route[\"handle\"].append(reverse_proxy)\n\n        return caddy_route\n\n    def validate(self, config: Config) -&gt; bool:\n        \"\"\"Validiere Caddy-Konfiguration.\"\"\"\n        # Warnungen f\u00fcr nicht unterst\u00fctzte Features\n        for service in config.services:\n            for route in service.routes:\n                # Rate Limiting erfordert caddy-ratelimit Plugin\n                if route.rate_limit and route.rate_limit.enabled:\n                    logger.warning(\n                        \"Rate Limiting in Caddy erfordert das caddy-ratelimit Plugin. \"\n                        \"Siehe: https://github.com/mholt/caddy-ratelimit\"\n                    )\n\n                # JWT Auth erfordert caddy-security Plugin\n                if route.authentication and route.authentication.type == \"jwt\":\n                    logger.warning(\n                        \"JWT Authentication in Caddy erfordert das caddy-security Plugin. \"\n                        \"Siehe: https://github.com/greenpau/caddy-security\"\n                    )\n\n                # Body Transformation nicht nativ unterst\u00fctzt\n                if route.body_transformation and route.body_transformation.enabled:\n                    logger.warning(\n                        \"Body Transformation wird von Caddy nicht nativ unterst\u00fctzt. \"\n                        \"Alternativen:\\n\"\n                        \"  1. Custom Caddy Module entwickeln\\n\"\n                        \"  2. Externen Transformation Service verwenden\\n\"\n                        \"  3. Alternative Provider: Envoy, Kong, APISIX, Nginx, HAProxy\"\n                    )\n\n        return True\n</code></pre>"},{"location":"v1.5.0-PLAN/#feature-support-matrix","title":"Feature-Support Matrix","text":"Feature Caddy Support GAL Implementation Hinweise Load Balancing \u2705 Vollst\u00e4ndig <code>selection_policy</code> round_robin, least_conn, ip_hash, weighted Active Health Checks \u2705 Vollst\u00e4ndig <code>health_checks.active</code> HTTP/HTTPS endpoints Passive Health Checks \u2705 Vollst\u00e4ndig <code>health_checks.passive</code> failure_policy Rate Limiting \u26a0\ufe0f Plugin <code>rate_limit</code> handler Requires caddy-ratelimit plugin Basic Auth \u2705 Vollst\u00e4ndig <code>basicauth</code> handler Native support JWT Auth \u26a0\ufe0f Plugin caddy-security Requires caddy-security plugin Header Manipulation \u2705 Vollst\u00e4ndig <code>headers</code> handler Native request/response CORS \u2705 Vollst\u00e4ndig <code>headers</code> handler Via Access-Control-* headers Timeout \u2705 Vollst\u00e4ndig <code>transport</code> config dial_timeout, read_timeout, write_timeout Retry \u2705 Vollst\u00e4ndig <code>lb_try_duration</code> Native retry support Circuit Breaker \u26a0\ufe0f Plugin circuit-breaker module Via plugin WebSocket \u2705 Vollst\u00e4ndig Native Automatic upgrade Body Transformation \u26a0\ufe0f Module Custom module Requires development Automatic HTTPS \u2705 Unique <code>automatic_https</code> Caddy's Killer Feature! HTTP/3 \u2705 Unique <code>protocols</code> QUIC native"},{"location":"v1.5.0-PLAN/#testing-strategie","title":"Testing-Strategie","text":"<p>Datei: <code>tests/test_caddy.py</code> (15+ Tests)</p> <pre><code># Test-Kategorien:\n# 1. Provider basics (name, validate)\n# 2. Load balancing (round_robin, least_conn, ip_hash, weighted)\n# 3. Active health checks\n# 4. Basic authentication\n# 5. Header manipulation (request, response)\n# 6. CORS policies\n# 7. Timeout configuration\n# 8. Retry policies\n# 9. WebSocket support\n# 10. Multiple services/routes\n# 11. Automatic HTTPS configuration\n# 12. JSON output validation\n</code></pre>"},{"location":"v1.5.0-PLAN/#dokumentation","title":"Dokumentation","text":"<p>Datei: <code>docs/guides/CADDY.md</code> (1000+ Zeilen, Deutsch)</p> <p>Abschnitte: - \u00dcbersicht &amp; Caddy's Unique Features - Schnellstart (3 Beispiele mit automatischem HTTPS) - Installation &amp; Setup (Binary, Docker, Kubernetes) - Konfigurationsoptionen - Feature-Implementierungen (alle 10 Features) - Caddy-spezifische Details:   - JSON API vs Caddyfile   - Automatic HTTPS (Let's Encrypt, ZeroSSL)   - HTTP/3 / QUIC Configuration   - Admin API f\u00fcr Live-Updates   - Caddy Modules / Plugin System - Provider-Vergleich (vs anderen Gateways) - Best Practices - Troubleshooting</p> <p>Datei: <code>examples/caddy-example.yaml</code> (15+ Szenarien)</p> <p>Szenarien: 1. Basic Reverse Proxy mit Auto-HTTPS 2. Load Balancing - Round Robin 3. Active Health Checks 4. Rate Limiting (mit caddy-ratelimit Plugin) 5. Basic Authentication 6. Header Manipulation 7. CORS Configuration 8. WebSocket Support 9. gRPC Reverse Proxy 10. HTTP/3 / QUIC Enabled 11. Multiple Domains mit Auto-HTTPS 12. File Server + API Hybrid 13. Microservices Architecture 14. Development Environment (localhost) 15. Production Setup mit Let's Encrypt</p>"},{"location":"v1.5.0-PLAN/#meilensteine","title":"Meilensteine","text":"<p>Woche 1: Provider Implementation + Core Features - CaddyProvider Klasse - JSON-Config Generation - Load Balancing - Health Checks - 8+ Tests</p> <p>Woche 2: Advanced Features + Documentation - Rate Limiting (Plugin-Warning) - Authentication (Basic + JWT Warning) - Header Manipulation - CORS - Timeout &amp; Retry - WebSocket - 7+ Tests - docs/guides/CADDY.md (500+ Zeilen)</p> <p>Woche 3: Examples + Integration + Polish - examples/caddy-example.yaml (15 Szenarien) - CLI Integration - README.md Updates - ROADMAP.md Updates - docs/guides/CADDY.md vervollst\u00e4ndigen (1000+ Zeilen)</p>"},{"location":"v1.5.0-PLAN/#akzeptanzkriterien","title":"Akzeptanzkriterien","text":"<p>\u2705 CaddyProvider generiert valide JSON-Config \u2705 Alle Load-Balancing-Algorithmen unterst\u00fctzt \u2705 Active Health Checks funktionieren \u2705 Header Manipulation (request/response) \u2705 CORS via headers handler \u2705 Timeout &amp; Retry konfigurierbar \u2705 WebSocket native support \u2705 Automatic HTTPS konfigurierbar \u2705 15+ Tests bestehen (100% passing) \u2705 1000+ Zeilen deutsche Dokumentation \u2705 15+ Beispiel-Szenarien \u2705 CLI Integration komplett</p>"},{"location":"v1.5.0-PLAN/#deployment-beispiel","title":"Deployment-Beispiel","text":"<pre><code># GAL-Config generieren\ngal generate --config config.yaml --provider caddy --output caddy.json\n\n# Caddy mit generierter Config starten\ncaddy run --config caddy.json\n\n# Oder Caddy JSON API verwenden (Live-Update)\ncurl -X POST http://localhost:2019/load \\\n  -H \"Content-Type: application/json\" \\\n  -d @caddy.json\n\n# Automatic HTTPS aktiv\n# Caddy l\u00e4dt automatisch Let's Encrypt Zertifikate f\u00fcr alle Domains!\n</code></pre>"},{"location":"v1.5.0-PLAN/#feature-2-6-weitere-v150-features","title":"Feature 2-6: Weitere v1.5.0 Features","text":"<p>(Werden in zuk\u00fcnftigen Updates detailliert)</p>"},{"location":"v1.5.0-PLAN/#feature-2-web-ui-dashboard-8-wochen","title":"Feature 2: Web UI / Dashboard (8 Wochen)","text":"<ul> <li>Visual Config Builder</li> <li>Drag &amp; Drop Route Configuration</li> <li>Real-time Validation</li> <li>Provider Comparison View</li> <li>Export/Import Configurations</li> </ul>"},{"location":"v1.5.0-PLAN/#feature-3-service-mesh-integration-6-wochen","title":"Feature 3: Service Mesh Integration (6 Wochen)","text":"<ul> <li>Istio Support</li> <li>Linkerd Support</li> <li>Consul Connect Support</li> <li>Service-to-Service Auth</li> </ul>"},{"location":"v1.5.0-PLAN/#feature-4-advanced-observability-4-wochen","title":"Feature 4: Advanced Observability (4 Wochen)","text":"<ul> <li>OpenTelemetry Full Support (Tracing, Metrics, Logs)</li> <li>Prometheus Metrics Export</li> <li>Grafana Dashboard Templates</li> <li>Jaeger Integration</li> </ul>"},{"location":"v1.5.0-PLAN/#feature-5-multi-tenant-support-3-wochen","title":"Feature 5: Multi-Tenant Support (3 Wochen)","text":"<ul> <li>Namespace Isolation</li> <li>Per-Tenant Rate Limiting</li> <li>Tenant-Specific Configurations</li> </ul>"},{"location":"v1.5.0-PLAN/#feature-6-api-versioning-2-wochen","title":"Feature 6: API Versioning (2 Wochen)","text":"<ul> <li>Version-based Routing</li> <li>Deprecation Policies</li> <li>Backward Compatibility Checks</li> </ul>"},{"location":"v1.5.0-PLAN/#zeitplan","title":"Zeitplan","text":"<ul> <li>Monat 1 (Wochen 1-3): Caddy Provider</li> <li>Monat 2-3 (Wochen 4-11): Web UI / Dashboard</li> <li>Monat 4 (Wochen 12-17): Service Mesh Integration</li> <li>Monat 5 (Wochen 18-21): Advanced Observability</li> <li>Monat 6 (Wochen 22-26): Multi-Tenant + API Versioning</li> </ul> <p>Gesamt: 6 Monate (Q4 2026)</p>"},{"location":"v1.5.0-PLAN/#abhangigkeiten","title":"Abh\u00e4ngigkeiten","text":""},{"location":"v1.5.0-PLAN/#caddy-provider","title":"Caddy Provider","text":"<ul> <li>Caddy v2.7+ - Caddy Server Binary</li> <li>Keine zus\u00e4tzlichen Abh\u00e4ngigkeiten! (Single Binary)</li> </ul>"},{"location":"v1.5.0-PLAN/#optional-fur-erweiterte-features","title":"Optional (f\u00fcr erweiterte Features)","text":"<ul> <li>caddy-ratelimit - Rate Limiting Plugin</li> <li>caddy-security - JWT Authentication Plugin</li> <li>caddy-circuit-breaker - Circuit Breaker Plugin</li> </ul>"},{"location":"v1.5.0-PLAN/#nachste-schritte-nach-v140-abschluss","title":"N\u00e4chste Schritte (Nach v1.4.0 Abschluss)","text":"<ol> <li>Caddy Provider Anforderungen mit Community \u00fcberpr\u00fcfen</li> <li>Prototype CaddyProvider erstellen</li> <li>JSON-Config Generation testen</li> <li>Caddy Plugins evaluieren (rate-limit, security)</li> <li>Implementation in Q4 2026 beginnen</li> </ol> <p>Status: \ud83d\udcdd Planungsdokument - Bereit f\u00fcr v1.5.0 Implementierung</p>"},{"location":"v1.5.0-PLAN/#provider-vergleich-mit-caddy","title":"Provider-Vergleich (mit Caddy)","text":"Feature Envoy Kong APISIX Traefik Nginx HAProxy Caddy Ease of Use \u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Auto HTTPS \u26a0\ufe0f \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u26a0\ufe0f \u2b50\u2b50\u2b50\u2b50\u2b50 HTTP/3 \u2705 \u26a0\ufe0f \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f \u2705 Performance \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 Plugin System \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u26a0\ufe0f \u26a0\ufe0f \u2b50\u2b50\u2b50\u2b50 Zero Config \u274c \u274c \u274c \u2b50\u2b50\u2b50 \u274c \u274c \u2b50\u2b50\u2b50\u2b50\u2b50 <p>Caddy's St\u00e4rken: - \ud83e\udd47 Beste Developer Experience - Einfachste Konfiguration - \ud83e\udd47 Bestes Auto-HTTPS - Zero-Config TLS - \ud83e\udd47 Bestes Zero-Config - Funktioniert out-of-the-box - \u2705 HTTP/3 / QUIC Native - \u2705 Single Binary (keine Dependencies) - \u2705 JSON API f\u00fcr dynamische Updates - \u2705 Perfekt f\u00fcr Entwicklungsumgebungen</p> <p>Beste Wahl f\u00fcr: - \ud83d\ude80 Rapid Prototyping - \ud83d\udcbb Entwicklungsumgebungen (lokales HTTPS ohne Zertifikate) - \ud83c\udfe2 Kleine bis mittlere Deployments - \ud83c\udf10 Edge Computing (lightweight) - \ud83d\udcf1 Mobile Backend Development</p>"},{"location":"api/CLI_REFERENCE/","title":"GAL CLI Referenz","text":""},{"location":"api/CLI_REFERENCE/#ubersicht","title":"\u00dcbersicht","text":"<p>Das GAL Command-Line Interface (CLI) bietet einen einfachen Zugang zur Gateway Abstraction Layer-Funktionalit\u00e4t f\u00fcr die Generierung, Validierung und Verwaltung von API-Gateway-Konfigurationen.</p>"},{"location":"api/CLI_REFERENCE/#installation","title":"Installation","text":"<pre><code># Mit pip\npip install gal\n\n# Aus dem Quellcode\ngit clone https://github.com/pt9912/x-gal.git\ncd x-gal\npip install -e .\n</code></pre>"},{"location":"api/CLI_REFERENCE/#globale-optionen","title":"Globale Optionen","text":"<p>Alle Befehle unterst\u00fctzen folgende globale Optionen:</p> <ul> <li><code>--help</code> - Zeigt Hilfetext an</li> </ul>"},{"location":"api/CLI_REFERENCE/#befehle","title":"Befehle","text":""},{"location":"api/CLI_REFERENCE/#generate","title":"<code>generate</code>","text":"<p>Generiert Gateway-Konfigurationen f\u00fcr einen spezifischen Provider.</p> <p>Syntax: <pre><code>gal-cli.py generate --config &lt;datei&gt; [--provider &lt;provider&gt;] [--output &lt;datei&gt;]\n</code></pre></p> <p>Optionen:</p> Option Kurzform Beschreibung Erforderlich <code>--config</code> <code>-c</code> Pfad zur YAML-Konfigurationsdatei Ja <code>--provider</code> <code>-p</code> Provider-Name (\u00fcberschreibt Config) Nein <code>--output</code> <code>-o</code> Ausgabedatei (Standard: stdout) Nein <p>Unterst\u00fctzte Provider: - <code>envoy</code> - Envoy Proxy - <code>kong</code> - Kong API Gateway - <code>apisix</code> - Apache APISIX - <code>traefik</code> - Traefik</p> <p>Beispiele:</p> <pre><code># Konfiguration f\u00fcr Envoy generieren\ngal-cli.py generate -c examples/gateway-config.yaml -o generated/envoy.yaml\n\n# Provider \u00fcberschreiben und nach stdout ausgeben\ngal-cli.py generate -c examples/gateway-config.yaml -p kong\n\n# Kong-Konfiguration in Datei schreiben\ngal-cli.py generate -c examples/gateway-config.yaml -p kong -o kong-config.yaml\n</code></pre> <p>Ausgabe:</p> <pre><code>Generating configuration for: envoy\nServices: 5 (3 gRPC, 2 REST)\n\u2713 Configuration written to: generated/envoy.yaml\n</code></pre>"},{"location":"api/CLI_REFERENCE/#validate","title":"<code>validate</code>","text":"<p>Validiert eine GAL-Konfigurationsdatei.</p> <p>Syntax: <pre><code>gal-cli.py validate --config &lt;datei&gt;\n</code></pre></p> <p>Optionen:</p> Option Kurzform Beschreibung Erforderlich <code>--config</code> <code>-c</code> Pfad zur YAML-Konfigurationsdatei Ja <p>Beispiele:</p> <pre><code># Konfiguration validieren\ngal-cli.py validate -c examples/gateway-config.yaml\n</code></pre> <p>Ausgabe (Erfolg):</p> <pre><code>\u2713 Configuration is valid\n  Provider: envoy\n  Services: 5\n  gRPC services: 3\n  REST services: 2\n</code></pre> <p>Ausgabe (Fehler):</p> <pre><code>\u2717 Configuration is invalid: Port must be specified\n</code></pre>"},{"location":"api/CLI_REFERENCE/#generate-all","title":"<code>generate-all</code>","text":"<p>Generiert Konfigurationen f\u00fcr alle unterst\u00fctzten Provider gleichzeitig.</p> <p>Syntax: <pre><code>gal-cli.py generate-all --config &lt;datei&gt; [--output-dir &lt;verzeichnis&gt;]\n</code></pre></p> <p>Optionen:</p> Option Kurzform Beschreibung Erforderlich Standard <code>--config</code> <code>-c</code> Pfad zur YAML-Konfigurationsdatei Ja - <code>--output-dir</code> <code>-o</code> Ausgabeverzeichnis Nein <code>generated</code> <p>Beispiele:</p> <pre><code># Alle Provider generieren\ngal-cli.py generate-all -c examples/gateway-config.yaml\n\n# Mit benutzerdefiniertem Ausgabeverzeichnis\ngal-cli.py generate-all -c examples/gateway-config.yaml -o output/configs\n</code></pre> <p>Ausgabe:</p> <pre><code>Generating configurations for all providers...\nOutput directory: /path/to/generated\n\n  \u2713 envoy: /path/to/generated/envoy.yaml\n  \u2713 kong: /path/to/generated/kong.yaml\n  \u2713 apisix: /path/to/generated/apisix.json\n  \u2713 traefik: /path/to/generated/traefik.yaml\n\n\u2713 All configurations generated successfully\n</code></pre> <p>Generierte Dateien:</p> <ul> <li><code>envoy.yaml</code> - Envoy-Konfiguration im YAML-Format</li> <li><code>kong.yaml</code> - Kong deklarative Konfiguration</li> <li><code>apisix.json</code> - APISIX-Konfiguration im JSON-Format</li> <li><code>traefik.yaml</code> - Traefik-Konfiguration</li> </ul>"},{"location":"api/CLI_REFERENCE/#info","title":"<code>info</code>","text":"<p>Zeigt detaillierte Informationen \u00fcber eine Konfigurationsdatei an.</p> <p>Syntax: <pre><code>gal-cli.py info --config &lt;datei&gt;\n</code></pre></p> <p>Optionen:</p> Option Kurzform Beschreibung Erforderlich <code>--config</code> <code>-c</code> Pfad zur YAML-Konfigurationsdatei Ja <p>Beispiele:</p> <pre><code># Konfigurationsinformationen anzeigen\ngal-cli.py info -c examples/gateway-config.yaml\n</code></pre> <p>Ausgabe:</p> <pre><code>============================================================\nGAL Configuration Information\n============================================================\nProvider: envoy\nVersion: 1.0\n\nGlobal Settings:\n  Host: 0.0.0.0\n  Port: 10000\n  Admin Port: 9901\n  Timeout: 30s\n\nServices (5 total):\n\n  \u2022 user_service\n    Type: grpc\n    Upstream: user-service:9090\n    Routes: 1\n    Transformations: \u2713 Enabled\n      Defaults: 3 fields\n      Computed: 2 fields\n\n  \u2022 order_service\n    Type: grpc\n    Upstream: order-service:9091\n    Routes: 1\n    Transformations: \u2713 Enabled\n      Defaults: 3 fields\n      Computed: 2 fields\n\n  \u2022 product_service\n    Type: rest\n    Upstream: product-service:8080\n    Routes: 1\n    Transformations: \u2713 Enabled\n      Defaults: 4 fields\n      Computed: 2 fields\n\n  \u2022 payment_service\n    Type: rest\n    Upstream: payment-service:8081\n    Routes: 1\n    Transformations: \u2713 Enabled\n      Defaults: 3 fields\n      Computed: 2 fields\n      Required: order_id, amount, method\n\nPlugins (1):\n  \u2713 rate_limiting\n</code></pre>"},{"location":"api/CLI_REFERENCE/#list-providers","title":"<code>list-providers</code>","text":"<p>Listet alle verf\u00fcgbaren Gateway-Provider auf.</p> <p>Syntax: <pre><code>gal-cli.py list-providers\n</code></pre></p> <p>Keine Optionen erforderlich.</p> <p>Beispiele:</p> <pre><code># Verf\u00fcgbare Provider auflisten\ngal-cli.py list-providers\n</code></pre> <p>Ausgabe:</p> <pre><code>Available providers:\n  \u2022 envoy   - Envoy Proxy\n  \u2022 kong    - Kong API Gateway\n  \u2022 apisix  - Apache APISIX\n  \u2022 traefik - Traefik\n</code></pre>"},{"location":"api/CLI_REFERENCE/#docker-verwendung","title":"Docker-Verwendung","text":""},{"location":"api/CLI_REFERENCE/#grundlegende-verwendung","title":"Grundlegende Verwendung","text":"<pre><code># Image bauen\ndocker build -t gal:latest .\n\n# Befehl ausf\u00fchren\ndocker run --rm gal:latest list-providers\n</code></pre>"},{"location":"api/CLI_REFERENCE/#mit-volume-mounting","title":"Mit Volume-Mounting","text":"<pre><code># Konfiguration generieren mit Volume\ndocker run --rm \\\n  -v $(pwd)/examples:/app/examples \\\n  -v $(pwd)/generated:/app/generated \\\n  gal:latest generate \\\n    --config examples/gateway-config.yaml \\\n    --output generated/envoy.yaml\n</code></pre>"},{"location":"api/CLI_REFERENCE/#mit-docker-compose","title":"Mit Docker Compose","text":"<pre><code># Standard-Generierung (Envoy)\ndocker-compose up gal-generate\n\n# F\u00fcr spezifischen Provider\nPROVIDER=kong docker-compose up gal-generate\n\n# Alle Provider generieren\ndocker-compose up gal-generate-all\n</code></pre>"},{"location":"api/CLI_REFERENCE/#fehlerbehandlung","title":"Fehlerbehandlung","text":""},{"location":"api/CLI_REFERENCE/#exit-codes","title":"Exit-Codes","text":"Code Bedeutung 0 Erfolg 1 Fehler (Validierung fehlgeschlagen, Datei nicht gefunden, etc.)"},{"location":"api/CLI_REFERENCE/#haufige-fehler","title":"H\u00e4ufige Fehler","text":"<p>Datei nicht gefunden: <pre><code>Error: [Errno 2] No such file or directory: 'config.yaml'\n</code></pre> \u2192 Pr\u00fcfen Sie, ob die Konfigurationsdatei existiert und der Pfad korrekt ist.</p> <p>Ung\u00fcltige YAML-Syntax: <pre><code>Error: while parsing a block mapping\n</code></pre> \u2192 Pr\u00fcfen Sie die YAML-Syntax Ihrer Konfigurationsdatei.</p> <p>Provider nicht unterst\u00fctzt: <pre><code>Error: Provider 'unknown' not registered\n</code></pre> \u2192 Verwenden Sie einen der unterst\u00fctzten Provider: envoy, kong, apisix, traefik.</p> <p>Validierung fehlgeschlagen: <pre><code>Error: Port must be specified\n</code></pre> \u2192 Stellen Sie sicher, dass alle erforderlichen Felder in der Konfiguration gesetzt sind.</p>"},{"location":"api/CLI_REFERENCE/#scripting-beispiele","title":"Scripting-Beispiele","text":""},{"location":"api/CLI_REFERENCE/#bash-script-fur-continuous-deployment","title":"Bash-Script f\u00fcr Continuous Deployment","text":"<pre><code>#!/bin/bash\nset -e\n\nCONFIG_FILE=\"config/gateway.yaml\"\nOUTPUT_DIR=\"deploy/configs\"\n\necho \"Validating configuration...\"\ngal-cli.py validate -c \"$CONFIG_FILE\"\n\necho \"Generating configurations...\"\ngal-cli.py generate-all -c \"$CONFIG_FILE\" -o \"$OUTPUT_DIR\"\n\necho \"Deploying to environments...\"\nkubectl apply -f \"$OUTPUT_DIR/envoy.yaml\" --namespace=production\n\necho \"\u2713 Deployment complete\"\n</code></pre>"},{"location":"api/CLI_REFERENCE/#python-integration","title":"Python-Integration","text":"<pre><code>import subprocess\nimport json\n\ndef generate_gateway_config(config_path, provider, output_path):\n    \"\"\"Generate gateway configuration using GAL CLI\"\"\"\n    cmd = [\n        'gal-cli.py', 'generate',\n        '--config', config_path,\n        '--provider', provider,\n        '--output', output_path\n    ]\n\n    result = subprocess.run(cmd, capture_output=True, text=True)\n\n    if result.returncode != 0:\n        raise RuntimeError(f\"Failed to generate config: {result.stderr}\")\n\n    return output_path\n\n# Verwendung\ntry:\n    output = generate_gateway_config(\n        'examples/gateway-config.yaml',\n        'envoy',\n        'generated/envoy.yaml'\n    )\n    print(f\"Configuration generated: {output}\")\nexcept RuntimeError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"api/CLI_REFERENCE/#siehe-auch","title":"Siehe auch","text":"<ul> <li>Konfigurationsreferenz</li> <li>Provider-Dokumentation</li> <li>Transformations-Guide</li> </ul>"},{"location":"api/CONFIGURATION/","title":"GAL Konfigurationsreferenz","text":""},{"location":"api/CONFIGURATION/#ubersicht","title":"\u00dcbersicht","text":"<p>GAL verwendet YAML-Dateien zur Definition von Gateway-Konfigurationen. Diese Konfigurationen sind provider-agnostisch und k\u00f6nnen f\u00fcr jeden unterst\u00fctzten Gateway-Provider (Envoy, Kong, APISIX, Traefik) generiert werden.</p>"},{"location":"api/CONFIGURATION/#konfigurationsschema","title":"Konfigurationsschema","text":""},{"location":"api/CONFIGURATION/#root-level-struktur","title":"Root-Level-Struktur","text":"<pre><code>version: string          # Konfigurationsversion (erforderlich)\nprovider: string         # Ziel-Provider (erforderlich)\nglobal: object          # Globale Gateway-Einstellungen (optional)\nservices: array         # Liste der Services (erforderlich)\nplugins: array          # Liste der Plugins (optional)\n</code></pre>"},{"location":"api/CONFIGURATION/#global-configuration","title":"Global Configuration","text":"<p>Globale Einstellungen, die auf das gesamte Gateway angewendet werden.</p> <pre><code>global:\n  host: string          # Listen-Host (Standard: \"0.0.0.0\")\n  port: integer         # Listen-Port (Standard: 10000)\n  admin_port: integer   # Admin-Port (Standard: 9901)\n  timeout: string       # Request-Timeout (Standard: \"30s\")\n</code></pre> <p>Beispiel:</p> <pre><code>global:\n  host: 0.0.0.0\n  port: 10000\n  admin_port: 9901\n  timeout: 30s\n</code></pre>"},{"location":"api/CONFIGURATION/#services","title":"Services","text":"<p>Liste der Backend-Services, die \u00fcber das Gateway geroutet werden.</p> <pre><code>services:\n  - name: string                # Service-Name (erforderlich, einzigartig)\n    type: string                # Service-Typ: \"grpc\" oder \"rest\" (erforderlich)\n    protocol: string            # Protokoll: \"http\", \"http2\", \"grpc\" (erforderlich)\n    upstream: object            # Upstream-Konfiguration (erforderlich)\n    routes: array              # Route-Definitionen (erforderlich)\n    transformation: object     # Transformationsregeln (optional)\n</code></pre>"},{"location":"api/CONFIGURATION/#upstream","title":"Upstream","text":"<p>Definiert den Backend-Service-Endpunkt.</p> <pre><code>upstream:\n  host: string    # Hostname oder IP-Adresse (erforderlich)\n  port: integer   # Port-Nummer (erforderlich)\n</code></pre> <p>Beispiel:</p> <pre><code>upstream:\n  host: user-service\n  port: 9090\n</code></pre>"},{"location":"api/CONFIGURATION/#routes","title":"Routes","text":"<p>Definiert, wie Requests zum Service geroutet werden.</p> <pre><code>routes:\n  - path_prefix: string    # URL-Path-Pr\u00e4fix (erforderlich)\n    methods: array         # HTTP-Methoden (optional, nur f\u00fcr REST)\n</code></pre> <p>Beispiele:</p> <pre><code># gRPC-Route\nroutes:\n  - path_prefix: /myapp.UserService\n\n# REST-Route mit Methoden\nroutes:\n  - path_prefix: /api/products\n    methods: [GET, POST, PUT, DELETE]\n\n# Mehrere Routes\nroutes:\n  - path_prefix: /api/v1/users\n    methods: [GET, POST]\n  - path_prefix: /api/v1/users/{id}\n    methods: [GET, PUT, DELETE]\n</code></pre>"},{"location":"api/CONFIGURATION/#transformation","title":"Transformation","text":"<p>Definiert Payload-Transformationen, die auf Requests angewendet werden.</p> <pre><code>transformation:\n  enabled: boolean              # Transformationen aktivieren (Standard: true)\n  defaults: object             # Default-Werte f\u00fcr Felder\n  computed_fields: array       # Berechnete/generierte Felder\n  metadata: object             # Zus\u00e4tzliche Metadaten\n  validation: object           # Validierungsregeln\n</code></pre> <p>defaults:</p> <p>Setzt Standard-Werte f\u00fcr fehlende Felder im Request-Body.</p> <pre><code>defaults:\n  field_name: value\n</code></pre> <p>Beispiel:</p> <pre><code>defaults:\n  status: \"pending\"\n  currency: \"USD\"\n  active: true\n  priority: 5\n</code></pre> <p>computed_fields:</p> <p>Generiert Felder automatisch basierend auf vordefinierten Generatoren.</p> <pre><code>computed_fields:\n  - field: string        # Feldname (erforderlich)\n    generator: string    # Generator-Typ (erforderlich)\n    prefix: string       # Pr\u00e4fix f\u00fcr generierten Wert (optional)\n    suffix: string       # Suffix f\u00fcr generierten Wert (optional)\n    expression: string   # Custom-Expression (optional, derzeit nicht verwendet)\n</code></pre> <p>Verf\u00fcgbare Generatoren:</p> Generator Beschreibung Beispiel-Ausgabe <code>uuid</code> Generiert UUID v4 <code>550e8400-e29b-41d4-a716-446655440000</code> <code>timestamp</code> Unix-Timestamp <code>1698765432</code> <code>random</code> Zufallszahl <code>42</code> <p>Beispiel:</p> <pre><code>computed_fields:\n  - field: user_id\n    generator: uuid\n    prefix: \"user_\"\n    # Ergebnis: user_550e8400-e29b-41d4-a716-446655440000\n\n  - field: created_at\n    generator: timestamp\n    # Ergebnis: 1698765432\n\n  - field: order_id\n    generator: uuid\n    prefix: \"order_\"\n    suffix: \"_v1\"\n    # Ergebnis: order_550e8400-e29b-41d4-a716-446655440000_v1\n</code></pre> <p>metadata:</p> <p>F\u00fcgt zus\u00e4tzliche Metadaten zum Request hinzu.</p> <pre><code>metadata:\n  key: value\n</code></pre> <p>Beispiel:</p> <pre><code>metadata:\n  enriched_by: \"gateway\"\n  service_name: \"product_service\"\n  version: \"1.0\"\n</code></pre> <p>validation:</p> <p>Definiert Validierungsregeln f\u00fcr Request-Payloads.</p> <pre><code>validation:\n  required_fields: array    # Liste erforderlicher Felder\n</code></pre> <p>Beispiel:</p> <pre><code>validation:\n  required_fields:\n    - order_id\n    - amount\n    - method\n</code></pre>"},{"location":"api/CONFIGURATION/#plugins","title":"Plugins","text":"<p>Gateway-Plugins f\u00fcr erweiterte Funktionalit\u00e4t.</p> <pre><code>plugins:\n  - name: string        # Plugin-Name (erforderlich)\n    enabled: boolean    # Plugin aktiviert (Standard: true)\n    config: object      # Plugin-Konfiguration (optional)\n</code></pre> <p>Beispiel:</p> <pre><code>plugins:\n  - name: rate_limiting\n    enabled: true\n    config:\n      requests_per_second: 100\n      burst: 200\n\n  - name: cors\n    enabled: true\n    config:\n      origins: [\"*\"]\n      methods: [GET, POST, PUT, DELETE]\n      headers: [Content-Type, Authorization]\n</code></pre>"},{"location":"api/CONFIGURATION/#vollstandiges-beispiel","title":"Vollst\u00e4ndiges Beispiel","text":"<pre><code>version: \"1.0\"\nprovider: envoy\n\nglobal:\n  host: 0.0.0.0\n  port: 10000\n  admin_port: 9901\n  timeout: 30s\n\nservices:\n  # gRPC Service mit Transformationen\n  - name: user_service\n    type: grpc\n    protocol: http2\n    upstream:\n      host: user-service\n      port: 9090\n    routes:\n      - path_prefix: /myapp.UserService\n    transformation:\n      enabled: true\n      defaults:\n        role: \"user\"\n        age: 0\n        active: true\n      computed_fields:\n        - field: user_id\n          generator: uuid\n          prefix: \"user_\"\n        - field: created_at\n          generator: timestamp\n      metadata:\n        service: \"user_service\"\n        version: \"1.0\"\n\n  # REST Service mit Validierung\n  - name: payment_service\n    type: rest\n    protocol: http\n    upstream:\n      host: payment-service\n      port: 8081\n    routes:\n      - path_prefix: /api/payments\n        methods: [POST]\n    transformation:\n      enabled: true\n      defaults:\n        status: \"pending\"\n        currency: \"USD\"\n        provider: \"stripe\"\n      computed_fields:\n        - field: payment_id\n          generator: uuid\n          prefix: \"pay_\"\n        - field: timestamp\n          generator: timestamp\n      validation:\n        required_fields:\n          - order_id\n          - amount\n          - method\n\n  # REST Service ohne Transformationen\n  - name: health_check\n    type: rest\n    protocol: http\n    upstream:\n      host: health-service\n      port: 8082\n    routes:\n      - path_prefix: /health\n        methods: [GET]\n\nplugins:\n  - name: rate_limiting\n    enabled: true\n    config:\n      requests_per_second: 100\n      burst: 200\n\n  - name: authentication\n    enabled: true\n    config:\n      jwt_secret: ${JWT_SECRET}\n      token_header: Authorization\n</code></pre>"},{"location":"api/CONFIGURATION/#provider-spezifische-hinweise","title":"Provider-spezifische Hinweise","text":""},{"location":"api/CONFIGURATION/#envoy","title":"Envoy","text":"<ul> <li>gRPC-Services erhalten automatisch <code>http2_protocol_options</code></li> <li>Transformationen werden als Lua-Filter implementiert</li> <li>Admin-Interface l\u00e4uft auf konfiguriertem <code>admin_port</code></li> </ul>"},{"location":"api/CONFIGURATION/#kong","title":"Kong","text":"<ul> <li>Output ist Kong Declarative Configuration (v3.0)</li> <li>Transformationen nutzen <code>request-transformer</code> Plugin</li> <li>gRPC-Services verwenden <code>protocol: grpc</code></li> </ul>"},{"location":"api/CONFIGURATION/#apisix","title":"APISIX","text":"<ul> <li>Output ist JSON-Format</li> <li>Transformationen werden als Lua-Serverless-Functions implementiert</li> <li>Automatische Upstream-Generierung mit Round-Robin Load Balancing</li> </ul>"},{"location":"api/CONFIGURATION/#traefik","title":"Traefik","text":"<ul> <li>Routes verwenden PathPrefix-Regel</li> <li>Transformationen werden als Middleware-Plugins implementiert</li> <li>Services erhalten automatische LoadBalancer-Konfiguration</li> </ul>"},{"location":"api/CONFIGURATION/#validierung","title":"Validierung","text":"<p>Nutzen Sie den <code>validate</code>-Befehl, um Ihre Konfiguration zu pr\u00fcfen:</p> <pre><code>gal-cli.py validate -c config.yaml\n</code></pre>"},{"location":"api/CONFIGURATION/#best-practices","title":"Best Practices","text":""},{"location":"api/CONFIGURATION/#1-naming-conventions","title":"1. Naming Conventions","text":"<ul> <li>Verwenden Sie snake_case f\u00fcr Service-Namen</li> <li>Nutzen Sie aussagekr\u00e4ftige Namen, die die Funktion beschreiben</li> <li>Vermeiden Sie Sonderzeichen au\u00dfer Unterstrichen</li> </ul> <pre><code># Gut\nname: user_authentication_service\n\n# Schlecht\nname: UserAuth123!\n</code></pre>"},{"location":"api/CONFIGURATION/#2-transformationen","title":"2. Transformationen","text":"<ul> <li>Nutzen Sie Defaults f\u00fcr optionale Felder</li> <li>Computed Fields f\u00fcr eindeutige IDs und Timestamps</li> <li>Validation f\u00fcr kritische Business-Felder</li> </ul> <pre><code>transformation:\n  enabled: true\n  defaults:\n    status: \"draft\"  # Optionales Feld mit sinnvollem Default\n  computed_fields:\n    - field: id\n      generator: uuid  # Eindeutige ID garantiert\n  validation:\n    required_fields:\n      - customer_id  # Kritisches Business-Feld\n</code></pre>"},{"location":"api/CONFIGURATION/#3-environment-variables","title":"3. Environment Variables","text":"<p>Nutzen Sie Environment Variables f\u00fcr Secrets:</p> <pre><code>plugins:\n  - name: auth\n    config:\n      secret: ${JWT_SECRET}  # Nie hardcoden!\n      api_key: ${API_KEY}\n</code></pre>"},{"location":"api/CONFIGURATION/#4-service-organisation","title":"4. Service-Organisation","text":"<p>Gruppieren Sie Services logisch:</p> <pre><code>services:\n  # Authentication Services\n  - name: auth_service\n    ...\n\n  - name: user_service\n    ...\n\n  # Business Logic Services\n  - name: order_service\n    ...\n\n  - name: payment_service\n    ...\n\n  # Infrastructure Services\n  - name: health_check\n    ...\n</code></pre>"},{"location":"api/CONFIGURATION/#fehlerbehandlung","title":"Fehlerbehandlung","text":""},{"location":"api/CONFIGURATION/#haufige-fehler","title":"H\u00e4ufige Fehler","text":"<p>Fehlende erforderliche Felder:</p> <pre><code># Fehler: upstream fehlt\nservices:\n  - name: my_service\n    type: rest\n    protocol: http\n    # upstream: FEHLT!\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Ung\u00fcltiger Service-Typ:</p> <pre><code># Fehler: type muss \"grpc\" oder \"rest\" sein\nservices:\n  - name: my_service\n    type: http  # FALSCH!\n    ...\n</code></pre> <p>Duplikat Service-Namen:</p> <pre><code># Fehler: Service-Namen m\u00fcssen eindeutig sein\nservices:\n  - name: user_service\n    ...\n  - name: user_service  # DUPLIKAT!\n    ...\n</code></pre>"},{"location":"api/CONFIGURATION/#siehe-auch","title":"Siehe auch","text":"<ul> <li>CLI-Referenz</li> <li>Transformations-Guide</li> <li>Provider-Dokumentation</li> </ul>"},{"location":"architecture/ARCHITECTURE/","title":"GAL Architektur-Dokumentation","text":""},{"location":"architecture/ARCHITECTURE/#uberblick","title":"\u00dcberblick","text":"<p>Gateway Abstraction Layer (GAL) ist ein provider-agnostisches Konfigurationssystem f\u00fcr API-Gateways. Es erm\u00f6glicht die Definition von Gateway-Konfigurationen in einem einheitlichen Format und deren Transformation f\u00fcr verschiedene Gateway-Provider.</p>"},{"location":"architecture/ARCHITECTURE/#system-architektur","title":"System-Architektur","text":"<pre><code>graph TB\n    subgraph \"Benutzer-Interface\"\n        CLI[CLI Tool&lt;br/&gt;gal-cli.py]\n        Docker[Docker Container]\n    end\n\n    subgraph \"Core Layer\"\n        Manager[Manager&lt;br/&gt;Orchestration]\n        Config[Config&lt;br/&gt;Datenmodelle]\n    end\n\n    subgraph \"Provider Layer\"\n        ProviderBase[Provider&lt;br/&gt;ABC]\n        Envoy[EnvoyProvider]\n        Kong[KongProvider]\n        APISIX[APISIXProvider]\n        Traefik[TraefikProvider]\n    end\n\n    subgraph \"Transformation Layer\"\n        TransEngine[Transformation Engine]\n        Generators[Field Generators&lt;br/&gt;UUID, Timestamp]\n    end\n\n    subgraph \"Output\"\n        EnvoyYAML[Envoy YAML]\n        KongYAML[Kong YAML]\n        APISIXJSON[APISIX JSON]\n        TraefikYAML[Traefik YAML]\n    end\n\n    CLI --&gt; Manager\n    Docker --&gt; CLI\n    Manager --&gt; Config\n    Manager --&gt; ProviderBase\n    ProviderBase -.implements.-&gt; Envoy\n    ProviderBase -.implements.-&gt; Kong\n    ProviderBase -.implements.-&gt; APISIX\n    ProviderBase -.implements.-&gt; Traefik\n\n    Envoy --&gt; TransEngine\n    Kong --&gt; TransEngine\n    APISIX --&gt; TransEngine\n    Traefik --&gt; TransEngine\n\n    TransEngine --&gt; Generators\n\n    Envoy --&gt; EnvoyYAML\n    Kong --&gt; KongYAML\n    APISIX --&gt; APISIXJSON\n    Traefik --&gt; TraefikYAML\n\n    style Manager fill:#4CAF50\n    style Config fill:#2196F3\n    style ProviderBase fill:#FF9800\n    style TransEngine fill:#9C27B0</code></pre>"},{"location":"architecture/ARCHITECTURE/#komponentendiagramm","title":"Komponentendiagramm","text":"<pre><code>graph LR\n    subgraph \"gal Package\"\n        direction TB\n\n        ConfigModule[config.py&lt;br/&gt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&lt;br/&gt;\u2022 GlobalConfig&lt;br/&gt;\u2022 Service&lt;br/&gt;\u2022 Route&lt;br/&gt;\u2022 Upstream&lt;br/&gt;\u2022 Transformation]\n\n        ManagerModule[manager.py&lt;br/&gt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&lt;br/&gt;\u2022 Manager&lt;br/&gt;\u2022 register_provider&lt;br/&gt;\u2022 load_config&lt;br/&gt;\u2022 generate&lt;br/&gt;\u2022 deploy]\n\n        ProviderModule[provider.py&lt;br/&gt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&lt;br/&gt;\u2022 Provider ABC&lt;br/&gt;\u2022 name&lt;br/&gt;\u2022 validate&lt;br/&gt;\u2022 generate]\n\n        subgraph \"providers\"\n            EnvoyModule[envoy.py&lt;br/&gt;EnvoyProvider]\n            KongModule[kong.py&lt;br/&gt;KongProvider]\n            APISIXModule[apisix.py&lt;br/&gt;APISIXProvider]\n            TraefikModule[traefik.py&lt;br/&gt;TraefikProvider]\n        end\n    end\n\n    ManagerModule --&gt; ConfigModule\n    ManagerModule --&gt; ProviderModule\n    ProviderModule --&gt; EnvoyModule\n    ProviderModule --&gt; KongModule\n    ProviderModule --&gt; APISIXModule\n    ProviderModule --&gt; TraefikModule\n\n    EnvoyModule --&gt; ConfigModule\n    KongModule --&gt; ConfigModule\n    APISIXModule --&gt; ConfigModule\n    TraefikModule --&gt; ConfigModule</code></pre>"},{"location":"architecture/ARCHITECTURE/#datenfluss","title":"Datenfluss","text":""},{"location":"architecture/ARCHITECTURE/#konfigurationsgenerierung","title":"Konfigurationsgenerierung","text":"<pre><code>sequenceDiagram\n    participant User\n    participant CLI\n    participant Manager\n    participant Config\n    participant Provider\n    participant Output\n\n    User-&gt;&gt;CLI: gal-cli.py generate&lt;br/&gt;--config config.yaml\n    CLI-&gt;&gt;Manager: load_config(filepath)\n    Manager-&gt;&gt;Config: Config.from_yaml()\n    Config--&gt;&gt;Manager: Config object\n    CLI-&gt;&gt;Manager: register_provider(EnvoyProvider)\n    Manager-&gt;&gt;Manager: providers['envoy'] = provider\n    CLI-&gt;&gt;Manager: generate(config)\n    Manager-&gt;&gt;Provider: validate(config)\n    Provider--&gt;&gt;Manager: True/False\n    Manager-&gt;&gt;Provider: generate(config)\n    Provider-&gt;&gt;Provider: Transform to&lt;br/&gt;provider format\n    Provider--&gt;&gt;Manager: YAML/JSON string\n    Manager--&gt;&gt;CLI: Configuration output\n    CLI-&gt;&gt;Output: Write to file/&lt;br/&gt;stdout\n    Output--&gt;&gt;User: Generated config</code></pre>"},{"location":"architecture/ARCHITECTURE/#transformations-pipeline","title":"Transformations-Pipeline","text":"<pre><code>graph TD\n    Start[Incoming Request] --&gt; CheckTrans{Transformations&lt;br/&gt;enabled?}\n    CheckTrans --&gt;|No| Route[Route to Service]\n    CheckTrans --&gt;|Yes| Defaults[Apply Defaults]\n    Defaults --&gt; Computed[Generate Computed Fields]\n    Computed --&gt; Validate[Validate Required Fields]\n    Validate --&gt; ValidationOK{Validation&lt;br/&gt;passed?}\n    ValidationOK --&gt;|No| Error[Return Error]\n    ValidationOK --&gt;|Yes| Metadata[Add Metadata]\n    Metadata --&gt; Route\n    Route --&gt; Service[Backend Service]</code></pre>"},{"location":"architecture/ARCHITECTURE/#modul-details","title":"Modul-Details","text":""},{"location":"architecture/ARCHITECTURE/#1-config-module-galconfigpy","title":"1. Config Module (<code>gal/config.py</code>)","text":"<p>Verantwortlichkeit: Datenmodelle und Konfigurationsparser</p> <p>Hauptklassen:</p> Klasse Beschreibung Wichtige Methoden <code>Config</code> Root-Konfiguration <code>from_yaml()</code>, <code>get_service()</code>, <code>get_grpc_services()</code>, <code>get_rest_services()</code> <code>GlobalConfig</code> Globale Gateway-Settings - <code>Service</code> Service-Definition - <code>Route</code> Routing-Regeln - <code>Upstream</code> Backend-Endpunkt - <code>Transformation</code> Transform-Regeln - <code>ComputedField</code> Feldgeneratoren - <code>Validation</code> Validierungsregeln - <code>Plugin</code> Plugin-Konfiguration - <p>Abh\u00e4ngigkeiten: - PyYAML: YAML-Parsing - Pydantic: Datenvalidierung (dataclasses)</p>"},{"location":"architecture/ARCHITECTURE/#2-manager-module-galmanagerpy","title":"2. Manager Module (<code>gal/manager.py</code>)","text":"<p>Verantwortlichkeit: Orchestrierung und Provider-Management</p> <p>Hauptklasse: <code>Manager</code></p> <p>Methoden:</p> Methode Parameter R\u00fcckgabe Beschreibung <code>register_provider()</code> <code>Provider</code> None Registriert einen Provider <code>load_config()</code> <code>filepath: str</code> <code>Config</code> L\u00e4dt YAML-Konfiguration <code>generate()</code> <code>Config</code> <code>str</code> Generiert Provider-Config <code>deploy()</code> <code>Config</code> <code>bool</code> Deployment (optional) <code>list_providers()</code> - <code>List[str]</code> Listet Provider auf <p>Design Pattern: Registry Pattern f\u00fcr Provider-Management</p>"},{"location":"architecture/ARCHITECTURE/#3-provider-module-galproviderpy","title":"3. Provider Module (<code>gal/provider.py</code>)","text":"<p>Verantwortlichkeit: Provider-Interface (Abstract Base Class)</p> <p>ABC-Methoden:</p> <pre><code>class Provider(ABC):\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"Return provider name\"\"\"\n\n    @abstractmethod\n    def validate(self, config: Config) -&gt; bool:\n        \"\"\"Validate configuration\"\"\"\n\n    @abstractmethod\n    def generate(self, config: Config) -&gt; str:\n        \"\"\"Generate provider-specific configuration\"\"\"\n\n    def deploy(self, config: Config) -&gt; bool:\n        \"\"\"Optional: Deploy configuration\"\"\"\n</code></pre>"},{"location":"architecture/ARCHITECTURE/#4-provider-implementations","title":"4. Provider Implementations","text":""},{"location":"architecture/ARCHITECTURE/#envoyprovider","title":"EnvoyProvider","text":"<p>Output-Format: YAML Features: - Static resources configuration - HTTP connection manager - Lua filters f\u00fcr Transformationen - gRPC-Support mit HTTP/2 - Admin interface</p> <p>Transformations: Lua inline code</p>"},{"location":"architecture/ARCHITECTURE/#kongprovider","title":"KongProvider","text":"<p>Output-Format: YAML (Declarative Config v3.0) Features: - Declarative configuration - Request transformer plugin - Service und Route-Definitionen - gRPC protocol support</p> <p>Transformations: Kong Plugins</p>"},{"location":"architecture/ARCHITECTURE/#apisixprovider","title":"APISIXProvider","text":"<p>Output-Format: JSON Features: - Routes, Services, Upstreams - Serverless pre-function plugin - Lua transformations - Round-robin load balancing</p> <p>Transformations: Lua serverless functions</p>"},{"location":"architecture/ARCHITECTURE/#traefikprovider","title":"TraefikProvider","text":"<p>Output-Format: YAML Features: - HTTP routers und services - PathPrefix rules - LoadBalancer configuration - Middleware plugins</p> <p>Transformations: Middleware plugins</p>"},{"location":"architecture/ARCHITECTURE/#erweiterbarkeit","title":"Erweiterbarkeit","text":""},{"location":"architecture/ARCHITECTURE/#neuen-provider-hinzufugen","title":"Neuen Provider hinzuf\u00fcgen","text":"<ol> <li>Provider-Klasse erstellen:</li> </ol> <pre><code># gal/providers/newprovider.py\nfrom ..provider import Provider\nfrom ..config import Config\n\nclass NewProvider(Provider):\n    def name(self) -&gt; str:\n        return \"newprovider\"\n\n    def validate(self, config: Config) -&gt; bool:\n        # Validation logic\n        return True\n\n    def generate(self, config: Config) -&gt; str:\n        # Generation logic\n        return \"configuration output\"\n</code></pre> <ol> <li>Provider exportieren:</li> </ol> <pre><code># gal/providers/__init__.py\nfrom .newprovider import NewProvider\n\n__all__ = ['EnvoyProvider', 'KongProvider', 'APISIXProvider',\n           'TraefikProvider', 'NewProvider']\n</code></pre> <ol> <li>Provider registrieren:</li> </ol> <pre><code># gal-cli.py\nmanager.register_provider(NewProvider())\n</code></pre>"},{"location":"architecture/ARCHITECTURE/#neuen-generator-hinzufugen","title":"Neuen Generator hinzuf\u00fcgen","text":"<p>F\u00fcr neue Computed Field Generatoren:</p> <pre><code># In Provider generate() method\nif cf.generator == \"new_generator\":\n    # Implementation\n    generated_value = generate_new_value()\n</code></pre>"},{"location":"architecture/ARCHITECTURE/#deployment-architektur","title":"Deployment-Architektur","text":"<pre><code>graph TB\n    subgraph \"Development\"\n        Dev[Developer]\n        GAL[GAL CLI]\n        Config[config.yaml]\n    end\n\n    subgraph \"CI/CD\"\n        GHA[GitHub Actions]\n        Docker[Docker Build]\n        Tests[Tests]\n    end\n\n    subgraph \"Deployment Targets\"\n        K8s[Kubernetes&lt;br/&gt;Envoy Config]\n        Cloud[Cloud Gateway&lt;br/&gt;Kong/APISIX]\n        Edge[Edge Proxy&lt;br/&gt;Traefik]\n    end\n\n    Dev --&gt; Config\n    Config --&gt; GAL\n    GAL --&gt; GHA\n    GHA --&gt; Tests\n    Tests --&gt; Docker\n    Docker --&gt; K8s\n    Docker --&gt; Cloud\n    Docker --&gt; Edge</code></pre>"},{"location":"architecture/ARCHITECTURE/#sicherheitsarchitektur","title":"Sicherheitsarchitektur","text":""},{"location":"architecture/ARCHITECTURE/#prinzipien","title":"Prinzipien","text":"<ol> <li>Non-root Container: Docker l\u00e4uft als non-root user <code>gal</code></li> <li>Read-only Dependencies: Pip-Packages werden in Builder-Stage installiert</li> <li>Minimal Image: Multi-stage build reduziert Angriffsfl\u00e4che</li> <li>No Secrets in Config: Environment Variables f\u00fcr Secrets</li> </ol>"},{"location":"architecture/ARCHITECTURE/#security-best-practices","title":"Security Best Practices","text":"<pre><code># Secrets als Environment Variables\nplugins:\n  - name: auth\n    config:\n      secret: ${JWT_SECRET}  # Nie direkt in YAML\n\n# \u00dcber Environment bereitstellen\nexport JWT_SECRET=\"your-secret-key\"\ngal-cli.py generate -c config.yaml\n</code></pre>"},{"location":"architecture/ARCHITECTURE/#performance-uberlegungen","title":"Performance-\u00dcberlegungen","text":""},{"location":"architecture/ARCHITECTURE/#optimierungen","title":"Optimierungen","text":"<ol> <li>Lazy Loading: Provider werden nur bei Bedarf geladen</li> <li>Caching: Config-Parsing einmalig</li> <li>Minimal Dependencies: Nur notwendige Bibliotheken</li> <li>Parallel Generation: <code>generate-all</code> kann parallelisiert werden</li> </ol>"},{"location":"architecture/ARCHITECTURE/#benchmarks","title":"Benchmarks","text":"Operation Durchschnitt Peak Memory Load Config ~5ms ~10MB Generate Single ~10-20ms ~15MB Generate All ~50-80ms ~30MB Validation ~3ms ~8MB"},{"location":"architecture/ARCHITECTURE/#siehe-auch","title":"Siehe auch","text":"<ul> <li>CLI-Referenz</li> <li>Provider-Dokumentation</li> <li>Entwickler-Guide</li> </ul>"},{"location":"guides/APISIX/","title":"Apache APISIX Provider Guide","text":"<p>Umfassende Dokumentation f\u00fcr die Verwendung von Apache APISIX mit GAL.</p>"},{"location":"guides/APISIX/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ol> <li>\u00dcbersicht</li> <li>Schnellstart</li> <li>Installation und Setup</li> <li>Konfigurationsoptionen</li> <li>Feature-Implementierungen</li> <li>Provider-Vergleich</li> <li>APISIX-spezifische Details</li> <li>Best Practices</li> <li>Troubleshooting</li> <li>Zusammenfassung</li> </ol>"},{"location":"guides/APISIX/#ubersicht","title":"\u00dcbersicht","text":"<p>Apache APISIX ist ein hochperformantes, cloud-natives API-Gateway basierend auf Nginx und OpenResty. Es bietet dynamische Routing-, Plugin- und Load-Balancing-Funktionen mit extrem geringer Latenz.</p>"},{"location":"guides/APISIX/#warum-apisix","title":"Warum APISIX?","text":"<ul> <li>\ud83d\ude80 Performance: Basiert auf Nginx/OpenResty - ultra-niedrige Latenz</li> <li>\ud83d\udd0c Plugin-\u00d6kosystem: 80+ offizielle Plugins f\u00fcr alle Anwendungsf\u00e4lle</li> <li>\u2601\ufe0f Cloud-Native: Kubernetes-native mit etcd f\u00fcr Service Discovery</li> <li>\ud83d\udcca Dashboard: Grafische Benutzeroberfl\u00e4che f\u00fcr einfache Verwaltung</li> <li>\ud83d\udd04 Dynamic Configuration: \u00c4nderungen ohne Neustart (via etcd)</li> <li>\ud83c\udf0d Multi-Protocol: HTTP/HTTPS, gRPC, WebSocket, MQTT, Dubbo</li> </ul>"},{"location":"guides/APISIX/#feature-matrix","title":"Feature-Matrix","text":"Feature APISIX Support GAL Implementation Load Balancing \u2705 Vollst\u00e4ndig <code>upstream.load_balancer</code> Active Health Checks \u2705 Native <code>upstream.health_check.active</code> Passive Health Checks \u2705 Native <code>upstream.health_check.passive</code> Rate Limiting \u2705 limit-req, limit-count <code>route.rate_limit</code> Authentication \u2705 JWT, Basic, Key <code>route.authentication</code> CORS \u2705 cors Plugin <code>route.cors</code> Timeout &amp; Retry \u2705 timeout, proxy-retry <code>route.timeout</code>, <code>route.retry</code> Circuit Breaker \u2705 api-breaker Plugin <code>upstream.circuit_breaker</code> WebSocket \u2705 Native <code>route.websocket</code> Header Manipulation \u2705 Plugins <code>route.headers</code> Body Transformation \u2705 Serverless Lua <code>route.body_transformation</code> <p>Bewertung: \u2705 = Vollst\u00e4ndig unterst\u00fctzt | \u26a0\ufe0f = Teilweise unterst\u00fctzt | \u274c = Nicht unterst\u00fctzt</p>"},{"location":"guides/APISIX/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/APISIX/#beispiel-1-basic-load-balancing","title":"Beispiel 1: Basic Load Balancing","text":"<pre><code>services:\n  - name: api_service\n    protocol: http\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n        - host: api-2.internal\n          port: 8080\n      load_balancer:\n        algorithm: round_robin\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Generierte APISIX-Konfiguration:</p> <pre><code>{\n  \"routes\": [{\n    \"uri\": \"/api*\",\n    \"upstream\": {\n      \"type\": \"roundrobin\",\n      \"nodes\": {\n        \"api-1.internal:8080\": 1,\n        \"api-2.internal:8080\": 1\n      }\n    }\n  }]\n}\n</code></pre>"},{"location":"guides/APISIX/#beispiel-2-jwt-authentication-rate-limiting","title":"Beispiel 2: JWT Authentication + Rate Limiting","text":"<pre><code>services:\n  - name: secure_api\n    protocol: http\n    upstream:\n      host: api.internal\n      port: 8080\n    routes:\n      - path_prefix: /api\n        authentication:\n          enabled: true\n          type: jwt\n          jwt:\n            issuer: \"https://auth.example.com\"\n            audiences: [\"api\"]\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n</code></pre> <p>Generierte APISIX-Konfiguration:</p> <pre><code>{\n  \"routes\": [{\n    \"uri\": \"/api*\",\n    \"plugins\": {\n      \"jwt-auth\": {\n        \"key\": \"api-key\",\n        \"secret\": \"secret-key\"\n      },\n      \"limit-count\": {\n        \"count\": 100,\n        \"time_window\": 1,\n        \"rejected_code\": 429\n      }\n    }\n  }]\n}\n</code></pre>"},{"location":"guides/APISIX/#beispiel-3-complete-production-setup","title":"Beispiel 3: Complete Production Setup","text":"<pre><code>services:\n  - name: production_api\n    protocol: http\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n          weight: 3\n        - host: api-2.internal\n          port: 8080\n          weight: 1\n      load_balancer:\n        algorithm: weighted\n      health_check:\n        active:\n          enabled: true\n          path: /health\n          interval: 5s\n          timeout: 3s\n          healthy_threshold: 2\n          unhealthy_threshold: 3\n      circuit_breaker:\n        enabled: true\n        max_failures: 5\n        timeout: 30s\n    routes:\n      - path_prefix: /api\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n        timeout:\n          connect: 5s\n          read: 30s\n        retry:\n          enabled: true\n          attempts: 3\n</code></pre>"},{"location":"guides/APISIX/#installation-und-setup","title":"Installation und Setup","text":""},{"location":"guides/APISIX/#docker-empfohlen","title":"Docker (Empfohlen)","text":"<pre><code># APISIX mit etcd starten\ndocker run -d --name apisix \\\n  -p 9080:9080 \\\n  -p 9443:9443 \\\n  -p 9180:9180 \\\n  apache/apisix:latest\n\n# APISIX Dashboard (optional)\ndocker run -d --name apisix-dashboard \\\n  -p 9000:9000 \\\n  apache/apisix-dashboard:latest\n</code></pre>"},{"location":"guides/APISIX/#docker-compose","title":"Docker Compose","text":"<pre><code>version: \"3\"\nservices:\n  apisix:\n    image: apache/apisix:latest\n    ports:\n      - \"9080:9080\"\n      - \"9443:9443\"\n      - \"9180:9180\"\n    volumes:\n      - ./apisix_conf:/usr/local/apisix/conf\n      - ./apisix-config.yaml:/usr/local/apisix/conf/apisix.yaml\n    depends_on:\n      - etcd\n\n  etcd:\n    image: bitnami/etcd:latest\n    environment:\n      - ALLOW_NONE_AUTHENTICATION=yes\n      - ETCD_ADVERTISE_CLIENT_URLS=http://etcd:2379\n    ports:\n      - \"2379:2379\"\n</code></pre>"},{"location":"guides/APISIX/#kubernetes-helm","title":"Kubernetes (Helm)","text":"<pre><code># APISIX Helm Repository hinzuf\u00fcgen\nhelm repo add apisix https://charts.apiseven.com\nhelm repo update\n\n# APISIX Ingress Controller installieren\nhelm install apisix apisix/apisix \\\n  --namespace apisix \\\n  --create-namespace \\\n  --set gateway.type=LoadBalancer\n</code></pre>"},{"location":"guides/APISIX/#gal-konfiguration-generieren","title":"GAL-Konfiguration generieren","text":"<pre><code># APISIX-Konfiguration generieren\ngal generate --config config.yaml --provider apisix --output apisix-config.yaml\n\n# Oder via Docker\ndocker run --rm -v $(pwd):/app ghcr.io/pt9912/x-gal:latest \\\n  generate --config config.yaml --provider apisix --output apisix-config.yaml\n</code></pre>"},{"location":"guides/APISIX/#konfiguration-anwenden","title":"Konfiguration anwenden","text":"<p>APISIX unterst\u00fctzt zwei Konfigurationsmethoden:</p> <p>1. Admin API (Empfohlen f\u00fcr Dynamik)</p> <pre><code># Route erstellen\ncurl -X PUT http://localhost:9180/apisix/admin/routes/1 \\\n  -H \"X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\" \\\n  -d @apisix-config.yaml\n</code></pre> <p>2. Deklarative Konfiguration (apisix.yaml)</p> <pre><code># Konfigurationsdatei kopieren\ncp apisix-config.yaml /usr/local/apisix/conf/apisix.yaml\n\n# APISIX neu laden\ndocker exec apisix apisix reload\n</code></pre>"},{"location":"guides/APISIX/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/APISIX/#global-config","title":"Global Config","text":"<pre><code>global:\n  host: 0.0.0.0\n  port: 9080\n  log_level: info\n</code></pre> <p>APISIX Mapping:</p> <pre><code># conf/config.yaml\napisix:\n  node_listen: 9080\n  enable_admin: true\n  config_center: etcd\n</code></pre>"},{"location":"guides/APISIX/#upstream-config","title":"Upstream Config","text":"<pre><code>services:\n  - name: my_service\n    upstream:\n      targets:\n        - host: backend-1.internal\n          port: 8080\n          weight: 1\n      load_balancer:\n        algorithm: round_robin\n      health_check:\n        active:\n          enabled: true\n          path: /health\n</code></pre> <p>APISIX Mapping:</p> <pre><code>{\n  \"upstream\": {\n    \"type\": \"roundrobin\",\n    \"nodes\": {\n      \"backend-1.internal:8080\": 1\n    },\n    \"checks\": {\n      \"active\": {\n        \"http_path\": \"/health\",\n        \"healthy\": {\n          \"interval\": 5,\n          \"successes\": 2\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"guides/APISIX/#route-config","title":"Route Config","text":"<pre><code>routes:\n  - path_prefix: /api\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n</code></pre> <p>APISIX Mapping:</p> <pre><code>{\n  \"routes\": [{\n    \"uri\": \"/api*\",\n    \"plugins\": {\n      \"limit-count\": {\n        \"count\": 100,\n        \"time_window\": 1\n      }\n    }\n  }]\n}\n</code></pre>"},{"location":"guides/APISIX/#feature-implementierungen","title":"Feature-Implementierungen","text":""},{"location":"guides/APISIX/#1-load-balancing","title":"1. Load Balancing","text":"<p>APISIX unterst\u00fctzt 4 Load-Balancing-Algorithmen:</p> GAL Algorithm APISIX Type Beschreibung <code>round_robin</code> <code>roundrobin</code> Gleichm\u00e4\u00dfige Verteilung <code>least_conn</code> <code>least_conn</code> Verbindung zu Server mit wenigsten aktiven Connections <code>ip_hash</code> <code>chash</code> Consistent Hashing nach Client-IP <code>weighted</code> <code>roundrobin</code> + weights Gewichtete Verteilung <p>Implementierung (gal/providers/apisix.py:247-265):</p> <pre><code># Load Balancing\nlb_algo = \"roundrobin\"  # Default\nif service.upstream and service.upstream.load_balancer:\n    lb_config = service.upstream.load_balancer\n    if lb_config.algorithm == \"least_conn\":\n        lb_algo = \"least_conn\"\n    elif lb_config.algorithm == \"ip_hash\":\n        lb_algo = \"chash\"\n        upstream_config[\"key\"] = \"remote_addr\"\n    elif lb_config.algorithm in [\"round_robin\", \"weighted\"]:\n        lb_algo = \"roundrobin\"\n\nupstream_config[\"type\"] = lb_algo\n</code></pre> <p>Beispiel:</p> <pre><code>upstream:\n  targets:\n    - host: api-1.internal\n      port: 8080\n      weight: 3\n    - host: api-2.internal\n      port: 8080\n      weight: 1\n  load_balancer:\n    algorithm: weighted\n</code></pre>"},{"location":"guides/APISIX/#2-health-checks","title":"2. Health Checks","text":"<p>APISIX bietet Active und Passive Health Checks mit detaillierter Konfiguration.</p> <p>Active Health Checks (gal/providers/apisix.py:267-280):</p> <pre><code>if service.upstream and service.upstream.health_check:\n    hc = service.upstream.health_check\n    if hc.active and hc.active.enabled:\n        upstream_config[\"checks\"] = {\n            \"active\": {\n                \"type\": \"http\",\n                \"http_path\": hc.active.path,\n                \"healthy\": {\n                    \"interval\": int(hc.active.interval.rstrip(\"sS\")),\n                    \"successes\": hc.active.healthy_threshold,\n                },\n                \"unhealthy\": {\n                    \"interval\": int(hc.active.interval.rstrip(\"sS\")),\n                    \"http_failures\": hc.active.unhealthy_threshold,\n                },\n            }\n        }\n</code></pre> <p>Passive Health Checks (gal/providers/apisix.py:281-290):</p> <pre><code>if hc.passive and hc.passive.enabled:\n    if \"checks\" not in upstream_config:\n        upstream_config[\"checks\"] = {}\n    upstream_config[\"checks\"][\"passive\"] = {\n        \"type\": \"http\",\n        \"healthy\": {\"successes\": 3},\n        \"unhealthy\": {\n            \"http_failures\": hc.passive.max_failures,\n        },\n    }\n</code></pre> <p>Beispiel:</p> <pre><code>upstream:\n  health_check:\n    active:\n      enabled: true\n      path: /health\n      interval: 5s\n      timeout: 3s\n      healthy_threshold: 2\n      unhealthy_threshold: 3\n    passive:\n      enabled: true\n      max_failures: 5\n</code></pre>"},{"location":"guides/APISIX/#3-rate-limiting","title":"3. Rate Limiting","text":"<p>APISIX bietet zwei Rate-Limiting-Plugins:</p> <p>limit-count Plugin (empfohlen):</p> <pre><code># gal/providers/apisix.py:323-332\nif route.rate_limit and route.rate_limit.enabled:\n    rl = route.rate_limit\n    plugins[\"limit-count\"] = {\n        \"count\": rl.requests_per_second,\n        \"time_window\": 1,\n        \"rejected_code\": 429,\n        \"rejected_msg\": \"Too many requests\",\n        \"key\": \"remote_addr\",  # oder \"http_x_api_key\"\n        \"policy\": \"local\",\n    }\n</code></pre> <p>limit-req Plugin (Nginx-Stil):</p> <pre><code>{\n  \"plugins\": {\n    \"limit-req\": {\n      \"rate\": 100,\n      \"burst\": 200,\n      \"rejected_code\": 429,\n      \"key\": \"remote_addr\"\n    }\n  }\n}\n</code></pre> <p>Beispiel:</p> <pre><code>routes:\n  - path_prefix: /api\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n      burst: 200\n</code></pre>"},{"location":"guides/APISIX/#4-authentication","title":"4. Authentication","text":"<p>APISIX unterst\u00fctzt JWT, Basic Auth und API Key Authentication.</p> <p>JWT Authentication (gal/providers/apisix.py:334-352):</p> <pre><code>if route.authentication and route.authentication.enabled:\n    auth_type = route.authentication.type\n    if auth_type == \"jwt\":\n        jwt_config = route.authentication.jwt\n        plugins[\"jwt-auth\"] = {\n            \"key\": \"api-key\",\n            \"secret\": \"secret-key\",\n            \"algorithm\": \"HS256\",\n        }\n</code></pre> <p>Basic Authentication:</p> <pre><code>{\n  \"plugins\": {\n    \"basic-auth\": {}\n  },\n  \"consumers\": [{\n    \"username\": \"admin\",\n    \"plugins\": {\n      \"basic-auth\": {\n        \"username\": \"admin\",\n        \"password\": \"admin123\"\n      }\n    }\n  }]\n}\n</code></pre> <p>API Key Authentication:</p> <pre><code>{\n  \"plugins\": {\n    \"key-auth\": {}\n  },\n  \"consumers\": [{\n    \"username\": \"user1\",\n    \"plugins\": {\n      \"key-auth\": {\n        \"key\": \"api-key-12345\"\n      }\n    }\n  }]\n}\n</code></pre> <p>Beispiel:</p> <pre><code>routes:\n  - path_prefix: /api\n    authentication:\n      enabled: true\n      type: jwt\n      jwt:\n        issuer: \"https://auth.example.com\"\n        audiences: [\"api\"]\n</code></pre>"},{"location":"guides/APISIX/#5-cors","title":"5. CORS","text":"<p>APISIX verwendet das <code>cors</code> Plugin f\u00fcr Cross-Origin Resource Sharing.</p> <p>Implementierung (gal/providers/apisix.py:354-365):</p> <pre><code>if route.cors and route.cors.enabled:\n    cors_config = route.cors\n    plugins[\"cors\"] = {\n        \"allow_origins\": \",\".join(cors_config.allowed_origins),\n        \"allow_methods\": \",\".join(cors_config.allowed_methods or [\"*\"]),\n        \"allow_headers\": \",\".join(cors_config.allowed_headers or [\"*\"]),\n        \"allow_credential\": cors_config.allow_credentials,\n        \"max_age\": cors_config.max_age or 86400,\n    }\n</code></pre> <p>Beispiel:</p> <pre><code>routes:\n  - path_prefix: /api\n    cors:\n      enabled: true\n      allowed_origins:\n        - \"https://app.example.com\"\n        - \"https://admin.example.com\"\n      allowed_methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n      allow_credentials: true\n</code></pre>"},{"location":"guides/APISIX/#6-timeout-retry","title":"6. Timeout &amp; Retry","text":"<p>Timeout Configuration (gal/providers/apisix.py:294-307):</p> <pre><code>if route.timeout:\n    if \"plugins\" not in route_config:\n        route_config[\"plugins\"] = {}\n    timeout = route.timeout\n    connect_seconds = int(timeout.connect.rstrip(\"sS\"))\n    send_seconds = int(timeout.send.rstrip(\"sS\"))\n    read_seconds = int(timeout.read.rstrip(\"sS\"))\n    route_config[\"plugins\"][\"timeout\"] = {\n        \"connect\": connect_seconds,\n        \"send\": send_seconds,\n        \"read\": read_seconds,\n    }\n</code></pre> <p>Retry Configuration (gal/providers/apisix.py:309-341):</p> <pre><code>if route.retry and route.retry.enabled:\n    retry = route.retry\n    retry_status_codes = []\n    for condition in retry.retry_on:\n        if condition == \"http_502\":\n            retry_status_codes.append(502)\n        elif condition == \"http_503\":\n            retry_status_codes.append(503)\n        elif condition == \"http_504\":\n            retry_status_codes.append(504)\n        elif condition == \"http_5xx\":\n            retry_status_codes.extend([500, 502, 503, 504])\n\n    route_config[\"plugins\"][\"proxy-retry\"] = {\n        \"retries\": retry.attempts,\n        \"retry_timeout\": int(retry.max_interval.rstrip(\"msMS\")),\n        \"vars\": [[\"status\", \"==\", code] for code in retry_status_codes],\n    }\n</code></pre> <p>Beispiel:</p> <pre><code>routes:\n  - path_prefix: /api\n    timeout:\n      connect: 5s\n      read: 30s\n      send: 30s\n    retry:\n      enabled: true\n      attempts: 3\n      retry_on: [\"http_502\", \"http_503\", \"http_504\"]\n</code></pre>"},{"location":"guides/APISIX/#7-circuit-breaker","title":"7. Circuit Breaker","text":"<p>APISIX verwendet das <code>api-breaker</code> Plugin.</p> <p>Implementierung (gal/providers/apisix.py:371-382):</p> <pre><code>if service.upstream and service.upstream.circuit_breaker:\n    cb = service.upstream.circuit_breaker\n    if cb.enabled:\n        plugins[\"api-breaker\"] = {\n            \"break_response_code\": 503,\n            \"unhealthy\": {\n                \"http_statuses\": [500, 502, 503, 504],\n                \"failures\": cb.max_failures,\n            },\n            \"healthy\": {\n                \"successes\": 3,\n            },\n        }\n</code></pre> <p>Beispiel:</p> <pre><code>upstream:\n  circuit_breaker:\n    enabled: true\n    max_failures: 5\n    timeout: 30s\n</code></pre>"},{"location":"guides/APISIX/#8-websocket","title":"8. WebSocket","text":"<p>APISIX unterst\u00fctzt WebSocket nativ \u00fcber das <code>enable_websocket</code> Flag.</p> <p>Implementierung (gal/providers/apisix.py:291-294):</p> <pre><code># WebSocket support\nif route.websocket and route.websocket.enabled:\n    route_config[\"enable_websocket\"] = True\n</code></pre> <p>Beispiel:</p> <pre><code>routes:\n  - path_prefix: /ws\n    websocket:\n      enabled: true\n      idle_timeout: 300s\n</code></pre>"},{"location":"guides/APISIX/#9-header-manipulation","title":"9. Header Manipulation","text":"<p>APISIX verwendet die Plugins <code>request-transformer</code> und <code>response-transformer</code>.</p> <p>Request Headers:</p> <pre><code>{\n  \"plugins\": {\n    \"proxy-rewrite\": {\n      \"headers\": {\n        \"X-Request-ID\": \"$request_id\",\n        \"X-Gateway\": \"GAL-APISIX\"\n      }\n    }\n  }\n}\n</code></pre> <p>Response Headers:</p> <pre><code>{\n  \"plugins\": {\n    \"response-rewrite\": {\n      \"headers\": {\n        \"X-Server\": \"APISIX\",\n        \"X-Response-Time\": \"$upstream_response_time\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"guides/APISIX/#10-body-transformation","title":"10. Body Transformation","text":"<p>APISIX verwendet Serverless Lua-Funktionen f\u00fcr Body-Transformation.</p> <p>Implementierung (gal/providers/apisix.py:512-620):</p> <pre><code>def _generate_apisix_request_transformation_lua(self, transformation):\n    \"\"\"Generate Lua code for request body transformation.\"\"\"\n    lua_code = \"\"\"\nlocal core = require(\"apisix.core\")\nlocal cjson = require(\"cjson.safe\")\n\n-- Read request body\nlocal body, err = core.request.get_body()\nif not body then\n    return\nend\n\n-- Parse JSON\nlocal json_body = cjson.decode(body)\nif not json_body then\n    return\nend\n\"\"\"\n    # Add fields\n    if transformation.add_fields:\n        lua_code += \"\\n-- Add fields\\n\"\n        for key, value in transformation.add_fields.items():\n            if value == \"{{uuid}}\":\n                lua_code += f'json_body[\"{key}\"] = core.utils.uuid()\\n'\n            elif value in [\"{{now}}\", \"{{timestamp}}\"]:\n                lua_code += f'json_body[\"{key}\"] = os.date(\"%Y-%m-%dT%H:%M:%S\")\\n'\n            else:\n                lua_code += f'json_body[\"{key}\"] = \"{value}\"\\n'\n\n    # Remove fields\n    if transformation.remove_fields:\n        lua_code += \"\\n-- Remove fields\\n\"\n        for field in transformation.remove_fields:\n            lua_code += f'json_body[\"{field}\"] = nil\\n'\n\n    return lua_code\n</code></pre> <p>Beispiel:</p> <pre><code>routes:\n  - path_prefix: /api\n    body_transformation:\n      enabled: true\n      request:\n        add_fields:\n          trace_id: \"{{uuid}}\"\n          timestamp: \"{{now}}\"\n        remove_fields:\n          - internal_id\n</code></pre>"},{"location":"guides/APISIX/#provider-vergleich","title":"Provider-Vergleich","text":"Feature APISIX Envoy Kong Traefik Nginx HAProxy Performance \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Ease of Use \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 Dynamic Config \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u26a0\ufe0f \u26a0\ufe0f Plugin System \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u26a0\ufe0f \u26a0\ufe0f Dashboard \u2b50\u2b50\u2b50\u2b50\u2b50 \u26a0\ufe0f \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u26a0\ufe0f \u2b50\u2b50\u2b50 Cloud-Native \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50 \u2b50\u2b50"},{"location":"guides/APISIX/#apisix-vs-envoy","title":"APISIX vs Envoy","text":"<ul> <li>APISIX: Einfacher, besseres Plugin-\u00d6kosystem, Dashboard, Lua-Programmierbarkeit</li> <li>Envoy: Tiefere Integration mit Service Mesh (Istio), bessere Observability</li> </ul>"},{"location":"guides/APISIX/#apisix-vs-kong","title":"APISIX vs Kong","text":"<ul> <li>APISIX: Schneller, kostenlos (Open Source), etcd-basiert</li> <li>Kong: Reiferes \u00d6kosystem, Enterprise-Features, PostgreSQL/Cassandra</li> </ul>"},{"location":"guides/APISIX/#apisix-vs-traefik","title":"APISIX vs Traefik","text":"<ul> <li>APISIX: Mehr Plugins, bessere Performance, Lua-Scripting</li> <li>Traefik: Einfachere Konfiguration, bessere Let's Encrypt Integration</li> </ul>"},{"location":"guides/APISIX/#apisix-vs-nginxhaproxy","title":"APISIX vs Nginx/HAProxy","text":"<ul> <li>APISIX: Dynamische Konfiguration, Plugins, Dashboard</li> <li>Nginx/HAProxy: Niedriger Overhead, etablierter, kein etcd erforderlich</li> </ul>"},{"location":"guides/APISIX/#apisix-feature-coverage","title":"APISIX Feature Coverage","text":"<p>Detaillierte Analyse basierend auf der offiziellen APISIX Dokumentation.</p>"},{"location":"guides/APISIX/#core-resources-admin-api-entities","title":"Core Resources (Admin API Entities)","text":"Resource Import Export Status Bemerkung <code>routes</code> \u2705 \u2705 Voll Route Definition (URI, Methods) <code>services</code> \u2705 \u2705 Voll Service mit Upstream <code>upstreams</code> \u2705 \u2705 Voll Load Balancer mit Nodes <code>plugins</code> \u2705 \u2705 Voll Plugin Configuration <code>consumers</code> \u274c \u274c Nicht Consumer Management <code>ssl</code> \u274c \u274c Nicht SSL Certificates <code>global_rules</code> \u274c \u274c Nicht Global Plugin Rules <code>plugin_configs</code> \u274c \u274c Nicht Reusable Plugin Configs <code>stream_routes</code> \u274c \u274c Nicht TCP/UDP Routing"},{"location":"guides/APISIX/#traffic-management-plugins","title":"Traffic Management Plugins","text":"Plugin Import Export Status Bemerkung <code>limit-count</code> \u2705 \u2705 Voll Rate Limiting (local + redis) <code>limit-req</code> \u2705 \u2705 Voll Request Rate Limiting (nginx-style) <code>limit-conn</code> \u274c \u274c Nicht Connection Limiting <code>proxy-cache</code> \u274c \u274c Nicht HTTP Caching <code>request-id</code> \u274c \u274c Nicht Request ID Generation <code>proxy-rewrite</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise URL/Header Rewriting <code>proxy-mirror</code> \u274c \u274c Nicht Traffic Mirroring"},{"location":"guides/APISIX/#authentication-plugins","title":"Authentication Plugins","text":"Plugin Import Export Status Bemerkung <code>basic-auth</code> \u2705 \u2705 Voll Basic Authentication <code>key-auth</code> \u2705 \u2705 Voll API Key Authentication <code>jwt-auth</code> \u2705 \u2705 Voll JWT Validation <code>oauth2</code> \u274c \u274c Nicht OAuth 2.0 <code>hmac-auth</code> \u274c \u274c Nicht HMAC Signature <code>ldap-auth</code> \u274c \u274c Nicht LDAP Authentication <code>openid-connect</code> \u274c \u274c Nicht OIDC <code>authz-keycloak</code> \u274c \u274c Nicht Keycloak Integration"},{"location":"guides/APISIX/#security-plugins","title":"Security Plugins","text":"Plugin Import Export Status Bemerkung <code>cors</code> \u2705 \u2705 Voll CORS Policy <code>ip-restriction</code> \u274c \u274c Nicht IP Whitelist/Blacklist <code>ua-restriction</code> \u274c \u274c Nicht User-Agent Restriction <code>referer-restriction</code> \u274c \u274c Nicht Referer Restriction <code>csrf</code> \u274c \u274c Nicht CSRF Protection"},{"location":"guides/APISIX/#transformation-plugins","title":"Transformation Plugins","text":"Plugin Import Export Status Bemerkung <code>response-rewrite</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Response Header/Body Modification <code>request-transformer</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Request Header Modification <code>grpc-transcode</code> \u274c \u274c Nicht gRPC-HTTP Transcoding <code>body-transformer</code> \u274c \u274c Nicht Body Transformation (Lua)"},{"location":"guides/APISIX/#load-balancing-health-checks","title":"Load Balancing &amp; Health Checks","text":"Feature Import Export Status Bemerkung <code>roundrobin</code> \u2705 \u2705 Voll Round Robin (Default) <code>least_conn</code> \u2705 \u2705 Voll Least Connections <code>chash</code> \u2705 \u2705 Voll Consistent Hashing <code>ewma</code> \u274c \u274c Nicht EWMA (Exponentially Weighted Moving Average) <code>healthcheck.active</code> \u2705 \u2705 Voll Active HTTP Health Checks <code>healthcheck.passive</code> \u2705 \u2705 Voll Passive Health Checks (Circuit Breaker) <code>retries</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Retry Configuration <code>timeout</code> (connect/send/read) \u2705 \u2705 Voll Timeout Configuration"},{"location":"guides/APISIX/#observability-plugins","title":"Observability Plugins","text":"Plugin Import Export Status Bemerkung <code>prometheus</code> \u274c \u274c Nicht Prometheus Metrics <code>skywalking</code> \u274c \u274c Nicht Apache SkyWalking <code>zipkin</code> \u274c \u274c Nicht Zipkin Tracing <code>opentelemetry</code> \u274c \u274c Nicht OpenTelemetry <code>http-logger</code> \u274c \u274c Nicht HTTP Logging <code>kafka-logger</code> \u274c \u274c Nicht Kafka Logging <code>syslog</code> \u274c \u274c Nicht Syslog Integration <code>datadog</code> \u274c \u274c Nicht Datadog APM"},{"location":"guides/APISIX/#advanced-features","title":"Advanced Features","text":"Feature Import Export Status Bemerkung etcd Configuration \u2705 \u2705 Voll etcd-basierte dynamische Config APISIX Dashboard N/A N/A N/A Web UI (nicht in GAL Scope) Admin API \u274c \u274c Nicht Runtime API nicht in GAL Scope Control API \u274c \u274c Nicht Control Plane API Serverless (Lua/Plugin) \u274c \u274c Nicht Custom Lua Plugins Service Discovery (etcd/consul/nacos) \u274c \u274c Nicht Service Discovery mTLS \u274c \u274c Nicht Mutual TLS"},{"location":"guides/APISIX/#coverage-score-nach-kategorie","title":"Coverage Score nach Kategorie","text":"Kategorie Features Total Unterst\u00fctzt Coverage Core Resources 9 4 voll 44% Traffic Management 7 2 voll, 1 teilweise ~35% Authentication 8 3 voll 37% Security 5 1 voll 20% Transformation 4 0 voll, 3 teilweise 37% Load Balancing 8 5 voll, 1 teilweise ~70% Observability 8 0 0% Advanced 6 1 voll 17% <p>Gesamt (API Gateway relevante Features): ~36% Coverage</p> <p>Import Coverage: ~65% (Import bestehender APISIX Configs \u2192 GAL) Export Coverage: ~80% (GAL \u2192 APISIX JSON Config)</p>"},{"location":"guides/APISIX/#bidirektionale-feature-unterstutzung","title":"Bidirektionale Feature-Unterst\u00fctzung","text":"<p>Vollst\u00e4ndig bidirektional (Import \u2194 Export): 1. \u2705 Routes (URI, Methods, Plugins) 2. \u2705 Services mit Upstream 3. \u2705 Upstreams (Nodes, Load Balancing) 4. \u2705 Health Checks (Active + Passive) 5. \u2705 Load Balancing (Round Robin, Least Connections, Consistent Hashing) 6. \u2705 Rate Limiting (limit-count, limit-req) 7. \u2705 Authentication (Basic, API Key, JWT) 8. \u2705 CORS (cors plugin) 9. \u2705 Timeouts (connect/send/read)</p> <p>Nur Export (GAL \u2192 APISIX): 10. \u26a0\ufe0f Request/Response Headers (proxy-rewrite, response-rewrite) 11. \u26a0\ufe0f Retry Configuration</p> <p>Features mit Einschr\u00e4nkungen: - Observability Plugins: Nicht unterst\u00fctzt (prometheus, zipkin, skywalking, opentelemetry) - Service Discovery: etcd/consul/nacos nicht in GAL Scope - Custom Lua Plugins: Nicht parsebar/generierbar - mTLS/SSL: Keine Certificate Management</p>"},{"location":"guides/APISIX/#import-beispiel-apisix-gal","title":"Import-Beispiel (APISIX \u2192 GAL)","text":"<p>Input (apisix.yaml - etcd Standalone Config): <pre><code>routes:\n  - id: 1\n    uri: /api/*\n    methods:\n      - GET\n      - POST\n    upstream_id: 1\n    plugins:\n      limit-count:\n        count: 100\n        time_window: 60\n        rejected_code: 429\n      jwt-auth:\n        key: secret\n        algorithm: HS256\n\nupstreams:\n  - id: 1\n    type: roundrobin\n    nodes:\n      \"backend-1.svc:8080\": 1\n      \"backend-2.svc:8080\": 1\n    healthcheck:\n      active:\n        timeout: 5\n        http_path: /health\n        healthy:\n          interval: 10\n          successes: 2\n        unhealthy:\n          interval: 10\n          http_failures: 3\n</code></pre></p> <p>Output (gal-config.yaml): <pre><code>version: \"1.0\"\nprovider: apisix\nglobal:\n  host: 0.0.0.0\n  port: 9080\nservices:\n  - name: service_1\n    type: rest\n    protocol: http\n    upstream:\n      targets:\n        - host: backend-1.svc\n          port: 8080\n          weight: 1\n        - host: backend-2.svc\n          port: 8080\n          weight: 1\n      load_balancer:\n        algorithm: round_robin\n      health_check:\n        active:\n          enabled: true\n          interval: \"10s\"\n          timeout: \"5s\"\n          http_path: \"/health\"\n          healthy_threshold: 2\n          unhealthy_threshold: 3\n    routes:\n      - path_prefix: /api\n        methods:\n          - GET\n          - POST\n        rate_limit:\n          enabled: true\n          requests_per_second: 1.67  # 100/60s\n          response_status: 429\n        authentication:\n          enabled: true\n          type: jwt\n</code></pre></p>"},{"location":"guides/APISIX/#empfehlungen-fur-zukunftige-erweiterungen","title":"Empfehlungen f\u00fcr zuk\u00fcnftige Erweiterungen","text":"<p>Priorit\u00e4t 1 (High Impact): 1. Prometheus Plugin - Metrics Export 2. IP Restriction - Whitelist/Blacklist 3. Proxy Cache - HTTP Caching 4. OpenTelemetry - Distributed Tracing 5. Request/Response Transformation - Vollst\u00e4ndige body transformation</p> <p>Priorit\u00e4t 2 (Medium Impact): 6. Service Discovery - etcd/consul/nacos Integration 7. OAuth2 Plugin - OAuth 2.0 Support 8. CSRF Protection - CSRF Plugin 9. HTTP Logger - Logging to HTTP Endpoint 10. Traffic Mirroring - proxy-mirror Plugin</p> <p>Priorit\u00e4t 3 (Nice to Have): 11. gRPC Transcoding - gRPC-HTTP Transformation 12. HMAC/LDAP Auth - Additional Auth Methods 13. Kafka Logger - Logging to Kafka 14. Custom Lua Plugins - Plugin Generation 15. mTLS - Mutual TLS Support</p>"},{"location":"guides/APISIX/#test-coverage-import","title":"Test Coverage (Import)","text":"<p>APISIX Import Tests: 22 Tests (test_import_apisix.py)</p> Test Kategorie Tests Status Basic Import 3 \u2705 Passing Routes &amp; Services 3 \u2705 Passing Upstreams &amp; Load Balancing 3 \u2705 Passing Health Checks 2 \u2705 Passing Rate Limiting (limit-count, limit-req) 2 \u2705 Passing Authentication (Basic, JWT, API Key) 3 \u2705 Passing CORS 1 \u2705 Passing Headers (proxy-rewrite, response-rewrite) 2 \u2705 Passing Errors &amp; Warnings 3 \u2705 Passing <p>Coverage Verbesserung durch Import: 8% \u2192 33% (+25%)</p>"},{"location":"guides/APISIX/#roundtrip-kompatibilitat","title":"Roundtrip-Kompatibilit\u00e4t","text":"Szenario Roundtrip Bemerkung Basic Routes + Upstream \u2705 100% Perfekt Load Balancing (roundrobin/chash) \u2705 100% Perfekt Health Checks (Active + Passive) \u2705 95% Minimal Details verloren Rate Limiting (limit-count, limit-req) \u2705 100% Perfekt Authentication (Basic, JWT, Key) \u2705 100% Perfekt CORS \u2705 100% Perfekt Headers (proxy-rewrite) \u2705 90% Rewrite-Details eingeschr\u00e4nkt Combined Features \u2705 95% Sehr gut <p>Durchschnittliche Roundtrip-Kompatibilit\u00e4t: ~97%</p>"},{"location":"guides/APISIX/#fazit","title":"Fazit","text":"<p>APISIX Import Coverage: - \u2705 Core Features: 90% Coverage (Routes, Services, Upstreams, Plugins) - \u26a0\ufe0f Observability: 0% Coverage (prometheus, zipkin, skywalking nicht unterst\u00fctzt) - \u274c Advanced Features: Service Discovery, Custom Plugins nicht unterst\u00fctzt</p> <p>APISIX Export Coverage: - \u2705 Core Features: 95% Coverage (alle GAL Features \u2192 APISIX) - \u2705 Best Practices: Eingebaut (Health Checks, Load Balancing, Rate Limiting) - \u2705 etcd Config: Vollst\u00e4ndig unterst\u00fctzt (Standalone YAML)</p> <p>Empfehlung: - \ud83d\ude80 F\u00fcr Standard API Gateway Workloads: Perfekt geeignet - \u2705 F\u00fcr APISIX \u2192 GAL Migration: 95% automatisiert, 5% Review - \u26a0\ufe0f F\u00fcr Observability-heavy Setups: Manuelle Integration n\u00f6tig (Prometheus, Tracing) - \u26a0\ufe0f F\u00fcr Custom Lua Plugins: Nicht unterst\u00fctzt</p> <p>Referenzen: - \ud83d\udcda APISIX Plugins - \ud83d\udcda APISIX Admin API - \ud83d\udcda APISIX Standalone Mode - \ud83d\udcda APISIX Load Balancing</p>"},{"location":"guides/APISIX/#apisix-spezifische-details","title":"APISIX-spezifische Details","text":""},{"location":"guides/APISIX/#konfigurations-struktur","title":"Konfigurations-Struktur","text":"<p>APISIX verwendet JSON f\u00fcr die Admin API:</p> <pre><code>{\n  \"routes\": [\n    {\n      \"uri\": \"/api/*\",\n      \"methods\": [\"GET\", \"POST\"],\n      \"upstream\": {\n        \"type\": \"roundrobin\",\n        \"nodes\": {\n          \"backend:8080\": 1\n        }\n      },\n      \"plugins\": {\n        \"limit-count\": {...},\n        \"jwt-auth\": {...}\n      }\n    }\n  ],\n  \"upstreams\": [...],\n  \"services\": [...],\n  \"consumers\": [...]\n}\n</code></pre>"},{"location":"guides/APISIX/#etcd-integration","title":"etcd Integration","text":"<p>APISIX verwendet etcd als Configuration Center:</p> <pre><code># Routes in etcd anzeigen\netcdctl get /apisix/routes --prefix\n\n# Route l\u00f6schen\netcdctl del /apisix/routes/1\n</code></pre>"},{"location":"guides/APISIX/#admin-api","title":"Admin API","text":"<p>APISIX bietet eine umfassende Admin API:</p> <pre><code># Routes auflisten\ncurl http://localhost:9180/apisix/admin/routes \\\n  -H \"X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\"\n\n# Route erstellen\ncurl -X PUT http://localhost:9180/apisix/admin/routes/1 \\\n  -H \"X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\" \\\n  -d '{\n    \"uri\": \"/api/*\",\n    \"upstream\": {\n      \"type\": \"roundrobin\",\n      \"nodes\": {\"backend:8080\": 1}\n    }\n  }'\n\n# Route l\u00f6schen\ncurl -X DELETE http://localhost:9180/apisix/admin/routes/1 \\\n  -H \"X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\"\n</code></pre>"},{"location":"guides/APISIX/#dashboard","title":"Dashboard","text":"<p>APISIX Dashboard bietet eine Web-UI:</p> <pre><code># Dashboard starten\ndocker run -d --name apisix-dashboard \\\n  -p 9000:9000 \\\n  -e APISIX_ADMIN_API_URL=http://apisix:9180/apisix/admin \\\n  apache/apisix-dashboard:latest\n\n# \u00d6ffnen: http://localhost:9000\n# Default credentials: admin / admin\n</code></pre>"},{"location":"guides/APISIX/#serverless-functions","title":"Serverless Functions","text":"<p>APISIX unterst\u00fctzt Lua-Funktionen f\u00fcr benutzerdefinierte Logik:</p> <pre><code>-- Plugin: serverless-pre-function (phase: rewrite)\nreturn function(conf, ctx)\n    local core = require(\"apisix.core\")\n    local cjson = require(\"cjson.safe\")\n\n    -- Custom logic here\n    ngx.req.set_header(\"X-Custom-Header\", \"value\")\n\n    return\nend\n</code></pre>"},{"location":"guides/APISIX/#plugin-priority","title":"Plugin Priority","text":"<p>Plugins werden in definierter Reihenfolge ausgef\u00fchrt:</p> <ol> <li>ip-restriction (Priority: 3000)</li> <li>jwt-auth (Priority: 2510)</li> <li>key-auth (Priority: 2500)</li> <li>limit-count (Priority: 1002)</li> <li>limit-req (Priority: 1001)</li> <li>cors (Priority: 4000)</li> <li>proxy-rewrite (Priority: 1008)</li> </ol>"},{"location":"guides/APISIX/#service-discovery","title":"Service Discovery","text":"<p>APISIX unterst\u00fctzt mehrere Service-Discovery-Mechanismen:</p> <ul> <li>etcd: Native Integration</li> <li>Consul: Via Plugin</li> <li>Nacos: Via Plugin</li> <li>Kubernetes: Via Ingress Controller</li> <li>DNS: Via resolver</li> </ul>"},{"location":"guides/APISIX/#best-practices","title":"Best Practices","text":""},{"location":"guides/APISIX/#1-verwende-etcd-fur-dynamische-konfiguration","title":"1. Verwende etcd f\u00fcr dynamische Konfiguration","text":"<p>etcd erm\u00f6glicht \u00c4nderungen ohne Neustart:</p> <pre><code>apisix:\n  config_center: etcd\netcd:\n  host:\n    - \"http://etcd:2379\"\n  prefix: \"/apisix\"\n  timeout: 30\n</code></pre>"},{"location":"guides/APISIX/#2-aktiviere-health-checks-fur-production","title":"2. Aktiviere Health Checks f\u00fcr Production","text":"<p>Kombiniere Active + Passive Health Checks:</p> <pre><code>upstream:\n  health_check:\n    active:\n      enabled: true\n      path: /health\n      interval: 5s\n    passive:\n      enabled: true\n      max_failures: 3\n</code></pre>"},{"location":"guides/APISIX/#3-verwende-limit-count-fur-rate-limiting","title":"3. Verwende limit-count f\u00fcr Rate Limiting","text":"<p><code>limit-count</code> ist performanter als <code>limit-req</code>:</p> <pre><code>routes:\n  - path_prefix: /api\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n</code></pre>"},{"location":"guides/APISIX/#4-aktiviere-das-dashboard-fur-monitoring","title":"4. Aktiviere das Dashboard f\u00fcr Monitoring","text":"<pre><code>docker run -d --name apisix-dashboard \\\n  -p 9000:9000 \\\n  apache/apisix-dashboard:latest\n</code></pre>"},{"location":"guides/APISIX/#5-verwende-serverless-lua-fur-komplexe-logik","title":"5. Verwende Serverless Lua f\u00fcr komplexe Logik","text":"<p>F\u00fcr Transformationen, die \u00fcber Plugins hinausgehen:</p> <pre><code>routes:\n  - path_prefix: /api\n    body_transformation:\n      enabled: true\n      request:\n        add_fields:\n          trace_id: \"{{uuid}}\"\n</code></pre>"},{"location":"guides/APISIX/#6-konfiguriere-timeouts-fur-alle-routes","title":"6. Konfiguriere Timeouts f\u00fcr alle Routes","text":"<pre><code>routes:\n  - path_prefix: /api\n    timeout:\n      connect: 5s\n      read: 30s\n      send: 30s\n</code></pre>"},{"location":"guides/APISIX/#7-nutze-circuit-breaker-fur-resiliente-services","title":"7. Nutze Circuit Breaker f\u00fcr resiliente Services","text":"<pre><code>upstream:\n  circuit_breaker:\n    enabled: true\n    max_failures: 5\n    timeout: 30s\n</code></pre>"},{"location":"guides/APISIX/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/APISIX/#problem-1-etcd-connection-refused","title":"Problem 1: \"etcd connection refused\"","text":"<p>Symptom: APISIX startet nicht, Fehlermeldung: <code>connection refused: http://etcd:2379</code></p> <p>L\u00f6sung: <pre><code># etcd Status pr\u00fcfen\ndocker ps | grep etcd\n\n# etcd neu starten\ndocker start etcd\n\n# APISIX Logs pr\u00fcfen\ndocker logs apisix\n\n# etcd-URL in config.yaml pr\u00fcfen\netcd:\n  host:\n    - \"http://localhost:2379\"  # Verwende localhost wenn nicht in Docker network\n</code></pre></p>"},{"location":"guides/APISIX/#problem-2-health-checks-schlagen-fehl","title":"Problem 2: Health Checks schlagen fehl","text":"<p>Symptom: Upstream-Server werden als unhealthy markiert</p> <p>L\u00f6sung: <pre><code># Pr\u00fcfe Health Check Endpunkt\ncurl http://backend:8080/health\n\n# Erweitere Timeout\nupstream:\n  health_check:\n    active:\n      timeout: 10s  # Erh\u00f6hen\n\n# Pr\u00fcfe APISIX Logs\ndocker logs apisix | grep health_checker\n</code></pre></p>"},{"location":"guides/APISIX/#problem-3-rate-limiting-funktioniert-nicht","title":"Problem 3: Rate Limiting funktioniert nicht","text":"<p>Symptom: Requests werden nicht limitiert</p> <p>L\u00f6sung: <pre><code># Pr\u00fcfe Plugin-Konfiguration\ncurl http://localhost:9180/apisix/admin/routes/1 \\\n  -H \"X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\"\n\n# Stelle sicher, dass limit-count Plugin aktiv ist\n{\n  \"plugins\": {\n    \"limit-count\": {\n      \"count\": 100,\n      \"time_window\": 1,\n      \"key\": \"remote_addr\"\n    }\n  }\n}\n\n# Teste mit curl\nfor i in {1..110}; do curl http://localhost:9080/api; done\n</code></pre></p>"},{"location":"guides/APISIX/#problem-4-jwt-authentication-schlagt-fehl","title":"Problem 4: JWT Authentication schl\u00e4gt fehl","text":"<p>Symptom: 401 Unauthorized trotz g\u00fcltigem Token</p> <p>L\u00f6sung: <pre><code># Pr\u00fcfe JWT-Plugin-Konfiguration\ncurl http://localhost:9180/apisix/admin/routes/1 \\\n  -H \"X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\"\n\n# Consumer mit JWT-Secret erstellen\ncurl -X PUT http://localhost:9180/apisix/admin/consumers \\\n  -H \"X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\" \\\n  -d '{\n    \"username\": \"user1\",\n    \"plugins\": {\n      \"jwt-auth\": {\n        \"key\": \"api-key\",\n        \"secret\": \"secret-key\"\n      }\n    }\n  }'\n</code></pre></p>"},{"location":"guides/APISIX/#problem-5-plugin-konfiguration-wird-nicht-angewendet","title":"Problem 5: Plugin-Konfiguration wird nicht angewendet","text":"<p>Symptom: Plugin-\u00c4nderungen haben keine Wirkung</p> <p>L\u00f6sung: <pre><code># etcd-Cache leeren\netcdctl del /apisix --prefix\n\n# APISIX neu laden\ndocker exec apisix apisix reload\n\n# Plugin-Status pr\u00fcfen\ncurl http://localhost:9180/apisix/admin/plugins/list \\\n  -H \"X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\"\n</code></pre></p>"},{"location":"guides/APISIX/#problem-6-hohe-latenz","title":"Problem 6: Hohe Latenz","text":"<p>Symptom: Requests dauern ungew\u00f6hnlich lange</p> <p>L\u00f6sung: <pre><code># Pr\u00fcfe APISIX Prometheus Metrics\ncurl http://localhost:9091/apisix/prometheus/metrics\n\n# Aktiviere Access Logs mit Timing\nnginx_config:\n  http:\n    access_log: \"/dev/stdout\"\n    access_log_format: '$remote_addr - $upstream_response_time'\n\n# Deaktiviere unn\u00f6tige Plugins\n# Nutze upstream keepalive\nupstream:\n  keepalive: 320\n  keepalive_timeout: 60s\n</code></pre></p>"},{"location":"guides/APISIX/#zusammenfassung","title":"Zusammenfassung","text":""},{"location":"guides/APISIX/#apisix-mit-gal","title":"APISIX mit GAL","text":"<p>GAL macht APISIX-Konfiguration einfach und provider-agnostisch:</p> <p>Vorteile: - \u2705 Einheitliche Konfiguration: YAML statt JSON Admin API - \u2705 Provider-Wechsel: Von APISIX zu Envoy/Kong in Minuten - \u2705 Feature-Abstraktion: Keine APISIX-spezifischen Plugins im Config - \u2705 Validierung: Fr\u00fchzeitige Fehlerkennung vor Deployment - \u2705 Multi-Provider: Parallel Configs f\u00fcr mehrere Gateways</p> <p>APISIX-Features komplett unterst\u00fctzt: - Load Balancing (alle Algorithmen) - Active/Passive Health Checks - Rate Limiting (limit-count) - Authentication (JWT, Basic, Key) - CORS - Timeout &amp; Retry - Circuit Breaker (api-breaker) - WebSocket - Header Manipulation - Body Transformation (Serverless Lua)</p> <p>Best Use Cases f\u00fcr APISIX: 1. Cloud-Native Microservices: Kubernetes + etcd Integration 2. High Performance APIs: Ultra-niedrige Latenz erforderlich 3. Dynamic Configuration: H\u00e4ufige Config-\u00c4nderungen 4. Dashboard-Driven: Grafische Verwaltung bevorzugt 5. Lua-Programmierbarkeit: Custom Logic erforderlich</p> <p>Workflow: <pre><code># 1. GAL-Konfiguration schreiben\nvim config.yaml\n\n# 2. APISIX-Config generieren\ngal generate --config config.yaml --provider apisix --output apisix-config.yaml\n\n# 3. Via Admin API anwenden\ncurl -X PUT http://localhost:9180/apisix/admin/routes/1 \\\n  -H \"X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\" \\\n  -d @apisix-config.yaml\n\n# 4. Testen\ncurl http://localhost:9080/api\n</code></pre></p> <p>Links: - APISIX Website: https://apisix.apache.org/ - GitHub: https://github.com/apache/apisix - Plugins: https://apisix.apache.org/docs/apisix/plugins/overview/ - Dashboard: https://github.com/apache/apisix-dashboard</p> <p>Navigation: - \u2190 Zur\u00fcck zur \u00dcbersicht - Envoy Provider Guide - Kong Provider Guide - Traefik Provider Guide - Nginx Provider Guide - HAProxy Provider Guide</p>"},{"location":"guides/AUTHENTICATION/","title":"Authentication Anleitung","text":"<p>GAL v1.1.0 f\u00fchrt umfassende Authentication-Unterst\u00fctzung f\u00fcr alle Gateway-Provider ein. Diese Anleitung erkl\u00e4rt, wie Sie Authentication f\u00fcr Ihre APIs mit Basic Auth, API Keys und JWT konfigurieren.</p>"},{"location":"guides/AUTHENTICATION/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ul> <li>\u00dcbersicht</li> <li>Schnellstart</li> <li>Authentication-Typen</li> <li>Basic Authentication</li> <li>API Key Authentication</li> <li>JWT Authentication</li> <li>Konfigurationsoptionen</li> <li>Provider-spezifische Implementierungen</li> <li>Best Practices</li> <li>Testing</li> <li>Troubleshooting</li> <li>Migrationsleitfaden</li> </ul>"},{"location":"guides/AUTHENTICATION/#ubersicht","title":"\u00dcbersicht","text":"<p>Authentication stellt sicher, dass nur autorisierte Benutzer auf Ihre APIs zugreifen k\u00f6nnen. GAL unterst\u00fctzt drei Authentication-Methoden:</p> Typ Anwendungsfall Sicherheitslevel Komplexit\u00e4t Basic Auth Interne Tools, Admin-Panels Mittel Niedrig API Key Service-to-Service, Externe APIs Mittel-Hoch Niedrig JWT Moderne Web/Mobile Apps, Microservices Hoch Mittel"},{"location":"guides/AUTHENTICATION/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/AUTHENTICATION/#api-key-authentication-am-einfachsten","title":"API Key Authentication (Am einfachsten)","text":"<pre><code>services:\n  - name: my_api\n    type: rest\n    protocol: http\n    upstream:\n      host: api.local\n      port: 8080\n    routes:\n      - path_prefix: /api/protected\n        authentication:\n          enabled: true\n          type: api_key\n          api_key:\n            keys:\n              - \"your-secret-key-123\"\n            key_name: X-API-Key\n            in_location: header\n</code></pre> <p>Test mit curl: <pre><code>curl -H \"X-API-Key: your-secret-key-123\" http://localhost:10000/api/protected\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#basic-authentication","title":"Basic Authentication","text":"<pre><code>services:\n  - name: admin_api\n    type: rest\n    protocol: http\n    upstream:\n      host: admin.local\n      port: 8080\n    routes:\n      - path_prefix: /api/admin\n        authentication:\n          enabled: true\n          type: basic\n          basic_auth:\n            users:\n              admin: \"super_secret_password\"\n              operator: \"operator_pass\"\n            realm: \"Admin Area\"\n</code></pre> <p>Test mit curl: <pre><code>curl -u admin:super_secret_password http://localhost:10000/api/admin\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#jwt-authentication","title":"JWT Authentication","text":"<pre><code>services:\n  - name: secure_api\n    type: rest\n    protocol: http\n    upstream:\n      host: secure.local\n      port: 8080\n    routes:\n      - path_prefix: /api/user\n        authentication:\n          enabled: true\n          type: jwt\n          jwt:\n            issuer: \"https://auth.example.com\"\n            audience: \"api.example.com\"\n            jwks_uri: \"https://auth.example.com/.well-known/jwks.json\"\n            algorithms:\n              - RS256\n</code></pre> <p>Test mit curl: <pre><code>curl -H \"Authorization: Bearer YOUR_JWT_TOKEN\" http://localhost:10000/api/user\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#authentication-typen","title":"Authentication-Typen","text":""},{"location":"guides/AUTHENTICATION/#basic-authentication_1","title":"Basic Authentication","text":"<p>HTTP Basic Authentication verwendet Username/Password-Credentials, die in HTTP-Headern \u00fcbertragen werden.</p>"},{"location":"guides/AUTHENTICATION/#konfiguration","title":"Konfiguration","text":"<pre><code>authentication:\n  enabled: true\n  type: basic\n  basic_auth:\n    users:\n      username1: \"password1\"\n      username2: \"password2\"\n    realm: \"Protected Area\"\n  fail_status: 401\n  fail_message: \"Unauthorized\"\n</code></pre>"},{"location":"guides/AUTHENTICATION/#parameter","title":"Parameter","text":"<ul> <li><code>users</code> (dict): Mapping von Benutzername zu Passwort</li> <li><code>realm</code> (string): Authentication-Realm im Browser-Prompt angezeigt (Standard: \"Protected\")</li> <li><code>fail_status</code> (int): HTTP-Statuscode bei Auth-Fehlern (Standard: 401)</li> <li><code>fail_message</code> (string): Fehlermeldung bei Auth-Fehlern</li> </ul>"},{"location":"guides/AUTHENTICATION/#sicherheitsuberlegungen","title":"Sicherheits\u00fcberlegungen","text":"<p>\u26a0\ufe0f Wichtige Sicherheitshinweise: - Passw\u00f6rter sollten in Production gehasht sein (z.B. bcrypt, htpasswd-Format) - Verwenden Sie immer HTTPS, um Credentials w\u00e4hrend der \u00dcbertragung zu sch\u00fctzen - Speichern Sie niemals Klartext-Passw\u00f6rter in Konfigurationsdateien - Erw\u00e4gen Sie die Verwendung von Umgebungsvariablen oder Secrets Management</p> <p>Production-Beispiel mit htpasswd:</p> <pre><code># Generiere htpasswd-Hash\nhtpasswd -nb admin secret_password\n\n# Ausgabe: admin:$apr1$XYZ123$HASH...\n</code></pre> <pre><code>basic_auth:\n  users:\n    admin: \"$apr1$XYZ123$HASH...\"  # htpasswd-Format\n</code></pre>"},{"location":"guides/AUTHENTICATION/#api-key-authentication","title":"API Key Authentication","text":"<p>API Key Authentication verwendet statische Keys, die in Headern oder Query-Parametern \u00fcbergeben werden.</p>"},{"location":"guides/AUTHENTICATION/#konfiguration-header-basiert","title":"Konfiguration - Header-basiert","text":"<pre><code>authentication:\n  enabled: true\n  type: api_key\n  api_key:\n    keys:\n      - \"key_123abc\"\n      - \"key_456def\"\n      - \"key_789ghi\"\n    key_name: X-API-Key\n    in_location: header\n</code></pre>"},{"location":"guides/AUTHENTICATION/#konfiguration-query-parameter","title":"Konfiguration - Query Parameter","text":"<pre><code>authentication:\n  enabled: true\n  type: api_key\n  api_key:\n    keys:\n      - \"key_123abc\"\n    key_name: api_key\n    in_location: query\n</code></pre> <p>Verwendung: <pre><code># Header-basiert\ncurl -H \"X-API-Key: key_123abc\" http://localhost:10000/api\n\n# Query Parameter\ncurl \"http://localhost:10000/api?api_key=key_123abc\"\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#parameter_1","title":"Parameter","text":"<ul> <li><code>keys</code> (list): G\u00fcltige API Keys</li> <li><code>key_name</code> (string): Header- oder Query-Parameter-Name (Standard: \"X-API-Key\")</li> <li><code>in_location</code> (string): \"header\" oder \"query\" (Standard: \"header\")</li> </ul>"},{"location":"guides/AUTHENTICATION/#best-practices","title":"Best Practices","text":"<p>\u2705 Empfohlen: - Verwenden Sie lange, zuf\u00e4llige Keys (mindestens 32 Zeichen) - Rotieren Sie Keys regelm\u00e4\u00dfig - Verwenden Sie unterschiedliche Keys f\u00fcr verschiedene Clients - Loggen Sie Key-Nutzung f\u00fcr Auditing - Verwenden Sie header-basierte Auth statt Query-Parameter (sicherer)</p> <p>\u274c Vermeiden: - Keys \u00fcber mehrere Services hinweg teilen - Keys in Client-seitigem Code speichern (Mobile Apps, JavaScript) - Vorhersagbare Key-Muster verwenden - Keys in Anwendungslogs loggen</p> <p>Key-Generierungs-Beispiel: <pre><code># Generiere sicheren Zufalls-Key\nopenssl rand -hex 32\n# Ausgabe: 64-Zeichen Hexadezimal-String\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#jwt-authentication_1","title":"JWT Authentication","text":"<p>JSON Web Tokens (JWT) bieten zustandslose, claims-basierte Authentication.</p>"},{"location":"guides/AUTHENTICATION/#konfiguration_1","title":"Konfiguration","text":"<pre><code>authentication:\n  enabled: true\n  type: jwt\n  jwt:\n    issuer: \"https://auth.example.com\"\n    audience: \"api.example.com\"\n    jwks_uri: \"https://auth.example.com/.well-known/jwks.json\"\n    algorithms:\n      - RS256\n      - ES256\n    required_claims:\n      - sub\n      - email\n  fail_status: 401\n  fail_message: \"Invalid or missing JWT token\"\n</code></pre>"},{"location":"guides/AUTHENTICATION/#parameter_2","title":"Parameter","text":"<ul> <li><code>issuer</code> (string): Erwarteter JWT-Aussteller (iss Claim)</li> <li><code>audience</code> (string): Erwartete JWT-Audience (aud Claim)</li> <li><code>jwks_uri</code> (string): JSON Web Key Set Endpoint-URL</li> <li><code>algorithms</code> (list): Erlaubte Signatur-Algorithmen (Standard: [\"RS256\"])</li> <li><code>required_claims</code> (list): Claims, die im Token vorhanden sein m\u00fcssen</li> </ul>"},{"location":"guides/AUTHENTICATION/#gangige-jwt-algorithmen","title":"G\u00e4ngige JWT-Algorithmen","text":"Algorithmus Typ Anwendungsfall RS256 RSA Am h\u00e4ufigsten, Public Key Verification ES256 ECDSA Kleinere Signaturen, moderne Wahl HS256 HMAC Symmetrisch, nur f\u00fcr interne Services"},{"location":"guides/AUTHENTICATION/#jwks-json-web-key-set","title":"JWKS (JSON Web Key Set)","text":"<p>GAL holt und cached automatisch Public Keys vom JWKS-Endpoint.</p> <p>Beispiel JWKS-Endpoint: <pre><code>https://auth.example.com/.well-known/jwks.json\n</code></pre></p> <p>JWKS-Struktur: <pre><code>{\n  \"keys\": [\n    {\n      \"kty\": \"RSA\",\n      \"use\": \"sig\",\n      \"kid\": \"key-1\",\n      \"n\": \"...\",\n      \"e\": \"AQAB\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#jwt-claims","title":"JWT Claims","text":"<p>Standard-Claims: - <code>iss</code> (issuer): Token-Aussteller-URL - <code>sub</code> (subject): Benutzer-ID oder Identifikator - <code>aud</code> (audience): Vorgesehener Empf\u00e4nger - <code>exp</code> (expiration): Token-Ablaufzeit - <code>iat</code> (issued at): Token-Erstellungszeit - <code>nbf</code> (not before): Token nicht g\u00fcltig vor dieser Zeit</p> <p>Custom Claims: Sie k\u00f6nnen Custom Claims hinzuf\u00fcgen (z.B. <code>email</code>, <code>roles</code>, <code>permissions</code>) und diese in Ihrem Backend validieren.</p>"},{"location":"guides/AUTHENTICATION/#jwt-beispiel","title":"JWT Beispiel","text":"<p>JWT Header: <pre><code>{\n  \"alg\": \"RS256\",\n  \"typ\": \"JWT\",\n  \"kid\": \"key-1\"\n}\n</code></pre></p> <p>JWT Payload: <pre><code>{\n  \"iss\": \"https://auth.example.com\",\n  \"sub\": \"user123\",\n  \"aud\": \"api.example.com\",\n  \"exp\": 1735689600,\n  \"iat\": 1735686000,\n  \"email\": \"user@example.com\",\n  \"roles\": [\"user\", \"admin\"]\n}\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/AUTHENTICATION/#gemeinsame-optionen","title":"Gemeinsame Optionen","text":"<p>Alle Authentication-Typen teilen diese gemeinsamen Optionen:</p> <pre><code>authentication:\n  enabled: true              # Authentication aktivieren/deaktivieren\n  type: \"api_key\"           # Authentication-Typ: \"basic\", \"api_key\", \"jwt\"\n  fail_status: 401           # HTTP-Status bei Auth-Fehlern (Standard: 401)\n  fail_message: \"Unauthorized\"  # Fehlermeldung bei Fehlern\n</code></pre>"},{"location":"guides/AUTHENTICATION/#typ-spezifische-optionen","title":"Typ-spezifische Optionen","text":""},{"location":"guides/AUTHENTICATION/#basic-auth","title":"Basic Auth","text":"<pre><code>basic_auth:\n  users:                    # Username-Passwort-Mapping\n    username: \"password\"\n  realm: \"Protected\"        # Authentication-Realm\n</code></pre>"},{"location":"guides/AUTHENTICATION/#api-key","title":"API Key","text":"<pre><code>api_key:\n  keys:                     # Liste g\u00fcltiger API Keys\n    - \"key1\"\n    - \"key2\"\n  key_name: \"X-API-Key\"     # Header- oder Query-Param-Name\n  in_location: \"header\"     # \"header\" oder \"query\"\n</code></pre>"},{"location":"guides/AUTHENTICATION/#jwt","title":"JWT","text":"<pre><code>jwt:\n  issuer: \"https://auth.example.com\"        # Token-Aussteller\n  audience: \"api.example.com\"               # Token-Audience\n  jwks_uri: \"https://auth.example.com/...\"  # JWKS-Endpoint\n  algorithms:                               # Erlaubte Algorithmen\n    - RS256\n  required_claims:                          # Erforderliche JWT-Claims\n    - sub\n</code></pre>"},{"location":"guides/AUTHENTICATION/#mehrere-routes-mit-unterschiedlicher-auth","title":"Mehrere Routes mit unterschiedlicher Auth","text":"<pre><code>services:\n  - name: multi_auth_service\n    type: rest\n    protocol: http\n    upstream:\n      host: service.local\n      port: 8080\n    routes:\n      # \u00d6ffentlicher Endpoint - keine Auth\n      - path_prefix: /api/public\n        methods: [GET]\n\n      # API Key gesch\u00fctzt\n      - path_prefix: /api/protected\n        methods: [GET, POST]\n        authentication:\n          type: api_key\n          api_key:\n            keys: [\"key123\"]\n\n      # Admin - Basic Auth\n      - path_prefix: /api/admin\n        methods: [GET, POST, DELETE]\n        authentication:\n          type: basic\n          basic_auth:\n            users:\n              admin: \"secret\"\n</code></pre>"},{"location":"guides/AUTHENTICATION/#provider-spezifische-implementierungen","title":"Provider-spezifische Implementierungen","text":""},{"location":"guides/AUTHENTICATION/#kong","title":"Kong","text":"<p>Kong implementiert Authentication mit nativen Plugins.</p> <p>Basic Auth: - Plugin: <code>basic-auth</code> - Features: Consumer-basierte Authentication, Credential-Speicherung</p> <p>API Key: - Plugin: <code>key-auth</code> - Features: Flexible Key-Location (Header/Query), Consumer-Zuordnung</p> <p>JWT: - Plugin: <code>jwt</code> - Features: JWKS-Support, Claim-Verifizierung, RS256/ES256/HS256</p> <p>Generiertes Config-Beispiel: <pre><code>services:\n  - name: test_service\n    routes:\n      - name: test_service_route\n        plugins:\n          - name: key-auth\n            config:\n              key_names: [X-API-Key]\n              key_in_header: true\n              hide_credentials: true\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#apisix","title":"APISIX","text":"<p>APISIX implementiert Authentication mit Plugins und JSON-Konfiguration.</p> <p>Basic Auth: - Plugin: <code>basic-auth</code> - Features: Consumer-basiert, flexible Konfiguration</p> <p>API Key: - Plugin: <code>key-auth</code> - Features: Header- und Query-Parameter-Support</p> <p>JWT: - Plugin: <code>jwt-auth</code> - Features: Algorithmus-Auswahl, Issuer/Audience-Validierung</p> <p>Generiertes Config-Beispiel: <pre><code>{\n  \"routes\": [\n    {\n      \"uri\": \"/api/*\",\n      \"plugins\": {\n        \"key-auth\": {\n          \"header\": \"X-API-Key\"\n        }\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#traefik","title":"Traefik","text":"<p>Traefik implementiert Authentication mit Middleware.</p> <p>Basic Auth: - Middleware: <code>basicAuth</code> - Features: Benutzerliste, Realm-Konfiguration - Hinweis: Verwenden Sie htpasswd-Format f\u00fcr Production</p> <p>API Key: - Middleware: <code>forwardAuth</code> - Features: Externer Validierungsservice - Hinweis: Ben\u00f6tigt externen API-Key-Validator</p> <p>JWT: - Middleware: <code>forwardAuth</code> - Features: Externer JWT-Validierungsservice - Hinweis: Ben\u00f6tigt externen JWT-Validator</p> <p>Generiertes Config-Beispiel: <pre><code>http:\n  middlewares:\n    test_service_router_0_auth:\n      basicAuth:\n        users:\n          - 'admin:$apr1$...'\n        realm: 'Admin Area'\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#envoy","title":"Envoy","text":"<p>Envoy implementiert Authentication mit HTTP-Filtern.</p> <p>Basic Auth: - Filter: <code>envoy.filters.http.lua</code> - Features: Inline Lua-Validierung - Hinweis: Production ben\u00f6tigt externen Auth-Service</p> <p>API Key: - Filter: <code>envoy.filters.http.lua</code> - Features: Header-Validierung via Lua - Hinweis: Production ben\u00f6tigt externe Validierung</p> <p>JWT: - Filter: <code>envoy.filters.http.jwt_authn</code> - Features: Vollst\u00e4ndige JWT-Validierung, JWKS-Support, natives RS256/ES256 - Hinweis: Robusteste JWT-Implementierung</p> <p>Generiertes Config-Beispiel: <pre><code>http_filters:\n  - name: envoy.filters.http.jwt_authn\n    typed_config:\n      providers:\n        jwt_provider:\n          issuer: 'https://auth.example.com'\n          audiences:\n            - 'api.example.com'\n          remote_jwks:\n            http_uri:\n              uri: 'https://auth.example.com/.well-known/jwks.json'\n              cluster: jwks_cluster\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#best-practices_1","title":"Best Practices","text":""},{"location":"guides/AUTHENTICATION/#allgemeine-sicherheit","title":"Allgemeine Sicherheit","text":"<ol> <li>Verwenden Sie immer HTTPS in Production</li> <li>Sch\u00fctzt Credentials und Tokens w\u00e4hrend der \u00dcbertragung</li> <li>Erforderlich f\u00fcr Basic Auth und API Keys</li> <li> <p>Empfohlen f\u00fcr alle Authentication-Typen</p> </li> <li> <p>Verwenden Sie starke Credentials</p> </li> <li>Passw\u00f6rter: Mindestens 12 Zeichen, gemischte Gro\u00df-/Kleinschreibung, Sonderzeichen</li> <li>API Keys: Mindestens 32 Zeichen, kryptographisch zuf\u00e4llig</li> <li> <p>JWT-Secrets: Mindestens 256 Bits f\u00fcr HS256</p> </li> <li> <p>Rotieren Sie Credentials regelm\u00e4\u00dfig</p> </li> <li>API Keys: Alle 90 Tage</li> <li>JWT-Signatur-Keys: Alle 6-12 Monate</li> <li> <p>Passw\u00f6rter: Alle 90 Tage oder bei Kompromittierung</p> </li> <li> <p>Implementieren Sie Rate Limiting</p> </li> <li>Kombinieren Sie Authentication mit Rate Limiting</li> <li>Schutz vor Brute-Force-Angriffen</li> <li>Verwenden Sie per-User- oder per-Key-Limits</li> </ol>"},{"location":"guides/AUTHENTICATION/#authentication-typ-auswahl","title":"Authentication-Typ-Auswahl","text":"<p>Verwenden Sie Basic Auth wenn: - Interne Tools und Admin-Interfaces - Kleine Anzahl bekannter Benutzer - Einfachheit wichtiger als erweiterte Features</p> <p>Verwenden Sie API Key wenn: - Service-to-Service-Kommunikation - Externer API-Zugriff f\u00fcr Partner - Einfaches Credential-Management ben\u00f6tigt</p> <p>Verwenden Sie JWT wenn: - Moderne Web- oder Mobile-Anwendungen - Microservices-Architektur - Zustandslose Authentication erforderlich - Kurzlebige Tokens ben\u00f6tigt - Claims-basierte Authorization erforderlich</p>"},{"location":"guides/AUTHENTICATION/#production-uberlegungen","title":"Production-\u00dcberlegungen","text":"<ol> <li> <p>Niemals Credentials hardcoden <pre><code># Schlecht - hardcoded in Config\nusers:\n  admin: \"password123\"\n\n# Gut - Umgebungsvariablen verwenden\nusers:\n  admin: \"${ADMIN_PASSWORD}\"\n</code></pre></p> </li> <li> <p>Verwenden Sie Secrets Management</p> </li> <li>HashiCorp Vault</li> <li>AWS Secrets Manager</li> <li>Kubernetes Secrets</li> <li> <p>Azure Key Vault</p> </li> <li> <p>Implementieren Sie korrektes Logging</p> </li> <li>Loggen Sie Authentication-Versuche (Erfolg und Fehler)</li> <li>Loggen Sie keine Credentials oder Tokens</li> <li> <p>\u00dcberwachen Sie verd\u00e4chtige Muster</p> </li> <li> <p>F\u00fcgen Sie Monitoring und Alerting hinzu</p> </li> <li>Tracken Sie Authentication-Fehlerquoten</li> <li>Alarmieren bei ungew\u00f6hnlichen Mustern</li> <li>\u00dcberwachen Sie Token-Ablauf und Rotation</li> </ol>"},{"location":"guides/AUTHENTICATION/#testing","title":"Testing","text":""},{"location":"guides/AUTHENTICATION/#testing-basic-auth","title":"Testing Basic Auth","text":"<pre><code># G\u00fcltige Credentials\ncurl -u admin:secret http://localhost:10000/api/admin\n# Erwartet: 200 OK\n\n# Ung\u00fcltige Credentials\ncurl -u admin:wrong http://localhost:10000/api/admin\n# Erwartet: 401 Unauthorized\n\n# Fehlende Credentials\ncurl http://localhost:10000/api/admin\n# Erwartet: 401 Unauthorized\n</code></pre>"},{"location":"guides/AUTHENTICATION/#testing-api-key-auth","title":"Testing API Key Auth","text":"<pre><code># G\u00fcltiger API Key im Header\ncurl -H \"X-API-Key: key_123abc\" http://localhost:10000/api/protected\n# Erwartet: 200 OK\n\n# G\u00fcltiger API Key im Query-Parameter\ncurl \"http://localhost:10000/api/protected?api_key=key_123abc\"\n# Erwartet: 200 OK\n\n# Ung\u00fcltiger API Key\ncurl -H \"X-API-Key: invalid_key\" http://localhost:10000/api/protected\n# Erwartet: 401 Unauthorized\n\n# Fehlender API Key\ncurl http://localhost:10000/api/protected\n# Erwartet: 401 Unauthorized\n</code></pre>"},{"location":"guides/AUTHENTICATION/#testing-jwt-auth","title":"Testing JWT Auth","text":"<p>Generieren Sie zuerst einen Test-JWT-Token auf https://jwt.io oder mit einer Bibliothek:</p> <pre><code>import jwt\nimport time\n\n# Generiere JWT\npayload = {\n    \"iss\": \"https://auth.example.com\",\n    \"sub\": \"user123\",\n    \"aud\": \"api.example.com\",\n    \"exp\": int(time.time()) + 3600,\n    \"iat\": int(time.time())\n}\n\n# Verwenden Sie Ihren Private Key\ntoken = jwt.encode(payload, private_key, algorithm=\"RS256\")\n</code></pre> <pre><code># G\u00fcltiger JWT Token\ncurl -H \"Authorization: Bearer YOUR_JWT_TOKEN\" http://localhost:10000/api/user\n# Erwartet: 200 OK\n\n# Ung\u00fcltiger JWT Token\ncurl -H \"Authorization: Bearer invalid.token.here\" http://localhost:10000/api/user\n# Erwartet: 401 Unauthorized\n\n# Fehlender Authorization-Header\ncurl http://localhost:10000/api/user\n# Erwartet: 401 Unauthorized\n\n# Abgelaufener Token\ncurl -H \"Authorization: Bearer EXPIRED_TOKEN\" http://localhost:10000/api/user\n# Erwartet: 401 Unauthorized\n</code></pre>"},{"location":"guides/AUTHENTICATION/#load-testing-mit-authentication","title":"Load Testing mit Authentication","text":"<pre><code># Apache Bench mit API Key\nab -n 1000 -c 10 -H \"X-API-Key: key_123abc\" http://localhost:10000/api/protected\n\n# wrk mit JWT\nwrk -t4 -c100 -d30s -H \"Authorization: Bearer YOUR_JWT\" http://localhost:10000/api/user\n</code></pre>"},{"location":"guides/AUTHENTICATION/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/AUTHENTICATION/#haufige-probleme","title":"H\u00e4ufige Probleme","text":""},{"location":"guides/AUTHENTICATION/#1-401-unauthorized-trotz-korrekter-credentials","title":"1. 401 Unauthorized trotz korrekter Credentials","text":"<p>Symptom: Authentication schl\u00e4gt fehl trotz korrekter Credentials</p> <p>M\u00f6gliche Ursachen: - Credentials nicht korrekt im Gateway konfiguriert - Tippfehler in Username/Passwort/Key - Falscher Authentication-Typ konfiguriert - Gro\u00df-/Kleinschreibungsprobleme</p> <p>L\u00f6sung: <pre><code># Pr\u00fcfe generierte Config\npython gal-cli.py generate -f examples/authentication-test.yaml\n\n# Verifiziere Credentials in Ausgabe\n# F\u00fcr Basic Auth, pr\u00fcfe users-Sektion\n# F\u00fcr API Key, pr\u00fcfe keys-Liste\n# F\u00fcr JWT, verifiziere issuer/audience\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#2-jwt-validierung-schlagt-fehl","title":"2. JWT-Validierung schl\u00e4gt fehl","text":"<p>Symptom: G\u00fcltige JWT-Tokens werden abgelehnt</p> <p>M\u00f6gliche Ursachen: - Falscher Issuer oder Audience - JWKS-Endpoint nicht erreichbar - Token abgelaufen - Algorithmus-Mismatch - Erforderliche Claims fehlen</p> <p>L\u00f6sung: <pre><code># Verifiziere JWT auf jwt.io\n# Pr\u00fcfe ob Issuer mit Konfiguration \u00fcbereinstimmt\n# Verifiziere JWKS-Endpoint ist erreichbar\ncurl https://auth.example.com/.well-known/jwks.json\n\n# Pr\u00fcfe Token-Ablauf\n# Verifiziere Algorithmus im JWT-Header stimmt mit Config \u00fcberein\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#3-api-key-wird-nicht-erkannt","title":"3. API Key wird nicht erkannt","text":"<p>Symptom: API Key im Header/Query wird nicht validiert</p> <p>M\u00f6gliche Ursachen: - Key-Name-Mismatch (case-sensitive) - Location-Mismatch (header vs query) - Key nicht in konfigurierter Keys-Liste - Sonderzeichen im Key verursachen Parsing-Probleme</p> <p>L\u00f6sung: <pre><code># Verifiziere Konfiguration\nauthentication:\n  type: api_key\n  api_key:\n    key_name: X-API-Key  # Muss exakt \u00fcbereinstimmen (case-sensitive)\n    in_location: header   # Muss mit Request-Location \u00fcbereinstimmen\n    keys:\n      - \"your_actual_key\"  # Muss exakt \u00fcbereinstimmen\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#4-basic-auth-prompts-erscheinen-nicht","title":"4. Basic Auth Prompts erscheinen nicht","text":"<p>Symptom: Browser zeigt keinen Authentication-Prompt</p> <p>M\u00f6gliche Ursachen: - Falsche Realm-Konfiguration - Vorher gecachte Credentials - Browser-Sicherheitseinstellungen</p> <p>L\u00f6sung: - Browser-Cache und Cookies l\u00f6schen - Zuerst mit curl testen - Verifizieren, dass Realm korrekt konfiguriert ist</p>"},{"location":"guides/AUTHENTICATION/#5-jwks-fetch-fehler-envoy","title":"5. JWKS Fetch-Fehler (Envoy)","text":"<p>Symptom: Envoy kann JWKS nicht abrufen</p> <p>M\u00f6gliche Ursachen: - JWKS-Cluster nicht konfiguriert - DNS-Aufl\u00f6sungsfehler - HTTPS-Zertifikat-Validierungsfehler - Netzwerkverbindungsprobleme</p> <p>L\u00f6sung: - Verifizieren Sie, dass JWKS-URL erreichbar ist - Pr\u00fcfen Sie, dass Cluster-Konfiguration TLS-Einstellungen enth\u00e4lt - Testen Sie JWKS-Endpoint manuell: <pre><code>curl https://auth.example.com/.well-known/jwks.json\n</code></pre></p>"},{"location":"guides/AUTHENTICATION/#debug-modus","title":"Debug-Modus","text":"<p>Aktivieren Sie Debug-Logging f\u00fcr Troubleshooting:</p> <pre><code># Generiere Config mit ausf\u00fchrlicher Ausgabe\npython gal-cli.py generate -f config.yaml --verbose\n\n# Pr\u00fcfe Gateway-Logs\n# Kong\ndocker logs &lt;kong-container&gt;\n\n# APISIX\ndocker logs &lt;apisix-container&gt;\n\n# Traefik\ndocker logs &lt;traefik-container&gt;\n\n# Envoy\ndocker logs &lt;envoy-container&gt;\n</code></pre>"},{"location":"guides/AUTHENTICATION/#migrationsleitfaden","title":"Migrationsleitfaden","text":""},{"location":"guides/AUTHENTICATION/#von-v100-zu-v110","title":"Von v1.0.0 zu v1.1.0","text":"<p>Authentication ist ein neues Feature in v1.1.0. Bestehende Konfigurationen ohne Authentication funktionieren weiterhin.</p> <p>Authentication zu bestehenden Routes hinzuf\u00fcgen:</p> <pre><code># Vorher (v1.0.0)\nroutes:\n  - path_prefix: /api/users\n    methods: [GET, POST]\n\n# Nachher (v1.1.0)\nroutes:\n  - path_prefix: /api/users\n    methods: [GET, POST]\n    authentication:  # Neues Feld\n      enabled: true\n      type: api_key\n      api_key:\n        keys: [\"your_key\"]\n</code></pre>"},{"location":"guides/AUTHENTICATION/#kombination-mit-rate-limiting","title":"Kombination mit Rate Limiting","text":"<p>Authentication und Rate Limiting funktionieren nahtlos zusammen:</p> <pre><code>routes:\n  - path_prefix: /api/premium\n    authentication:\n      type: jwt\n      jwt:\n        issuer: \"https://auth.example.com\"\n    rate_limit:\n      enabled: true\n      requests_per_second: 1000\n      key_type: jwt_claim\n      key_claim: sub  # Rate Limit pro JWT-Subject\n</code></pre>"},{"location":"guides/AUTHENTICATION/#erweiterte-themen","title":"Erweiterte Themen","text":""},{"location":"guides/AUTHENTICATION/#multi-tenancy-mit-jwt-claims","title":"Multi-Tenancy mit JWT Claims","text":"<p>Verwenden Sie JWT Claims f\u00fcr Multi-Tenant Rate Limiting:</p> <pre><code>rate_limit:\n  enabled: true\n  key_type: jwt_claim\n  key_claim: tenant_id  # Custom Claim\n  requests_per_second: 100\n</code></pre>"},{"location":"guides/AUTHENTICATION/#oauth-20-integration","title":"OAuth 2.0 Integration","text":"<p>GAL JWT-Support funktioniert mit jedem OAuth 2.0 / OIDC-Provider:</p> <ul> <li>Auth0</li> <li>Okta</li> <li>Keycloak</li> <li>AWS Cognito</li> <li>Azure AD</li> <li>Google Cloud Identity</li> </ul> <p>Konfigurieren Sie den JWKS-Endpoint von Ihrem OAuth-Provider:</p> <pre><code>jwt:\n  issuer: \"https://your-tenant.auth0.com/\"\n  audience: \"https://your-api.example.com\"\n  jwks_uri: \"https://your-tenant.auth0.com/.well-known/jwks.json\"\n</code></pre>"},{"location":"guides/AUTHENTICATION/#custom-authentication","title":"Custom Authentication","text":"<p>F\u00fcr Custom-Authentication-Anforderungen, die nicht von eingebauten Typen abgedeckt werden:</p> <ol> <li>Traefik: Verwenden Sie forwardAuth Middleware mit Custom-Validierungsservice</li> <li>Envoy: Verwenden Sie ext_authz Filter mit Custom gRPC/HTTP-Service</li> <li>Kong: Entwickeln Sie Custom Plugin</li> <li>APISIX: Verwenden Sie Serverless Plugin mit Lua-Code</li> </ol>"},{"location":"guides/AUTHENTICATION/#zusammenfassung","title":"Zusammenfassung","text":"<p>GAL v1.1.0 bietet umfassende Authentication-Unterst\u00fctzung:</p> <p>\u2705 Drei Authentication-Typen: Basic, API Key, JWT \u2705 Alle vier Gateway-Provider unterst\u00fctzt \u2705 Per-Route Authentication-Konfiguration \u2705 Kombination mit Rate Limiting \u2705 Production-ready JWT mit JWKS-Support \u2705 Flexibles Credential-Management</p> <p>F\u00fcr Fragen oder Probleme, besuchen Sie: https://github.com/pt9912/x-gal/issues</p>"},{"location":"guides/BODY_TRANSFORMATION/","title":"Body Transformation - Request/Response Body Manipulation","text":"<p>Request- und Response-Body-Transformation erm\u00f6glicht die Manipulation von JSON-Payloads w\u00e4hrend der Verarbeitung durch das Gateway.</p>"},{"location":"guides/BODY_TRANSFORMATION/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ul> <li>\u00dcbersicht</li> <li>Schnellstart</li> <li>Konfigurationsoptionen</li> <li>Provider-Implementierungen</li> <li>H\u00e4ufige Anwendungsf\u00e4lle</li> <li>Best Practices</li> <li>Troubleshooting</li> <li>Provider-Vergleich</li> </ul>"},{"location":"guides/BODY_TRANSFORMATION/#ubersicht","title":"\u00dcbersicht","text":""},{"location":"guides/BODY_TRANSFORMATION/#was-ist-body-transformation","title":"Was ist Body Transformation?","text":"<p>Body Transformation erlaubt die Manipulation von Request- und Response-Bodys auf Gateway-Ebene:</p> <p>Request Transformation: - Add Fields: Felder hinzuf\u00fcgen (z.B. <code>trace_id</code>, <code>timestamp</code>) - Remove Fields: Sensitive Felder entfernen (z.B. <code>internal_id</code>, <code>secret</code>) - Rename Fields: Felder umbenennen (z.B. <code>user_id</code> \u2192 <code>id</code>)</p> <p>Response Transformation: - Filter Fields: Sensitive Felder filtern (z.B. <code>password</code>, <code>ssn</code>) - Add Fields: Metadata hinzuf\u00fcgen (z.B. <code>server_time</code>, <code>api_version</code>)</p>"},{"location":"guides/BODY_TRANSFORMATION/#template-variablen","title":"Template-Variablen","text":"<p>GAL unterst\u00fctzt dynamische Werte:</p> Variable Beschreibung Beispiel <code>{{uuid}}</code> Generiert UUID v4 <code>550e8400-e29b-41d4-a716-446655440000</code> <code>{{now}}</code> Aktueller Timestamp (ISO 8601) <code>2025-01-18T14:30:00Z</code> <code>{{timestamp}}</code> Alias f\u00fcr <code>{{now}}</code> <code>2025-01-18T14:30:00Z</code>"},{"location":"guides/BODY_TRANSFORMATION/#wann-verwenden","title":"Wann verwenden?","text":"<p>\u2705 Verwenden bei: - Trace-IDs f\u00fcr Distributed Tracing hinzuf\u00fcgen - Sensitive Daten aus Responses filtern - API-Versionierung \u00fcber Metadata - Legacy-System-Integration (Field Mapping) - Audit-Logging-Informationen hinzuf\u00fcgen</p> <p>\u274c Nicht verwenden bei: - Komplexen Business-Logic-Transformationen - Verschl\u00fcsselung/Entschl\u00fcsselung (nutze TLS) - Gro\u00dfen Payloads (Performance-Impact)</p>"},{"location":"guides/BODY_TRANSFORMATION/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/BODY_TRANSFORMATION/#beispiel-1-trace-id-hinzufugen","title":"Beispiel 1: Trace-ID hinzuf\u00fcgen","text":"<pre><code>services:\n  - name: api_service\n    protocol: http\n    upstream:\n      host: api.internal\n      port: 8080\n    routes:\n      - path_prefix: /api/users\n        body_transformation:\n          enabled: true\n          request:\n            add_fields:\n              trace_id: \"{{uuid}}\"\n              timestamp: \"{{now}}\"\n</code></pre> <p>Ergebnis: <pre><code>// Original Request\n{\"username\": \"alice\", \"email\": \"alice@example.com\"}\n\n// Transformed Request\n{\n  \"username\": \"alice\",\n  \"email\": \"alice@example.com\",\n  \"trace_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"timestamp\": \"2025-01-18T14:30:00Z\"\n}\n</code></pre></p>"},{"location":"guides/BODY_TRANSFORMATION/#beispiel-2-sensitive-felder-entfernen","title":"Beispiel 2: Sensitive Felder entfernen","text":"<pre><code>routes:\n  - path_prefix: /api/users\n    body_transformation:\n      enabled: true\n      request:\n        remove_fields:\n          - internal_id\n          - secret_key\n</code></pre> <p>Ergebnis: <pre><code>// Original Request\n{\"username\": \"alice\", \"internal_id\": \"INT123\", \"secret_key\": \"abc\"}\n\n// Transformed Request\n{\"username\": \"alice\"}\n</code></pre></p>"},{"location":"guides/BODY_TRANSFORMATION/#beispiel-3-response-felder-filtern","title":"Beispiel 3: Response-Felder filtern","text":"<pre><code>routes:\n  - path_prefix: /api/users/{id}\n    body_transformation:\n      enabled: true\n      response:\n        filter_fields:\n          - password\n          - ssn\n        add_fields:\n          server_time: \"{{timestamp}}\"\n</code></pre> <p>Ergebnis: <pre><code>// Original Response\n{\"id\": 1, \"username\": \"alice\", \"password\": \"hashed\", \"ssn\": \"123-45-6789\"}\n\n// Transformed Response\n{\n  \"id\": 1,\n  \"username\": \"alice\",\n  \"server_time\": \"2025-01-18T14:30:00Z\"\n}\n</code></pre></p>"},{"location":"guides/BODY_TRANSFORMATION/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/BODY_TRANSFORMATION/#bodytransformationconfig","title":"BodyTransformationConfig","text":"<pre><code>body_transformation:\n  enabled: true              # Body Transformation aktivieren\n  request:                   # Request-Transformation (optional)\n    add_fields:              # Felder hinzuf\u00fcgen\n      field_name: \"value\"\n      trace_id: \"{{uuid}}\"\n    remove_fields:           # Felder entfernen\n      - field_to_remove\n    rename_fields:           # Felder umbenennen\n      old_name: new_name\n  response:                  # Response-Transformation (optional)\n    filter_fields:           # Sensitive Felder filtern\n      - password\n      - ssn\n    add_fields:              # Metadata hinzuf\u00fcgen\n      server_time: \"{{timestamp}}\"\n</code></pre>"},{"location":"guides/BODY_TRANSFORMATION/#request-transformation","title":"Request Transformation","text":""},{"location":"guides/BODY_TRANSFORMATION/#add_fields-dictstr-any","title":"<code>add_fields</code> (Dict[str, Any])","text":"<p>Felder zum Request-Body hinzuf\u00fcgen. Unterst\u00fctzt Template-Variablen.</p> <pre><code>request:\n  add_fields:\n    trace_id: \"{{uuid}}\"           # Dynamisch: UUID\n    timestamp: \"{{now}}\"           # Dynamisch: Timestamp\n    api_version: \"v1\"              # Statisch: String\n    priority: 1                    # Statisch: Integer\n    enabled: true                  # Statisch: Boolean\n</code></pre>"},{"location":"guides/BODY_TRANSFORMATION/#remove_fields-liststr","title":"<code>remove_fields</code> (List[str])","text":"<p>Felder aus dem Request-Body entfernen.</p> <pre><code>request:\n  remove_fields:\n    - internal_id      # Interne IDs\n    - secret_key       # Secrets\n    - password         # Passw\u00f6rter\n    - debug_info       # Debug-Informationen\n</code></pre>"},{"location":"guides/BODY_TRANSFORMATION/#rename_fields-dictstr-str","title":"<code>rename_fields</code> (Dict[str, str])","text":"<p>Felder im Request-Body umbenennen (Field Mapping).</p> <pre><code>request:\n  rename_fields:\n    user_id: id               # user_id \u2192 id\n    user_name: name           # user_name \u2192 name\n    user_email: email         # user_email \u2192 email\n    created_at: timestamp     # created_at \u2192 timestamp\n</code></pre> <p>Hinweis: Nicht alle Provider unterst\u00fctzen <code>rename_fields</code> nativ. Siehe Provider-Vergleich.</p>"},{"location":"guides/BODY_TRANSFORMATION/#response-transformation","title":"Response Transformation","text":""},{"location":"guides/BODY_TRANSFORMATION/#filter_fields-liststr","title":"<code>filter_fields</code> (List[str])","text":"<p>Sensitive Felder aus dem Response-Body entfernen.</p> <pre><code>response:\n  filter_fields:\n    - password             # Passw\u00f6rter\n    - ssn                  # Social Security Numbers\n    - credit_card          # Kreditkarten-Nummern\n    - api_key              # API Keys\n    - internal_notes       # Interne Notizen\n</code></pre>"},{"location":"guides/BODY_TRANSFORMATION/#add_fields-dictstr-any_1","title":"<code>add_fields</code> (Dict[str, Any])","text":"<p>Metadata-Felder zum Response-Body hinzuf\u00fcgen.</p> <pre><code>response:\n  add_fields:\n    server_time: \"{{timestamp}}\"    # Server-Timestamp\n    server_id: \"gateway-1\"          # Server-ID\n    api_version: \"v1.2.0\"           # API-Version\n    response_id: \"{{uuid}}\"         # Response-ID\n</code></pre>"},{"location":"guides/BODY_TRANSFORMATION/#provider-implementierungen","title":"Provider-Implementierungen","text":""},{"location":"guides/BODY_TRANSFORMATION/#1-envoy-lua-filter-100-support","title":"1. Envoy - Lua Filter (100% Support)","text":"<p>Implementierung: envoy.filters.http.lua</p> <p>Konfiguration: <pre><code># GAL Config\nbody_transformation:\n  enabled: true\n  request:\n    add_fields:\n      trace_id: \"{{uuid}}\"\n</code></pre></p> <p>Generierte Envoy Config: <pre><code>http_filters:\n  - name: envoy.filters.http.lua\n    typed_config:\n      '@type': type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua\n      inline_code: |\n        local cjson = require('cjson')\n\n        function generate_uuid()\n          -- UUID v4 generation\n        end\n\n        function envoy_on_request(request_handle)\n          local body = request_handle:body()\n          if body and body:length() &gt; 0 then\n            local body_json = cjson.decode(body:getBytes(0, body:length()))\n            body_json.trace_id = generate_uuid()\n            request_handle:body():setBytes(cjson.encode(body_json))\n          end\n        end\n</code></pre></p> <p>Features: - \u2705 Add Fields (inkl. Template-Variablen) - \u2705 Remove Fields - \u2705 Rename Fields - \u2705 Filter Fields (Response) - \u2705 Add Fields (Response)</p> <p>Template-Variablen: - <code>{{uuid}}</code> \u2192 <code>generate_uuid()</code> (Lua-Funktion) - <code>{{now}}</code> / <code>{{timestamp}}</code> \u2192 <code>os.date('%Y-%m-%dT%H:%M:%SZ')</code></p>"},{"location":"guides/BODY_TRANSFORMATION/#2-kong-transformer-plugins-95-support","title":"2. Kong - Transformer Plugins (95% Support)","text":"<p>Implementierung: request-transformer &amp; response-transformer Plugins</p> <p>Konfiguration: <pre><code># GAL Config\nbody_transformation:\n  enabled: true\n  request:\n    add_fields:\n      trace_id: \"{{uuid}}\"\n    remove_fields:\n      - secret\n</code></pre></p> <p>Generierte Kong Config: <pre><code>plugins:\n  - name: request-transformer\n    config:\n      add:\n        json:\n          - trace_id:$(uuid())\n      remove:\n        json:\n          - secret\n</code></pre></p> <p>Features: - \u2705 Add Fields - \u2705 Remove Fields - \u26a0\ufe0f Rename Fields (ben\u00f6tigt custom Lua Plugin) - \u2705 Filter Fields (Response) - \u2705 Add Fields (Response)</p> <p>Template-Variablen: - <code>{{uuid}}</code> \u2192 <code>$(uuid())</code> (Kong-Funktion, falls verf\u00fcgbar) - <code>{{now}}</code> / <code>{{timestamp}}</code> \u2192 <code>$(date())</code></p> <p>Limitation: Kong's <code>request-transformer</code> Plugin unterst\u00fctzt <code>rename_fields</code> nicht nativ. GAL loggt eine Warnung und empfiehlt ein custom Lua Plugin.</p>"},{"location":"guides/BODY_TRANSFORMATION/#3-apisix-serverless-functions-100-support","title":"3. APISIX - Serverless Functions (100% Support)","text":"<p>Implementierung: serverless-pre-function &amp; serverless-post-function</p> <p>Konfiguration: <pre><code># GAL Config\nbody_transformation:\n  enabled: true\n  request:\n    add_fields:\n      request_id: \"{{uuid}}\"\n  response:\n    filter_fields:\n      - password\n</code></pre></p> <p>Generierte APISIX Config: <pre><code>{\n  \"plugins\": {\n    \"serverless-pre-function\": {\n      \"phase\": \"rewrite\",\n      \"functions\": [\n        \"return function(conf, ctx)\\n  local core = require('apisix.core')\\n  local cjson = require('cjson.safe')\\n  local body = core.request.get_body()\\n  if body then\\n    local json_body = cjson.decode(body)\\n    json_body.request_id = core.utils.uuid()\\n    ngx.req.set_body_data(cjson.encode(json_body))\\n  end\\nend\"\n      ]\n    },\n    \"serverless-post-function\": {\n      \"phase\": \"body_filter\",\n      \"functions\": [\n        \"return function(conf, ctx)\\n  local cjson = require('cjson.safe')\\n  local chunk = ngx.arg[1]\\n  if chunk then\\n    local body_json = cjson.decode(chunk)\\n    body_json.password = nil\\n    ngx.arg[1] = cjson.encode(body_json)\\n  end\\nend\"\n      ]\n    }\n  }\n}\n</code></pre></p> <p>Features: - \u2705 Add Fields - \u2705 Remove Fields - \u2705 Rename Fields - \u2705 Filter Fields (Response) - \u2705 Add Fields (Response)</p> <p>Template-Variablen: - <code>{{uuid}}</code> \u2192 <code>core.utils.uuid()</code> - <code>{{now}}</code> / <code>{{timestamp}}</code> \u2192 <code>os.date('%Y-%m-%dT%H:%M:%SZ')</code></p>"},{"location":"guides/BODY_TRANSFORMATION/#4-traefik-nicht-unterstutzt-0-support","title":"4. Traefik - Nicht unterst\u00fctzt (0% Support)","text":"<p>Implementierung: Keine native Unterst\u00fctzung</p> <p>Traefik unterst\u00fctzt Body Transformation nicht nativ. GAL generiert eine Warnung mit Alternativen:</p> <pre><code>WARNING: Body transformation configured for api_service//api/users,\nbut Traefik does not natively support request/response body transformation.\n\nConsider using:\n  1. ForwardAuth middleware with external transformation service\n  2. Custom Traefik plugin (requires Go development)\n  3. Alternative provider (Envoy, Kong, APISIX, Nginx, HAProxy)\n</code></pre> <p>Alternativen:</p> <p>Option 1: ForwardAuth Middleware <pre><code>middlewares:\n  transformation:\n    forwardAuth:\n      address: \"http://transform-service:8080\"\n      authRequestHeaders:\n        - \"Content-Type\"\n</code></pre></p> <p>Externer Transformation-Service (Python/Go/Node.js) \u00fcbernimmt Body Transformation.</p> <p>Option 2: Custom Traefik Plugin (Go)</p> <p>Entwickle ein Traefik Plugin in Go: <pre><code>// plugins-local/src/github.com/username/transform/transform.go\npackage transform\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"io\"\n    \"net/http\"\n)\n\ntype Config struct {\n    AddFields map[string]interface{} `json:\"addFields,omitempty\"`\n}\n\nfunc (t *Transform) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n    body, _ := io.ReadAll(req.Body)\n    var jsonBody map[string]interface{}\n    json.Unmarshal(body, &amp;jsonBody)\n\n    // Add fields\n    for key, value := range t.config.AddFields {\n        jsonBody[key] = value\n    }\n\n    newBody, _ := json.Marshal(jsonBody)\n    req.Body = io.NopCloser(bytes.NewReader(newBody))\n    t.next.ServeHTTP(rw, req)\n}\n</code></pre></p>"},{"location":"guides/BODY_TRANSFORMATION/#5-nginx-openresty-lua-100-support","title":"5. Nginx - OpenResty Lua (100% Support)","text":"<p>Implementierung: access_by_lua_block &amp; body_filter_by_lua_block</p> <p>Voraussetzung: OpenResty (Nginx + Lua)</p> <p>Konfiguration: <pre><code># GAL Config\nbody_transformation:\n  enabled: true\n  request:\n    add_fields:\n      request_id: \"{{uuid}}\"\n</code></pre></p> <p>Generierte Nginx Config: <pre><code>location /api/users {\n    # Request body transformation (requires OpenResty)\n    access_by_lua_block {\n        local cjson = require('cjson')\n        ngx.req.read_body()\n        local body_data = ngx.req.get_body_data()\n        if body_data then\n            local body_json = cjson.decode(body_data)\n            body_json.request_id = ngx.var.request_id\n            ngx.req.set_body_data(cjson.encode(body_json))\n        end\n    }\n\n    # Response body transformation\n    body_filter_by_lua_block {\n        local cjson = require('cjson')\n        local chunk = ngx.arg[1]\n        if chunk then\n            local body_json = cjson.decode(chunk)\n            body_json.password = nil\n            ngx.arg[1] = cjson.encode(body_json)\n        end\n    }\n\n    proxy_pass http://upstream_api_service;\n}\n</code></pre></p> <p>Features: - \u2705 Add Fields - \u2705 Remove Fields - \u2705 Rename Fields - \u2705 Filter Fields (Response) - \u2705 Add Fields (Response)</p> <p>Template-Variablen: - <code>{{uuid}}</code> \u2192 <code>ngx.var.request_id</code> - <code>{{now}}</code> / <code>{{timestamp}}</code> \u2192 <code>ngx.utctime()</code></p> <p>Installation: <pre><code># Ubuntu/Debian\napt-get install openresty\n\n# macOS\nbrew install openresty/brew/openresty\n</code></pre></p>"},{"location":"guides/BODY_TRANSFORMATION/#6-haproxy-lua-scripting-90-support","title":"6. HAProxy - Lua Scripting (90% Support)","text":"<p>Implementierung: Lua-Funktionen (manuell implementiert)</p> <p>Konfiguration: <pre><code># GAL Config\nbody_transformation:\n  enabled: true\n  request:\n    add_fields:\n      trace_id: \"{{uuid}}\"\n</code></pre></p> <p>Generierte HAProxy Config: <pre><code>frontend http_frontend\n    # Body transformation for /api/users (requires Lua)\n    http-request lua.transform_request_api_service_route0 if is_api_service_route0\n    http-response lua.transform_response_api_service_route0 if is_api_service_route0\n</code></pre></p> <p>Lua-Implementierung (manuell):</p> <p>GAL generiert Funktionsreferenzen, aber du musst die Lua-Funktionen selbst implementieren:</p> <pre><code>-- /etc/haproxy/transform.lua\ncore.register_action(\"transform_request_api_service_route0\", {\"http-req\"}, function(txn)\n    local json = require(\"json\")\n    local body = txn.req:dup():get_body()\n\n    if body then\n        local data = json.decode(body)\n        data.trace_id = core.uuid()\n        data.timestamp = os.date(\"!%Y-%m-%dT%H:%M:%SZ\")\n        txn.req:set_body_data(json.encode(data))\n    end\nend)\n\ncore.register_action(\"transform_response_api_service_route0\", {\"http-res\"}, function(txn)\n    local json = require(\"json\")\n    local body = txn.res:dup():get_body()\n\n    if body then\n        local data = json.decode(body)\n        data.password = nil\n        txn.res:set_body_data(json.encode(data))\n    end\nend)\n</code></pre> <p>HAProxy Global Config: <pre><code>global\n    lua-load /etc/haproxy/transform.lua\n</code></pre></p> <p>Features: - \u2705 Add Fields (manuell implementieren) - \u2705 Remove Fields (manuell implementieren) - \u2705 Rename Fields (manuell implementieren) - \u2705 Filter Fields (Response, manuell) - \u2705 Add Fields (Response, manuell)</p> <p>Warnung: GAL loggt eine Warnung mit Implementierungshinweisen.</p>"},{"location":"guides/BODY_TRANSFORMATION/#haufige-anwendungsfalle","title":"H\u00e4ufige Anwendungsf\u00e4lle","text":""},{"location":"guides/BODY_TRANSFORMATION/#1-distributed-tracing-trace-ids-hinzufugen","title":"1. Distributed Tracing - Trace-IDs hinzuf\u00fcgen","text":"<p>Use Case: Jeder Request bekommt eine eindeutige Trace-ID f\u00fcr End-to-End-Tracking.</p> <pre><code>routes:\n  - path_prefix: /api\n    body_transformation:\n      enabled: true\n      request:\n        add_fields:\n          trace_id: \"{{uuid}}\"\n          request_time: \"{{timestamp}}\"\n      response:\n        add_fields:\n          response_time: \"{{timestamp}}\"\n</code></pre> <p>Vorteile: - \u2705 Einfaches Request-Tracking \u00fcber Microservices - \u2705 Korrelation von Logs - \u2705 Performance-Monitoring</p>"},{"location":"guides/BODY_TRANSFORMATION/#2-legacy-system-integration-field-mapping","title":"2. Legacy-System-Integration - Field Mapping","text":"<p>Use Case: Legacy-System erwartet alte Feldnamen.</p> <pre><code>routes:\n  - path_prefix: /legacy/users\n    body_transformation:\n      enabled: true\n      request:\n        rename_fields:\n          id: userId\n          name: userName\n          email: userEmail\n          created: createdAt\n</code></pre> <p>Original Request: <pre><code>{\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\"}\n</code></pre></p> <p>Transformed Request: <pre><code>{\"userId\": 1, \"userName\": \"Alice\", \"userEmail\": \"alice@example.com\"}\n</code></pre></p>"},{"location":"guides/BODY_TRANSFORMATION/#3-security-sensitive-daten-filtern","title":"3. Security - Sensitive Daten filtern","text":"<p>Use Case: PII (Personally Identifiable Information) aus Responses entfernen.</p> <pre><code>routes:\n  - path_prefix: /api/users\n    body_transformation:\n      enabled: true\n      response:\n        filter_fields:\n          - password\n          - ssn\n          - credit_card\n          - api_key\n          - internal_notes\n</code></pre> <p>Original Response: <pre><code>{\n  \"id\": 1,\n  \"username\": \"alice\",\n  \"password\": \"hashed_password\",\n  \"ssn\": \"123-45-6789\",\n  \"email\": \"alice@example.com\"\n}\n</code></pre></p> <p>Transformed Response: <pre><code>{\n  \"id\": 1,\n  \"username\": \"alice\",\n  \"email\": \"alice@example.com\"\n}\n</code></pre></p>"},{"location":"guides/BODY_TRANSFORMATION/#4-api-versioning-metadata-hinzufugen","title":"4. API Versioning - Metadata hinzuf\u00fcgen","text":"<p>Use Case: API-Version und Server-Informationen zu Responses hinzuf\u00fcgen.</p> <pre><code>routes:\n  - path_prefix: /api/v1\n    body_transformation:\n      enabled: true\n      response:\n        add_fields:\n          api_version: \"v1.2.0\"\n          server: \"gateway-1\"\n          timestamp: \"{{timestamp}}\"\n</code></pre>"},{"location":"guides/BODY_TRANSFORMATION/#5-audit-logging-audit-informationen","title":"5. Audit Logging - Audit-Informationen","text":"<p>Use Case: Audit-Trail-Informationen zu Requests hinzuf\u00fcgen.</p> <pre><code>routes:\n  - path_prefix: /api/admin\n    body_transformation:\n      enabled: true\n      request:\n        add_fields:\n          audit_id: \"{{uuid}}\"\n          audit_timestamp: \"{{timestamp}}\"\n          gateway: \"gal-gateway-1\"\n      response:\n        add_fields:\n          audit_response_time: \"{{timestamp}}\"\n</code></pre>"},{"location":"guides/BODY_TRANSFORMATION/#6-canary-deployment-version-flag","title":"6. Canary Deployment - Version-Flag","text":"<p>Use Case: Requests f\u00fcr Canary-Deployment markieren.</p> <pre><code>routes:\n  - path_prefix: /api/v2-beta\n    body_transformation:\n      enabled: true\n      request:\n        add_fields:\n          deployment: \"canary\"\n          version: \"v2-beta\"\n          canary_weight: 10\n</code></pre>"},{"location":"guides/BODY_TRANSFORMATION/#7-multi-tenant-tenant-id-hinzufugen","title":"7. Multi-Tenant - Tenant-ID hinzuf\u00fcgen","text":"<p>Use Case: Tenant-ID basierend auf Header hinzuf\u00fcgen.</p> <pre><code>routes:\n  - path_prefix: /api/tenant\n    body_transformation:\n      enabled: true\n      request:\n        add_fields:\n          tenant_id: \"extracted-from-header\"  # In Produktion: Lua/Custom Logic\n          tenant_region: \"eu-west-1\"\n</code></pre>"},{"location":"guides/BODY_TRANSFORMATION/#best-practices","title":"Best Practices","text":""},{"location":"guides/BODY_TRANSFORMATION/#1-minimale-transformation","title":"1. \u2705 Minimale Transformation","text":"<p>Regel: Transformiere nur, was wirklich n\u00f6tig ist.</p> <p>\u274c Schlecht: <pre><code>request:\n  add_fields:\n    field1: \"value1\"\n    field2: \"value2\"\n    field3: \"value3\"\n    field4: \"value4\"\n    field5: \"value5\"\n</code></pre></p> <p>\u2705 Gut: <pre><code>request:\n  add_fields:\n    trace_id: \"{{uuid}}\"  # Nur f\u00fcr Tracing\n</code></pre></p> <p>Grund: Jede Transformation hat Performance-Impact (JSON decode/encode).</p>"},{"location":"guides/BODY_TRANSFORMATION/#2-template-variablen-verwenden","title":"2. \u2705 Template-Variablen verwenden","text":"<p>Regel: Nutze <code>{{uuid}}</code> und <code>{{timestamp}}</code> f\u00fcr dynamische Werte.</p> <p>\u274c Schlecht: <pre><code>request:\n  add_fields:\n    trace_id: \"static-value\"  # Immer gleich!\n</code></pre></p> <p>\u2705 Gut: <pre><code>request:\n  add_fields:\n    trace_id: \"{{uuid}}\"  # Eindeutig pro Request\n</code></pre></p>"},{"location":"guides/BODY_TRANSFORMATION/#3-provider-kompatibilitat-prufen","title":"3. \u2705 Provider-Kompatibilit\u00e4t pr\u00fcfen","text":"<p>Regel: Verwende Features, die dein Provider unterst\u00fctzt.</p> <pre><code># Kong unterst\u00fctzt rename_fields NICHT nativ\nrequest:\n  rename_fields:  # \u26a0\ufe0f Warnung bei Kong!\n    old: new\n</code></pre> <p>L\u00f6sung: Nutze Provider-Vergleich vor der Implementierung.</p>"},{"location":"guides/BODY_TRANSFORMATION/#4-response-filterung-fur-security","title":"4. \u2705 Response-Filterung f\u00fcr Security","text":"<p>Regel: Filtere IMMER sensitive Daten aus Responses.</p> <pre><code>response:\n  filter_fields:\n    - password\n    - ssn\n    - credit_card\n    - api_key\n    - secret\n    - internal_notes\n</code></pre>"},{"location":"guides/BODY_TRANSFORMATION/#5-testing-mit-echten-payloads","title":"5. \u2705 Testing mit echten Payloads","text":"<p>Regel: Teste Transformationen mit realistischen Payloads.</p> <pre><code># Test Request\ncurl -X POST http://gateway/api/users \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\": \"alice\", \"internal_id\": \"INT123\"}'\n\n# Check transformed request im Backend\n</code></pre>"},{"location":"guides/BODY_TRANSFORMATION/#6-monitoring-logging","title":"6. \u2705 Monitoring &amp; Logging","text":"<p>Regel: \u00dcberwache Transformation-Fehler.</p> <pre><code># Envoy: Lua-Fehler landen in Envoy-Logs\n# Kong: Plugin-Errors in Kong-Logs\n# APISIX: Serverless-Function-Errors in error.log\n</code></pre> <p>Metric-Beispiele: - <code>body_transformation_errors_total</code> - <code>body_transformation_duration_seconds</code></p>"},{"location":"guides/BODY_TRANSFORMATION/#7-dokumentiere-custom-lua","title":"7. \u2705 Dokumentiere Custom Lua","text":"<p>Regel: Wenn du custom Lua verwendest (HAProxy, Nginx), dokumentiere es!</p> <pre><code>-- /etc/haproxy/transform.lua\n-- Purpose: Transform request body for api_service\n-- Author: DevOps Team\n-- Date: 2025-01-18\n-- Dependencies: lua-json\n\ncore.register_action(\"transform_request_api_service_route0\", {\"http-req\"}, function(txn)\n    -- Implementation...\nend)\n</code></pre>"},{"location":"guides/BODY_TRANSFORMATION/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/BODY_TRANSFORMATION/#problem-1-transformation-funktioniert-nicht","title":"Problem 1: Transformation funktioniert nicht","text":"<p>Symptom: Body wird nicht transformiert.</p> <p>Debugging:</p> <ol> <li> <p>Check Provider-Logs: <pre><code># Envoy\nkubectl logs -f envoy-pod | grep lua\n\n# Kong\ntail -f /usr/local/kong/logs/error.log\n\n# APISIX\ntail -f /usr/local/apisix/logs/error.log\n\n# Nginx (OpenResty)\ntail -f /var/log/nginx/error.log\n</code></pre></p> </li> <li> <p>Check Config-Syntax: <pre><code># Envoy\nenvoy --mode validate -c envoy.yaml\n\n# Kong\nkong config parse kong.yaml\n\n# Nginx\nnginx -t -c nginx.conf\n</code></pre></p> </li> <li> <p>Check JSON-Parsing: <pre><code># Teste ob Request/Response valides JSON ist\necho '{\"test\": \"value\"}' | jq .\n</code></pre></p> </li> </ol> <p>H\u00e4ufige Ursachen: - \u274c Request/Response ist kein JSON - \u274c Lua-Module fehlen (cjson) - \u274c Provider unterst\u00fctzt Feature nicht</p>"},{"location":"guides/BODY_TRANSFORMATION/#problem-2-template-variablen-werden-nicht-ersetzt","title":"Problem 2: Template-Variablen werden nicht ersetzt","text":"<p>Symptom: <code>{{uuid}}</code> bleibt als String im Body.</p> <p>L\u00f6sung:</p> <p>Check Provider-Implementation:</p> <p>Envoy: <pre><code>-- Muss generate_uuid() Funktion haben\nfunction generate_uuid()\n  -- Implementation\nend\n</code></pre></p> <p>APISIX: <pre><code>-- Muss core.utils.uuid() verwenden\nbody_json.trace_id = core.utils.uuid()\n</code></pre></p> <p>Kong: <pre><code># Kong: $(uuid()) statt {{uuid}}\nadd:\n  json:\n    - trace_id:$(uuid())\n</code></pre></p>"},{"location":"guides/BODY_TRANSFORMATION/#problem-3-performance-degradation","title":"Problem 3: Performance-Degradation","text":"<p>Symptom: Gateway-Response-Zeit steigt signifikant.</p> <p>Debugging:</p> <ol> <li> <p>Measure Transformation-Overhead: <pre><code># Ohne Transformation\nab -n 1000 -c 10 http://gateway/api/users\n\n# Mit Transformation\nab -n 1000 -c 10 http://gateway/api/users-transformed\n</code></pre></p> </li> <li> <p>Profile Lua-Code (Envoy): <pre><code>function envoy_on_request(request_handle)\n    local start_time = os.clock()\n    -- Transformation logic\n    local duration = os.clock() - start_time\n    request_handle:logInfo(\"Transformation took: \" .. duration .. \"s\")\nend\n</code></pre></p> </li> </ol> <p>Optimierungen: - \u2705 Reduziere Anzahl der transformierten Felder - \u2705 Cache Lua-Module (cjson) - \u2705 Nutze lightweight JSON-Parser - \u2705 Erw\u00e4ge Transformation im Backend</p>"},{"location":"guides/BODY_TRANSFORMATION/#problem-4-rename_fields-funktioniert-nicht-kong","title":"Problem 4: rename_fields funktioniert nicht (Kong)","text":"<p>Symptom: Kong loggt Warnung \u00fcber <code>rename_fields</code>.</p> <p>L\u00f6sung:</p> <p>Kong's <code>request-transformer</code> Plugin unterst\u00fctzt <code>rename_fields</code> nicht nativ.</p> <p>Option 1: Custom Lua Plugin <pre><code>-- kong/plugins/rename-transformer/handler.lua\nlocal kong = kong\nlocal cjson = require(\"cjson\")\n\nlocal RenameTransformer = {}\n\nfunction RenameTransformer:access(conf)\n    local body = kong.request.get_raw_body()\n    if body then\n        local json_body = cjson.decode(body)\n\n        for old_name, new_name in pairs(conf.rename_fields) do\n            if json_body[old_name] ~= nil then\n                json_body[new_name] = json_body[old_name]\n                json_body[old_name] = nil\n            end\n        end\n\n        kong.service.request.set_raw_body(cjson.encode(json_body))\n    end\nend\n\nreturn RenameTransformer\n</code></pre></p> <p>Option 2: Alternative Provider</p> <p>Nutze Envoy, APISIX oder Nginx statt Kong f\u00fcr <code>rename_fields</code>.</p>"},{"location":"guides/BODY_TRANSFORMATION/#problem-5-traefik-warnung","title":"Problem 5: Traefik-Warnung","text":"<p>Symptom: GAL loggt Warnung \"Traefik does not natively support...\".</p> <p>L\u00f6sung:</p> <p>Traefik unterst\u00fctzt Body Transformation nicht nativ. Optionen:</p> <ol> <li>ForwardAuth + Externer Service</li> <li>Custom Traefik Plugin (Go)</li> <li>Alternative Provider (Envoy, Kong, etc.)</li> </ol> <p>Siehe Traefik-Implementierung.</p>"},{"location":"guides/BODY_TRANSFORMATION/#problem-6-haproxy-lua-script-nicht-gefunden","title":"Problem 6: HAProxy Lua-Script nicht gefunden","text":"<p>Symptom: HAProxy startet nicht: \"lua-load /path/to/transform.lua: No such file\".</p> <p>L\u00f6sung:</p> <ol> <li> <p>Create Lua-Script: <pre><code>mkdir -p /etc/haproxy\ncat &gt; /etc/haproxy/transform.lua &lt;&lt; 'EOF'\n-- Transformation functions\ncore.register_action(\"transform_request_api_service_route0\", {\"http-req\"}, function(txn)\n    -- Implementation\nend)\nEOF\n</code></pre></p> </li> <li> <p>Update haproxy.cfg: <pre><code>global\n    lua-load /etc/haproxy/transform.lua\n</code></pre></p> </li> <li> <p>Restart HAProxy: <pre><code>systemctl restart haproxy\n</code></pre></p> </li> </ol>"},{"location":"guides/BODY_TRANSFORMATION/#provider-vergleich","title":"Provider-Vergleich","text":""},{"location":"guides/BODY_TRANSFORMATION/#feature-matrix","title":"Feature-Matrix","text":"Feature Envoy Kong APISIX Traefik Nginx HAProxy Request Transformation Add Fields \u2705 Lua \u2705 Plugin \u2705 Lua \u274c \u2705 Lua \u26a0\ufe0f Manual Lua Remove Fields \u2705 Lua \u2705 Plugin \u2705 Lua \u274c \u2705 Lua \u26a0\ufe0f Manual Lua Rename Fields \u2705 Lua \u26a0\ufe0f Custom \u2705 Lua \u274c \u2705 Lua \u26a0\ufe0f Manual Lua Response Transformation Filter Fields \u2705 Lua \u2705 Plugin \u2705 Lua \u274c \u2705 Lua \u26a0\ufe0f Manual Lua Add Fields \u2705 Lua \u2705 Plugin \u2705 Lua \u274c \u2705 Lua \u26a0\ufe0f Manual Lua Template Variables {{uuid}} \u2705 \u26a0\ufe0f $(uuid()) \u2705 \u274c \u2705 \u26a0\ufe0f Manual {{timestamp}} \u2705 \u26a0\ufe0f $(date()) \u2705 \u274c \u2705 \u26a0\ufe0f Manual Setup Configuration \u2705 Auto \u2705 Auto \u2705 Auto \u26a0\ufe0f Manual \u26a0\ufe0f OpenResty \u26a0\ufe0f Manual Lua Performance \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 N/A \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 Complexity Medium Low Medium High Medium High <p>Legende: - \u2705 = Full native support - \u26a0\ufe0f = Partial support / requires setup - \u274c = Not supported</p>"},{"location":"guides/BODY_TRANSFORMATION/#empfehlungen","title":"Empfehlungen","text":""},{"location":"guides/BODY_TRANSFORMATION/#bester-provider-apisix","title":"Bester Provider: APISIX \ud83c\udfc6","text":"<ul> <li>\u2705 100% Feature-Support</li> <li>\u2705 Beste Performance</li> <li>\u2705 Einfache Konfiguration</li> <li>\u2705 Native Template-Variablen</li> </ul>"},{"location":"guides/BODY_TRANSFORMATION/#fur-kubernetes-envoy","title":"F\u00fcr Kubernetes: Envoy \ud83d\ude80","text":"<ul> <li>\u2705 100% Feature-Support</li> <li>\u2705 Best Practices mit Service Mesh (Istio)</li> <li>\u2705 Robuste Lua-Implementation</li> </ul>"},{"location":"guides/BODY_TRANSFORMATION/#fur-einfachheit-kong","title":"F\u00fcr Einfachheit: Kong \ud83d\udca1","text":"<ul> <li>\u2705 95% Feature-Support (au\u00dfer rename)</li> <li>\u2705 Einfachste Konfiguration</li> <li>\u2705 Gro\u00dfes Plugin-\u00d6kosystem</li> </ul>"},{"location":"guides/BODY_TRANSFORMATION/#fur-nginx-nutzer-nginx-openresty","title":"F\u00fcr Nginx-Nutzer: Nginx + OpenResty \ud83d\udd27","text":"<ul> <li>\u2705 100% Feature-Support</li> <li>\u26a0\ufe0f Requires OpenResty Installation</li> <li>\u2705 Gute Performance</li> </ul>"},{"location":"guides/BODY_TRANSFORMATION/#nicht-empfohlen","title":"Nicht empfohlen:","text":"<ul> <li>\u274c Traefik: Keine native Unterst\u00fctzung</li> <li>\u26a0\ufe0f HAProxy: Manuelle Lua-Implementierung erforderlich</li> </ul>"},{"location":"guides/BODY_TRANSFORMATION/#zusammenfassung","title":"Zusammenfassung","text":""},{"location":"guides/BODY_TRANSFORMATION/#body-transformation-ermoglicht","title":"\u2705 Body Transformation erm\u00f6glicht:","text":"<ul> <li>Request-Body-Manipulation (add/remove/rename fields)</li> <li>Response-Body-Filterung (sensitive data)</li> <li>Template-Variablen ({{uuid}}, {{timestamp}})</li> <li>Provider-agnostische Konfiguration</li> </ul>"},{"location":"guides/BODY_TRANSFORMATION/#best-practices_1","title":"\ud83c\udfaf Best Practices:","text":"<ol> <li>Minimale Transformation f\u00fcr Performance</li> <li>Template-Variablen f\u00fcr dynamische Werte</li> <li>Provider-Kompatibilit\u00e4t pr\u00fcfen</li> <li>Response-Filterung f\u00fcr Security</li> <li>Testing mit echten Payloads</li> <li>Monitoring &amp; Logging aktivieren</li> <li>Custom Lua dokumentieren</li> </ol>"},{"location":"guides/BODY_TRANSFORMATION/#provider-empfehlungen","title":"\ud83d\udcca Provider-Empfehlungen:","text":"<ul> <li>APISIX: Beste Wahl (100% Support, Top Performance)</li> <li>Envoy: Ideal f\u00fcr Kubernetes/Service Mesh</li> <li>Kong: Einfachste Setup (95% Support)</li> <li>Nginx: Gut mit OpenResty (100% Support)</li> <li>Traefik: \u274c Nicht empfohlen</li> <li>HAProxy: \u26a0\ufe0f Nur mit Manual Lua</li> </ul>"},{"location":"guides/BODY_TRANSFORMATION/#weitere-ressourcen","title":"\ud83d\udd17 Weitere Ressourcen:","text":"<ul> <li>Body Transformation Examples</li> <li>Provider Documentation</li> <li>v1.2.0 Plan</li> </ul> <p>Version: v1.2.0 Zuletzt aktualisiert: 2025-01-18 Autor: GAL Development Team</p>"},{"location":"guides/CIRCUIT_BREAKER/","title":"Circuit Breaker Anleitung","text":"<p>Umfassende Anleitung f\u00fcr Circuit Breaker Pattern in GAL (Gateway Abstraction Layer)</p>"},{"location":"guides/CIRCUIT_BREAKER/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ol> <li>\u00dcbersicht</li> <li>Schnellstart</li> <li>Konfigurationsoptionen</li> <li>Provider-Implementierung</li> <li>H\u00e4ufige Anwendungsf\u00e4lle</li> <li>Best Practices</li> <li>Circuit Breaker Testen</li> <li>Troubleshooting</li> </ol>"},{"location":"guides/CIRCUIT_BREAKER/#ubersicht","title":"\u00dcbersicht","text":"<p>Das Circuit Breaker Pattern ist ein Resilience-Mechanismus, der verhindert, dass fehlerhafte oder langsame Upstream-Services das gesamte System zum Absturz bringen. GAL bietet eine einheitliche Circuit Breaker-Konfiguration f\u00fcr alle unterst\u00fctzten Gateway-Provider.</p>"},{"location":"guides/CIRCUIT_BREAKER/#was-ist-ein-circuit-breaker","title":"Was ist ein Circuit Breaker?","text":"<p>Ein Circuit Breaker funktioniert wie eine elektrische Sicherung: Wenn zu viele Fehler auftreten, \"\u00f6ffnet\" sich der Circuit Breaker und blockiert weitere Requests tempor\u00e4r, um dem fehlerhaften Service Zeit zur Erholung zu geben.</p> <p>Circuit Breaker Zust\u00e4nde:</p> <pre><code>CLOSED (Normal) \u2192 OPEN (Broken) \u2192 HALF_OPEN (Testing) \u2192 CLOSED\n</code></pre> <ol> <li>CLOSED (Geschlossen): Normal operation, alle Requests werden durchgelassen</li> <li>OPEN (Offen): Circuit ist \"gebrochen\", Requests werden sofort abgelehnt</li> <li>HALF_OPEN (Halb-offen): Testet mit wenigen Requests, ob Service wieder funktioniert</li> </ol>"},{"location":"guides/CIRCUIT_BREAKER/#warum-ist-circuit-breaker-wichtig","title":"Warum ist Circuit Breaker wichtig?","text":"<ul> <li>\u2705 Fehler-Isolation: Verhindert Cascading Failures</li> <li>\u2705 Schnelle Fehlerbehandlung: Sofortige R\u00fcckmeldung bei defekten Services</li> <li>\u2705 Automatische Erholung: Testet automatisch, wann Service wieder verf\u00fcgbar ist</li> <li>\u2705 Resource-Schonung: Verschwendet keine Ressourcen f\u00fcr defekte Services</li> <li>\u2705 Bessere User Experience: Schnelle Fehlerseiten statt Timeouts</li> </ul>"},{"location":"guides/CIRCUIT_BREAKER/#provider-unterstutzung","title":"Provider-Unterst\u00fctzung","text":"Feature Kong APISIX Traefik Envoy Implementierung Circuit Breaker \u26a0\ufe0f \u2705 \u2705 \u2705 Kong: Third-party only Max Failures - \u2705 \u2705 \u2705 Fehler-Schwellwert Timeout - \u2705 \u2705 \u2705 Erholungszeit Half-Open Requests - \u2705 - \u2705 Test-Requests Status Code Detection - \u2705 \u2705 \u2705 Welche Codes = Fehler <p>Coverage: 75% (3 von 4 Providern haben native Unterst\u00fctzung)</p> <ul> <li>APISIX: Native <code>api-breaker</code> Plugin \u2705</li> <li>Traefik: Native <code>CircuitBreaker</code> Middleware \u2705</li> <li>Envoy: Native <code>Outlier Detection</code> \u2705</li> <li>Kong: Nur Third-Party Plugin (kong-circuit-breaker) \u26a0\ufe0f</li> </ul>"},{"location":"guides/CIRCUIT_BREAKER/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/CIRCUIT_BREAKER/#einfache-circuit-breaker-konfiguration","title":"Einfache Circuit Breaker-Konfiguration","text":"<p>Basis-Konfiguration f\u00fcr alle Provider (au\u00dfer Kong):</p> <pre><code>version: \"1.0\"\nprovider: apisix\n\nservices:\n  - name: payment_service\n    type: rest\n    protocol: http\n    upstream:\n      host: payment.internal\n      port: 8080\n    routes:\n      - path_prefix: /api/payments\n        methods: [GET, POST]\n        circuit_breaker:\n          enabled: true\n          max_failures: 5           # Nach 5 Fehlern \u2192 OPEN\n          timeout: \"30s\"            # 30 Sekunden warten\n          half_open_requests: 3     # 3 Test-Requests in HALF_OPEN\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#fortgeschrittene-konfiguration","title":"Fortgeschrittene Konfiguration","text":"<p>Mit custom Status Codes und Response-Konfiguration:</p> <pre><code>routes:\n  - path_prefix: /api/payments\n    methods: [GET, POST]\n    circuit_breaker:\n      enabled: true\n      max_failures: 5\n      timeout: \"30s\"\n      half_open_requests: 3\n\n      # Welche Status Codes sind \"Fehler\"?\n      unhealthy_status_codes: [500, 502, 503, 504]\n\n      # Welche Status Codes sind \"gesund\"?\n      healthy_status_codes: [200, 201, 202, 204]\n\n      # Response wenn Circuit OPEN ist\n      failure_response_code: 503\n      failure_response_message: \"Service temporarily unavailable\"\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#circuit-breaker-mit-rate-limiting-kombinieren","title":"Circuit Breaker mit Rate Limiting kombinieren","text":"<p>Sch\u00fctze deinen Service vor \u00dcberlastung und Ausf\u00e4llen:</p> <pre><code>routes:\n  - path_prefix: /api/critical\n    methods: [GET, POST]\n\n    # Rate Limiting: Maximal 100 Requests/Sekunde\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n      burst: 150\n\n    # Circuit Breaker: Bei Problemen sofort abschalten\n    circuit_breaker:\n      enabled: true\n      max_failures: 10\n      timeout: \"60s\"\n      unhealthy_status_codes: [500, 502, 503, 504, 429]\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/CIRCUIT_BREAKER/#circuitbreakerconfig-felder","title":"CircuitBreakerConfig Felder","text":"<pre><code>circuit_breaker:\n  # Aktivierung\n  enabled: true\n\n  # Maximale aufeinanderfolgende Fehler vor OPEN\n  max_failures: 5\n\n  # Wartezeit bis HALF_OPEN-Test (Format: \"30s\", \"1m\", \"2h\")\n  timeout: \"30s\"\n\n  # Anzahl Test-Requests in HALF_OPEN-Phase\n  half_open_requests: 3\n\n  # HTTP Status Codes die als \"Fehler\" z\u00e4hlen\n  unhealthy_status_codes:\n    - 500  # Internal Server Error\n    - 502  # Bad Gateway\n    - 503  # Service Unavailable\n    - 504  # Gateway Timeout\n\n  # HTTP Status Codes die als \"gesund\" z\u00e4hlen\n  healthy_status_codes:\n    - 200  # OK\n    - 201  # Created\n    - 202  # Accepted\n    - 204  # No Content\n\n  # Response Code wenn Circuit OPEN ist\n  failure_response_code: 503\n\n  # Response Message wenn Circuit OPEN ist\n  failure_response_message: \"Service temporarily unavailable\"\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#standard-werte","title":"Standard-Werte","text":"<p>Wenn Felder weggelassen werden, gelten folgende Defaults:</p> <pre><code>circuit_breaker:\n  enabled: true\n  max_failures: 5\n  timeout: \"30s\"\n  half_open_requests: 3\n  unhealthy_status_codes: [500, 502, 503, 504]\n  healthy_status_codes: [200, 201, 202, 204]\n  failure_response_code: 503\n  failure_response_message: \"Service temporarily unavailable\"\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#parameter-erklarung","title":"Parameter-Erkl\u00e4rung","text":""},{"location":"guides/CIRCUIT_BREAKER/#max_failures-int","title":"max_failures (int)","text":"<p>Anzahl aufeinanderfolgender Fehler, bevor Circuit auf OPEN schaltet.</p> <pre><code>max_failures: 5  # Nach 5 Fehlern \u2192 OPEN\n</code></pre> <p>Empfehlung: - Kritische Services: 3-5 Fehler - Normale Services: 5-10 Fehler - Robuste Services: 10-20 Fehler</p>"},{"location":"guides/CIRCUIT_BREAKER/#timeout-string","title":"timeout (string)","text":"<p>Wartezeit in OPEN-Phase, bevor HALF_OPEN-Test startet.</p> <pre><code>timeout: \"30s\"   # 30 Sekunden\ntimeout: \"1m\"    # 1 Minute\ntimeout: \"2h\"    # 2 Stunden\n</code></pre> <p>Empfehlung: - Schnelle Erholung: 10-30 Sekunden - Normale Erholung: 30-60 Sekunden - Lange Erholung: 1-5 Minuten</p>"},{"location":"guides/CIRCUIT_BREAKER/#half_open_requests-int","title":"half_open_requests (int)","text":"<p>Anzahl Test-Requests in HALF_OPEN-Phase.</p> <pre><code>half_open_requests: 3  # 3 Test-Requests\n</code></pre> <p>Empfehlung: - Vorsichtig: 1-3 Requests - Normal: 3-5 Requests - Aggressiv: 5-10 Requests</p>"},{"location":"guides/CIRCUIT_BREAKER/#unhealthy_status_codes-list","title":"unhealthy_status_codes (list)","text":"<p>HTTP Status Codes die als Fehler gewertet werden.</p> <pre><code>unhealthy_status_codes:\n  - 500  # Internal Server Error\n  - 502  # Bad Gateway\n  - 503  # Service Unavailable\n  - 504  # Gateway Timeout\n  - 429  # Too Many Requests (optional)\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#healthy_status_codes-list","title":"healthy_status_codes (list)","text":"<p>HTTP Status Codes die als erfolgreich gewertet werden.</p> <pre><code>healthy_status_codes:\n  - 200  # OK\n  - 201  # Created\n  - 202  # Accepted\n  - 204  # No Content\n  - 304  # Not Modified (optional)\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#provider-implementierung","title":"Provider-Implementierung","text":""},{"location":"guides/CIRCUIT_BREAKER/#apisix-api-breaker-plugin","title":"APISIX (api-breaker plugin)","text":"<p>APISIX verwendet das native <code>api-breaker</code> Plugin mit zustandsbasierter Erkennung:</p> <pre><code># GAL Konfiguration\ncircuit_breaker:\n  enabled: true\n  max_failures: 5\n  timeout: \"30s\"\n  half_open_requests: 3\n  unhealthy_status_codes: [500, 502, 503, 504]\n  healthy_status_codes: [200, 201, 202, 204]\n\n# Wird zu APISIX-Config:\n{\n  \"plugins\": {\n    \"api-breaker\": {\n      \"break_response_code\": 503,\n      \"max_breaker_sec\": 30,\n      \"unhealthy\": {\n        \"http_statuses\": [500, 502, 503, 504],\n        \"failures\": 5\n      },\n      \"healthy\": {\n        \"http_statuses\": [200, 201, 202, 204],\n        \"successes\": 3\n      }\n    }\n  }\n}\n</code></pre> <p>APISIX Besonderheiten: - \u2705 Vollst\u00e4ndige Circuit Breaker-Unterst\u00fctzung - \u2705 State-basierte Erkennung (CLOSED/OPEN/HALF_OPEN) - \u2705 Flexible Status Code-Konfiguration - \u2705 Timeout in Sekunden (<code>max_breaker_sec</code>)</p>"},{"location":"guides/CIRCUIT_BREAKER/#traefik-circuitbreaker-middleware","title":"Traefik (CircuitBreaker middleware)","text":"<p>Traefik verwendet Expression-basierte Circuit Breaker:</p> <pre><code># GAL Konfiguration\ncircuit_breaker:\n  enabled: true\n  max_failures: 5\n  unhealthy_status_codes: [500, 504]\n\n# Wird zu Traefik-Config:\nmiddlewares:\n  payment_router_0_circuitbreaker:\n    circuitBreaker:\n      expression: 'ResponseCodeRatio(500, 505, 0, 600) &gt; 0.50'\n</code></pre> <p>Traefik Expression-Syntax:</p> <p>GAL generiert automatisch passende Expressions:</p> <pre><code># Beispiel 1: Status Code Ratio\nmax_failures: 5\nunhealthy_status_codes: [500, 502, 503, 504]\n# \u2192 Expression: \"ResponseCodeRatio(500, 505, 0, 600) &gt; 0.50\"\n\n# Beispiel 2: Network Error Ratio (Fallback)\nmax_failures: 3\nunhealthy_status_codes: []\n# \u2192 Expression: \"NetworkErrorRatio() &gt; 0.30\"\n</code></pre> <p>Traefik Besonderheiten: - \u2705 Expression-basierte Konfiguration - \u2705 Flexible Ratio-Berechnung - \u2705 <code>ResponseCodeRatio(min, max, 0, 600)</code> - \u26a0\ufe0f Timeout nicht direkt konfigurierbar</p>"},{"location":"guides/CIRCUIT_BREAKER/#envoy-outlier-detection","title":"Envoy (Outlier Detection)","text":"<p>Envoy verwendet Outlier Detection f\u00fcr Circuit Breaking:</p> <pre><code># GAL Konfiguration\ncircuit_breaker:\n  enabled: true\n  max_failures: 5\n  timeout: \"30s\"\n  half_open_requests: 3\n\n# Wird zu Envoy-Config:\nclusters:\n  - name: payment_cluster\n    outlier_detection:\n      consecutive_5xx: 5\n      interval: 10s\n      base_ejection_time: 30s\n      max_ejection_percent: 50\n      enforcing_consecutive_5xx: 100\n      success_rate_minimum_hosts: 3\n      success_rate_request_volume: 10\n      enforcing_success_rate: 100\n</code></pre> <p>Envoy Besonderheiten: - \u2705 Outlier Detection auf Cluster-Level - \u2705 <code>consecutive_5xx</code> f\u00fcr Fehler-Erkennung - \u2705 <code>base_ejection_time</code> f\u00fcr Timeout - \u2705 Success Rate Enforcement - \u26a0\ufe0f Max 50% der Hosts k\u00f6nnen ausgeschlossen werden</p>"},{"location":"guides/CIRCUIT_BREAKER/#kong-keine-native-unterstutzung","title":"Kong (\u26a0\ufe0f Keine native Unterst\u00fctzung)","text":"<p>Kong hat keine native Circuit Breaker-Unterst\u00fctzung.</p> <p>Warnung: <pre><code># GAL Konfiguration\ncircuit_breaker:\n  enabled: true\n\n# Kong generiert WARNUNG:\n\u26a0 Circuit breaker configured for route payment_service/api/payments,\n  but Kong does not have native circuit breaker support.\n  Consider using kong-circuit-breaker plugin or switch to a provider\n  with native support.\n</code></pre></p> <p>Alternativen f\u00fcr Kong: 1. Third-Party Plugin: <code>kong-circuit-breaker</code> (Dream11) 2. Provider wechseln: APISIX, Traefik oder Envoy verwenden 3. External Service: Circuit Breaker in Application-Code</p>"},{"location":"guides/CIRCUIT_BREAKER/#haufige-anwendungsfalle","title":"H\u00e4ufige Anwendungsf\u00e4lle","text":""},{"location":"guides/CIRCUIT_BREAKER/#1-payment-service-kritisch","title":"1. Payment Service (Kritisch)","text":"<p>Sofortiger Schutz f\u00fcr kritische Payment-Services:</p> <pre><code>services:\n  - name: payment_service\n    routes:\n      - path_prefix: /api/payments\n        methods: [POST]\n        circuit_breaker:\n          enabled: true\n          max_failures: 3           # Sehr sensitiv\n          timeout: \"60s\"            # L\u00e4ngere Erholung\n          unhealthy_status_codes: [500, 502, 503, 504]\n          failure_response_code: 503\n          failure_response_message: \"Payment service unavailable\"\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#2-external-api-integration","title":"2. External API Integration","text":"<p>Schutz vor externen API-Ausf\u00e4llen:</p> <pre><code>services:\n  - name: external_api\n    upstream:\n      host: api.external.com\n      port: 443\n    routes:\n      - path_prefix: /api/external\n        circuit_breaker:\n          enabled: true\n          max_failures: 5\n          timeout: \"2m\"             # Externe APIs brauchen l\u00e4nger\n          unhealthy_status_codes: [429, 500, 502, 503, 504]\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#3-database-service","title":"3. Database Service","text":"<p>Schutz vor Database-\u00dcberlastung:</p> <pre><code>services:\n  - name: database_api\n    routes:\n      - path_prefix: /api/db\n        circuit_breaker:\n          enabled: true\n          max_failures: 10\n          timeout: \"30s\"\n          unhealthy_status_codes: [500, 503]\n          healthy_status_codes: [200, 201]\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#4-microservices-mesh","title":"4. Microservices Mesh","text":"<p>Circuit Breaker f\u00fcr alle Microservices:</p> <pre><code>services:\n  - name: user_service\n    routes:\n      - path_prefix: /api/users\n        circuit_breaker:\n          enabled: true\n          max_failures: 5\n          timeout: \"30s\"\n\n  - name: order_service\n    routes:\n      - path_prefix: /api/orders\n        circuit_breaker:\n          enabled: true\n          max_failures: 7\n          timeout: \"45s\"\n\n  - name: inventory_service\n    routes:\n      - path_prefix: /api/inventory\n        circuit_breaker:\n          enabled: true\n          max_failures: 10\n          timeout: \"60s\"\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#5-circuit-breaker-rate-limiting-authentication","title":"5. Circuit Breaker + Rate Limiting + Authentication","text":"<p>Vollst\u00e4ndiger Schutz-Stack:</p> <pre><code>routes:\n  - path_prefix: /api/protected\n    methods: [GET, POST]\n\n    # 1. Rate Limiting (\u00dcberlastungsschutz)\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n      burst: 150\n\n    # 2. Authentication (Zugriffsschutz)\n    authentication:\n      enabled: true\n      type: jwt\n      jwt:\n        issuer: \"https://auth.example.com\"\n\n    # 3. Circuit Breaker (Fehler-Schutz)\n    circuit_breaker:\n      enabled: true\n      max_failures: 5\n      timeout: \"30s\"\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#6-gradual-rollback-bei-deployments","title":"6. Gradual Rollback bei Deployments","text":"<p>Schnelle Fehler-Erkennung nach Deployments:</p> <pre><code># Nach neuem Deployment: Sehr sensitive Settings\ncircuit_breaker:\n  enabled: true\n  max_failures: 3             # Sehr sensitiv\n  timeout: \"15s\"              # Schneller Test\n  half_open_requests: 1       # Vorsichtig testen\n\n# Nach Stabilisierung: Normal Settings\ncircuit_breaker:\n  enabled: true\n  max_failures: 10\n  timeout: \"60s\"\n  half_open_requests: 5\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#7-multi-region-failover","title":"7. Multi-Region Failover","text":"<p>Circuit Breaker f\u00fcr Region-Failover:</p> <pre><code>services:\n  - name: primary_region\n    upstream:\n      host: api.us-east-1.example.com\n    routes:\n      - path_prefix: /api\n        circuit_breaker:\n          enabled: true\n          max_failures: 5\n          timeout: \"30s\"\n\n  - name: fallback_region\n    upstream:\n      host: api.eu-west-1.example.com\n    routes:\n      - path_prefix: /api/fallback\n        circuit_breaker:\n          enabled: true\n          max_failures: 5\n          timeout: \"30s\"\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#best-practices","title":"Best Practices","text":""},{"location":"guides/CIRCUIT_BREAKER/#1-richtige-schwellwerte-wahlen","title":"1. \u2705 Richtige Schwellwerte w\u00e4hlen","text":"<p>Zu sensitiv (schlecht): <pre><code>max_failures: 1  # \u274c \u00d6ffnet bei jedem Fehler\ntimeout: \"5s\"    # \u274c Zu kurze Erholung\n</code></pre></p> <p>Gut kalibriert: <pre><code>max_failures: 5-10  # \u2705 Toleriert vereinzelte Fehler\ntimeout: \"30s-60s\"  # \u2705 Angemessene Erholung\n</code></pre></p>"},{"location":"guides/CIRCUIT_BREAKER/#2-service-spezifische-konfiguration","title":"2. \u2705 Service-spezifische Konfiguration","text":"<p>Verschiedene Services brauchen verschiedene Settings:</p> <pre><code># Kritischer Payment Service\n- name: payment\n  circuit_breaker:\n    max_failures: 3\n    timeout: \"60s\"\n\n# Robuster Logging Service\n- name: logging\n  circuit_breaker:\n    max_failures: 20\n    timeout: \"10s\"\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#3-unhealthy-status-codes-richtig-wahlen","title":"3. \u2705 Unhealthy Status Codes richtig w\u00e4hlen","text":"<pre><code># \u2705 Gut: Nur echte Fehler\nunhealthy_status_codes: [500, 502, 503, 504]\n\n# \u26a0\ufe0f Optional: Rate Limiting einbeziehen\nunhealthy_status_codes: [429, 500, 502, 503, 504]\n\n# \u274c Schlecht: Client-Fehler einbeziehen\nunhealthy_status_codes: [400, 404, 500]  # 400/404 sind keine Service-Fehler!\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#4-monitoring-und-alerting","title":"4. \u2705 Monitoring und Alerting","text":"<p>Wichtige Metriken: - Circuit Breaker State Changes (CLOSED \u2192 OPEN) - Anzahl rejected Requests in OPEN-Phase - Success Rate in HALF_OPEN-Phase - Durchschnittliche Erholungszeit</p> <pre><code># Logging aktivieren f\u00fcr Debugging\n# Siehe Provider-spezifische Logs\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#5-graceful-degradation","title":"5. \u2705 Graceful Degradation","text":"<p>Liefere sinnvolle Fallback-Responses:</p> <pre><code>circuit_breaker:\n  failure_response_code: 503\n  failure_response_message: \"Service temporarily unavailable. Please try again later.\"\n</code></pre> <p>Application-Level Fallback: <pre><code>// Client-Code\ntry {\n  const response = await fetch('/api/data');\n  if (response.status === 503) {\n    // Fallback: Cached Data oder Default-Werte\n    return getCachedData();\n  }\n  return response.json();\n} catch (error) {\n  return getDefaultData();\n}\n</code></pre></p>"},{"location":"guides/CIRCUIT_BREAKER/#6-testing-in-staging","title":"6. \u2705 Testing in Staging","text":"<p>Teste Circuit Breaker in Staging-Umgebung:</p> <pre><code># Simuliere Fehler\nfor i in {1..10}; do\n  curl -X POST http://staging.api/test/fail\ndone\n\n# Circuit sollte nach max_failures \u00f6ffnen\ncurl http://staging.api/test\n# \u2192 503 Service temporarily unavailable\n\n# Warte timeout-Dauer\nsleep 30\n\n# Circuit sollte HALF_OPEN testen\ncurl http://staging.api/test\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#7-dokumentiere-settings","title":"7. \u2705 Dokumentiere Settings","text":"<p>Dokumentiere, warum du bestimmte Settings gew\u00e4hlt hast:</p> <pre><code>circuit_breaker:\n  # Payment Service ist kritisch: Sehr sensitive Settings\n  # Bei 3 Fehlern sofort abschalten um Daten-Inkonsistenz zu vermeiden\n  max_failures: 3\n\n  # L\u00e4ngeres Timeout: Payment Provider braucht 30-60s zur Erholung\n  timeout: \"60s\"\n\n  # Vorsichtig testen: Nur 1 Request in HALF_OPEN\n  half_open_requests: 1\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#circuit-breaker-testen","title":"Circuit Breaker Testen","text":""},{"location":"guides/CIRCUIT_BREAKER/#mit-curl","title":"Mit cURL","text":""},{"location":"guides/CIRCUIT_BREAKER/#test-1-normale-requests","title":"Test 1: Normale Requests","text":"<pre><code># Normale Requests sollten durchgehen\nfor i in {1..5}; do\n  curl -X GET http://api.example.com/api/test\n  echo \"Request $i completed\"\ndone\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#test-2-fehler-provozieren","title":"Test 2: Fehler provozieren","text":"<pre><code># Provoziere Fehler um Circuit zu \u00f6ffnen\n# (Voraussetzung: Backend gibt 500 zur\u00fcck)\nfor i in {1..10}; do\n  curl -X GET http://api.example.com/api/fail\n  echo \"Error request $i: $(date)\"\ndone\n\n# Circuit sollte nach max_failures \u00f6ffnen\ncurl -v http://api.example.com/api/test\n# \u2192 HTTP/1.1 503 Service temporarily unavailable\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#test-3-erholung-testen","title":"Test 3: Erholung testen","text":"<pre><code># Warte timeout-Dauer\nsleep 30\n\n# Circuit sollte jetzt HALF_OPEN sein und Requests testen\ncurl -v http://api.example.com/api/test\n# \u2192 Wenn erfolgreich: Circuit geht zu CLOSED\n# \u2192 Wenn fehlschl\u00e4gt: Circuit geht zur\u00fcck zu OPEN\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#mit-python-requests","title":"Mit Python Requests","text":"<pre><code>import requests\nimport time\n\ndef test_circuit_breaker():\n    \"\"\"Test Circuit Breaker functionality\"\"\"\n    api_url = \"http://api.example.com/api/test\"\n\n    # 1. Provoziere Fehler\n    print(\"Provoking failures...\")\n    for i in range(10):\n        response = requests.get(api_url + \"/fail\")\n        print(f\"Request {i+1}: Status {response.status_code}\")\n\n    # 2. Circuit sollte jetzt OPEN sein\n    print(\"\\nTesting circuit OPEN state...\")\n    response = requests.get(api_url)\n    assert response.status_code == 503, \"Circuit should be OPEN\"\n    print(f\"\u2713 Circuit is OPEN: {response.status_code}\")\n\n    # 3. Warte auf timeout\n    print(\"\\nWaiting for timeout (30s)...\")\n    time.sleep(30)\n\n    # 4. Circuit sollte HALF_OPEN sein\n    print(\"\\nTesting circuit HALF_OPEN state...\")\n    response = requests.get(api_url)\n    print(f\"Half-open test: Status {response.status_code}\")\n\n    # 5. Wenn erfolgreich: Circuit sollte CLOSED sein\n    if response.status_code == 200:\n        print(\"\u2713 Circuit recovered to CLOSED\")\n    else:\n        print(\"\u2717 Circuit failed half-open test\")\n\nif __name__ == \"__main__\":\n    test_circuit_breaker()\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#automatisierte-tests","title":"Automatisierte Tests","text":"<pre><code>import pytest\nimport requests\nimport time\n\n@pytest.fixture\ndef api_base_url():\n    return \"http://localhost:8080\"\n\ndef test_circuit_opens_after_failures(api_base_url):\n    \"\"\"Test that circuit opens after max_failures\"\"\"\n    # Provoziere 5 Fehler (max_failures = 5)\n    for _ in range(5):\n        requests.get(f\"{api_base_url}/api/fail\")\n\n    # Circuit sollte OPEN sein\n    response = requests.get(f\"{api_base_url}/api/test\")\n    assert response.status_code == 503\n\ndef test_circuit_half_open_after_timeout(api_base_url):\n    \"\"\"Test that circuit goes to HALF_OPEN after timeout\"\"\"\n    # \u00d6ffne Circuit\n    for _ in range(5):\n        requests.get(f\"{api_base_url}/api/fail\")\n\n    # Warte timeout (30s)\n    time.sleep(30)\n\n    # Circuit sollte HALF_OPEN sein und Requests testen\n    response = requests.get(f\"{api_base_url}/api/test\")\n    # Wenn Backend funktioniert: 200, sonst 503\n    assert response.status_code in [200, 503]\n\ndef test_circuit_closes_after_successful_half_open(api_base_url):\n    \"\"\"Test that circuit closes after successful half_open_requests\"\"\"\n    # \u00d6ffne Circuit\n    for _ in range(5):\n        requests.get(f\"{api_base_url}/api/fail\")\n\n    # Warte timeout\n    time.sleep(30)\n\n    # half_open_requests (z.B. 3) erfolgreiche Requests\n    for _ in range(3):\n        response = requests.get(f\"{api_base_url}/api/test\")\n        assert response.status_code == 200\n\n    # Circuit sollte jetzt CLOSED sein\n    response = requests.get(f\"{api_base_url}/api/test\")\n    assert response.status_code == 200\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#provider-spezifisches-testing","title":"Provider-spezifisches Testing","text":""},{"location":"guides/CIRCUIT_BREAKER/#apisix-testing","title":"APISIX Testing","text":"<pre><code># APISIX Admin API abfragen\ncurl -X GET http://localhost:9180/apisix/admin/routes/1 \\\n  -H \"X-API-KEY: your-admin-key\"\n\n# Circuit Breaker Status pr\u00fcfen\n# (APISIX speichert Circuit State in Memory/Redis)\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#envoy-testing","title":"Envoy Testing","text":"<pre><code># Envoy Admin Interface\ncurl http://localhost:9901/stats | grep outlier_detection\n\n# Outlier Detection Stats:\n# cluster.payment_cluster.outlier_detection.ejections_active: 1\n# cluster.payment_cluster.outlier_detection.ejections_total: 5\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#traefik-testing","title":"Traefik Testing","text":"<pre><code># Traefik Dashboard\nopen http://localhost:8080/dashboard/\n\n# Circuit Breaker Metrics in Dashboard sichtbar\n# Anzahl offener Circuits\n# Anzahl abgelehnter Requests\n</code></pre>"},{"location":"guides/CIRCUIT_BREAKER/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/CIRCUIT_BREAKER/#problem-1-circuit-offnet-zu-haufig","title":"Problem 1: Circuit \u00f6ffnet zu h\u00e4ufig","text":"<p>Symptom: Circuit Breaker \u00f6ffnet bei vereinzelten Fehlern.</p> <p>Ursache: <code>max_failures</code> zu niedrig eingestellt.</p> <p>L\u00f6sung: <pre><code># \u274c Zu sensitiv\nmax_failures: 1\n\n# \u2705 Toleriert vereinzelte Fehler\nmax_failures: 5-10\n</code></pre></p>"},{"location":"guides/CIRCUIT_BREAKER/#problem-2-circuit-offnet-nie","title":"Problem 2: Circuit \u00f6ffnet nie","text":"<p>Symptom: Trotz vieler Fehler \u00f6ffnet Circuit nie.</p> <p>L\u00f6sung 1: Pr\u00fcfe <code>unhealthy_status_codes</code> <pre><code># \u274c Falsch: Backend gibt 502 zur\u00fcck, aber nur 500 konfiguriert\nunhealthy_status_codes: [500]\n\n# \u2705 Richtig: Alle 5xx-Fehler\nunhealthy_status_codes: [500, 502, 503, 504]\n</code></pre></p> <p>L\u00f6sung 2: Pr\u00fcfe Provider-Logs <pre><code># APISIX Logs\ndocker logs apisix | grep api-breaker\n\n# Envoy Logs\ndocker logs envoy | grep outlier_detection\n\n# Traefik Logs\ndocker logs traefik | grep circuitbreaker\n</code></pre></p>"},{"location":"guides/CIRCUIT_BREAKER/#problem-3-circuit-bleibt-dauerhaft-open","title":"Problem 3: Circuit bleibt dauerhaft OPEN","text":"<p>Symptom: Circuit erholt sich nie, bleibt permanent OPEN.</p> <p>Ursache: Backend ist dauerhaft kaputt oder <code>timeout</code> zu kurz.</p> <p>L\u00f6sung: <pre><code># \u274c Timeout zu kurz\ntimeout: \"5s\"  # Backend braucht l\u00e4nger zur Erholung\n\n# \u2705 L\u00e4ngerer Timeout\ntimeout: \"60s\"\n\n# \u2705 Oder Backend fixen!\n</code></pre></p>"},{"location":"guides/CIRCUIT_BREAKER/#problem-4-half_open-tests-schlagen-fehl","title":"Problem 4: HALF_OPEN Tests schlagen fehl","text":"<p>Symptom: Circuit geht zu HALF_OPEN, aber Tests schlagen immer fehl.</p> <p>L\u00f6sung 1: Reduziere <code>half_open_requests</code> <pre><code># \u274c Zu viele Test-Requests\nhalf_open_requests: 10\n\n# \u2705 Weniger Test-Requests\nhalf_open_requests: 1-3\n</code></pre></p> <p>L\u00f6sung 2: Erh\u00f6he <code>timeout</code> <pre><code># Gib Backend mehr Zeit zur Erholung\ntimeout: \"2m\"  # Statt 30s\n</code></pre></p>"},{"location":"guides/CIRCUIT_BREAKER/#problem-5-kong-circuit-breaker-funktioniert-nicht","title":"Problem 5: Kong Circuit Breaker funktioniert nicht","text":"<p>Symptom: Kong ignoriert Circuit Breaker-Konfiguration.</p> <p>Ursache: Kong hat keine native Unterst\u00fctzung.</p> <p>L\u00f6sung: 1. Option 1: Wechsle zu APISIX, Traefik oder Envoy <pre><code># \u00c4ndere Provider in gateway.yaml\nprovider: apisix  # Statt kong\n</code></pre></p> <ol> <li> <p>Option 2: Installiere Third-Party Plugin <pre><code># kong-circuit-breaker (Dream11)\nluarocks install kong-circuit-breaker\n</code></pre></p> </li> <li> <p>Option 3: Implementiere in Application-Code <pre><code>// Circuit Breaker in Node.js\nconst CircuitBreaker = require('opossum');\nconst breaker = new CircuitBreaker(apiCall, {\n  timeout: 30000,\n  errorThresholdPercentage: 50,\n  resetTimeout: 30000\n});\n</code></pre></p> </li> </ol>"},{"location":"guides/CIRCUIT_BREAKER/#problem-6-fehler-metriken-stimmen-nicht","title":"Problem 6: Fehler-Metriken stimmen nicht","text":"<p>Symptom: Circuit \u00f6ffnet, obwohl Metriken gut aussehen.</p> <p>L\u00f6sung: Pr\u00fcfe Provider-spezifische Metrics</p> <p>APISIX: <pre><code># APISIX Prometheus Metrics\ncurl http://localhost:9091/apisix/prometheus/metrics | grep api_breaker\n</code></pre></p> <p>Envoy: <pre><code># Envoy Stats\ncurl http://localhost:9901/stats | grep outlier\n</code></pre></p> <p>Traefik: <pre><code># Traefik Metrics\ncurl http://localhost:8080/metrics | grep circuit\n</code></pre></p>"},{"location":"guides/CIRCUIT_BREAKER/#problem-7-circuit-breaker-ignoriert-healthy_status_codes","title":"Problem 7: Circuit Breaker ignoriert healthy_status_codes","text":"<p>Symptom: 201, 202 werden als Fehler gewertet.</p> <p>L\u00f6sung: Erweitere <code>healthy_status_codes</code> <pre><code># \u2705 Alle Success-Codes\nhealthy_status_codes: [200, 201, 202, 204, 304]\n</code></pre></p>"},{"location":"guides/CIRCUIT_BREAKER/#best-practice-checkliste","title":"Best Practice Checkliste","text":""},{"location":"guides/CIRCUIT_BREAKER/#vor-deployment","title":"Vor Deployment","text":"<ul> <li> \u2705 <code>max_failures</code> an Service-Kritikalit\u00e4t anpassen</li> <li> \u2705 <code>timeout</code> basierend auf Service-Erholungszeit w\u00e4hlen</li> <li> \u2705 <code>unhealthy_status_codes</code> korrekt konfigurieren (nur 5xx!)</li> <li> \u2705 <code>healthy_status_codes</code> vollst\u00e4ndig definieren</li> <li> \u2705 Provider-Support pr\u00fcfen (Kong hat keine native Unterst\u00fctzung!)</li> <li> \u2705 Circuit Breaker in Staging testen</li> <li> \u2705 Monitoring f\u00fcr Circuit States einrichten</li> </ul>"},{"location":"guides/CIRCUIT_BREAKER/#monitoring-alerting","title":"Monitoring &amp; Alerting","text":"<ul> <li> \u2705 Alert bei Circuit State = OPEN</li> <li> \u2705 Dashboard f\u00fcr Circuit Breaker Metrics</li> <li> \u2705 Log Circuit State Changes</li> <li> \u2705 Track Erholungszeit (Zeit in OPEN-Phase)</li> <li> \u2705 Monitor HALF_OPEN Success Rate</li> </ul>"},{"location":"guides/CIRCUIT_BREAKER/#testing","title":"Testing","text":"<ul> <li> \u2705 Test: Circuit \u00f6ffnet nach max_failures</li> <li> \u2705 Test: Circuit geht zu HALF_OPEN nach timeout</li> <li> \u2705 Test: Circuit schlie\u00dft nach erfolgreichen Tests</li> <li> \u2705 Test: Circuit bleibt OPEN bei fehlgeschlagenen Tests</li> <li> \u2705 Load Testing mit Circuit Breaker</li> </ul>"},{"location":"guides/CIRCUIT_BREAKER/#zusammenfassung","title":"Zusammenfassung","text":"<p>Circuit Breaker in GAL erm\u00f6glicht:</p> <p>\u2705 Fehler-Isolation: Verhindert Cascading Failures \u2705 Automatische Erholung: Selbstheilende Systeme \u2705 Resource-Schonung: Verschwendet keine Ressourcen \u2705 Provider-Abstraktion: APISIX, Traefik, Envoy (75% Coverage)</p> <p>Wichtige Erkenntnisse: - \u26a0\ufe0f Kong hat keine native Unterst\u00fctzung (nur Third-Party) - \u2705 APISIX, Traefik, Envoy haben vollst\u00e4ndige Unterst\u00fctzung - \u26a0\ufe0f Settings m\u00fcssen pro Service kalibriert werden - \u2705 Kombiniere mit Rate Limiting f\u00fcr optimalen Schutz</p> <p>N\u00e4chste Schritte: - Siehe RATE_LIMITING.md f\u00fcr Traffic-Schutz - Siehe examples/circuit-breaker-example.yaml f\u00fcr vollst\u00e4ndige Beispiele - Siehe PROVIDERS.md f\u00fcr Provider-Details</p> <p>Hilfe ben\u00f6tigt? - Probleme melden: https://github.com/pt9912/x-gal/issues - Dokumentation: https://docs.gal.dev - Beispiele: examples/</p>"},{"location":"guides/CORS/","title":"CORS (Cross-Origin Resource Sharing) Anleitung","text":"<p>Umfassende Anleitung f\u00fcr CORS-Policies in GAL (Gateway Abstraction Layer)</p>"},{"location":"guides/CORS/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ol> <li>\u00dcbersicht</li> <li>Schnellstart</li> <li>Konfigurationsoptionen</li> <li>Provider-Implementierung</li> <li>H\u00e4ufige Anwendungsf\u00e4lle</li> <li>Sicherheits-Best-Practices</li> <li>CORS Testen</li> <li>Troubleshooting</li> </ol>"},{"location":"guides/CORS/#ubersicht","title":"\u00dcbersicht","text":"<p>CORS (Cross-Origin Resource Sharing) ist ein Sicherheitsmechanismus, der es Webanwendungen erm\u00f6glicht, Ressourcen von verschiedenen Urspr\u00fcngen (Origins) anzufordern. GAL bietet eine einheitliche CORS-Konfiguration f\u00fcr alle unterst\u00fctzten Gateway-Provider.</p>"},{"location":"guides/CORS/#was-ist-cors","title":"Was ist CORS?","text":"<p>CORS erm\u00f6glicht es Browsern, Cross-Origin-Requests durchzuf\u00fchren, die normalerweise durch die Same-Origin-Policy blockiert w\u00fcrden. Beispiel:</p> <ul> <li>Frontend: <code>https://app.example.com</code></li> <li>API: <code>https://api.example.com</code></li> </ul> <p>Ohne CORS w\u00fcrde der Browser die Requests vom Frontend zur API blockieren, da sie unterschiedliche Origins haben.</p>"},{"location":"guides/CORS/#warum-ist-cors-wichtig","title":"Warum ist CORS wichtig?","text":"<ul> <li>\u2705 Sicherheit: Kontrolliert, welche Domains auf deine API zugreifen d\u00fcrfen</li> <li>\u2705 Flexibilit\u00e4t: Erm\u00f6glicht moderne Frontend-Architekturen (SPA, PWA)</li> <li>\u2705 Browser-Kompatibilit\u00e4t: Funktioniert mit allen modernen Browsern</li> <li>\u2705 Credentials-Support: Erm\u00f6glicht Cookies und Authentication headers</li> </ul>"},{"location":"guides/CORS/#unterstutzte-features","title":"Unterst\u00fctzte Features","text":"Feature Kong APISIX Traefik Envoy Beschreibung Allowed Origins \u2705 \u2705 \u2705 \u2705 Welche Origins d\u00fcrfen zugreifen Allowed Methods \u2705 \u2705 \u2705 \u2705 Erlaubte HTTP-Methoden Allowed Headers \u2705 \u2705 \u2705 \u2705 Erlaubte Request-Headers Exposed Headers \u2705 \u2705 \u2705 \u2705 Headers die an Client zur\u00fcckgegeben werden Credentials \u2705 \u2705 \u2705 \u2705 Cookies/Auth headers erlauben Max Age \u2705 \u2705 \u2705 \u2705 Preflight-Cache-Dauer"},{"location":"guides/CORS/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/CORS/#einfache-cors-konfiguration","title":"Einfache CORS-Konfiguration","text":"<p>Erlaube alle Origins (nur f\u00fcr Entwicklung!):</p> <pre><code>version: \"1.0\"\nprovider: kong\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      host: api.example.com\n      port: 8080\n    routes:\n      - path_prefix: /api\n        methods: [GET, POST, OPTIONS]\n        cors:\n          enabled: true\n          allowed_origins: [\"*\"]\n          allowed_methods: [GET, POST, PUT, DELETE, OPTIONS]\n          allowed_headers: [Content-Type, Authorization]\n</code></pre>"},{"location":"guides/CORS/#produktions-cors-konfiguration","title":"Produktions-CORS-Konfiguration","text":"<p>Beschr\u00e4nke auf spezifische Origins:</p> <pre><code>routes:\n  - path_prefix: /api\n    methods: [GET, POST, OPTIONS]\n    cors:\n      enabled: true\n      allowed_origins:\n        - \"https://app.example.com\"\n        - \"https://www.example.com\"\n      allowed_methods: [GET, POST, PUT, DELETE, OPTIONS]\n      allowed_headers: [Content-Type, Authorization, X-API-Key]\n      expose_headers: [X-Request-ID, X-RateLimit-Remaining]\n      allow_credentials: true\n      max_age: 86400  # 24 Stunden\n</code></pre>"},{"location":"guides/CORS/#cors-mit-authentication","title":"CORS mit Authentication","text":"<p>Kombiniere CORS mit JWT-Authentication:</p> <pre><code>routes:\n  - path_prefix: /api/protected\n    methods: [GET, POST, OPTIONS]\n\n    # CORS-Konfiguration\n    cors:\n      enabled: true\n      allowed_origins: [\"https://app.example.com\"]\n      allowed_methods: [GET, POST, OPTIONS]\n      allowed_headers: [Content-Type, Authorization]\n      allow_credentials: true\n\n    # Authentication\n    authentication:\n      enabled: true\n      type: jwt\n      jwt:\n        issuer: \"https://auth.example.com\"\n        audience: \"api.example.com\"\n        jwks_uri: \"https://auth.example.com/.well-known/jwks.json\"\n</code></pre>"},{"location":"guides/CORS/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/CORS/#corspolicy-felder","title":"CORSPolicy Felder","text":"<pre><code>cors:\n  # Aktivierung\n  enabled: true\n\n  # Erlaubte Origins (Domains)\n  allowed_origins:\n    - \"https://app.example.com\"\n    - \"https://admin.example.com\"\n    # Oder Wildcard (NUR f\u00fcr Entwicklung!)\n    # - \"*\"\n\n  # Erlaubte HTTP-Methoden\n  allowed_methods:\n    - GET\n    - POST\n    - PUT\n    - DELETE\n    - OPTIONS  # Wichtig f\u00fcr Preflight!\n\n  # Erlaubte Request-Headers\n  allowed_headers:\n    - Content-Type\n    - Authorization\n    - X-API-Key\n    - X-Custom-Header\n\n  # Headers die an Browser zur\u00fcckgegeben werden\n  expose_headers:\n    - X-Request-ID\n    - X-Response-Time\n    - X-RateLimit-Remaining\n\n  # Credentials erlauben (Cookies, Auth headers)\n  allow_credentials: true\n\n  # Preflight-Cache-Dauer (in Sekunden)\n  max_age: 86400  # 24 Stunden\n</code></pre>"},{"location":"guides/CORS/#standard-werte","title":"Standard-Werte","text":"<p>Wenn Felder weggelassen werden, gelten folgende Defaults:</p> <pre><code>cors:\n  enabled: true\n  allowed_origins: [\"*\"]\n  allowed_methods: [GET, POST, PUT, DELETE, OPTIONS]\n  allowed_headers: [Content-Type, Authorization]\n  expose_headers: []\n  allow_credentials: false\n  max_age: 86400\n</code></pre>"},{"location":"guides/CORS/#wildcard-origins","title":"Wildcard Origins (<code>*</code>)","text":"<p>\u26a0\ufe0f Warnung: Wildcard Origins sind unsicher f\u00fcr Produktion!</p> <pre><code># \u274c NICHT in Produktion verwenden!\ncors:\n  allowed_origins: [\"*\"]\n  allow_credentials: true  # Funktioniert nicht mit \"*\"!\n\n# \u2705 Stattdessen spezifische Origins:\ncors:\n  allowed_origins:\n    - \"https://app.example.com\"\n    - \"https://admin.example.com\"\n  allow_credentials: true\n</code></pre> <p>Wichtig: Wenn <code>allow_credentials: true</code>, dann darf NICHT <code>*</code> als Origin verwendet werden!</p>"},{"location":"guides/CORS/#provider-implementierung","title":"Provider-Implementierung","text":""},{"location":"guides/CORS/#kong-cors-plugin","title":"Kong (cors plugin)","text":"<p>Kong verwendet das native <code>cors</code> Plugin:</p> <pre><code># GAL Konfiguration\ncors:\n  enabled: true\n  allowed_origins: [\"https://app.example.com\"]\n  allowed_methods: [GET, POST]\n  allow_credentials: true\n\n# Wird zu Kong-Config:\nplugins:\n  - name: cors\n    config:\n      origins:\n        - \"https://app.example.com\"\n      methods:\n        - GET\n        - POST\n      headers:\n        - Content-Type\n        - Authorization\n      credentials: true\n      max_age: 86400\n</code></pre> <p>Kong Besonderheiten: - \u2705 Vollst\u00e4ndige CORS-Unterst\u00fctzung - \u2705 Native Plugin-Integration - \u2705 Regex-Support f\u00fcr Origins - \u26a0\ufe0f OPTIONS-Methode muss in Route-Methoden enthalten sein</p>"},{"location":"guides/CORS/#apisix-cors-plugin","title":"APISIX (cors plugin)","text":"<p>APISIX verwendet das <code>cors</code> Plugin mit komma-separiertem Format:</p> <pre><code># GAL Konfiguration\ncors:\n  enabled: true\n  allowed_origins: [\"https://app.example.com\", \"https://www.example.com\"]\n  allowed_methods: [GET, POST]\n\n# Wird zu APISIX-Config:\n{\n  \"plugins\": {\n    \"cors\": {\n      \"allow_origins\": \"https://app.example.com,https://www.example.com\",\n      \"allow_methods\": \"GET,POST\",\n      \"allow_headers\": \"Content-Type,Authorization\",\n      \"allow_credential\": true,\n      \"max_age\": 86400\n    }\n  }\n}\n</code></pre> <p>APISIX Besonderheiten: - \u2705 Native CORS-Plugin - \u26a0\ufe0f Komma-separierte Listen (automatisch konvertiert) - \u26a0\ufe0f <code>allow_credential</code> (singular, nicht plural!)</p>"},{"location":"guides/CORS/#traefik-headers-middleware","title":"Traefik (headers middleware)","text":"<p>Traefik implementiert CORS via Headers-Middleware:</p> <pre><code># GAL Konfiguration\ncors:\n  enabled: true\n  allowed_origins: [\"https://app.example.com\"]\n  allowed_methods: [GET, POST]\n\n# Wird zu Traefik-Config:\nmiddlewares:\n  api_router_0_cors:\n    headers:\n      accessControlAllowMethods:\n        - GET\n        - POST\n      accessControlAllowOriginList:\n        - \"https://app.example.com\"\n      accessControlAllowHeaders:\n        - Content-Type\n        - Authorization\n      accessControlAllowCredentials: true\n      accessControlMaxAge: 86400\n</code></pre> <p>Traefik Besonderheiten: - \u2705 Headers-Middleware f\u00fcr CORS - \u2705 <code>accessControl*</code> Konfiguration - \u26a0\ufe0f Middleware muss in Router referenziert werden</p>"},{"location":"guides/CORS/#envoy-native-cors-policy","title":"Envoy (native CORS policy)","text":"<p>Envoy hat native CORS-Unterst\u00fctzung auf Route-Level:</p> <pre><code># GAL Konfiguration\ncors:\n  enabled: true\n  allowed_origins: [\"https://app.example.com\"]\n  allowed_methods: [GET, POST]\n\n# Wird zu Envoy-Config:\nroutes:\n  - match:\n      prefix: /api\n    route:\n      cluster: api_cluster\n    cors:\n      allow_origin_string_match:\n        - exact: \"https://app.example.com\"\n      allow_methods: \"GET, POST\"\n      allow_headers: \"Content-Type, Authorization\"\n      allow_credentials: true\n      max_age: \"86400\"\n</code></pre> <p>Envoy Besonderheiten: - \u2705 Native CORS-Policy - \u2705 Regex-Support f\u00fcr Origins - \u26a0\ufe0f Wildcard <code>*</code> wird zu <code>safe_regex: '.*'</code> konvertiert</p>"},{"location":"guides/CORS/#haufige-anwendungsfalle","title":"H\u00e4ufige Anwendungsf\u00e4lle","text":""},{"location":"guides/CORS/#1-single-page-application-spa","title":"1. Single-Page Application (SPA)","text":"<p>Frontend und Backend auf verschiedenen Domains:</p> <pre><code># Frontend: https://app.example.com\n# Backend: https://api.example.com\n\nservices:\n  - name: api\n    routes:\n      - path_prefix: /api\n        methods: [GET, POST, PUT, DELETE, OPTIONS]\n        cors:\n          enabled: true\n          allowed_origins:\n            - \"https://app.example.com\"\n          allowed_methods: [GET, POST, PUT, DELETE, OPTIONS]\n          allowed_headers: [Content-Type, Authorization]\n          allow_credentials: true\n</code></pre>"},{"location":"guides/CORS/#2-mehrere-frontend-domains","title":"2. Mehrere Frontend-Domains","text":"<p>Erlaube mehrere Subdomains:</p> <pre><code>cors:\n  enabled: true\n  allowed_origins:\n    - \"https://app.example.com\"\n    - \"https://admin.example.com\"\n    - \"https://mobile.example.com\"\n  allowed_methods: [GET, POST, PUT, DELETE, OPTIONS]\n  allow_credentials: true\n</code></pre>"},{"location":"guides/CORS/#3-public-api-keine-credentials","title":"3. Public API (keine Credentials)","text":"<p>\u00d6ffentliche API ohne Authentication:</p> <pre><code>cors:\n  enabled: true\n  allowed_origins: [\"*\"]  # OK f\u00fcr public APIs\n  allowed_methods: [GET, POST, OPTIONS]\n  allowed_headers: [Content-Type]\n  allow_credentials: false  # Wichtig!\n  max_age: 86400\n</code></pre>"},{"location":"guides/CORS/#4-api-mit-custom-headers","title":"4. API mit Custom Headers","text":"<p>Erlaube spezielle API-Keys im Header:</p> <pre><code>cors:\n  enabled: true\n  allowed_origins: [\"https://app.example.com\"]\n  allowed_methods: [GET, POST, OPTIONS]\n  allowed_headers:\n    - Content-Type\n    - Authorization\n    - X-API-Key        # Custom Header\n    - X-Client-ID      # Custom Header\n  expose_headers:\n    - X-RateLimit-Limit\n    - X-RateLimit-Remaining\n    - X-RateLimit-Reset\n</code></pre>"},{"location":"guides/CORS/#5-entwicklung-vs-produktion","title":"5. Entwicklung vs. Produktion","text":"<p>Verschiedene CORS-Konfigurationen:</p> <pre><code># development.yaml\ncors:\n  enabled: true\n  allowed_origins: [\"*\"]\n  allowed_methods: [GET, POST, PUT, DELETE, OPTIONS]\n  allow_credentials: false\n\n# production.yaml\ncors:\n  enabled: true\n  allowed_origins:\n    - \"https://app.example.com\"\n    - \"https://www.example.com\"\n  allowed_methods: [GET, POST, PUT, DELETE, OPTIONS]\n  allowed_headers: [Content-Type, Authorization]\n  allow_credentials: true\n</code></pre>"},{"location":"guides/CORS/#6-mobile-apps","title":"6. Mobile Apps","text":"<p>Erlaube spezielle Origins f\u00fcr mobile Apps:</p> <pre><code>cors:\n  enabled: true\n  allowed_origins:\n    - \"https://app.example.com\"      # Web\n    - \"capacitor://localhost\"        # Capacitor iOS\n    - \"http://localhost\"             # Capacitor Android\n  allowed_methods: [GET, POST, PUT, DELETE, OPTIONS]\n  allow_credentials: true\n</code></pre>"},{"location":"guides/CORS/#7-graphql-api","title":"7. GraphQL API","text":"<p>CORS f\u00fcr GraphQL-Endpoints:</p> <pre><code>services:\n  - name: graphql_api\n    routes:\n      - path_prefix: /graphql\n        methods: [GET, POST, OPTIONS]\n        cors:\n          enabled: true\n          allowed_origins: [\"https://app.example.com\"]\n          allowed_methods: [GET, POST, OPTIONS]\n          allowed_headers:\n            - Content-Type\n            - Authorization\n            - X-Apollo-Tracing  # GraphQL-spezifisch\n</code></pre>"},{"location":"guides/CORS/#8-websocket-verbindungen","title":"8. WebSocket-Verbindungen","text":"<p>CORS f\u00fcr WebSocket-Upgrades:</p> <pre><code>services:\n  - name: websocket_service\n    routes:\n      - path_prefix: /ws\n        methods: [GET, OPTIONS]  # WebSocket uses GET for upgrade\n        cors:\n          enabled: true\n          allowed_origins: [\"https://app.example.com\"]\n          allowed_methods: [GET, OPTIONS]\n          allowed_headers:\n            - Sec-WebSocket-Protocol\n            - Sec-WebSocket-Extensions\n</code></pre>"},{"location":"guides/CORS/#sicherheits-best-practices","title":"Sicherheits-Best-Practices","text":""},{"location":"guides/CORS/#1-niemals-wildcard-mit-credentials","title":"1. \u274c Niemals Wildcard mit Credentials","text":"<p>Falsch (Sicherheitsl\u00fccke!): <pre><code>cors:\n  allowed_origins: [\"*\"]\n  allow_credentials: true  # \u274c GEF\u00c4HRLICH!\n</code></pre></p> <p>Richtig: <pre><code>cors:\n  allowed_origins:\n    - \"https://app.example.com\"\n  allow_credentials: true  # \u2705 Sicher\n</code></pre></p>"},{"location":"guides/CORS/#2-spezifische-origins-verwenden","title":"2. \u2705 Spezifische Origins verwenden","text":"<p>Falsch: <pre><code>allowed_origins: [\"*\"]  # \u274c Zu permissiv\n</code></pre></p> <p>Richtig: <pre><code>allowed_origins:\n  - \"https://app.example.com\"\n  - \"https://admin.example.com\"\n</code></pre></p>"},{"location":"guides/CORS/#3-minimale-header-rechte","title":"3. \u2705 Minimale Header-Rechte","text":"<p>Erlaube nur ben\u00f6tigte Headers:</p> <pre><code># \u274c Zu permissiv\nallowed_headers: [\"*\"]\n\n# \u2705 Nur ben\u00f6tigte Headers\nallowed_headers:\n  - Content-Type\n  - Authorization\n  - X-API-Key\n</code></pre>"},{"location":"guides/CORS/#4-options-methode-nicht-vergessen","title":"4. \u2705 OPTIONS-Methode nicht vergessen","text":"<p>F\u00fcr Preflight-Requests:</p> <pre><code>routes:\n  - path_prefix: /api\n    methods: [GET, POST, PUT, DELETE, OPTIONS]  # \u2705 OPTIONS!\n    cors:\n      enabled: true\n</code></pre>"},{"location":"guides/CORS/#5-https-fur-produktion","title":"5. \u2705 HTTPS f\u00fcr Produktion","text":"<p>Verwende immer HTTPS-Origins in Produktion:</p> <pre><code># \u274c HTTP in Produktion\nallowed_origins:\n  - \"http://app.example.com\"\n\n# \u2705 HTTPS in Produktion\nallowed_origins:\n  - \"https://app.example.com\"\n</code></pre>"},{"location":"guides/CORS/#6-max-age-begrenzen","title":"6. \u2705 Max Age begrenzen","text":"<p>Setze sinnvolle Preflight-Cache-Dauer:</p> <pre><code># \u274c Zu lang (1 Jahr)\nmax_age: 31536000\n\n# \u2705 Sinnvoll (24 Stunden)\nmax_age: 86400\n</code></pre>"},{"location":"guides/CORS/#7-expose-nur-benotigte-headers","title":"7. \u2705 Expose nur ben\u00f6tigte Headers","text":"<p>Exponiere nur Headers die der Client wirklich braucht:</p> <pre><code># \u2705 Nur ben\u00f6tigte Headers\nexpose_headers:\n  - X-Request-ID\n  - X-RateLimit-Remaining\n\n# \u274c Zu viele interne Headers\nexpose_headers:\n  - X-Internal-Service\n  - X-Database-Host  # Sensible Informationen!\n</code></pre>"},{"location":"guides/CORS/#cors-testen","title":"CORS Testen","text":""},{"location":"guides/CORS/#mit-curl","title":"Mit cURL","text":""},{"location":"guides/CORS/#preflight-request-options-testen","title":"Preflight-Request (OPTIONS) testen:","text":"<pre><code>curl -X OPTIONS http://api.example.com/api/users \\\n  -H \"Origin: https://app.example.com\" \\\n  -H \"Access-Control-Request-Method: POST\" \\\n  -H \"Access-Control-Request-Headers: Content-Type\" \\\n  -v\n</code></pre> <p>Erwartete Response-Headers: <pre><code>Access-Control-Allow-Origin: https://app.example.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS\nAccess-Control-Allow-Headers: Content-Type, Authorization\nAccess-Control-Max-Age: 86400\n</code></pre></p>"},{"location":"guides/CORS/#actual-request-testen","title":"Actual Request testen:","text":"<pre><code>curl -X GET http://api.example.com/api/users \\\n  -H \"Origin: https://app.example.com\" \\\n  -v\n</code></pre> <p>Erwartete Response-Headers: <pre><code>Access-Control-Allow-Origin: https://app.example.com\n</code></pre></p>"},{"location":"guides/CORS/#mit-javascript-browser","title":"Mit JavaScript (Browser)","text":"<pre><code>// Einfacher CORS-Test\nfetch('https://api.example.com/api/users', {\n  method: 'GET',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  credentials: 'include'  // Wenn allow_credentials: true\n})\n.then(response =&gt; {\n  console.log('CORS successful!');\n  console.log('Response headers:', response.headers);\n  return response.json();\n})\n.catch(error =&gt; {\n  console.error('CORS error:', error);\n});\n</code></pre>"},{"location":"guides/CORS/#mit-python-requests","title":"Mit Python Requests","text":"<pre><code>import requests\n\n# Test Preflight\nresponse = requests.options(\n    'http://api.example.com/api/users',\n    headers={\n        'Origin': 'https://app.example.com',\n        'Access-Control-Request-Method': 'POST',\n        'Access-Control-Request-Headers': 'Content-Type'\n    }\n)\n\nprint('Preflight Response Headers:')\nprint(response.headers)\n\n# Check CORS headers\nassert 'Access-Control-Allow-Origin' in response.headers\nassert response.headers['Access-Control-Allow-Origin'] == 'https://app.example.com'\n</code></pre>"},{"location":"guides/CORS/#automatisierte-tests","title":"Automatisierte Tests","text":"<pre><code>def test_cors_headers():\n    \"\"\"Test CORS configuration\"\"\"\n    response = requests.get(\n        'http://api.example.com/api/users',\n        headers={'Origin': 'https://app.example.com'}\n    )\n\n    # Check allowed origin\n    assert 'Access-Control-Allow-Origin' in response.headers\n    assert response.headers['Access-Control-Allow-Origin'] == 'https://app.example.com'\n\n    # Check credentials\n    if 'Access-Control-Allow-Credentials' in response.headers:\n        assert response.headers['Access-Control-Allow-Credentials'] == 'true'\n\ndef test_cors_preflight():\n    \"\"\"Test CORS preflight request\"\"\"\n    response = requests.options(\n        'http://api.example.com/api/users',\n        headers={\n            'Origin': 'https://app.example.com',\n            'Access-Control-Request-Method': 'POST'\n        }\n    )\n\n    assert response.status_code == 200\n    assert 'Access-Control-Allow-Methods' in response.headers\n</code></pre>"},{"location":"guides/CORS/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/CORS/#problem-1-cors-fehler-trotz-konfiguration","title":"Problem 1: CORS-Fehler trotz Konfiguration","text":"<p>Symptom: Browser zeigt CORS-Fehler, obwohl CORS konfiguriert ist.</p> <p>L\u00f6sung: 1. \u2705 OPTIONS-Methode erlauben: <pre><code>methods: [GET, POST, OPTIONS]  # OPTIONS nicht vergessen!\n</code></pre></p> <ol> <li> <p>\u2705 Origin exakt matchen: <pre><code># \u274c Falsch\nallowed_origins: [\"https://app.example.com/\"]\n\n# \u2705 Richtig (ohne trailing slash)\nallowed_origins: [\"https://app.example.com\"]\n</code></pre></p> </li> <li> <p>\u2705 CORS vor Authentication: <pre><code># Stelle sicher, dass CORS-Plugin VOR Authentication l\u00e4uft\n</code></pre></p> </li> </ol>"},{"location":"guides/CORS/#problem-2-credentials-funktionieren-nicht","title":"Problem 2: Credentials funktionieren nicht","text":"<p>Symptom: Cookies/Auth headers werden nicht gesendet.</p> <p>L\u00f6sung: <pre><code># \u274c Wildcard mit Credentials\ncors:\n  allowed_origins: [\"*\"]\n  allow_credentials: true\n\n# \u2705 Spezifische Origin\ncors:\n  allowed_origins: [\"https://app.example.com\"]\n  allow_credentials: true\n</code></pre></p> <p>Client-Side: <pre><code>// JavaScript: credentials einschlie\u00dfen\nfetch('https://api.example.com/api', {\n  credentials: 'include'  // Wichtig!\n})\n</code></pre></p>"},{"location":"guides/CORS/#problem-3-preflight-request-schlagt-fehl","title":"Problem 3: Preflight-Request schl\u00e4gt fehl","text":"<p>Symptom: OPTIONS-Request gibt 401/403 zur\u00fcck.</p> <p>L\u00f6sung: <pre><code># Authentication f\u00fcr OPTIONS deaktivieren\nroutes:\n  - path_prefix: /api\n    methods: [GET, POST, OPTIONS]\n    cors:\n      enabled: true\n    # CORS muss VOR Authentication kommen!\n</code></pre></p>"},{"location":"guides/CORS/#problem-4-custom-headers-werden-blockiert","title":"Problem 4: Custom Headers werden blockiert","text":"<p>Symptom: Custom Headers wie <code>X-API-Key</code> funktionieren nicht.</p> <p>L\u00f6sung: <pre><code>cors:\n  allowed_headers:\n    - Content-Type\n    - Authorization\n    - X-API-Key        # Custom Header explizit erlauben!\n</code></pre></p> <p>Client-Side: <pre><code>fetch('https://api.example.com/api', {\n  headers: {\n    'X-API-Key': 'key123'  // Muss in allowed_headers sein!\n  }\n})\n</code></pre></p>"},{"location":"guides/CORS/#problem-5-expose-headers-nicht-sichtbar","title":"Problem 5: Expose-Headers nicht sichtbar","text":"<p>Symptom: Response-Header sind im Browser nicht verf\u00fcgbar.</p> <p>L\u00f6sung: <pre><code>cors:\n  expose_headers:\n    - X-Request-ID        # Exponiere Header explizit!\n    - X-RateLimit-Remaining\n</code></pre></p> <p>Client-Side: <pre><code>response.headers.get('X-Request-ID')  // Jetzt verf\u00fcgbar\n</code></pre></p>"},{"location":"guides/CORS/#problem-6-cors-funktioniert-nur-auf-einem-provider","title":"Problem 6: CORS funktioniert nur auf einem Provider","text":"<p>Problem: CORS funktioniert auf Kong, aber nicht auf Envoy.</p> <p>L\u00f6sung: Provider-spezifische Besonderheiten pr\u00fcfen:</p> <p>Kong: <pre><code># OPTIONS in Route-Methoden\nmethods: [GET, POST, OPTIONS]\n</code></pre></p> <p>APISIX: <pre><code># allow_credential (singular!)\n</code></pre></p> <p>Traefik: <pre><code># Middleware muss in Router referenziert sein\n</code></pre></p> <p>Envoy: <pre><code># CORS ist route-level, nicht global\n</code></pre></p>"},{"location":"guides/CORS/#problem-7-max-age-funktioniert-nicht","title":"Problem 7: Max-Age funktioniert nicht","text":"<p>Symptom: Preflight-Requests werden nicht gecacht.</p> <p>L\u00f6sung: <pre><code># Setze max_age explizit\ncors:\n  max_age: 86400  # 24 Stunden\n\n# Browser-Cache pr\u00fcfen (DevTools \u2192 Network \u2192 Disable Cache)\n</code></pre></p>"},{"location":"guides/CORS/#best-practice-checkliste","title":"Best Practice Checkliste","text":""},{"location":"guides/CORS/#vor-deployment","title":"Vor Deployment","text":"<ul> <li> \u2705 Wildcard <code>*</code> nur in Entwicklung verwenden</li> <li> \u2705 Spezifische Origins f\u00fcr Produktion</li> <li> \u2705 OPTIONS-Methode in allen Routes</li> <li> \u2705 HTTPS-Origins in Produktion</li> <li> \u2705 allow_credentials nur mit spezifischen Origins</li> <li> \u2705 Minimale allowed_headers</li> <li> \u2705 Nur ben\u00f6tigte expose_headers</li> <li> \u2705 Sinnvolle max_age (24 Stunden)</li> </ul>"},{"location":"guides/CORS/#security-review","title":"Security Review","text":"<ul> <li> \u274c Keine Wildcard mit Credentials</li> <li> \u274c Keine sensitiven Headers exponiert</li> <li> \u274c Keine HTTP-Origins in Produktion</li> <li> \u2705 CORS vor Authentication</li> <li> \u2705 Rate Limiting f\u00fcr OPTIONS-Requests</li> </ul>"},{"location":"guides/CORS/#testing","title":"Testing","text":"<ul> <li> \u2705 Preflight-Request testen (OPTIONS)</li> <li> \u2705 Actual Request testen (GET/POST)</li> <li> \u2705 Mit Credentials testen</li> <li> \u2705 Custom Headers testen</li> <li> \u2705 Verschiedene Origins testen</li> <li> \u2705 Browser DevTools pr\u00fcfen</li> </ul>"},{"location":"guides/CORS/#zusammenfassung","title":"Zusammenfassung","text":"<p>CORS in GAL erm\u00f6glicht:</p> <p>\u2705 Einheitliche Konfiguration f\u00fcr alle Provider \u2705 Vollst\u00e4ndige CORS-Unterst\u00fctzung (Origins, Methods, Headers, Credentials) \u2705 Einfache Integration mit Authentication und Rate Limiting \u2705 Provider-Abstraktion - schreibe einmal, deploye \u00fcberall</p> <p>N\u00e4chste Schritte: - Siehe AUTHENTICATION.md f\u00fcr CORS + Auth - Siehe HEADERS.md f\u00fcr zus\u00e4tzliche Header-Manipulation - Siehe examples/cors-example.yaml f\u00fcr vollst\u00e4ndige Beispiele</p> <p>Hilfe ben\u00f6tigt? - Probleme melden: https://github.com/pt9912/x-gal/issues - Dokumentation: https://docs.gal.dev - Beispiele: examples/</p>"},{"location":"guides/DEVELOPMENT/","title":"GAL Entwickler-Guide","text":""},{"location":"guides/DEVELOPMENT/#ubersicht","title":"\u00dcbersicht","text":"<p>Dieser Guide hilft Entwicklern beim Einstieg in die GAL-Codebasis, erkl\u00e4rt die Entwicklungsumgebung und Best Practices f\u00fcr Contributions.</p>"},{"location":"guides/DEVELOPMENT/#entwicklungsumgebung-setup","title":"Entwicklungsumgebung Setup","text":""},{"location":"guides/DEVELOPMENT/#voraussetzungen","title":"Voraussetzungen","text":"<ul> <li>Python 3.8 oder h\u00f6her</li> <li>Git</li> <li>Docker (optional, f\u00fcr Container-basierte Entwicklung)</li> <li>Ein Code-Editor (VS Code, PyCharm, etc.)</li> </ul>"},{"location":"guides/DEVELOPMENT/#lokales-setup","title":"Lokales Setup","text":"<pre><code># Repository klonen\ngit clone https://github.com/pt9912/x-gal.git\ncd x-gal\n\n# Virtuelle Umgebung erstellen\npython3 -m venv venv\nsource venv/bin/activate  # Windows: venv\\Scripts\\activate\n\n# Abh\u00e4ngigkeiten installieren\npip install -r requirements.txt\n\n# Development-Abh\u00e4ngigkeiten installieren\npip install pytest pytest-cov black flake8 mypy\n\n# Paket im Development-Modus installieren\npip install -e .\n</code></pre>"},{"location":"guides/DEVELOPMENT/#entwicklung-mit-docker","title":"Entwicklung mit Docker","text":"<pre><code># Image bauen\ndocker build -t gal:dev .\n\n# Interaktive Shell\ndocker run -it --rm -v $(pwd):/app -w /app gal:dev sh\n\n# Tests ausf\u00fchren\ndocker run --rm -v $(pwd):/app -w /app gal:dev pytest\n</code></pre>"},{"location":"guides/DEVELOPMENT/#projektstruktur","title":"Projektstruktur","text":"<pre><code>x-gal/\n\u251c\u2500\u2500 gal/                        # Hauptpaket\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 config.py              # Konfigurationsmodelle\n\u2502   \u251c\u2500\u2500 manager.py             # Manager-Orchestration\n\u2502   \u251c\u2500\u2500 provider.py            # Provider ABC\n\u2502   \u251c\u2500\u2500 providers/             # Provider-Implementierungen\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 envoy.py\n\u2502   \u2502   \u251c\u2500\u2500 kong.py\n\u2502   \u2502   \u251c\u2500\u2500 apisix.py\n\u2502   \u2502   \u2514\u2500\u2500 traefik.py\n\u2502   \u2514\u2500\u2500 transformation/        # Transformation-Engine (geplant)\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 engine.py\n\u2502       \u2514\u2500\u2500 generators.py\n\u251c\u2500\u2500 tests/                     # Test-Suite\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 test_config.py\n\u2502   \u251c\u2500\u2500 test_manager.py\n\u2502   \u2514\u2500\u2500 test_providers.py\n\u251c\u2500\u2500 examples/                  # Beispiel-Konfigurationen\n\u2502   \u251c\u2500\u2500 gateway-config.yaml\n\u2502   \u2514\u2500\u2500 output/\n\u251c\u2500\u2500 docs/                      # Dokumentation\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 architecture/\n\u2502   \u2514\u2500\u2500 guides/\n\u251c\u2500\u2500 gal-cli.py                 # CLI Entry-Point\n\u251c\u2500\u2500 setup.py                   # Package-Setup\n\u251c\u2500\u2500 requirements.txt           # Produktions-Dependencies\n\u251c\u2500\u2500 Dockerfile                 # Docker-Konfiguration\n\u251c\u2500\u2500 docker-compose.yml         # Docker Compose Services\n\u2514\u2500\u2500 README.md                  # Haupt-Readme\n</code></pre>"},{"location":"guides/DEVELOPMENT/#code-organisation","title":"Code-Organisation","text":""},{"location":"guides/DEVELOPMENT/#1-configpy-konfigurationsmodelle","title":"1. config.py - Konfigurationsmodelle","text":"<p>Verantwortlichkeit: Definition aller Datenmodelle</p> <pre><code>from dataclasses import dataclass, field\nfrom typing import List, Optional\n\n@dataclass\nclass Service:\n    name: str\n    type: str  # grpc oder rest\n    protocol: str\n    upstream: Upstream\n    routes: List[Route]\n    transformation: Optional[Transformation] = None\n</code></pre> <p>Best Practices: - Verwende <code>@dataclass</code> f\u00fcr alle Modelle - Nutze Type Hints konsequent - Optional-Felder mit <code>Optional[Type] = None</code> - Nutze <code>field(default_factory=list)</code> f\u00fcr mutable defaults</p>"},{"location":"guides/DEVELOPMENT/#2-managerpy-orchestration","title":"2. manager.py - Orchestration","text":"<p>Verantwortlichkeit: Provider-Management und Workflow-Koordination</p> <pre><code>class Manager:\n    def __init__(self):\n        self.providers: Dict[str, Provider] = {}\n\n    def register_provider(self, provider: Provider):\n        \"\"\"Register a gateway provider\"\"\"\n        self.providers[provider.name()] = provider\n</code></pre> <p>Best Practices: - Manager kennt keine Provider-Details - Nutze Registry Pattern f\u00fcr Provider - Validierung vor Generation - Aussagekr\u00e4ftige Error Messages</p>"},{"location":"guides/DEVELOPMENT/#3-providerpy-provider-interface","title":"3. provider.py - Provider Interface","text":"<p>Verantwortlichkeit: ABC f\u00fcr alle Provider</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Provider(ABC):\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"Return provider name\"\"\"\n        pass\n\n    @abstractmethod\n    def validate(self, config: Config) -&gt; bool:\n        \"\"\"Validate configuration for this provider\"\"\"\n        pass\n\n    @abstractmethod\n    def generate(self, config: Config) -&gt; str:\n        \"\"\"Generate provider-specific configuration\"\"\"\n        pass\n</code></pre> <p>Best Practices: - Minimales Interface (nur notwendige Methoden) - <code>deploy()</code> ist optional - Klare Dokumentation der Erwartungen - Konsistente R\u00fcckgabewerte</p>"},{"location":"guides/DEVELOPMENT/#4-provider-implementierungen","title":"4. Provider-Implementierungen","text":"<p>Struktur einer Provider-Implementierung:</p> <pre><code>class NewProvider(Provider):\n    def name(self) -&gt; str:\n        return \"newprovider\"\n\n    def validate(self, config: Config) -&gt; bool:\n        # Provider-spezifische Validierung\n        if not config.services:\n            raise ValueError(\"No services defined\")\n        return True\n\n    def generate(self, config: Config) -&gt; str:\n        output = []\n        output.append(\"# Configuration Header\")\n\n        # Service-Generierung\n        for service in config.services:\n            output.append(f\"service: {service.name}\")\n            # ... weitere Logik\n\n        return \"\\n\".join(output)\n</code></pre> <p>Best Practices: - Nutze <code>output = []</code> f\u00fcr Zeilen-basierte Generierung - Validiere Input gr\u00fcndlich - Provider-spezifische Kommentare - Nutze Templates f\u00fcr wiederkehrende Strukturen - Teste mit verschiedenen Service-Typen</p>"},{"location":"guides/DEVELOPMENT/#entwicklungsworkflow","title":"Entwicklungsworkflow","text":""},{"location":"guides/DEVELOPMENT/#branch-strategie","title":"Branch-Strategie","text":"<pre><code># Feature-Branch erstellen\ngit checkout -b feature/neue-funktion\n\n# Entwickeln und testen\n# ... Code \u00e4ndern ...\npytest\n\n# Commit mit aussagekr\u00e4ftiger Message\ngit add .\ngit commit -m \"Add neue Funktion mit X, Y, Z\"\n\n# Push und Pull Request\ngit push origin feature/neue-funktion\n</code></pre>"},{"location":"guides/DEVELOPMENT/#commit-konventionen","title":"Commit-Konventionen","text":"<p>Folge dem Conventional Commits Standard:</p> <pre><code>type(scope): kurze Beschreibung\n\nL\u00e4ngere Beschreibung mit Details\n\n- Bullet points f\u00fcr \u00c4nderungen\n- Weitere Details\n</code></pre> <p>Types: - <code>feat:</code> Neue Features - <code>fix:</code> Bugfixes - <code>docs:</code> Dokumentation - <code>test:</code> Tests - <code>refactor:</code> Refactoring - <code>chore:</code> Build, Dependencies, etc.</p> <p>Beispiele:</p> <pre><code>feat(providers): Add support for Traefik provider\n\n- Implement TraefikProvider class\n- Add router and service generation\n- Include middleware support for transformations\n\nCloses #42\n</code></pre> <pre><code>fix(config): Handle missing transformation validation\n\nPreviously, configurations without validation would cause\nNoneType errors. Now defaults to empty validation.\n\nFixes #15\n</code></pre>"},{"location":"guides/DEVELOPMENT/#testing","title":"Testing","text":""},{"location":"guides/DEVELOPMENT/#test-organisation","title":"Test-Organisation","text":"<pre><code>tests/\n\u251c\u2500\u2500 test_config.py          # Config-Modell Tests\n\u251c\u2500\u2500 test_manager.py         # Manager Tests\n\u2514\u2500\u2500 test_providers.py       # Alle Provider Tests\n</code></pre>"},{"location":"guides/DEVELOPMENT/#tests-schreiben","title":"Tests schreiben","text":"<p>Unit Test Beispiel:</p> <pre><code>def test_config_loading():\n    \"\"\"Test loading configuration from YAML\"\"\"\n    yaml_content = \"\"\"\n    version: \"1.0\"\n    provider: test\n    services:\n      - name: test_service\n        type: rest\n        protocol: http\n        upstream:\n          host: test.local\n          port: 8080\n        routes:\n          - path_prefix: /api\n    \"\"\"\n\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:\n        f.write(yaml_content)\n        temp_file = f.name\n\n    try:\n        config = Config.from_yaml(temp_file)\n        assert config.version == \"1.0\"\n        assert len(config.services) == 1\n    finally:\n        Path(temp_file).unlink()\n</code></pre> <p>Mock Provider f\u00fcr Tests:</p> <pre><code>class MockProvider(Provider):\n    def __init__(self, provider_name=\"mock\", should_validate=True):\n        self._name = provider_name\n        self._should_validate = should_validate\n\n    def name(self) -&gt; str:\n        return self._name\n\n    def validate(self, config: Config) -&gt; bool:\n        return self._should_validate\n\n    def generate(self, config: Config) -&gt; str:\n        return f\"# Mock configuration for {self._name}\"\n</code></pre>"},{"location":"guides/DEVELOPMENT/#tests-ausfuhren","title":"Tests ausf\u00fchren","text":"<pre><code># Alle Tests\npytest\n\n# Mit Coverage\npytest --cov=gal --cov-report=term-missing\n\n# Spezifische Testdatei\npytest tests/test_config.py\n\n# Spezifischer Test\npytest tests/test_config.py::test_config_loading\n\n# Mit Verbose Output\npytest -v\n\n# Tests parallel ausf\u00fchren (mit pytest-xdist)\npytest -n auto\n</code></pre>"},{"location":"guides/DEVELOPMENT/#test-coverage-ziele","title":"Test Coverage Ziele","text":"<ul> <li>Minimum: 80% Coverage</li> <li>Ziel: 95%+ Coverage</li> <li>Aktuell: 99% Coverage</li> </ul>"},{"location":"guides/DEVELOPMENT/#code-qualitat","title":"Code-Qualit\u00e4t","text":""},{"location":"guides/DEVELOPMENT/#linting","title":"Linting","text":"<pre><code># Flake8 (PEP 8)\nflake8 gal/ tests/\n\n# Black (Auto-Formatting)\nblack gal/ tests/\n\n# MyPy (Type Checking)\nmypy gal/\n</code></pre>"},{"location":"guides/DEVELOPMENT/#pre-commit-hook","title":"Pre-Commit Hook","text":"<p>Erstelle <code>.git/hooks/pre-commit</code>:</p> <pre><code>#!/bin/bash\nset -e\n\necho \"Running tests...\"\npytest\n\necho \"Running linters...\"\nflake8 gal/ tests/\nblack --check gal/ tests/\n\necho \"Running type checker...\"\nmypy gal/\n\necho \"\u2713 All checks passed\"\n</code></pre> <pre><code>chmod +x .git/hooks/pre-commit\n</code></pre>"},{"location":"guides/DEVELOPMENT/#debugging","title":"Debugging","text":""},{"location":"guides/DEVELOPMENT/#logging-einrichten","title":"Logging einrichten","text":"<pre><code>import logging\n\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\nlogger = logging.getLogger(__name__)\n\n# In Code\nlogger.debug(f\"Loading config from {filepath}\")\nlogger.info(f\"Registered provider: {provider.name()}\")\nlogger.warning(f\"Service {service.name} has no routes\")\nlogger.error(f\"Failed to generate: {e}\")\n</code></pre>"},{"location":"guides/DEVELOPMENT/#debugging-mit-pdb","title":"Debugging mit pdb","text":"<pre><code># Breakpoint setzen\nimport pdb; pdb.set_trace()\n\n# Oder mit Python 3.7+\nbreakpoint()\n</code></pre>"},{"location":"guides/DEVELOPMENT/#debugging-im-docker-container","title":"Debugging im Docker Container","text":"<pre><code># Container mit bash starten\ndocker run -it --rm -v $(pwd):/app -w /app gal:dev bash\n\n# Python interaktiv\npython\n&gt;&gt;&gt; from gal.config import Config\n&gt;&gt;&gt; config = Config.from_yaml('examples/gateway-config.yaml')\n&gt;&gt;&gt; config.services[0].name\n</code></pre>"},{"location":"guides/DEVELOPMENT/#einen-neuen-provider-hinzufugen","title":"Einen neuen Provider hinzuf\u00fcgen","text":""},{"location":"guides/DEVELOPMENT/#schritt-1-provider-datei-erstellen","title":"Schritt 1: Provider-Datei erstellen","text":"<pre><code>touch gal/providers/newgateway.py\n</code></pre>"},{"location":"guides/DEVELOPMENT/#schritt-2-provider-implementieren","title":"Schritt 2: Provider implementieren","text":"<pre><code># gal/providers/newgateway.py\nfrom ..provider import Provider\nfrom ..config import Config\n\nclass NewGatewayProvider(Provider):\n    def name(self) -&gt; str:\n        return \"newgateway\"\n\n    def validate(self, config: Config) -&gt; bool:\n        \"\"\"Validate configuration for NewGateway\"\"\"\n        # Spezifische Validierungen\n        if not config.services:\n            raise ValueError(\"At least one service required\")\n        return True\n\n    def generate(self, config: Config) -&gt; str:\n        \"\"\"Generate NewGateway configuration\"\"\"\n        output = []\n\n        # Header\n        output.append(\"# NewGateway Configuration\")\n        output.append(f\"version: {config.version}\")\n        output.append(\"\")\n\n        # Services\n        output.append(\"services:\")\n        for service in config.services:\n            output.append(f\"  - name: {service.name}\")\n            output.append(f\"    upstream: {service.upstream.host}:{service.upstream.port}\")\n\n            # Routes\n            output.append(\"    routes:\")\n            for route in service.routes:\n                output.append(f\"      - {route.path_prefix}\")\n\n        return \"\\n\".join(output)\n</code></pre>"},{"location":"guides/DEVELOPMENT/#schritt-3-provider-exportieren","title":"Schritt 3: Provider exportieren","text":"<pre><code># gal/providers/__init__.py\nfrom .envoy import EnvoyProvider\nfrom .kong import KongProvider\nfrom .apisix import APISIXProvider\nfrom .traefik import TraefikProvider\nfrom .newgateway import NewGatewayProvider  # Neu\n\n__all__ = [\n    'EnvoyProvider',\n    'KongProvider',\n    'APISIXProvider',\n    'TraefikProvider',\n    'NewGatewayProvider',  # Neu\n]\n</code></pre>"},{"location":"guides/DEVELOPMENT/#schritt-4-in-cli-registrieren","title":"Schritt 4: In CLI registrieren","text":"<pre><code># gal-cli.py\nfrom gal.providers import (\n    EnvoyProvider, KongProvider, APISIXProvider,\n    TraefikProvider, NewGatewayProvider\n)\n\n# In allen CLI-Befehlen\nmanager.register_provider(NewGatewayProvider())\n</code></pre>"},{"location":"guides/DEVELOPMENT/#schritt-5-tests-schreiben","title":"Schritt 5: Tests schreiben","text":"<pre><code># tests/test_providers.py\nclass TestNewGatewayProvider:\n    \"\"\"Test NewGateway provider\"\"\"\n\n    def test_name(self):\n        provider = NewGatewayProvider()\n        assert provider.name() == \"newgateway\"\n\n    def test_generate_basic_config(self):\n        provider = NewGatewayProvider()\n        config = self._create_basic_config()\n\n        result = provider.generate(config)\n\n        assert \"# NewGateway Configuration\" in result\n        assert \"services:\" in result\n\n    def _create_basic_config(self):\n        # Helper method\n        ...\n</code></pre>"},{"location":"guides/DEVELOPMENT/#schritt-6-dokumentation","title":"Schritt 6: Dokumentation","text":"<p>F\u00fcge den Provider zur Dokumentation hinzu: - README.md - docs/guides/PROVIDERS.md - docs/api/CLI_REFERENCE.md</p>"},{"location":"guides/DEVELOPMENT/#performance-optimierung","title":"Performance-Optimierung","text":""},{"location":"guides/DEVELOPMENT/#profiling","title":"Profiling","text":"<pre><code>import cProfile\nimport pstats\n\n# Profiling aktivieren\nprofiler = cProfile.Profile()\nprofiler.enable()\n\n# Code ausf\u00fchren\nmanager.generate(config)\n\n# Profiling beenden\nprofiler.disable()\nstats = pstats.Stats(profiler)\nstats.sort_stats('cumulative')\nstats.print_stats(20)  # Top 20\n</code></pre>"},{"location":"guides/DEVELOPMENT/#memory-profiling","title":"Memory Profiling","text":"<pre><code># Mit memory_profiler\npip install memory_profiler\n\n# Dekorator hinzuf\u00fcgen\nfrom memory_profiler import profile\n\n@profile\ndef generate(self, config):\n    ...\n\n# Ausf\u00fchren\npython -m memory_profiler gal-cli.py generate -c config.yaml\n</code></pre>"},{"location":"guides/DEVELOPMENT/#continuous-integration","title":"Continuous Integration","text":""},{"location":"guides/DEVELOPMENT/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<pre><code>name: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.11'\n\n    - name: Install dependencies\n      run: |\n        pip install -r requirements.txt\n        pip install pytest pytest-cov\n\n    - name: Run tests\n      run: pytest --cov=gal --cov-report=xml\n\n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n</code></pre>"},{"location":"guides/DEVELOPMENT/#haufige-probleme","title":"H\u00e4ufige Probleme","text":""},{"location":"guides/DEVELOPMENT/#problem-import-fehler","title":"Problem: Import-Fehler","text":"<pre><code># Falsch\nfrom gal.providers.envoy import EnvoyProvider\n\n# Richtig\nfrom gal.providers import EnvoyProvider\n</code></pre>"},{"location":"guides/DEVELOPMENT/#problem-circular-imports","title":"Problem: Circular Imports","text":"<p>Vermeide zirkul\u00e4re Imports durch: - Forward References mit Strings - TYPE_CHECKING Import - Refactoring</p> <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from .config import Config\n</code></pre>"},{"location":"guides/DEVELOPMENT/#ressourcen","title":"Ressourcen","text":"<ul> <li>Python Style Guide (PEP 8)</li> <li>Type Hints (PEP 484)</li> <li>Dataclasses Guide</li> <li>pytest Documentation</li> <li>Docker Best Practices</li> </ul>"},{"location":"guides/DEVELOPMENT/#contribution-checklist","title":"Contribution Checklist","text":"<p>Vor dem Pull Request:</p> <ul> <li> Tests geschrieben und alle bestehen</li> <li> Code-Coverage \u2265 95%</li> <li> Linting (flake8) ohne Fehler</li> <li> Type Checking (mypy) ohne Fehler</li> <li> Dokumentation aktualisiert</li> <li> CHANGELOG.md aktualisiert</li> <li> Commit Messages folgen Konventionen</li> <li> Branch ist rebased auf main</li> </ul>"},{"location":"guides/DEVELOPMENT/#support","title":"Support","text":"<p>Bei Fragen: - GitHub Issues: https://github.com/pt9912/x-gal/issues - Discussions: https://github.com/pt9912/x-gal/discussions</p>"},{"location":"guides/ENVOY/","title":"Envoy Provider Anleitung","text":"<p>Umfassende Anleitung f\u00fcr den Envoy Proxy Provider in GAL (Gateway Abstraction Layer)</p>"},{"location":"guides/ENVOY/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ol> <li>\u00dcbersicht</li> <li>Schnellstart</li> <li>Installation und Setup</li> <li>Konfigurationsoptionen</li> <li>Feature-Implementierungen</li> <li>Provider-Vergleich</li> <li>Envoy-spezifische Details</li> <li>Advanced Features</li> <li>Best Practices</li> <li>Troubleshooting</li> </ol>"},{"location":"guides/ENVOY/#ubersicht","title":"\u00dcbersicht","text":"<p>Envoy Proxy ist ein moderner, hochperformanter Cloud-Native Proxy und Service Mesh Sidecar, entwickelt von Lyft und jetzt Teil der Cloud Native Computing Foundation (CNCF). Envoy ist die Grundlage f\u00fcr viele Service Mesh L\u00f6sungen wie Istio, Consul Connect und AWS App Mesh.</p>"},{"location":"guides/ENVOY/#warum-envoy","title":"Warum Envoy?","text":"<ul> <li>\u2705 Modern &amp; Cloud-Native - Gebaut f\u00fcr Kubernetes und Microservices</li> <li>\u2705 Feature-reich - Umfassendste Feature-Set aller Provider</li> <li>\u2705 Observability - Eingebaute Metrics, Tracing, Logging</li> <li>\u2705 Performance - C++ implementiert, extrem schnell</li> <li>\u2705 Extensibility - Filter-basierte Architektur, Lua Support</li> <li>\u2705 Service Mesh Ready - Perfekt f\u00fcr Istio, Envoy Gateway</li> <li>\u2705 Hot Reload - Configuration Changes ohne Downtime</li> </ul>"},{"location":"guides/ENVOY/#gal-envoy-perfekte-kombination","title":"GAL + Envoy = Perfekte Kombination","text":"<p>GAL vereinfacht Envoy's komplexe YAML-Konfiguration drastisch:</p> Feature Envoy (nativ) GAL f\u00fcr Envoy Konfigurationsgr\u00f6\u00dfe 200+ Zeilen 30 Zeilen Lernkurve Steil (Wochen) Flach (Stunden) Fehleranf\u00e4lligkeit Hoch Niedrig Wartbarkeit Schwierig Einfach Provider-Wechsel Unm\u00f6glich 1 Command"},{"location":"guides/ENVOY/#envoy-feature-matrix","title":"Envoy Feature-Matrix","text":"Feature Envoy Support GAL Implementation Traffic Management Rate Limiting \u2705 Native (envoy.filters.http.ratelimit) \u2705 Vollst\u00e4ndig Circuit Breaker \u2705 Native (outlier_detection) \u2705 Vollst\u00e4ndig Health Checks \u2705 Active + Passive \u2705 Vollst\u00e4ndig Load Balancing \u2705 Round Robin, Least Request, Ring Hash, etc. \u2705 Vollst\u00e4ndig Timeout &amp; Retry \u2705 Umfassend (per-try timeout, retry policy) \u2705 Vollst\u00e4ndig Security Basic Auth \u26a0\ufe0f Via Lua/External \u26a0\ufe0f Lua Filter JWT Validation \u2705 Native (envoy.filters.http.jwt_authn) \u2705 Vollst\u00e4ndig API Key Auth \u26a0\ufe0f Via External Auth \u26a0\ufe0f External Service CORS \u2705 Native (cors policy) \u2705 Vollst\u00e4ndig Advanced WebSocket \u2705 Native (HTTP/1.1 Upgrade) \u2705 Vollst\u00e4ndig gRPC \u2705 Native (HTTP/2) \u2705 Vollst\u00e4ndig Body Transformation \u2705 Via Lua Filter \u2705 Lua Implementation Request/Response Headers \u2705 Native \u2705 Vollst\u00e4ndig Observability Access Logs \u2705 Structured (JSON, text) \u2705 Vollst\u00e4ndig Metrics (Prometheus) \u2705 Native \u2705 Vollst\u00e4ndig Distributed Tracing \u2705 Zipkin, Jaeger, OpenTelemetry \u2705 Vollst\u00e4ndig"},{"location":"guides/ENVOY/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/ENVOY/#beispiel-1-einfacher-reverse-proxy","title":"Beispiel 1: Einfacher Reverse Proxy","text":"<pre><code>version: \"1.0\"\nprovider: envoy\n\nglobal:\n  host: 0.0.0.0\n  port: 10000\n  admin_port: 9901\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      host: api-backend.default.svc.cluster.local\n      port: 8080\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Generierte Envoy-Konfiguration (~150 Zeilen): <pre><code>gal generate --config config.yaml --provider envoy &gt; envoy.yaml\n</code></pre></p> <p>Enth\u00e4lt: - Static Resources (clusters, listeners) - HTTP Connection Manager - Route Configuration - Cluster mit Health Checks</p>"},{"location":"guides/ENVOY/#beispiel-2-load-balancing-mit-health-checks","title":"Beispiel 2: Load Balancing mit Health Checks","text":"<pre><code>services:\n  - name: api_service\n    upstream:\n      targets:\n        - host: api-1.default.svc.cluster.local\n          port: 8080\n        - host: api-2.default.svc.cluster.local\n          port: 8080\n        - host: api-3.default.svc.cluster.local\n          port: 8080\n      health_check:\n        active:\n          enabled: true\n          interval: \"10s\"\n          timeout: \"5s\"\n          http_path: \"/health\"\n          healthy_threshold: 2\n          unhealthy_threshold: 3\n      load_balancer:\n        algorithm: round_robin\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Generiert: - Cluster mit 3 Endpoints - Active Health Checks (HTTP GET /health) - Round Robin Load Balancing</p>"},{"location":"guides/ENVOY/#beispiel-3-complete-production-setup","title":"Beispiel 3: Complete Production Setup","text":"<pre><code>services:\n  - name: api_service\n    upstream:\n      targets:\n        - host: api-1.svc\n          port: 8080\n      health_check:\n        active:\n          enabled: true\n          interval: \"10s\"\n          http_path: \"/health\"\n      load_balancer:\n        algorithm: least_request\n    routes:\n      - path_prefix: /api\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n          burst: 200\n        authentication:\n          enabled: true\n          type: jwt\n          jwt:\n            issuer: \"https://auth.example.com\"\n            audiences: [\"api\"]\n        cors:\n          enabled: true\n          allowed_origins: [\"https://app.example.com\"]\n          allowed_methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n        timeout:\n          connect: \"5s\"\n          read: \"60s\"\n        retry:\n          enabled: true\n          attempts: 3\n          retry_on:\n            - connect_timeout\n            - http_5xx\n</code></pre>"},{"location":"guides/ENVOY/#installation-und-setup","title":"Installation und Setup","text":""},{"location":"guides/ENVOY/#1-envoy-binary-installation","title":"1. Envoy Binary Installation","text":""},{"location":"guides/ENVOY/#option-a-docker-empfohlen","title":"Option A: Docker (Empfohlen)","text":"<pre><code># Official Envoy Image\ndocker pull envoyproxy/envoy:v1.28-latest\n\n# Envoy starten mit GAL-generierter Config\ndocker run -d \\\n  --name envoy \\\n  -p 10000:10000 \\\n  -p 9901:9901 \\\n  -v $(pwd)/envoy.yaml:/etc/envoy/envoy.yaml \\\n  envoyproxy/envoy:v1.28-latest\n</code></pre>"},{"location":"guides/ENVOY/#option-b-binary-download","title":"Option B: Binary Download","text":"<pre><code># Linux (Ubuntu/Debian)\ncurl -L https://github.com/envoyproxy/envoy/releases/download/v1.28.0/envoy-1.28.0-linux-x86_64 \\\n  -o /usr/local/bin/envoy\nchmod +x /usr/local/bin/envoy\n\n# macOS (via Homebrew)\nbrew install envoy\n</code></pre>"},{"location":"guides/ENVOY/#option-c-kubernetes-deployment","title":"Option C: Kubernetes Deployment","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: envoy-gateway\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: envoy\n  template:\n    metadata:\n      labels:\n        app: envoy\n    spec:\n      containers:\n      - name: envoy\n        image: envoyproxy/envoy:v1.28-latest\n        ports:\n        - containerPort: 10000\n          name: http\n        - containerPort: 9901\n          name: admin\n        volumeMounts:\n        - name: config\n          mountPath: /etc/envoy\n      volumes:\n      - name: config\n        configMap:\n          name: envoy-config\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: envoy-gateway\nspec:\n  type: LoadBalancer\n  selector:\n    app: envoy\n  ports:\n  - port: 80\n    targetPort: 10000\n    name: http\n  - port: 9901\n    targetPort: 9901\n    name: admin\n</code></pre>"},{"location":"guides/ENVOY/#2-gal-config-generieren","title":"2. GAL Config generieren","text":"<pre><code># GAL installieren\npip install gal-gateway\n\n# Config generieren\ngal generate --config gateway.yaml --provider envoy &gt; envoy.yaml\n\n# Validieren\nenvoy --mode validate -c envoy.yaml\n\n# Starten\nenvoy -c envoy.yaml\n</code></pre>"},{"location":"guides/ENVOY/#3-admin-interface-prufen","title":"3. Admin Interface pr\u00fcfen","text":"<pre><code># Stats\ncurl http://localhost:9901/stats\n\n# Config Dump\ncurl http://localhost:9901/config_dump\n\n# Clusters Status\ncurl http://localhost:9901/clusters\n</code></pre>"},{"location":"guides/ENVOY/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/ENVOY/#global-configuration","title":"Global Configuration","text":"<pre><code>global:\n  host: 0.0.0.0           # Listener Address\n  port: 10000             # HTTP Port\n  admin_port: 9901        # Admin Interface Port\n</code></pre> <p>Generiert: <pre><code>admin:\n  address:\n    socket_address:\n      address: 0.0.0.0\n      port_value: 9901\n\nstatic_resources:\n  listeners:\n  - name: listener_0\n    address:\n      socket_address:\n        address: 0.0.0.0\n        port_value: 10000\n</code></pre></p>"},{"location":"guides/ENVOY/#upstream-configuration","title":"Upstream Configuration","text":"<pre><code>upstream:\n  host: backend.svc        # Single host\n  port: 8080\n  # ODER\n  targets:                 # Multiple targets\n    - host: backend-1.svc\n      port: 8080\n      weight: 1\n    - host: backend-2.svc\n      port: 8080\n      weight: 2\n</code></pre> <p>Generiert Cluster: <pre><code>clusters:\n- name: api_service_cluster\n  connect_timeout: 5s\n  type: STRICT_DNS\n  lb_policy: ROUND_ROBIN\n  load_assignment:\n    cluster_name: api_service_cluster\n    endpoints:\n    - lb_endpoints:\n      - endpoint:\n          address:\n            socket_address:\n              address: backend-1.svc\n              port_value: 8080\n        load_balancing_weight: 1\n      - endpoint:\n          address:\n            socket_address:\n              address: backend-2.svc\n              port_value: 8080\n        load_balancing_weight: 2\n</code></pre></p>"},{"location":"guides/ENVOY/#feature-implementierungen","title":"Feature-Implementierungen","text":""},{"location":"guides/ENVOY/#1-load-balancing","title":"1. Load Balancing","text":"<p>Envoy unterst\u00fctzt die meisten Load Balancing Algorithmen:</p> <pre><code>load_balancer:\n  algorithm: round_robin    # ROUND_ROBIN\n  # algorithm: least_conn    # LEAST_REQUEST\n  # algorithm: ip_hash       # RING_HASH (Consistent Hashing)\n  # algorithm: weighted      # ROUND_ROBIN mit Weights\n</code></pre> <p>Generierte Envoy Config: <pre><code>lb_policy: ROUND_ROBIN      # oder LEAST_REQUEST, RING_HASH\n</code></pre></p> <p>Algorithmen: - <code>round_robin</code> \u2192 <code>ROUND_ROBIN</code> (Default) - <code>least_conn</code> \u2192 <code>LEAST_REQUEST</code> (bevorzugt Server mit wenigsten aktiven Requests) - <code>ip_hash</code> \u2192 <code>RING_HASH</code> (Consistent Hashing, Session Persistence) - <code>weighted</code> \u2192 <code>ROUND_ROBIN</code> + <code>load_balancing_weight</code></p>"},{"location":"guides/ENVOY/#2-health-checks","title":"2. Health Checks","text":"<p>Active Health Checks: <pre><code>health_check:\n  active:\n    enabled: true\n    interval: \"10s\"           # Probe-Intervall\n    timeout: \"5s\"             # Probe-Timeout\n    http_path: \"/health\"      # Health Endpoint\n    healthy_threshold: 2      # Erfolge bis \"healthy\"\n    unhealthy_threshold: 3    # Fehler bis \"unhealthy\"\n    healthy_status_codes: [200, 204]\n</code></pre></p> <p>Generiert: <pre><code>health_checks:\n- timeout: 5s\n  interval: 10s\n  unhealthy_threshold: 3\n  healthy_threshold: 2\n  http_health_check:\n    path: /health\n    expected_statuses:\n    - start: 200\n      end: 201\n    - start: 204\n      end: 205\n</code></pre></p> <p>Passive Health Checks (Outlier Detection): <pre><code>health_check:\n  passive:\n    enabled: true\n    max_failures: 5           # Max Fehler\n    failure_window: \"30s\"     # Zeitfenster\n</code></pre></p> <p>Generiert: <pre><code>outlier_detection:\n  consecutive_5xx: 5\n  interval: 30s\n  base_ejection_time: 30s\n  max_ejection_percent: 50\n</code></pre></p>"},{"location":"guides/ENVOY/#3-rate-limiting","title":"3. Rate Limiting","text":"<pre><code>rate_limit:\n  enabled: true\n  requests_per_second: 100\n  burst: 200\n  response_status: 429\n</code></pre> <p>Generiert (Global Rate Limit Service): <pre><code>http_filters:\n- name: envoy.filters.http.ratelimit\n  typed_config:\n    \"@type\": type.googleapis.com/envoy.extensions.filters.http.ratelimit.v3.RateLimit\n    domain: gal_ratelimit\n    rate_limit_service:\n      grpc_service:\n        envoy_grpc:\n          cluster_name: rate_limit_service\n</code></pre></p> <p>Hinweis: Envoy ben\u00f6tigt einen externen Rate Limit Service (z.B. lyft/ratelimit).</p>"},{"location":"guides/ENVOY/#4-authentication","title":"4. Authentication","text":"<p>JWT Validation: <pre><code>authentication:\n  enabled: true\n  type: jwt\n  jwt:\n    issuer: \"https://auth.example.com\"\n    audiences: [\"api\"]\n    jwks_uri: \"https://auth.example.com/.well-known/jwks.json\"\n</code></pre></p> <p>Generiert: <pre><code>http_filters:\n- name: envoy.filters.http.jwt_authn\n  typed_config:\n    \"@type\": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication\n    providers:\n      jwt_provider:\n        issuer: https://auth.example.com\n        audiences:\n        - api\n        remote_jwks:\n          http_uri:\n            uri: https://auth.example.com/.well-known/jwks.json\n            cluster: jwt_cluster\n          cache_duration: 3600s\n    rules:\n    - match:\n        prefix: /api\n      requires:\n        provider_name: jwt_provider\n</code></pre></p> <p>Basic Auth (via Lua Filter): <pre><code>authentication:\n  enabled: true\n  type: basic\n  basic_auth:\n    users:\n      admin: password123\n</code></pre></p> <p>Generiert Lua Filter f\u00fcr Basic Auth Validation.</p>"},{"location":"guides/ENVOY/#5-cors","title":"5. CORS","text":"<pre><code>cors:\n  enabled: true\n  allowed_origins: [\"https://app.example.com\"]\n  allowed_methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n  allowed_headers: [\"Content-Type\", \"Authorization\"]\n  allow_credentials: true\n  max_age: 86400\n</code></pre> <p>Generiert: <pre><code>cors:\n  allow_origin_string_match:\n  - exact: https://app.example.com\n  allow_methods: \"GET,POST,PUT,DELETE\"\n  allow_headers: \"Content-Type,Authorization\"\n  allow_credentials: true\n  max_age: \"86400\"\n</code></pre></p>"},{"location":"guides/ENVOY/#6-timeout-retry","title":"6. Timeout &amp; Retry","text":"<pre><code>timeout:\n  connect: \"5s\"\n  read: \"60s\"\n  idle: \"300s\"\nretry:\n  enabled: true\n  attempts: 3\n  backoff: exponential\n  base_interval: \"25ms\"\n  max_interval: \"250ms\"\n  retry_on:\n    - connect_timeout\n    - http_5xx\n</code></pre> <p>Generiert: <pre><code># Cluster-level\nconnect_timeout: 5s\n\n# Route-level\ntimeout: 60s\nidle_timeout: 300s\nretry_policy:\n  num_retries: 3\n  per_try_timeout: 25ms\n  retry_on: \"connect-failure,5xx\"\n</code></pre></p>"},{"location":"guides/ENVOY/#7-circuit-breaker","title":"7. Circuit Breaker","text":"<pre><code>circuit_breaker:\n  enabled: true\n  max_failures: 5\n  timeout: \"30s\"\n  unhealthy_status_codes: [500, 502, 503, 504]\n</code></pre> <p>Generiert (Outlier Detection): <pre><code>outlier_detection:\n  consecutive_5xx: 5\n  interval: 30s\n  base_ejection_time: 30s\n  max_ejection_percent: 50\n  enforcing_consecutive_5xx: 100\n</code></pre></p>"},{"location":"guides/ENVOY/#8-websocket","title":"8. WebSocket","text":"<pre><code>websocket:\n  enabled: true\n  idle_timeout: \"600s\"\n  ping_interval: \"30s\"\n</code></pre> <p>Generiert: <pre><code>upgrade_configs:\n- upgrade_type: websocket\nhttp_protocol_options:\n  idle_timeout: 600s\n</code></pre></p>"},{"location":"guides/ENVOY/#9-requestresponse-headers","title":"9. Request/Response Headers","text":"<pre><code>headers:\n  request_add:\n    X-Request-ID: \"{{uuid}}\"\n    X-Forwarded-Proto: \"https\"\n  request_remove:\n    - X-Internal-Secret\n  response_add:\n    X-Gateway: \"GAL-Envoy\"\n  response_remove:\n    - X-Powered-By\n</code></pre> <p>Generiert: <pre><code>request_headers_to_add:\n- header:\n    key: X-Request-ID\n    value: \"%REQ(X-REQUEST-ID)%\"\n  append: false\nrequest_headers_to_remove:\n- X-Internal-Secret\nresponse_headers_to_add:\n- header:\n    key: X-Gateway\n    value: GAL-Envoy\nresponse_headers_to_remove:\n- X-Powered-By\n</code></pre></p>"},{"location":"guides/ENVOY/#10-body-transformation","title":"10. Body Transformation","text":"<pre><code>body_transformation:\n  enabled: true\n  request:\n    add_fields:\n      trace_id: \"{{uuid}}\"\n    remove_fields:\n      - secret_key\n  response:\n    filter_fields:\n      - password\n</code></pre> <p>Generiert Lua Filter: <pre><code>http_filters:\n- name: envoy.filters.http.lua\n  typed_config:\n    \"@type\": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua\n    inline_code: |\n      function envoy_on_request(request_handle)\n        -- Transform request body\n      end\n      function envoy_on_response(response_handle)\n        -- Transform response body\n      end\n</code></pre></p>"},{"location":"guides/ENVOY/#provider-vergleich","title":"Provider-Vergleich","text":""},{"location":"guides/ENVOY/#envoy-vs-andere-provider","title":"Envoy vs. Andere Provider","text":"Feature Envoy Kong APISIX Traefik Nginx HAProxy Performance \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Feature-Set \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 Observability \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50 \u2b50\u2b50\u2b50 Cloud-Native \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50 \u2b50\u2b50 Lernkurve \u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 Dokumentation \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 <p>Envoy St\u00e4rken: - \u2705 Umfassendstes Feature-Set aller Provider - \u2705 Native Observability (Metrics, Tracing, Logging) - \u2705 Service Mesh Ready (Istio, Consul, Linkerd) - \u2705 Modern &amp; Cloud-Native - \u2705 Hot Reload ohne Downtime - \u2705 gRPC Native (HTTP/2)</p> <p>Envoy Schw\u00e4chen: - \u274c Steile Lernkurve (komplexe YAML-Config) - \u274c Verbose Config (sehr lang) - \u26a0\ufe0f Basic Auth nicht nativ (Lua/External) - \u26a0\ufe0f Rate Limiting ben\u00f6tigt externen Service</p>"},{"location":"guides/ENVOY/#envoy-feature-coverage","title":"Envoy Feature Coverage","text":"<p>Detaillierte Analyse basierend auf der offiziellen Envoy Dokumentation.</p>"},{"location":"guides/ENVOY/#http-filters-envoyfiltershttp","title":"HTTP Filters (envoy.filters.http.*)","text":"Filter Import Export Status Bemerkung <code>router</code> \u2705 \u2705 Voll HTTP Routing, immer aktiviert <code>jwt_authn</code> \u2705 \u2705 Voll JWT Validation mit JWKS <code>cors</code> \u2705 \u2705 Voll CORS Policy (native) <code>lua</code> \u274c \u2705 Export Body Transformation, Basic Auth <code>ratelimit</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Ben\u00f6tigt externen Service <code>local_ratelimit</code> \u274c \u26a0\ufe0f Export Local Rate Limiting (ohne Service) <code>ext_authz</code> \u274c \u26a0\ufe0f Export External Authorization (OPA, etc.) <code>fault</code> \u274c \u274c Nicht Fault Injection <code>grpc_json_transcoder</code> \u274c \u274c Nicht gRPC-JSON Transformation <code>header_to_metadata</code> \u274c \u274c Nicht Header \u2192 Metadata Mapping <code>ip_tagging</code> \u274c \u274c Nicht IP Tagging <code>buffer</code> \u274c \u274c Nicht Request/Response Buffering <code>gzip</code> \u274c \u274c Nicht Compression <code>adaptive_concurrency</code> \u274c \u274c Nicht Adaptive Concurrency Control"},{"location":"guides/ENVOY/#network-filters-envoyfiltersnetwork","title":"Network Filters (envoy.filters.network.*)","text":"Filter Import Export Status Bemerkung <code>http_connection_manager</code> \u2705 \u2705 Voll HTTP Connection Manager (core) <code>tcp_proxy</code> \u274c \u274c Nicht TCP Proxying <code>redis_proxy</code> \u274c \u274c Nicht Redis Proxying <code>mongo_proxy</code> \u274c \u274c Nicht MongoDB Proxying <code>mysql_proxy</code> \u274c \u274c Nicht MySQL Proxying"},{"location":"guides/ENVOY/#cluster-features","title":"Cluster Features","text":"Feature Import Export Status Bemerkung <code>load_assignment</code> \u2705 \u2705 Voll Endpoints mit IP:Port <code>lb_policy</code> (ROUND_ROBIN) \u2705 \u2705 Voll Round Robin Load Balancing <code>lb_policy</code> (LEAST_REQUEST) \u2705 \u2705 Voll Least Connections <code>lb_policy</code> (RING_HASH) \u2705 \u2705 Voll Consistent Hashing (IP Hash) <code>lb_policy</code> (RANDOM) \u26a0\ufe0f \u26a0\ufe0f Teilweise Random Selection <code>lb_policy</code> (MAGLEV) \u274c \u274c Nicht Maglev Hashing <code>health_checks</code> (HTTP) \u2705 \u2705 Voll Active Health Checks <code>health_checks</code> (TCP) \u274c \u274c Nicht TCP Health Checks <code>health_checks</code> (gRPC) \u274c \u274c Nicht gRPC Health Checks <code>outlier_detection</code> \u2705 \u2705 Voll Passive Health Checks / Circuit Breaker <code>circuit_breakers</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Connection/Request Limits <code>upstream_connection_options</code> \u274c \u274c Nicht TCP Keepalive <code>dns_lookup_family</code> \u274c \u2705 Export V4_ONLY (Default) <code>transport_socket</code> (TLS) \u274c \u274c Nicht Upstream TLS"},{"location":"guides/ENVOY/#route-configuration-features","title":"Route Configuration Features","text":"Feature Import Export Status Bemerkung <code>match.prefix</code> \u2705 \u2705 Voll Path Prefix Matching <code>match.path</code> \u2705 \u2705 Voll Exact Path Matching <code>match.safe_regex</code> \u274c \u274c Nicht Regex Path Matching <code>match.headers</code> \u274c \u274c Nicht Header-based Routing <code>match.query_parameters</code> \u274c \u274c Nicht Query Parameter Matching <code>route.cluster</code> \u2705 \u2705 Voll Single Cluster Routing <code>route.weighted_clusters</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Traffic Splitting <code>route.timeout</code> \u2705 \u2705 Voll Request Timeout <code>route.idle_timeout</code> \u2705 \u2705 Voll Idle Timeout <code>route.retry_policy</code> \u2705 \u2705 Voll Retry mit Exponential Backoff <code>route.cors</code> \u2705 \u2705 Voll Per-Route CORS <code>route.upgrade_configs</code> (WebSocket) \u2705 \u2705 Voll WebSocket Support <code>request_headers_to_add</code> \u2705 \u2705 Voll Request Header Manipulation <code>request_headers_to_remove</code> \u2705 \u2705 Voll Request Header Removal <code>response_headers_to_add</code> \u2705 \u2705 Voll Response Header Manipulation <code>response_headers_to_remove</code> \u2705 \u2705 Voll Response Header Removal <code>route.metadata</code> \u274c \u274c Nicht Route Metadata <code>route.decorator</code> \u274c \u274c Nicht Tracing Decorator"},{"location":"guides/ENVOY/#listener-features","title":"Listener Features","text":"Feature Import Export Status Bemerkung <code>address.socket_address</code> \u2705 \u2705 Voll TCP Socket (IP:Port) <code>filter_chains</code> \u2705 \u2705 Voll Filter Chain <code>listener_filters</code> \u274c \u274c Nicht TLS Inspector, HTTP Inspector <code>per_connection_buffer_limit_bytes</code> \u274c \u274c Nicht Buffer Limits <code>socket_options</code> \u274c \u274c Nicht TCP Socket Options <code>transport_socket</code> (TLS) \u274c \u274c Nicht TLS Termination"},{"location":"guides/ENVOY/#access-logging","title":"Access Logging","text":"Feature Import Export Status Bemerkung <code>file</code> (stdout/stderr) \u2705 \u2705 Voll File Access Logs <code>json_format</code> \u2705 \u2705 Voll JSON Structured Logs <code>text_format</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Text Logs (CEL Format) <code>grpc</code> \u274c \u274c Nicht gRPC Access Log Service <code>http</code> \u274c \u274c Nicht HTTP Access Log Service"},{"location":"guides/ENVOY/#metrics-observability","title":"Metrics &amp; Observability","text":"Feature Import Export Status Bemerkung Admin Interface (<code>/stats</code>) N/A \u2705 Export Prometheus Metrics Admin Interface (<code>/clusters</code>) N/A \u2705 Export Cluster Health Status Admin Interface (<code>/config_dump</code>) N/A \u2705 Export Config Dump Tracing (Zipkin) \u274c \u274c Nicht Distributed Tracing Tracing (Jaeger) \u274c \u274c Nicht Distributed Tracing Tracing (OpenTelemetry) \u274c \u274c Nicht Distributed Tracing StatsD \u274c \u274c Nicht Metrics Export DogStatsD \u274c \u274c Nicht Datadog Metrics"},{"location":"guides/ENVOY/#advanced-features","title":"Advanced Features","text":"Feature Import Export Status Bemerkung xDS API (Dynamic Config) \u274c \u274c Nicht LDS, RDS, CDS, EDS, SDS Hot Restart N/A N/A N/A Envoy-native Feature Runtime Configuration \u274c \u274c Nicht Feature Flags Overload Manager \u274c \u274c Nicht Resource Limits Wasm Filters \u274c \u274c Nicht WebAssembly Extensions"},{"location":"guides/ENVOY/#coverage-score-nach-kategorie","title":"Coverage Score nach Kategorie","text":"Kategorie Features Total Unterst\u00fctzt Coverage HTTP Filters 14 3 voll, 3 teilweise ~40% Network Filters 5 1 voll 20% Cluster Features 14 7 voll, 3 teilweise ~65% Route Configuration 18 11 voll, 2 teilweise ~70% Listener Features 6 2 voll 33% Access Logging 5 2 voll, 1 teilweise ~50% Metrics &amp; Observability 8 3 export 37% Advanced Features 5 0 0% <p>Gesamt (API Gateway relevante Features): ~52% Coverage</p> <p>Import Coverage: ~55% (Import bestehender Envoy Configs \u2192 GAL) Export Coverage: ~75% (GAL \u2192 Envoy Config Generation)</p>"},{"location":"guides/ENVOY/#bidirektionale-feature-unterstutzung","title":"Bidirektionale Feature-Unterst\u00fctzung","text":"<p>Vollst\u00e4ndig bidirektional (Import \u2194 Export): 1. \u2705 HTTP Routing (Prefix, Exact) 2. \u2705 Cluster Configuration (Endpoints, LB Policy) 3. \u2705 Health Checks (Active + Passive) 4. \u2705 Load Balancing (Round Robin, Least Request, Ring Hash) 5. \u2705 CORS Policy 6. \u2705 JWT Authentication 7. \u2705 Timeout &amp; Retry 8. \u2705 Request/Response Headers 9. \u2705 WebSocket Support 10. \u2705 Access Logs (JSON)</p> <p>Nur Export (GAL \u2192 Envoy): 11. \u26a0\ufe0f Lua Filters (Body Transformation, Basic Auth) 12. \u26a0\ufe0f Local Rate Limiting 13. \u26a0\ufe0f External Authorization (ext_authz)</p> <p>Features mit Einschr\u00e4nkungen: - Rate Limiting: Ben\u00f6tigt externen lyft/ratelimit Service (nicht in GAL Scope) - TLS: Keine TLS Termination/Upstream TLS (muss manuell konfiguriert werden) - Advanced Routing: Keine Regex/Header/Query Matching - Tracing: Keine Distributed Tracing Integration (Zipkin/Jaeger/OTel)</p>"},{"location":"guides/ENVOY/#import-beispiel-envoy-gal","title":"Import-Beispiel (Envoy \u2192 GAL)","text":"<p>Input (envoy.yaml): <pre><code>static_resources:\n  listeners:\n  - name: listener_0\n    address:\n      socket_address:\n        address: 0.0.0.0\n        port_value: 10000\n    filter_chains:\n    - filters:\n      - name: envoy.filters.network.http_connection_manager\n        typed_config:\n          route_config:\n            virtual_hosts:\n            - name: backend\n              domains: [\"*\"]\n              routes:\n              - match:\n                  prefix: /api\n                route:\n                  cluster: api_cluster\n                  timeout: 30s\n  clusters:\n  - name: api_cluster\n    connect_timeout: 5s\n    type: STRICT_DNS\n    lb_policy: ROUND_ROBIN\n    load_assignment:\n      cluster_name: api_cluster\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: backend.svc\n                port_value: 8080\n</code></pre></p> <p>Output (gal-config.yaml): <pre><code>version: \"1.0\"\nprovider: envoy\nglobal:\n  host: 0.0.0.0\n  port: 10000\nservices:\n  - name: backend\n    type: rest\n    protocol: http\n    upstream:\n      host: backend.svc\n      port: 8080\n      load_balancer:\n        algorithm: round_robin\n    routes:\n      - path_prefix: /api\n        timeout:\n          read: \"30s\"\n          connect: \"5s\"\n</code></pre></p>"},{"location":"guides/ENVOY/#empfehlungen-fur-zukunftige-erweiterungen","title":"Empfehlungen f\u00fcr zuk\u00fcnftige Erweiterungen","text":"<p>Priorit\u00e4t 1 (High Impact): 1. TLS Termination - Listener TLS Support (<code>transport_socket</code>) 2. Upstream TLS - Backend TLS Connections 3. Regex Routing - <code>match.safe_regex</code> f\u00fcr Advanced Routing 4. Header-based Routing - <code>match.headers</code> f\u00fcr A/B Testing 5. Traffic Splitting - <code>weighted_clusters</code> f\u00fcr Canary Deployments</p> <p>Priorit\u00e4t 2 (Medium Impact): 6. Tracing Integration - Zipkin/Jaeger/OpenTelemetry 7. gRPC Health Checks - <code>health_checks</code> mit gRPC 8. Fault Injection - <code>envoy.filters.http.fault</code> f\u00fcr Chaos Testing 9. Buffer Limits - <code>per_connection_buffer_limit_bytes</code> 10. Circuit Breaker Limits - Vollst\u00e4ndige <code>circuit_breakers</code> Config</p> <p>Priorit\u00e4t 3 (Nice to Have): 11. Wasm Filters - WebAssembly Extensions 12. xDS API - Dynamic Configuration Support 13. gRPC-JSON Transcoder - gRPC \u2192 JSON Transformation 14. Compression - <code>gzip</code> Filter 15. Adaptive Concurrency - <code>adaptive_concurrency</code> Filter</p>"},{"location":"guides/ENVOY/#test-coverage-import","title":"Test Coverage (Import)","text":"<p>Envoy Import Tests: 15 Tests (test_import_envoy.py)</p> Test Kategorie Tests Status Basic Import 3 \u2705 Passing Clusters &amp; Load Balancing 3 \u2705 Passing Health Checks 2 \u2705 Passing Routes &amp; Timeouts 2 \u2705 Passing Headers 1 \u2705 Passing CORS 1 \u2705 Passing WebSocket 1 \u2705 Passing Errors &amp; Warnings 2 \u2705 Passing <p>Coverage Verbesserung durch Import: 8% \u2192 45% (+37%)</p>"},{"location":"guides/ENVOY/#roundtrip-kompatibilitat","title":"Roundtrip-Kompatibilit\u00e4t","text":"Szenario Roundtrip Bemerkung Basic Routing + LB \u2705 100% Perfekt Health Checks (Active) \u2705 100% Perfekt CORS + Headers \u2705 100% Perfekt JWT Authentication \u2705 100% Perfekt Timeout &amp; Retry \u2705 95% Retry-Details verloren WebSocket \u2705 100% Perfekt Rate Limiting \u26a0\ufe0f 60% Externe Service-Config verloren Body Transformation (Lua) \u274c 20% Lua-Code nicht parsebar <p>Durchschnittliche Roundtrip-Kompatibilit\u00e4t: ~85%</p>"},{"location":"guides/ENVOY/#fazit","title":"Fazit","text":"<p>Envoy Import Coverage: - \u2705 Core Features: 85% Coverage (Routing, LB, Health Checks, CORS, JWT) - \u26a0\ufe0f Advanced Features: 25% Coverage (Tracing, TLS, Wasm, xDS) - \u274c Nicht unterst\u00fctzt: Lua Parsing, xDS Dynamic Config, Advanced Filters</p> <p>Envoy Export Coverage: - \u2705 Core Features: 95% Coverage (alle GAL Features \u2192 Envoy) - \u2705 Best Practices: Eingebaut (Timeouts, Retries, Health Checks) - \u26a0\ufe0f Einschr\u00e4nkungen: Rate Limiting ben\u00f6tigt externen Service, kein TLS Auto-Config</p> <p>Empfehlung: - \ud83d\ude80 F\u00fcr Standard API Gateway Workloads: Vollst\u00e4ndig ausreichend - \u26a0\ufe0f F\u00fcr komplexe Envoy Setups (Lua, xDS, Tracing): Manuelle Nachbearbeitung n\u00f6tig - \ud83d\udcda F\u00fcr Envoy \u2192 GAL Migration: 85% automatisiert, 15% Review</p> <p>Referenzen: - \ud83d\udcda Envoy Filter Reference - \ud83d\udcda Envoy Cluster Configuration - \ud83d\udcda Envoy Route Configuration - \ud83d\udcda Envoy Network Filters</p>"},{"location":"guides/ENVOY/#envoy-spezifische-details","title":"Envoy-spezifische Details","text":""},{"location":"guides/ENVOY/#configuration-structure","title":"Configuration Structure","text":"<p>Envoy verwendet eine hierarchische YAML-Struktur:</p> <pre><code>envoy.yaml\n\u251c\u2500\u2500 admin (Admin Interface)\n\u251c\u2500\u2500 static_resources\n\u2502   \u251c\u2500\u2500 listeners (Ingress)\n\u2502   \u2502   \u251c\u2500\u2500 filter_chains\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 filters (HTTP Connection Manager)\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 http_filters (JWT, Rate Limit, etc.)\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 route_config (Routing Rules)\n\u2502   \u2502   \u2502   \u2502       \u2514\u2500\u2500 virtual_hosts\n\u2502   \u2502   \u2502   \u2502           \u2514\u2500\u2500 routes (Path Matching)\n\u2502   \u2502   \u2502   \u2502               \u2514\u2500\u2500 route (Cluster Mapping)\n\u2502   \u251c\u2500\u2500 clusters (Upstreams)\n\u2502   \u2502   \u251c\u2500\u2500 load_assignment (Endpoints)\n\u2502   \u2502   \u251c\u2500\u2500 health_checks (Active HC)\n\u2502   \u2502   \u2514\u2500\u2500 outlier_detection (Passive HC)\n</code></pre>"},{"location":"guides/ENVOY/#filters-architecture","title":"Filters Architecture","text":"<p>Envoy's Macht liegt in seiner Filter-Chain:</p> <ol> <li>Network Filters (L3/L4):</li> <li><code>envoy.filters.network.http_connection_manager</code></li> <li> <p><code>envoy.filters.network.tcp_proxy</code></p> </li> <li> <p>HTTP Filters (L7):</p> </li> <li><code>envoy.filters.http.router</code> (Routing)</li> <li><code>envoy.filters.http.jwt_authn</code> (JWT)</li> <li><code>envoy.filters.http.ratelimit</code> (Rate Limiting)</li> <li><code>envoy.filters.http.cors</code> (CORS)</li> <li><code>envoy.filters.http.lua</code> (Custom Logic)</li> <li><code>envoy.filters.http.ext_authz</code> (External Auth)</li> </ol>"},{"location":"guides/ENVOY/#admin-interface","title":"Admin Interface","text":"<pre><code># Config Dump (aktuelle Config)\ncurl http://localhost:9901/config_dump\n\n# Stats (Prometheus Format)\ncurl http://localhost:9901/stats/prometheus\n\n# Clusters (Health Status)\ncurl http://localhost:9901/clusters\n\n# Logging Level \u00e4ndern (Runtime)\ncurl -X POST http://localhost:9901/logging?level=debug\n</code></pre>"},{"location":"guides/ENVOY/#hot-reload","title":"Hot Reload","text":"<p>Envoy unterst\u00fctzt Hot Reload ohne Downtime:</p> <pre><code># Config validieren\nenvoy --mode validate -c new-envoy.yaml\n\n# Hot Restart (zero-downtime)\nenvoy --restart-epoch 1 -c new-envoy.yaml\n</code></pre>"},{"location":"guides/ENVOY/#advanced-features_1","title":"Advanced Features","text":""},{"location":"guides/ENVOY/#1-xds-api-dynamic-configuration","title":"1. xDS API (Dynamic Configuration)","text":"<p>Envoy unterst\u00fctzt Dynamic Configuration via xDS (x Discovery Service):</p> <ul> <li>LDS (Listener Discovery Service)</li> <li>RDS (Route Discovery Service)</li> <li>CDS (Cluster Discovery Service)</li> <li>EDS (Endpoint Discovery Service)</li> <li>SDS (Secret Discovery Service)</li> </ul> <p>GAL generiert Static Config, aber Envoy kann mit Control Planes wie Istio, Envoy Gateway, oder Gloo arbeiten.</p>"},{"location":"guides/ENVOY/#2-lua-scripting","title":"2. Lua Scripting","text":"<p>Envoy unterst\u00fctzt Lua Filters f\u00fcr Custom Logic:</p> <pre><code>http_filters:\n- name: envoy.filters.http.lua\n  typed_config:\n    inline_code: |\n      function envoy_on_request(request_handle)\n        request_handle:headers():add(\"x-custom\", \"value\")\n      end\n</code></pre> <p>GAL nutzt Lua f\u00fcr: - Basic Authentication - Body Transformation - Custom Request/Response Manipulation</p>"},{"location":"guides/ENVOY/#3-external-authorization","title":"3. External Authorization","text":"<pre><code>http_filters:\n- name: envoy.filters.http.ext_authz\n  typed_config:\n    grpc_service:\n      envoy_grpc:\n        cluster_name: ext_authz_cluster\n    with_request_body:\n      max_request_bytes: 8192\n</code></pre> <p>Externe Auth-Services (z.B. OPA, custom auth services) k\u00f6nnen Authorization Decisions treffen.</p>"},{"location":"guides/ENVOY/#4-metrics-tracing","title":"4. Metrics &amp; Tracing","text":"<p>Prometheus Metrics: <pre><code>admin:\n  address:\n    socket_address:\n      address: 0.0.0.0\n      port_value: 9901\n</code></pre></p> <pre><code>curl http://localhost:9901/stats/prometheus\n</code></pre> <p>Distributed Tracing: <pre><code>tracing:\n  http:\n    name: envoy.tracers.zipkin\n    typed_config:\n      \"@type\": type.googleapis.com/envoy.config.trace.v3.ZipkinConfig\n      collector_cluster: zipkin\n      collector_endpoint: \"/api/v2/spans\"\n</code></pre></p>"},{"location":"guides/ENVOY/#best-practices","title":"Best Practices","text":""},{"location":"guides/ENVOY/#1-verwende-admin-interface-fur-debugging","title":"1. Verwende Admin Interface f\u00fcr Debugging","text":"<pre><code># Live Config anzeigen\ncurl -s http://localhost:9901/config_dump | jq .\n\n# Cluster Health pr\u00fcfen\ncurl -s http://localhost:9901/clusters | grep health_flags\n</code></pre>"},{"location":"guides/ENVOY/#2-enable-access-logs","title":"2. Enable Access Logs","text":"<pre><code>access_log:\n- name: envoy.access_loggers.file\n  typed_config:\n    \"@type\": type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n    path: /dev/stdout\n    log_format:\n      json_format:\n        start_time: \"%START_TIME%\"\n        method: \"%REQ(:METHOD)%\"\n        path: \"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\"\n        response_code: \"%RESPONSE_CODE%\"\n        duration: \"%DURATION%\"\n</code></pre>"},{"location":"guides/ENVOY/#3-configure-resource-limits","title":"3. Configure Resource Limits","text":"<pre><code>circuit_breakers:\n  thresholds:\n  - priority: DEFAULT\n    max_connections: 1024\n    max_pending_requests: 1024\n    max_requests: 1024\n    max_retries: 3\n</code></pre>"},{"location":"guides/ENVOY/#4-use-health-checks","title":"4. Use Health Checks","text":"<p>Immer Active + Passive Health Checks kombinieren: <pre><code>health_check:\n  active:\n    enabled: true\n    interval: \"10s\"\n  passive:\n    enabled: true\n    max_failures: 5\n</code></pre></p>"},{"location":"guides/ENVOY/#5-tune-timeouts","title":"5. Tune Timeouts","text":"<pre><code>timeout:\n  connect: \"5s\"       # Kurz f\u00fcr schnelles Failover\n  read: \"60s\"         # Lang genug f\u00fcr normale Requests\n  idle: \"300s\"        # 5 Minuten Keep-Alive\n</code></pre>"},{"location":"guides/ENVOY/#6-enable-retry-mit-exponential-backoff","title":"6. Enable Retry mit Exponential Backoff","text":"<pre><code>retry:\n  enabled: true\n  attempts: 3\n  backoff: exponential\n  base_interval: \"25ms\"\n  max_interval: \"250ms\"\n</code></pre>"},{"location":"guides/ENVOY/#7-monitoring-alerting","title":"7. Monitoring &amp; Alerting","text":"<ul> <li>\u2705 Prometheus Metrics scrapen</li> <li>\u2705 Grafana Dashboards f\u00fcr Envoy</li> <li>\u2705 Alerting auf 5xx Errors, Timeout Rates</li> <li>\u2705 Distributed Tracing (Jaeger/Zipkin)</li> </ul>"},{"location":"guides/ENVOY/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/ENVOY/#problem-1-config-validation-errors","title":"Problem 1: Config Validation Errors","text":"<p>Symptom: <code>envoy --mode validate</code> schl\u00e4gt fehl</p> <p>L\u00f6sung: <pre><code># Detaillierte Fehlermeldung\nenvoy --mode validate -c envoy.yaml --log-level debug\n\n# GAL Config erneut generieren\ngal generate --config gateway.yaml --provider envoy &gt; envoy.yaml\n</code></pre></p>"},{"location":"guides/ENVOY/#problem-2-upstream-connection-failed","title":"Problem 2: Upstream Connection Failed","text":"<p>Symptom: <code>503 Service Unavailable</code>, Logs zeigen \"upstream connect error\"</p> <p>Diagnose: <pre><code># Cluster Status pr\u00fcfen\ncurl http://localhost:9901/clusters | grep api_service\n\n# Health Check Status\ncurl http://localhost:9901/clusters | grep health_flags\n</code></pre></p> <p>L\u00f6sung: - Pr\u00fcfe DNS-Aufl\u00f6sung: <code>nslookup backend.svc</code> - Pr\u00fcfe Backend-Health: <code>curl http://backend.svc:8080/health</code> - Erh\u00f6he Connection Timeout: <code>timeout.connect: \"10s\"</code></p>"},{"location":"guides/ENVOY/#problem-3-rate-limiting-funktioniert-nicht","title":"Problem 3: Rate Limiting funktioniert nicht","text":"<p>Symptom: Requests werden nicht gedrosselt</p> <p>L\u00f6sung: Envoy ben\u00f6tigt einen External Rate Limit Service:</p> <pre><code># lyft/ratelimit deployen\nkubectl apply -f https://github.com/envoyproxy/ratelimit/releases/latest/download/ratelimit.yaml\n</code></pre> <p>Oder verwende Local Rate Limiting: <pre><code>http_filters:\n- name: envoy.filters.http.local_ratelimit\n  typed_config:\n    stat_prefix: http_local_rate_limiter\n    token_bucket:\n      max_tokens: 200\n      tokens_per_fill: 100\n      fill_interval: 1s\n</code></pre></p>"},{"location":"guides/ENVOY/#problem-4-jwt-validation-schlagt-fehl","title":"Problem 4: JWT Validation schl\u00e4gt fehl","text":"<p>Symptom: <code>401 Unauthorized</code>, JWT ist g\u00fcltig</p> <p>Diagnose: <pre><code># JWT Token dekodieren\necho \"eyJhbGc...\" | base64 -d | jq .\n\n# JWKS URI pr\u00fcfen\ncurl https://auth.example.com/.well-known/jwks.json\n</code></pre></p> <p>L\u00f6sung: - Pr\u00fcfe <code>issuer</code> stimmt \u00fcberein - Pr\u00fcfe <code>audiences</code> ist korrekt - Pr\u00fcfe JWKS URI ist erreichbar</p>"},{"location":"guides/ENVOY/#problem-5-high-latency","title":"Problem 5: High Latency","text":"<p>Symptom: Langsame Response Times</p> <p>Diagnose: <pre><code># Stats pr\u00fcfen\ncurl http://localhost:9901/stats | grep duration\n\n# Tracing aktivieren (Jaeger)\ncurl http://localhost:9901/stats | grep tracing\n</code></pre></p> <p>L\u00f6sung: - Reduziere Retry-Versuche - Erh\u00f6he Connection Pool Size - Enable HTTP/2 f\u00fcr Backend - Tune Timeout-Werte</p>"},{"location":"guides/ENVOY/#problem-6-memorycpu-usage-hoch","title":"Problem 6: Memory/CPU Usage hoch","text":"<p>Symptom: Hoher Resource-Verbrauch</p> <p>L\u00f6sung: <pre><code># Resource Limits setzen\ncircuit_breakers:\n  thresholds:\n  - max_connections: 512\n    max_requests: 512\n\n# Buffer Limits\nper_connection_buffer_limit_bytes: 32768\n</code></pre></p>"},{"location":"guides/ENVOY/#zusammenfassung","title":"Zusammenfassung","text":"<p>Envoy Proxy ist der feature-reichste und modernste API Gateway Provider in GAL:</p> <p>\u2705 St\u00e4rken: - Umfassendstes Feature-Set - Native Observability - Service Mesh Ready - Hot Reload - gRPC Native</p> <p>\u26a0\ufe0f Herausforderungen: - Steile Lernkurve (GAL l\u00f6st dies!) - Verbose Configuration (GAL vereinfacht) - Rate Limiting ben\u00f6tigt External Service - Basic Auth nicht nativ</p> <p>GAL macht Envoy zug\u00e4nglich - von 200+ Zeilen Envoy-YAML zu 30 Zeilen GAL-YAML!</p> <p>N\u00e4chste Schritte: - Vergleiche Kong, APISIX, Traefik - Probiere WebSocket Support aus - Implementiere Circuit Breaker</p> <p>Siehe auch: - Official Envoy Docs - Envoy GitHub - Envoy Slack</p>"},{"location":"guides/HAPROXY/","title":"HAProxy Provider Guide","text":"<p>HAProxy Open Source Load Balancer Provider f\u00fcr GAL</p> <p>HAProxy ist der de-facto Standard f\u00fcr High-Performance Load Balancing und wird weltweit in kritischen Production-Umgebungen eingesetzt. Dieser Guide zeigt, wie Sie HAProxy \u00fcber GAL konfigurieren und nutzen k\u00f6nnen.</p>"},{"location":"guides/HAPROXY/#inhaltsverzeichnis","title":"\ud83d\udccb Inhaltsverzeichnis","text":"<ol> <li>\u00dcbersicht</li> <li>Installation &amp; Setup</li> <li>Schnellstart</li> <li>Konfigurationsoptionen</li> <li>Feature-Implementierungen</li> <li>HAProxy-spezifische Details</li> <li>Provider-Vergleich</li> <li>Best Practices</li> <li>Troubleshooting</li> </ol>"},{"location":"guides/HAPROXY/#ubersicht","title":"\u00dcbersicht","text":""},{"location":"guides/HAPROXY/#was-ist-haproxy","title":"Was ist HAProxy?","text":"<p>HAProxy (High Availability Proxy) ist ein \u00e4u\u00dferst performanter und zuverl\u00e4ssiger TCP/HTTP Load Balancer. Er wird von den gr\u00f6\u00dften Websites der Welt eingesetzt (GitHub, Reddit, Stack Overflow, etc.) und ist bekannt f\u00fcr:</p> <ul> <li>Extreme Performance: 100.000+ Requests pro Sekunde</li> <li>Enterprise-grade Reliability: H\u00f6chste Verf\u00fcgbarkeit</li> <li>Advanced Load Balancing: 10+ Algorithmen</li> <li>Flexible Health Checks: Active &amp; Passive</li> <li>Low Resource Usage: Minimale CPU/RAM Nutzung</li> </ul>"},{"location":"guides/HAPROXY/#feature-matrix","title":"Feature-Matrix","text":"Feature Support Level Implementierung Notes Load Balancing Round Robin \u2705 Full <code>balance roundrobin</code> Gleichm\u00e4\u00dfige Verteilung Least Connections \u2705 Full <code>balance leastconn</code> Wenigste Verbindungen IP Hash (Source) \u2705 Full <code>balance source</code> Session Persistence Weighted \u2705 Full <code>weight</code> per server Kapazit\u00e4tsbasiert URI Hash \u2705 Full <code>balance uri</code> URL-basiert Header Hash \u2705 Full <code>balance hdr(name)</code> Header-basiert Health Checks Active HTTP Checks \u2705 Full <code>option httpchk</code> Periodisches Probing Active TCP Checks \u2705 Full <code>check</code> TCP Connection Check Passive Checks \u2705 Full <code>fall/rise</code> thresholds Traffic-basiert Custom Health Checks \u2705 Full <code>http-check expect</code> Flexible Validierung Traffic Management Rate Limiting \u2705 Full <code>stick-table</code> IP &amp; Header-basiert Sticky Sessions \u2705 Full <code>cookie</code>, <code>source</code> Cookie oder IP-basiert Connection Pooling \u2705 Full <code>http-server-close</code> Connection Reuse Timeouts \u2705 Full <code>timeout *</code> Granulare Timeouts Security Basic Authentication \u2705 Full ACL + auth backend Via ACLs Header Manipulation \u2705 Full <code>http-request/response</code> Add/Set/Remove CORS \u26a0\ufe0f Limited Custom headers Via http-response JWT Authentication \u26a0\ufe0f Lua Lua scripting Lua-Script erforderlich Observability Access Logs \u2705 Full <code>log global</code> Structured logging Stats Page \u2705 Full <code>stats</code> section Web UI &amp; API Runtime API \u2705 Full <code>stats socket</code> Dynamic config <p>Legende: - \u2705 Full: Nativ unterst\u00fctzt - \u26a0\ufe0f Limited: Eingeschr\u00e4nkt oder ben\u00f6tigt Zusatzmodule - \u26a0\ufe0f Lua: Ben\u00f6tigt Lua Scripting - \u274c Not Supported: Nicht verf\u00fcgbar</p>"},{"location":"guides/HAPROXY/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"guides/HAPROXY/#haproxy-installation","title":"HAProxy Installation","text":"<p>Ubuntu/Debian: <pre><code># HAProxy 2.8+ (neueste Stable)\nsudo apt update\nsudo apt install haproxy\n\n# Version pr\u00fcfen\nhaproxy -v\n</code></pre></p> <p>CentOS/RHEL: <pre><code># EPEL Repository aktivieren\nsudo yum install epel-release\n\n# HAProxy installieren\nsudo yum install haproxy\n\n# Version pr\u00fcfen\nhaproxy -v\n</code></pre></p> <p>Docker: <pre><code># HAProxy 2.9 Official Image\ndocker pull haproxy:2.9-alpine\n\n# Mit Config starten\ndocker run -d \\\n  -p 80:80 \\\n  -v $(pwd)/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro \\\n  haproxy:2.9-alpine\n</code></pre></p>"},{"location":"guides/HAPROXY/#gal-installation","title":"GAL Installation","text":"<pre><code># PyPI Installation\npip install gal-gateway\n\n# Provider pr\u00fcfen\ngal list-providers\n# \u2192 haproxy - HAProxy Load Balancer\n</code></pre>"},{"location":"guides/HAPROXY/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/HAPROXY/#beispiel-1-basic-load-balancing","title":"Beispiel 1: Basic Load Balancing","text":"<p>config.yaml: <pre><code>version: \"1.0\"\nprovider: haproxy\n\nglobal:\n  host: \"0.0.0.0\"\n  port: 80\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n        - host: api-2.internal\n          port: 8080\n      load_balancer:\n        algorithm: round_robin  # Gleichm\u00e4\u00dfige Verteilung\n\n    routes:\n      - path_prefix: /api\n</code></pre></p> <p>Generierung: <pre><code>gal generate --config config.yaml --provider haproxy &gt; haproxy.cfg\n</code></pre></p> <p>Generierte haproxy.cfg: <pre><code>global\n    log         127.0.0.1 local0\n    maxconn     4000\n    daemon\n    stats socket /var/lib/haproxy/stats level admin\n\ndefaults\n    mode                    http\n    log                     global\n    option                  httplog\n    timeout client          30s\n    timeout server          30s\n    timeout connect         5s\n\nfrontend http_frontend\n    bind 0.0.0.0:80\n\n    acl is_api_service_route0 path_beg /api\n    use_backend backend_api_service if is_api_service_route0\n\nbackend backend_api_service\n    balance roundrobin\n    server server1 api-1.internal:8080 check\n    server server2 api-2.internal:8080 check\n</code></pre></p> <p>Testen: <pre><code># Config validieren\nhaproxy -c -f haproxy.cfg\n\n# HAProxy starten\nhaproxy -f haproxy.cfg\n\n# Requests testen\ncurl http://localhost/api\n</code></pre></p>"},{"location":"guides/HAPROXY/#beispiel-2-load-balancing-health-checks","title":"Beispiel 2: Load Balancing + Health Checks","text":"<pre><code>services:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n          weight: 2  # Erh\u00e4lt 2x mehr Traffic\n        - host: api-2.internal\n          port: 8080\n          weight: 1\n      health_check:\n        active:\n          enabled: true\n          http_path: /health\n          interval: \"10s\"\n          healthy_threshold: 2\n          unhealthy_threshold: 3\n          healthy_status_codes: [200, 204]\n      load_balancer:\n        algorithm: least_conn  # Wenigste Verbindungen\n\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Generierte haproxy.cfg (Backend): <pre><code>backend backend_api_service\n    balance leastconn\n    option httpchk GET /health HTTP/1.1\n    http-check expect status 200|204\n\n    server server1 api-1.internal:8080 check inter 10s fall 3 rise 2 weight 2\n    server server2 api-2.internal:8080 check inter 10s fall 3 rise 2 weight 1\n</code></pre></p>"},{"location":"guides/HAPROXY/#beispiel-3-rate-limiting-headers-cors","title":"Beispiel 3: Rate Limiting + Headers + CORS","text":"<pre><code>services:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      host: api.internal\n      port: 8080\n\n    routes:\n      - path_prefix: /api\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n          burst: 200\n          key_type: ip_address\n          response_status: 429\n\n        headers:\n          request_add:\n            X-Request-ID: \"{{uuid}}\"\n            X-Gateway: \"HAProxy\"\n          response_add:\n            X-Frame-Options: \"DENY\"\n            X-Content-Type-Options: \"nosniff\"\n\n        cors:\n          enabled: true\n          allowed_origins:\n            - \"https://app.example.com\"\n          allowed_methods:\n            - GET\n            - POST\n            - PUT\n            - DELETE\n          allow_credentials: true\n</code></pre> <p>Generierte haproxy.cfg (Frontend): <pre><code>frontend http_frontend\n    bind 0.0.0.0:80\n\n    # Rate Limiting\n    stick-table type ip size 100k expire 30s store http_req_rate(10s)\n    http-request track-sc0 src if is_api_service_route0\n    http-request deny deny_status 429 if is_api_service_route0 { sc_http_req_rate(0) gt 100 }\n\n    # Request Headers\n    http-request set-header X-Request-ID \"%[uuid()]\" if is_api_service_route0\n    http-request set-header X-Gateway \"HAProxy\" if is_api_service_route0\n\n    # Response Headers\n    http-response set-header X-Frame-Options \"DENY\" if is_api_service_route0\n    http-response set-header X-Content-Type-Options \"nosniff\" if is_api_service_route0\n\n    # CORS\n    http-response set-header Access-Control-Allow-Origin \"https://app.example.com\" if is_api_service_route0\n    http-response set-header Access-Control-Allow-Methods \"GET, POST, PUT, DELETE\" if is_api_service_route0\n    http-response set-header Access-Control-Allow-Credentials \"true\" if is_api_service_route0\n\n    use_backend backend_api_service if is_api_service_route0\n</code></pre></p>"},{"location":"guides/HAPROXY/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/HAPROXY/#global-configuration","title":"Global Configuration","text":"<pre><code>global:\n  host: \"0.0.0.0\"        # Listen Address (Standard: 0.0.0.0)\n  port: 80               # Listen Port (Standard: 10000)\n  admin_port: 9901       # Admin/Stats Port (nicht genutzt in HAProxy)\n  timeout: \"30s\"         # Default Timeout (Standard: 30s)\n</code></pre> <p>Mapping zu haproxy.cfg: - <code>host:port</code> \u2192 <code>bind</code> Direktive im Frontend - <code>timeout</code> \u2192 <code>timeout client</code>, <code>timeout server</code></p>"},{"location":"guides/HAPROXY/#upstream-configuration","title":"Upstream Configuration","text":"<pre><code>upstream:\n  # Option 1: Single Host (einfach)\n  host: api.example.com\n  port: 8080\n\n  # Option 2: Multiple Targets (Load Balancing)\n  targets:\n    - host: api-1.internal\n      port: 8080\n      weight: 2          # Load Balancing Gewichtung (default: 1)\n    - host: api-2.internal\n      port: 8080\n      weight: 1\n\n  # Health Checks\n  health_check:\n    active:\n      enabled: true\n      http_path: /health        # Health Check Pfad (default: /health)\n      interval: \"10s\"           # Check Intervall (default: 10s)\n      timeout: \"5s\"             # Check Timeout (default: 5s)\n      healthy_threshold: 2      # Erfolge bis gesund (default: 2)\n      unhealthy_threshold: 3    # Fehler bis ungesund (default: 3)\n      healthy_status_codes:     # Erfolgreiche Status Codes\n        - 200\n        - 201\n        - 204\n\n    passive:\n      enabled: true\n      max_failures: 5           # Max Fehler (default: 5)\n      unhealthy_status_codes:   # Fehlerhafte Status Codes\n        - 500\n        - 502\n        - 503\n        - 504\n\n  # Load Balancing\n  load_balancer:\n    algorithm: round_robin      # round_robin, least_conn, ip_hash, weighted\n    sticky_sessions: false      # Cookie-based Session Persistence\n    cookie_name: \"SERVERID\"     # Cookie Name (wenn sticky_sessions=true)\n</code></pre> <p>HAProxy Mapping:</p> GAL Option HAProxy Direktive Beschreibung <code>targets[].host:port</code> <code>server name host:port</code> Backend Server <code>targets[].weight</code> <code>server ... weight N</code> Load Balancing Gewicht <code>algorithm: round_robin</code> <code>balance roundrobin</code> Round Robin <code>algorithm: least_conn</code> <code>balance leastconn</code> Least Connections <code>algorithm: ip_hash</code> <code>balance source</code> IP Hash (Source) <code>algorithm: weighted</code> <code>balance roundrobin</code> + <code>weight</code> Weighted Round Robin <code>active.enabled</code> <code>option httpchk</code> Active Health Check <code>active.http_path</code> <code>option httpchk GET /path</code> Health Check Pfad <code>active.interval</code> <code>check inter N</code> Check Intervall <code>active.unhealthy_threshold</code> <code>fall N</code> Fehler bis ungesund <code>active.healthy_threshold</code> <code>rise N</code> Erfolge bis gesund <code>passive.max_failures</code> <code>fall N</code> Passive Fehlergrenze <code>sticky_sessions: true</code> <code>cookie NAME insert</code> Cookie Persistence"},{"location":"guides/HAPROXY/#route-configuration","title":"Route Configuration","text":"<pre><code>routes:\n  - path_prefix: /api           # Pfad-Pr\u00e4fix (ACL)\n    methods:                    # HTTP Methoden (optional)\n      - GET\n      - POST\n\n    # Rate Limiting\n    rate_limit:\n      enabled: true\n      requests_per_second: 100  # RPS Limit\n      burst: 200                # Burst Kapazit\u00e4t\n      key_type: ip_address      # ip_address oder header\n      key_header: X-API-Key     # Header Name (wenn key_type=header)\n      response_status: 429      # HTTP Status bei Limit\n\n    # Header Manipulation\n    headers:\n      request_add:              # Request Headers hinzuf\u00fcgen\n        X-Request-ID: \"{{uuid}}\"\n        X-Gateway: \"HAProxy\"\n      request_set:              # Request Headers setzen\n        User-Agent: \"HAProxy/1.0\"\n      request_remove:           # Request Headers entfernen\n        - X-Internal-Token\n\n      response_add:             # Response Headers hinzuf\u00fcgen\n        X-Frame-Options: \"DENY\"\n      response_set:             # Response Headers setzen\n        Server: \"HAProxy\"\n      response_remove:          # Response Headers entfernen\n        - X-Powered-By\n\n    # CORS\n    cors:\n      enabled: true\n      allowed_origins:\n        - \"https://app.example.com\"\n        - \"https://www.example.com\"\n      allowed_methods:\n        - GET\n        - POST\n        - PUT\n        - DELETE\n        - OPTIONS\n      allowed_headers:\n        - Content-Type\n        - Authorization\n        - X-API-Key\n      expose_headers:\n        - X-Request-ID\n      allow_credentials: true\n      max_age: 86400            # Preflight Cache (Sekunden)\n</code></pre>"},{"location":"guides/HAPROXY/#feature-implementierungen","title":"Feature-Implementierungen","text":""},{"location":"guides/HAPROXY/#1-load-balancing-algorithmen","title":"1. Load Balancing Algorithmen","text":"<p>HAProxy unterst\u00fctzt 10+ Load Balancing Algorithmen. GAL implementiert die wichtigsten:</p>"},{"location":"guides/HAPROXY/#round-robin-standard","title":"Round Robin (Standard)","text":"<p>Beschreibung: Gleichm\u00e4\u00dfige Verteilung \u00fcber alle Server.</p> <pre><code>load_balancer:\n  algorithm: round_robin\n</code></pre> <p>HAProxy: <pre><code>backend backend_api\n    balance roundrobin\n    server server1 api-1.internal:8080\n    server server2 api-2.internal:8080\n</code></pre></p> <p>Use Case: Homogene Server mit \u00e4hnlicher Kapazit\u00e4t.</p>"},{"location":"guides/HAPROXY/#least-connections","title":"Least Connections","text":"<p>Beschreibung: W\u00e4hlt Server mit wenigsten aktiven Verbindungen.</p> <pre><code>load_balancer:\n  algorithm: least_conn\n</code></pre> <p>HAProxy: <pre><code>backend backend_api\n    balance leastconn\n    server server1 api-1.internal:8080\n    server server2 api-2.internal:8080\n</code></pre></p> <p>Use Case: Long-running Requests, ungleiche Request-Dauer.</p>"},{"location":"guides/HAPROXY/#ip-hash-source","title":"IP Hash (Source)","text":"<p>Beschreibung: Konsistente Server-Auswahl basierend auf Client-IP.</p> <pre><code>load_balancer:\n  algorithm: ip_hash\n</code></pre> <p>HAProxy: <pre><code>backend backend_api\n    balance source\n    server server1 api-1.internal:8080\n    server server2 api-2.internal:8080\n</code></pre></p> <p>Use Case: Session Persistence ohne Cookies.</p>"},{"location":"guides/HAPROXY/#weighted-load-balancing","title":"Weighted Load Balancing","text":"<p>Beschreibung: Traffic-Verteilung basierend auf Server-Kapazit\u00e4t.</p> <pre><code>targets:\n  - host: powerful-server.internal\n    port: 8080\n    weight: 3  # Erh\u00e4lt 75% des Traffics\n  - host: small-server.internal\n    port: 8080\n    weight: 1  # Erh\u00e4lt 25% des Traffics\n\nload_balancer:\n  algorithm: weighted\n</code></pre> <p>HAProxy: <pre><code>backend backend_api\n    balance roundrobin\n    server server1 powerful-server.internal:8080 weight 3\n    server server2 small-server.internal:8080 weight 1\n</code></pre></p> <p>Use Case: Heterogene Server mit unterschiedlicher Kapazit\u00e4t.</p>"},{"location":"guides/HAPROXY/#2-health-checks","title":"2. Health Checks","text":""},{"location":"guides/HAPROXY/#active-health-checks","title":"Active Health Checks","text":"<p>Beschreibung: Periodisches Probing der Backend-Server.</p> <pre><code>health_check:\n  active:\n    enabled: true\n    http_path: /health\n    interval: \"5s\"\n    timeout: \"3s\"\n    healthy_threshold: 2      # 2 erfolgreiche Checks \u2192 gesund\n    unhealthy_threshold: 3    # 3 fehlgeschlagene Checks \u2192 ungesund\n    healthy_status_codes:\n      - 200\n      - 204\n</code></pre> <p>HAProxy: <pre><code>backend backend_api\n    option httpchk GET /health HTTP/1.1\n    http-check expect status 200|204\n\n    server server1 api-1.internal:8080 check inter 5s fall 3 rise 2\n</code></pre></p> <p>Parameter: - <code>check</code>: Aktiviert Health Checks - <code>inter 5s</code>: Check alle 5 Sekunden - <code>fall 3</code>: 3 Fehler \u2192 ungesund - <code>rise 2</code>: 2 Erfolge \u2192 gesund</p>"},{"location":"guides/HAPROXY/#passive-health-checks","title":"Passive Health Checks","text":"<p>Beschreibung: \u00dcberwacht echten Traffic, markiert fehlerhafte Server.</p> <pre><code>health_check:\n  passive:\n    enabled: true\n    max_failures: 5\n</code></pre> <p>HAProxy: <pre><code>backend backend_api\n    server server1 api-1.internal:8080 check fall 5 rise 2\n</code></pre></p> <p>Use Case: Kombination mit Active Checks f\u00fcr maximale Zuverl\u00e4ssigkeit.</p>"},{"location":"guides/HAPROXY/#3-rate-limiting","title":"3. Rate Limiting","text":"<p>HAProxy verwendet <code>stick-tables</code> f\u00fcr Rate Limiting.</p>"},{"location":"guides/HAPROXY/#ip-basiertes-rate-limiting","title":"IP-basiertes Rate Limiting","text":"<pre><code>rate_limit:\n  enabled: true\n  requests_per_second: 100\n  burst: 200\n  key_type: ip_address\n  response_status: 429\n</code></pre> <p>HAProxy: <pre><code>frontend http_frontend\n    # Stick-Table f\u00fcr IP-basierte Rate Limiting\n    stick-table type ip size 100k expire 30s store http_req_rate(10s)\n\n    # Track Client IP\n    http-request track-sc0 src if is_route\n\n    # Deny wenn &gt; 100 req/s\n    http-request deny deny_status 429 if is_route { sc_http_req_rate(0) gt 100 }\n</code></pre></p> <p>Erkl\u00e4rung: - <code>stick-table type ip</code>: Tabelle pro Client-IP - <code>store http_req_rate(10s)</code>: Request-Rate \u00fcber 10 Sekunden - <code>track-sc0 src</code>: Trackt Source IP (Client) - <code>sc_http_req_rate(0) gt 100</code>: Pr\u00fcft ob Rate &gt; 100</p>"},{"location":"guides/HAPROXY/#header-basiertes-rate-limiting","title":"Header-basiertes Rate Limiting","text":"<pre><code>rate_limit:\n  enabled: true\n  requests_per_second: 1000\n  key_type: header\n  key_header: X-API-Key\n</code></pre> <p>HAProxy: <pre><code>frontend http_frontend\n    http-request track-sc0 hdr(X-API-Key) if is_route\n    http-request deny deny_status 429 if is_route { sc_http_req_rate(0) gt 1000 }\n</code></pre></p> <p>Use Case: Unterschiedliche Limits pro API-Key/Tenant.</p>"},{"location":"guides/HAPROXY/#4-header-manipulation","title":"4. Header Manipulation","text":""},{"location":"guides/HAPROXY/#request-headers","title":"Request Headers","text":"<pre><code>headers:\n  request_add:\n    X-Request-ID: \"{{uuid}}\"\n    X-Real-IP: \"{{client_ip}}\"\n  request_set:\n    User-Agent: \"HAProxy/1.0\"\n  request_remove:\n    - X-Internal-Token\n</code></pre> <p>HAProxy: <pre><code>frontend http_frontend\n    # Add Headers\n    http-request set-header X-Request-ID \"%[uuid()]\" if is_route\n    http-request set-header X-Real-IP \"%[src]\" if is_route\n\n    # Set Headers (\u00fcberschreiben)\n    http-request set-header User-Agent \"HAProxy/1.0\" if is_route\n\n    # Remove Headers\n    http-request del-header X-Internal-Token if is_route\n</code></pre></p> <p>Template-Variablen: - <code>{{uuid}}</code> \u2192 <code>%[uuid()]</code>: Eindeutige Request-ID - <code>{{now}}</code> \u2192 <code>%[date()]</code>: ISO8601 Timestamp</p>"},{"location":"guides/HAPROXY/#response-headers","title":"Response Headers","text":"<pre><code>headers:\n  response_add:\n    X-Frame-Options: \"DENY\"\n    X-Content-Type-Options: \"nosniff\"\n  response_set:\n    Server: \"HAProxy\"\n  response_remove:\n    - X-Powered-By\n</code></pre> <p>HAProxy: <pre><code>frontend http_frontend\n    # Add Response Headers\n    http-response set-header X-Frame-Options \"DENY\" if is_route\n    http-response set-header X-Content-Type-Options \"nosniff\" if is_route\n\n    # Set Response Headers\n    http-response set-header Server \"HAProxy\" if is_route\n\n    # Remove Response Headers\n    http-response del-header X-Powered-By if is_route\n</code></pre></p>"},{"location":"guides/HAPROXY/#5-cors-configuration","title":"5. CORS Configuration","text":"<p>HAProxy unterst\u00fctzt CORS durch Response-Header.</p> <pre><code>cors:\n  enabled: true\n  allowed_origins:\n    - \"https://app.example.com\"\n  allowed_methods:\n    - GET\n    - POST\n    - PUT\n    - DELETE\n  allowed_headers:\n    - Content-Type\n    - Authorization\n  allow_credentials: true\n  max_age: 86400\n</code></pre> <p>HAProxy: <pre><code>frontend http_frontend\n    http-response set-header Access-Control-Allow-Origin \"https://app.example.com\" if is_route\n    http-response set-header Access-Control-Allow-Methods \"GET, POST, PUT, DELETE\" if is_route\n    http-response set-header Access-Control-Allow-Headers \"Content-Type, Authorization\" if is_route\n    http-response set-header Access-Control-Allow-Credentials \"true\" if is_route\n    http-response set-header Access-Control-Max-Age \"86400\" if is_route\n</code></pre></p> <p>Hinweis: Preflight OPTIONS Requests m\u00fcssen ggf. manuell behandelt werden.</p>"},{"location":"guides/HAPROXY/#6-sticky-sessions","title":"6. Sticky Sessions","text":""},{"location":"guides/HAPROXY/#cookie-basierte-persistence","title":"Cookie-basierte Persistence","text":"<pre><code>load_balancer:\n  sticky_sessions: true\n  cookie_name: \"SERVERID\"\n</code></pre> <p>HAProxy: <pre><code>backend backend_api\n    cookie SERVERID insert indirect nocache\n\n    server server1 api-1.internal:8080 cookie server1\n    server server2 api-2.internal:8080 cookie server2\n</code></pre></p> <p>Erkl\u00e4rung: - <code>cookie SERVERID insert</code>: F\u00fcgt Cookie hinzu - <code>indirect</code>: Cookie nur zwischen Client und HAProxy - <code>nocache</code>: Verhindert Caching - <code>cookie server1</code>: Server-spezifischer Cookie-Wert</p>"},{"location":"guides/HAPROXY/#source-ip-basierte-persistence","title":"Source IP-basierte Persistence","text":"<pre><code>load_balancer:\n  algorithm: ip_hash\n</code></pre> <p>HAProxy: <pre><code>backend backend_api\n    balance source\n</code></pre></p> <p>Use Case: Wenn Cookies nicht m\u00f6glich (z.B. native Apps).</p>"},{"location":"guides/HAPROXY/#haproxy-spezifische-details","title":"HAProxy-spezifische Details","text":""},{"location":"guides/HAPROXY/#haproxycfg-struktur","title":"haproxy.cfg Struktur","text":"<p>Eine generierte <code>haproxy.cfg</code> besteht aus 4 Hauptsektionen:</p> <pre><code># 1. Global Settings\nglobal\n    log         127.0.0.1 local0\n    chroot      /var/lib/haproxy\n    pidfile     /var/run/haproxy.pid\n    maxconn     4000\n    user        haproxy\n    group       haproxy\n    daemon\n    stats socket /var/lib/haproxy/stats level admin\n\n# 2. Defaults (f\u00fcr alle Frontends/Backends)\ndefaults\n    mode                    http\n    log                     global\n    option                  httplog\n    option                  dontlognull\n    option                  http-server-close\n    option                  forwardfor except 127.0.0.0/8\n    option                  redispatch\n    retries                 3\n    timeout http-request    30s\n    timeout queue           30s\n    timeout connect         5s\n    timeout client          30s\n    timeout server          30s\n    timeout http-keep-alive 10s\n    timeout check           5s\n    maxconn                 3000\n\n# 3. Frontend (Eingehende Requests)\nfrontend http_frontend\n    bind 0.0.0.0:80\n\n    # ACLs f\u00fcr Routing\n    acl is_api path_beg /api\n\n    # Rate Limiting\n    stick-table type ip size 100k expire 30s store http_req_rate(10s)\n\n    # Backend Routing\n    use_backend backend_api if is_api\n\n# 4. Backend (Upstream Services)\nbackend backend_api\n    balance roundrobin\n    option httpchk GET /health HTTP/1.1\n\n    server server1 api-1.internal:8080 check\n    server server2 api-2.internal:8080 check\n</code></pre>"},{"location":"guides/HAPROXY/#acls-access-control-lists","title":"ACLs (Access Control Lists)","text":"<p>GAL generiert automatisch ACLs f\u00fcr Routing:</p> <pre><code># Pfad-basiert\nacl is_api_route0 path_beg /api\n\n# Methoden-basiert\nacl is_api_method method GET POST\n\n# Kombiniert\nuse_backend backend_api if is_api_route0 is_api_method\n</code></pre> <p>Wichtige ACL Typen: - <code>path_beg</code>: Pfad beginnt mit - <code>path_end</code>: Pfad endet mit - <code>path_reg</code>: Pfad Regex Match - <code>hdr(name)</code>: Header-Wert - <code>method</code>: HTTP Methode</p>"},{"location":"guides/HAPROXY/#stats-page-runtime-api","title":"Stats Page &amp; Runtime API","text":"<p>HAProxy bietet eine integrierte Stats Page und Runtime API:</p> <pre><code>global\n    stats socket /var/lib/haproxy/stats level admin\n    stats timeout 30s\n\n# Optional: Web UI Stats Page\nlisten stats\n    bind *:8080\n    stats enable\n    stats uri /haproxy-stats\n    stats refresh 30s\n    stats admin if TRUE\n</code></pre> <p>Zugriff: - Web UI: <code>http://localhost:8080/haproxy-stats</code> - Runtime API: <code>echo \"show info\" | socat /var/lib/haproxy/stats -</code></p>"},{"location":"guides/HAPROXY/#logging","title":"Logging","text":"<p>HAProxy loggt standardm\u00e4\u00dfig via syslog:</p> <pre><code>global\n    log 127.0.0.1 local0\n    log 127.0.0.1 local1 notice\n\ndefaults\n    log     global\n    option  httplog\n</code></pre> <p>Syslog Konfiguration (rsyslog): <pre><code># /etc/rsyslog.d/haproxy.conf\n$ModLoad imudp\n$UDPServerRun 514\n\nlocal0.* /var/log/haproxy/access.log\nlocal1.* /var/log/haproxy/errors.log\n</code></pre></p> <p>Log-Format: <pre><code>Nov 18 12:34:56 localhost haproxy[1234]: 192.168.1.100:54321 [18/Nov/2025:12:34:56.789] http_frontend backend_api/server1 0/0/1/2/3 200 1234 - - ---- 1/1/0/0/0 0/0 \"GET /api/users HTTP/1.1\"\n</code></pre></p>"},{"location":"guides/HAPROXY/#provider-vergleich","title":"Provider-Vergleich","text":""},{"location":"guides/HAPROXY/#feature-matrix-haproxy-vs-andere-provider","title":"Feature-Matrix: HAProxy vs. andere Provider","text":"Feature Envoy Kong APISIX Traefik Nginx HAProxy Load Balancing Round Robin \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Least Connections \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 IP Hash \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 (source) Weighted \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Health Checks Active HTTP \u2705 \u2705 \u2705 \u2705 \u274c \u2705 Active TCP \u2705 \u2705 \u2705 \u2705 \u274c \u2705 Passive \u2705 \u2705 \u2705 \u26a0\ufe0f \u2705 \u2705 Security Basic Auth \u26a0\ufe0f Lua \u2705 \u2705 \u2705 \u2705 \u2705 ACL JWT Auth \u2705 \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f Lua API Key \u26a0\ufe0f Lua \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f ACL Headers \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 CORS \u2705 \u2705 \u2705 \u2705 \u2705 \u26a0\ufe0f Traffic Management Rate Limiting \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Sticky Sessions \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Circuit Breaker \u2705 \u26a0\ufe0f \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f Performance RPS (100k+) \u2705 \u26a0\ufe0f \u2705 \u26a0\ufe0f \u2705 \u2705 Memory Usage Medium High Medium Low Low Very Low CPU Usage Medium High Medium Low Low Very Low <p>Legende: - \u2705 Full: Vollst\u00e4ndig unterst\u00fctzt - \u26a0\ufe0f Limited: Eingeschr\u00e4nkt oder zus\u00e4tzliche Module erforderlich - \u274c Not Supported: Nicht verf\u00fcgbar</p>"},{"location":"guides/HAPROXY/#wann-haproxy-wahlen","title":"Wann HAProxy w\u00e4hlen?","text":"<p>\u2705 Ideal f\u00fcr: - Extreme Performance-Anforderungen: 100k+ RPS - Low Resource Usage: Minimale CPU/RAM - Layer 4 &amp; 7 Load Balancing: TCP + HTTP - Enterprise Production: H\u00f6chste Zuverl\u00e4ssigkeit - Complex Routing: ACL-basiertes Routing - Stats &amp; Monitoring: Integrierte Stats Page</p> <p>\u26a0\ufe0f Limitierungen: - Kein natives JWT: Ben\u00f6tigt Lua - Limitierte CORS: Nur via Headers - Statische Konfiguration: Reload erforderlich - Weniger Plugins: Kein Plugin-\u00d6kosystem wie Kong</p> <p>Alternativen: - Nginx: Einfacher, aber weniger Features f\u00fcr LB - Traefik: Dynamic Configuration, gute Docker Integration - Envoy: Moderne Service Mesh Integration - Kong/APISIX: Volles API Gateway mit Plugins</p>"},{"location":"guides/HAPROXY/#haproxy-feature-coverage","title":"HAProxy Feature Coverage","text":"<p>Detaillierte Analyse basierend auf der offiziellen HAProxy Dokumentation.</p>"},{"location":"guides/HAPROXY/#core-configuration-sections","title":"Core Configuration Sections","text":"Section Import Export Status Bemerkung <code>global</code> \u26a0\ufe0f \u2705 Export Global Settings (log, maxconn, etc.) <code>defaults</code> \u26a0\ufe0f \u2705 Export Default Optionen (mode, timeouts) <code>frontend</code> \u2705 \u2705 Voll Listener mit ACLs <code>backend</code> \u2705 \u2705 Voll Upstream mit Servers <code>listen</code> \u274c \u274c Nicht Combined Frontend+Backend"},{"location":"guides/HAPROXY/#load-balancing-algorithms","title":"Load Balancing Algorithms","text":"Algorithm Import Export Status Bemerkung <code>roundrobin</code> \u2705 \u2705 Voll Round Robin (Default) <code>leastconn</code> \u2705 \u2705 Voll Least Connections <code>source</code> \u2705 \u2705 Voll Source IP Hash <code>uri</code> \u274c \u274c Nicht URI Hash <code>url_param</code> \u274c \u274c Nicht URL Parameter Hash <code>hdr</code> \u274c \u274c Nicht Header Hash <code>rdp-cookie</code> \u274c \u274c Nicht RDP Cookie Hash"},{"location":"guides/HAPROXY/#health-check-features","title":"Health Check Features","text":"Feature Import Export Status Bemerkung <code>check</code> (HTTP) \u2705 \u2705 Voll Active HTTP Health Checks <code>check</code> (TCP) \u26a0\ufe0f \u26a0\ufe0f Teilweise TCP Connect Check <code>check inter</code> \u2705 \u2705 Voll Health Check Interval <code>check fall</code> \u2705 \u2705 Voll Failure Threshold <code>check rise</code> \u2705 \u2705 Voll Success Threshold <code>httpchk</code> \u2705 \u2705 Voll HTTP Request Method/Path <code>observe layer4/layer7</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Passive Health Checks <code>on-marked-down</code> \u274c \u274c Nicht Fallback Actions"},{"location":"guides/HAPROXY/#acl-access-control-lists","title":"ACL (Access Control Lists)","text":"ACL Type Import Export Status Bemerkung <code>path_beg</code> \u2705 \u2705 Voll Path Prefix Matching <code>path</code> \u2705 \u2705 Voll Exact Path Matching <code>path_reg</code> \u274c \u274c Nicht Regex Path Matching <code>hdr(host)</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Host Header Matching <code>method</code> \u274c \u274c Nicht HTTP Method Matching <code>src</code> \u274c \u274c Nicht Source IP Matching <code>ssl_fc</code> \u274c \u274c Nicht SSL/TLS Matching"},{"location":"guides/HAPROXY/#stick-tables-session-persistence","title":"Stick Tables (Session Persistence)","text":"Feature Import Export Status Bemerkung <code>stick-table</code> \u2705 \u2705 Voll Stick Table Definition <code>stick on src</code> \u2705 \u2705 Voll IP-based Persistence <code>stick on cookie</code> \u2705 \u2705 Voll Cookie-based Persistence <code>stick match</code> \u274c \u274c Nicht Conditional Matching <code>stick store-request</code> \u274c \u274c Nicht Store on Request"},{"location":"guides/HAPROXY/#rate-limiting-stick-tables","title":"Rate Limiting (Stick Tables)","text":"Feature Import Export Status Bemerkung <code>stick-table type ip size</code> \u2705 \u2705 Voll IP-based Rate Limiting Table <code>http-request track-sc0</code> \u2705 \u2705 Voll Track Client Requests <code>http-request deny if</code> \u2705 \u2705 Voll Deny when limit exceeded <code>sc_http_req_rate</code> \u2705 \u2705 Voll HTTP Request Rate Counter <code>sc_conn_rate</code> \u274c \u274c Nicht Connection Rate Counter"},{"location":"guides/HAPROXY/#requestresponse-headers","title":"Request/Response Headers","text":"Directive Import Export Status Bemerkung <code>http-request set-header</code> \u2705 \u2705 Voll Add Request Header <code>http-request del-header</code> \u2705 \u2705 Voll Remove Request Header <code>http-response set-header</code> \u2705 \u2705 Voll Add Response Header <code>http-response del-header</code> \u2705 \u2705 Voll Remove Response Header <code>http-request replace-header</code> \u274c \u274c Nicht Replace Header Value <code>http-response replace-value</code> \u274c \u274c Nicht Replace Response Value"},{"location":"guides/HAPROXY/#cors-support","title":"CORS Support","text":"Feature Import Export Status Bemerkung <code>Access-Control-Allow-Origin</code> \u2705 \u2705 Voll Via http-response set-header <code>Access-Control-Allow-Methods</code> \u2705 \u2705 Voll Via http-response set-header <code>Access-Control-Allow-Headers</code> \u2705 \u2705 Voll Via http-response set-header <code>Access-Control-Allow-Credentials</code> \u2705 \u2705 Voll Via http-response set-header <code>Access-Control-Max-Age</code> \u2705 \u2705 Voll Via http-response set-header Preflight (OPTIONS) Handling \u274c \u274c Nicht Manuell via ACLs"},{"location":"guides/HAPROXY/#authentication-features","title":"Authentication Features","text":"Feature Import Export Status Bemerkung Basic Auth (ACL) \u26a0\ufe0f \u26a0\ufe0f Teilweise Via ACL + user list JWT Auth (Lua) \u274c \u274c Nicht Ben\u00f6tigt Lua Scripting API Key (ACL) \u26a0\ufe0f \u26a0\ufe0f Teilweise Via ACL hdr matching"},{"location":"guides/HAPROXY/#timeouts","title":"Timeouts","text":"Timeout Import Export Status Bemerkung <code>timeout connect</code> \u2705 \u2705 Voll Backend Connection Timeout <code>timeout client</code> \u2705 \u2705 Voll Client Inactivity Timeout <code>timeout server</code> \u2705 \u2705 Voll Server Inactivity Timeout <code>timeout http-request</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise HTTP Request Timeout <code>timeout http-keep-alive</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Keep-Alive Timeout <code>timeout queue</code> \u274c \u274c Nicht Queue Timeout <code>timeout tunnel</code> \u274c \u274c Nicht Tunnel Timeout (WebSocket)"},{"location":"guides/HAPROXY/#observability","title":"Observability","text":"Feature Import Export Status Bemerkung Access Logs \u26a0\ufe0f \u2705 Export Syslog/File Logging Stats Page (HTTP) \u274c \u2705 Export /haproxy?stats Endpoint Stats Socket \u274c \u2705 Export Admin Socket Prometheus Exporter \u274c \u274c Nicht External Exporter Custom Log Format \u274c \u274c Nicht log-format Directive"},{"location":"guides/HAPROXY/#advanced-features","title":"Advanced Features","text":"Feature Import Export Status Bemerkung Lua Scripting \u274c \u274c Nicht Custom Lua Scripts SSL/TLS Termination \u274c \u274c Nicht bind ssl crt HTTP/2 \u274c \u274c Nicht alpn h2 TCP Mode \u274c \u274c Nicht mode tcp Server Templates \u274c \u274c Nicht server-template Directive Dynamic Scaling \u274c \u274c Nicht Runtime API"},{"location":"guides/HAPROXY/#coverage-score-nach-kategorie","title":"Coverage Score nach Kategorie","text":"Kategorie Features Total Unterst\u00fctzt Coverage Core Configuration 5 2 voll, 2 teilweise ~60% Load Balancing 7 3 voll 43% Health Checks 8 5 voll, 2 teilweise ~75% ACL 7 2 voll, 1 teilweise ~35% Stick Tables 5 3 voll 60% Rate Limiting 5 4 voll 80% Headers 6 4 voll 67% CORS 6 5 voll 83% Authentication 3 0 voll, 2 teilweise 33% Timeouts 7 3 voll, 2 teilweise ~55% Observability 5 2 export 40% Advanced 6 0 0% <p>Gesamt (API Gateway relevante Features): ~55% Coverage</p> <p>Import Coverage: ~50% (Import bestehender HAProxy Configs \u2192 GAL) Export Coverage: ~75% (GAL \u2192 HAProxy haproxy.cfg)</p>"},{"location":"guides/HAPROXY/#bidirektionale-feature-unterstutzung","title":"Bidirektionale Feature-Unterst\u00fctzung","text":"<p>Vollst\u00e4ndig bidirektional (Import \u2194 Export): 1. \u2705 Frontend/Backend Configuration 2. \u2705 Load Balancing (Round Robin, Least Connections, Source Hash) 3. \u2705 Health Checks (Active HTTP) 4. \u2705 Stick Tables (Session Persistence) 5. \u2705 Rate Limiting (Stick Table-based) 6. \u2705 Request/Response Headers 7. \u2705 CORS Headers 8. \u2705 ACL Path Matching (path_beg, path) 9. \u2705 Timeouts (connect, client, server)</p> <p>Nur Export (GAL \u2192 HAProxy): 10. \u26a0\ufe0f Global/Defaults Sections 11. \u26a0\ufe0f Stats Page Configuration 12. \u26a0\ufe0f Access Logs</p> <p>Features mit Einschr\u00e4nkungen: - JWT/API Key Auth: Nur via ACLs/Lua (nicht vollst\u00e4ndig) - SSL/TLS: Keine Auto-Konfiguration - Advanced ACLs: Regex, Method, Header Matching nicht unterst\u00fctzt - Lua Scripting: Nicht generierbar/parsebar</p>"},{"location":"guides/HAPROXY/#import-beispiel-haproxy-gal","title":"Import-Beispiel (HAProxy \u2192 GAL)","text":"<p>Input (haproxy.cfg): <pre><code>frontend http_frontend\n    bind 0.0.0.0:80\n\n    acl is_api path_beg /api\n    use_backend backend_api if is_api\n\nbackend backend_api\n    balance roundrobin\n    option httpchk GET /health\n\n    server server1 backend-1:8080 check inter 10s fall 3 rise 2\n    server server2 backend-2:8080 check inter 10s fall 3 rise 2\n\n    # Rate Limiting\n    stick-table type ip size 100k expire 30s store http_req_rate(10s)\n    http-request track-sc0 src\n    http-request deny if { sc_http_req_rate(0) gt 100 }\n\n    # Headers\n    http-request set-header X-Forwarded-Proto https\n    http-response set-header Access-Control-Allow-Origin *\n</code></pre></p> <p>Output (gal-config.yaml): <pre><code>version: \"1.0\"\nprovider: haproxy\nglobal:\n  host: 0.0.0.0\n  port: 80\nservices:\n  - name: backend_api\n    type: rest\n    protocol: http\n    upstream:\n      targets:\n        - host: backend-1\n          port: 8080\n        - host: backend-2\n          port: 8080\n      load_balancer:\n        algorithm: round_robin\n      health_check:\n        active:\n          enabled: true\n          interval: \"10s\"\n          http_path: \"/health\"\n          unhealthy_threshold: 3\n          healthy_threshold: 2\n    routes:\n      - path_prefix: /api\n        rate_limit:\n          enabled: true\n          requests_per_second: 10  # 100 requests per 10s\n        headers:\n          request_add:\n            X-Forwarded-Proto: \"https\"\n          response_add:\n            Access-Control-Allow-Origin: \"*\"\n</code></pre></p>"},{"location":"guides/HAPROXY/#empfehlungen-fur-zukunftige-erweiterungen","title":"Empfehlungen f\u00fcr zuk\u00fcnftige Erweiterungen","text":"<p>Priorit\u00e4t 1 (High Impact): 1. SSL/TLS Termination - bind ssl crt Configuration 2. Advanced ACLs - Regex, Method, Header Matching 3. Lua Scripting - JWT Auth, Custom Logic 4. Prometheus Metrics - Native Metrics Export 5. TCP Mode - Layer 4 Load Balancing</p> <p>Priorit\u00e4t 2 (Medium Impact): 6. HTTP/2 Support - alpn h2 7. Server Templates - Dynamic Backend Scaling 8. Custom Log Format - log-format Directive 9. Dynamic Scaling - Runtime API Integration 10. WebSocket - timeout tunnel Configuration</p> <p>Priorit\u00e4t 3 (Nice to Have): 11. URI/Header Hashing - Additional LB Algorithms 12. Passive Health Checks - observe layer7 vollst\u00e4ndig 13. On-Marked-Down - Fallback Actions 14. TCP Health Checks - Vollst\u00e4ndige TCP Check-Support 15. Preflight CORS - Automatisches OPTIONS Handling</p>"},{"location":"guides/HAPROXY/#test-coverage-import","title":"Test Coverage (Import)","text":"<p>HAProxy Import Tests: Noch nicht implementiert (v1.3.0 Feature 6)</p> Test Kategorie Tests Status Basic Import - \u23f3 Pending Frontend/Backend - \u23f3 Pending Load Balancing - \u23f3 Pending Health Checks - \u23f3 Pending Rate Limiting - \u23f3 Pending Headers - \u23f3 Pending CORS - \u23f3 Pending Errors &amp; Warnings - \u23f3 Pending <p>Status: Feature 6 (HAProxy Import) ist f\u00fcr v1.3.0 geplant (aktuell \u215d Features fertig)</p>"},{"location":"guides/HAPROXY/#fazit","title":"Fazit","text":"<p>HAProxy Import Coverage (geplant): - \u2705 Core Features: ~75% Coverage erwartet (Frontend, Backend, LB, HC) - \u26a0\ufe0f Authentication: Eingeschr\u00e4nkt (ACL-based, kein natives JWT) - \u274c Advanced Features: Lua, SSL, TCP Mode nicht unterst\u00fctzt</p> <p>HAProxy Export Coverage: - \u2705 Core Features: 90% Coverage (alle GAL Features \u2192 HAProxy) - \u2705 Best Practices: Eingebaut (Health Checks, Rate Limiting, Stats) - \u2705 haproxy.cfg: Vollst\u00e4ndig generiert</p> <p>Empfehlung: - \ud83d\ude80 F\u00fcr High-Performance Workloads: Perfekt geeignet (100k+ RPS) - \u2705 F\u00fcr Standard Load Balancing: Excellent Choice - \u26a0\ufe0f F\u00fcr API Gateway Features (JWT, Plugins): Kong/APISIX besser geeignet - \u26a0\ufe0f F\u00fcr SSL/TLS Auto-Config: Traefik besser geeignet</p> <p>Referenzen: - \ud83d\udcda HAProxy Configuration Manual - \ud83d\udcda HAProxy Load Balancing - \ud83d\udcda HAProxy Health Checks - \ud83d\udcda HAProxy ACLs</p>"},{"location":"guides/HAPROXY/#best-practices","title":"Best Practices","text":""},{"location":"guides/HAPROXY/#1-kombiniere-active-passive-health-checks","title":"1. Kombiniere Active + Passive Health Checks","text":"<p>Empfehlung: <pre><code>health_check:\n  active:\n    enabled: true\n    interval: \"10s\"\n  passive:\n    enabled: true\n    max_failures: 3\n</code></pre></p> <p>Vorteil: Schnelle Reaktion bei Ausf\u00e4llen + Traffic-basierte \u00dcberwachung.</p>"},{"location":"guides/HAPROXY/#2-nutze-weighted-load-balancing-fur-heterogene-server","title":"2. Nutze Weighted Load Balancing f\u00fcr heterogene Server","text":"<p>Empfehlung: <pre><code>targets:\n  - host: large-instance.internal\n    port: 8080\n    weight: 4\n  - host: medium-instance.internal\n    port: 8080\n    weight: 2\n  - host: small-instance.internal\n    port: 8080\n    weight: 1\n</code></pre></p> <p>Vorteil: Optimale Ressourcen-Nutzung.</p>"},{"location":"guides/HAPROXY/#3-setze-angemessene-timeouts","title":"3. Setze angemessene Timeouts","text":"<p>Empfehlung: <pre><code>global:\n  timeout: \"60s\"  # F\u00fcr lange API-Requests\n</code></pre></p> <p>Mapping: <pre><code>defaults\n    timeout client  60s\n    timeout server  60s\n    timeout connect 5s   # Immer kurz (Connection Setup)\n</code></pre></p>"},{"location":"guides/HAPROXY/#4-aktiviere-connection-pooling","title":"4. Aktiviere Connection Pooling","text":"<p>HAProxy Standard: <pre><code>defaults\n    option http-server-close  # Connection Reuse\n</code></pre></p> <p>Vorteil: Reduziert Backend-Verbindungen.</p>"},{"location":"guides/HAPROXY/#5-nutze-stick-tables-effizient","title":"5. Nutze Stick-Tables effizient","text":"<p>Empfehlung: <pre><code>stick-table type ip size 100k expire 30s store http_req_rate(10s)\n</code></pre></p> <ul> <li><code>size 100k</code>: F\u00fcr ~100k gleichzeitige IPs</li> <li><code>expire 30s</code>: Automatisches Cleanup</li> <li><code>store http_req_rate(10s)</code>: 10s Zeitfenster</li> </ul>"},{"location":"guides/HAPROXY/#6-monitoring-via-stats-socket","title":"6. Monitoring via Stats Socket","text":"<p>Setup: <pre><code>global\n    stats socket /var/lib/haproxy/stats level admin\n</code></pre></p> <p>Nutzung: <pre><code># Server Status\necho \"show servers state\" | socat /var/lib/haproxy/stats -\n\n# Disable Server\necho \"disable server backend_api/server1\" | socat /var/lib/haproxy/stats -\n\n# Enable Server\necho \"enable server backend_api/server1\" | socat /var/lib/haproxy/stats -\n</code></pre></p>"},{"location":"guides/HAPROXY/#7-logging-fur-production","title":"7. Logging f\u00fcr Production","text":"<p>Empfehlung: <pre><code>defaults\n    option httplog\n    log global\n</code></pre></p> <p>Mit Rsyslog: <pre><code># /etc/rsyslog.d/haproxy.conf\n$ModLoad imudp\n$UDPServerRun 514\nlocal0.* /var/log/haproxy/access.log\n</code></pre></p>"},{"location":"guides/HAPROXY/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/HAPROXY/#1-503-service-unavailable","title":"1. \"503 Service Unavailable\"","text":"<p>Symptom: Alle Requests \u2192 503</p> <p>M\u00f6gliche Ursachen: 1. Alle Backend-Server down 2. Health Checks schlagen fehl 3. Backend nicht erreichbar</p> <p>Debugging: <pre><code># Server Status pr\u00fcfen\necho \"show servers state\" | socat /var/lib/haproxy/stats -\n\n# HAProxy Logs\ntail -f /var/log/haproxy/access.log\n\n# Health Check testen\ncurl http://backend-server:8080/health\n</code></pre></p> <p>L\u00f6sung: <pre><code># Server manuell aktivieren\necho \"enable server backend_api/server1\" | socat /var/lib/haproxy/stats -\n\n# Health Check Path anpassen\nbackend backend_api\n    option httpchk GET /actuator/health HTTP/1.1\n</code></pre></p>"},{"location":"guides/HAPROXY/#2-rate-limiting-funktioniert-nicht","title":"2. Rate Limiting funktioniert nicht","text":"<p>Symptom: Keine 429 Responses</p> <p>M\u00f6gliche Ursachen: 1. Stick-Table nicht definiert 2. ACL falsch 3. Track nicht aktiv</p> <p>Debugging: <pre><code># Stick-Table anzeigen\necho \"show table\" | socat /var/lib/haproxy/stats -\n</code></pre></p> <p>L\u00f6sung: <pre><code>frontend http_frontend\n    # WICHTIG: Stick-Table definieren\n    stick-table type ip size 100k expire 30s store http_req_rate(10s)\n\n    # WICHTIG: Track BEFORE deny\n    http-request track-sc0 src if is_route\n    http-request deny deny_status 429 if is_route { sc_http_req_rate(0) gt 100 }\n</code></pre></p>"},{"location":"guides/HAPROXY/#3-sticky-sessions-funktionieren-nicht","title":"3. Sticky Sessions funktionieren nicht","text":"<p>Symptom: Requests landen auf verschiedenen Servern</p> <p>M\u00f6gliche Ursachen: 1. Cookie wird nicht gesetzt 2. Cookie wird nicht gesendet 3. Balance algorithm falsch</p> <p>Debugging: <pre><code># Request mit Cookie-Inspektion\ncurl -v http://localhost/api\n\n# Cookie in Response pr\u00fcfen\n# Set-Cookie: SERVERID=server1; path=/\n</code></pre></p> <p>L\u00f6sung: <pre><code>backend backend_api\n    cookie SERVERID insert indirect nocache\n    server server1 api-1.internal:8080 cookie server1\n    server server2 api-2.internal:8080 cookie server2\n</code></pre></p>"},{"location":"guides/HAPROXY/#4-headers-werden-nicht-gesetzt","title":"4. Headers werden nicht gesetzt","text":"<p>Symptom: X-Request-ID fehlt</p> <p>M\u00f6gliche Ursachen: 1. ACL-Condition falsch 2. Direktive an falscher Stelle</p> <p>L\u00f6sung: <pre><code>frontend http_frontend\n    # WICHTIG: if Condition muss matchen\n    http-request set-header X-Request-ID \"%[uuid()]\" if is_route\n\n    # NICHT im Backend setzen (zu sp\u00e4t)\n</code></pre></p>"},{"location":"guides/HAPROXY/#5-config-reload-schlagt-fehl","title":"5. Config Reload schl\u00e4gt fehl","text":"<p>Symptom: <code>haproxy -c -f haproxy.cfg</code> zeigt Fehler</p> <p>M\u00f6gliche Ursachen: 1. Syntax-Fehler 2. Fehlende Direktiven 3. Ung\u00fcltige Werte</p> <p>Debugging: <pre><code># Detaillierte Fehlerausgabe\nhaproxy -c -f haproxy.cfg -V\n\n# Zeile f\u00fcr Zeile pr\u00fcfen\nhaproxy -c -f haproxy.cfg -d\n</code></pre></p> <p>H\u00e4ufige Fehler: <pre><code># FALSCH: Fehlende Quotes\nhttp-request set-header X-Test value with spaces\n\n# RICHTIG\nhttp-request set-header X-Test \"value with spaces\"\n\n# FALSCH: Ung\u00fcltiger Balance Algorithm\nbalance round-robin\n\n# RICHTIG\nbalance roundrobin\n</code></pre></p>"},{"location":"guides/HAPROXY/#6-performance-probleme","title":"6. Performance-Probleme","text":"<p>Symptom: Hohe Latenz, niedrige Throughput</p> <p>Debugging: <pre><code># Stats anzeigen\necho \"show info\" | socat /var/lib/haproxy/stats -\n\n# Connection Limits pr\u00fcfen\necho \"show stat\" | socat /var/lib/haproxy/stats -\n</code></pre></p> <p>Tuning: <pre><code>global\n    maxconn 10000  # Erh\u00f6hen f\u00fcr mehr gleichzeitige Connections\n\ndefaults\n    timeout http-keep-alive 10s  # Connection Reuse\n    option http-server-close\n\nbackend backend_api\n    balance leastconn  # Bessere Verteilung bei ungleichen Requests\n</code></pre></p>"},{"location":"guides/HAPROXY/#weiterfuhrende-ressourcen","title":"Weiterf\u00fchrende Ressourcen","text":""},{"location":"guides/HAPROXY/#offizielle-dokumentation","title":"Offizielle Dokumentation","text":"<ul> <li>HAProxy Docs: https://docs.haproxy.org/</li> <li>Configuration Manual: https://cbonte.github.io/haproxy-dconv/2.9/configuration.html</li> <li>Best Practices: https://www.haproxy.com/documentation/hapee/latest/configuration/best-practices/</li> </ul>"},{"location":"guides/HAPROXY/#gal-dokumentation","title":"GAL Dokumentation","text":"<ul> <li>Hauptdokumentation: README.md</li> <li>Rate Limiting Guide: RATE_LIMITING.md</li> <li>Health Checks Guide: HEALTH_CHECKS.md</li> <li>Authentication Guide: AUTHENTICATION.md</li> </ul>"},{"location":"guides/HAPROXY/#beispiele","title":"Beispiele","text":"<ul> <li>HAProxy Examples: examples/haproxy-example.yaml</li> <li>Alle Provider: examples/</li> </ul> <p>Letzte Aktualisierung: 2025-10-18 GAL Version: 1.2.0 HAProxy Version: 2.9+</p>"},{"location":"guides/HEADERS/","title":"Header Manipulation Guide","text":"<p>Complete guide to HTTP header manipulation in GAL (Gateway Abstraction Layer)</p>"},{"location":"guides/HEADERS/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Quick Start</li> <li>Header Operations</li> <li>Configuration Levels</li> <li>Provider Implementation</li> <li>Common Use Cases</li> <li>Security Best Practices</li> <li>Testing Header Manipulation</li> <li>Troubleshooting</li> </ol>"},{"location":"guides/HEADERS/#overview","title":"Overview","text":"<p>Header manipulation allows you to modify HTTP request and response headers as they pass through the gateway. This is essential for:</p> <ul> <li>Security: Adding security headers, removing sensitive information</li> <li>CORS: Enabling cross-origin resource sharing</li> <li>Request Identification: Adding correlation/request IDs</li> <li>Backend Communication: Adding internal headers for backend services</li> <li>Response Modification: Customizing headers returned to clients</li> </ul>"},{"location":"guides/HEADERS/#supported-operations","title":"Supported Operations","text":"Operation Request Response Description Add \u2705 \u2705 Add header (keeps existing values) Set \u2705 \u2705 Set/replace header (overwrites existing) Remove \u2705 \u2705 Delete header completely"},{"location":"guides/HEADERS/#provider-support","title":"Provider Support","text":"<p>All GAL providers support header manipulation:</p> Provider Request Headers Response Headers Notes Kong \u2705 \u2705 request-transformer, response-transformer plugins APISIX \u2705 \u2705 proxy-rewrite, response-rewrite plugins Traefik \u2705 \u2705 headers middleware Envoy \u2705 \u2705 Native route-level header manipulation"},{"location":"guides/HEADERS/#quick-start","title":"Quick Start","text":""},{"location":"guides/HEADERS/#basic-example-adding-request-headers","title":"Basic Example: Adding Request Headers","text":"<pre><code>version: \"1.0\"\nprovider: kong\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      host: api.example.com\n      port: 8080\n    routes:\n      - path_prefix: /api\n        headers:\n          request_add:\n            X-Request-ID: \"{{uuid}}\"\n            X-API-Version: \"v1\"\n</code></pre>"},{"location":"guides/HEADERS/#basic-example-security-headers","title":"Basic Example: Security Headers","text":"<pre><code>routes:\n  - path_prefix: /api\n    headers:\n      response_add:\n        X-Frame-Options: DENY\n        X-Content-Type-Options: nosniff\n        Strict-Transport-Security: \"max-age=31536000\"\n      response_remove:\n        - Server\n        - X-Powered-By\n</code></pre>"},{"location":"guides/HEADERS/#header-operations","title":"Header Operations","text":""},{"location":"guides/HEADERS/#1-adding-headers-request_add-response_add","title":"1. Adding Headers (request_add / response_add)","text":"<p>Adds headers while preserving existing values. If the header already exists, the new value is appended.</p> <pre><code>headers:\n  request_add:\n    X-Custom-Header: \"custom-value\"\n    X-Correlation-ID: \"{{uuid}}\"\n    X-Forwarded-For: \"client-ip\"\n\n  response_add:\n    X-Response-Time: \"100ms\"\n    X-Cache-Status: \"HIT\"\n    X-Server-ID: \"gateway-01\"\n</code></pre> <p>Use Cases: - Adding custom headers for backend services - Injecting correlation/trace IDs - Adding caching information - Appending proxy chain information</p>"},{"location":"guides/HEADERS/#2-setting-headers-request_set-response_set","title":"2. Setting Headers (request_set / response_set)","text":"<p>Sets or replaces headers. If the header exists, it's overwritten with the new value.</p> <pre><code>headers:\n  request_set:\n    User-Agent: \"GAL-Gateway/1.0\"\n    Host: \"backend.internal.com\"\n    Authorization: \"Bearer {{token}}\"\n\n  response_set:\n    Server: \"GAL-Gateway\"\n    Content-Type: \"application/json\"\n</code></pre> <p>Use Cases: - Overwriting existing headers - Standardizing header values - Modifying upstream-generated headers - Setting security headers</p>"},{"location":"guides/HEADERS/#3-removing-headers-request_remove-response_remove","title":"3. Removing Headers (request_remove / response_remove)","text":"<p>Removes headers completely from the request or response.</p> <pre><code>headers:\n  request_remove:\n    - X-Internal-Token\n    - X-Debug-Mode\n    - Cookie\n\n  response_remove:\n    - Server\n    - X-Powered-By\n    - X-AspNet-Version\n</code></pre> <p>Use Cases: - Removing sensitive information - Hiding backend details - Stripping debug headers in production - Removing unnecessary headers</p>"},{"location":"guides/HEADERS/#configuration-levels","title":"Configuration Levels","text":"<p>GAL supports header manipulation at two levels:</p>"},{"location":"guides/HEADERS/#1-route-level-per-route","title":"1. Route-Level (Per-Route)","text":"<p>Configure headers for specific routes. Takes precedence over service-level configuration.</p> <pre><code>services:\n  - name: api_service\n    upstream:\n      host: api.local\n      port: 8080\n    routes:\n      - path_prefix: /api/public\n        headers:\n          request_add:\n            X-API-Type: \"public\"\n          response_add:\n            Cache-Control: \"public, max-age=3600\"\n\n      - path_prefix: /api/private\n        headers:\n          request_add:\n            X-API-Type: \"private\"\n          response_add:\n            Cache-Control: \"private, no-cache\"\n</code></pre> <p>Advantages: - Fine-grained control per endpoint - Different headers for different paths - Override service defaults</p>"},{"location":"guides/HEADERS/#2-service-level-transformation","title":"2. Service-Level (Transformation)","text":"<p>Configure headers for all routes in a service.</p> <pre><code>services:\n  - name: backend_service\n    upstream:\n      host: backend.local\n      port: 8080\n    routes:\n      - path_prefix: /api\n    transformation:\n      enabled: true\n      headers:\n        request_add:\n          X-Service-Name: \"backend_service\"\n          X-Environment: \"production\"\n        response_add:\n          X-API-Version: \"2.0\"\n</code></pre> <p>Advantages: - Apply headers to all routes - Centralized header configuration - DRY (Don't Repeat Yourself)</p>"},{"location":"guides/HEADERS/#provider-implementation","title":"Provider Implementation","text":""},{"location":"guides/HEADERS/#kong-request-transformer-response-transformer","title":"Kong (request-transformer &amp; response-transformer)","text":"<p>Kong uses two plugins for header manipulation:</p> <p>Request Headers: <pre><code>plugins:\n  - name: request-transformer\n    config:\n      add:\n        headers:\n          - \"X-Custom:value\"\n      replace:\n        headers:\n          - \"User-Agent:GAL\"\n      remove:\n        headers:\n          - X-Internal\n</code></pre></p> <p>Response Headers: <pre><code>plugins:\n  - name: response-transformer\n    config:\n      add:\n        headers:\n          - \"X-Response:ok\"\n      remove:\n        headers:\n          - Server\n</code></pre></p>"},{"location":"guides/HEADERS/#apisix-proxy-rewrite-response-rewrite","title":"APISIX (proxy-rewrite &amp; response-rewrite)","text":"<p>APISIX uses rewrite plugins:</p> <p>Request Headers: <pre><code>{\n  \"proxy-rewrite\": {\n    \"headers\": {\n      \"add\": {\"X-Custom\": \"value\"},\n      \"set\": {\"User-Agent\": \"GAL\"},\n      \"remove\": [\"X-Internal\"]\n    }\n  }\n}\n</code></pre></p> <p>Response Headers: <pre><code>{\n  \"response-rewrite\": {\n    \"headers\": {\n      \"add\": {\"X-Response\": \"ok\"},\n      \"remove\": [\"Server\"]\n    }\n  }\n}\n</code></pre></p>"},{"location":"guides/HEADERS/#traefik-headers-middleware","title":"Traefik (headers middleware)","text":"<p>Traefik uses the headers middleware:</p> <pre><code>middlewares:\n  api_headers:\n    headers:\n      customRequestHeaders:\n        X-Custom: \"value\"\n        X-Internal: \"\"  # Empty value removes header\n      customResponseHeaders:\n        X-Response: \"ok\"\n        Server: \"\"  # Empty value removes header\n</code></pre>"},{"location":"guides/HEADERS/#envoy-native-route-configuration","title":"Envoy (Native Route Configuration)","text":"<p>Envoy has native header manipulation:</p> <pre><code>routes:\n  - match:\n      prefix: /api\n    route:\n      cluster: backend\n    request_headers_to_add:\n      - header:\n          key: X-Custom\n          value: value\n        append: true  # true=add, false=set\n    request_headers_to_remove:\n      - X-Internal\n    response_headers_to_add:\n      - header:\n          key: X-Response\n          value: ok\n    response_headers_to_remove:\n      - Server\n</code></pre>"},{"location":"guides/HEADERS/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guides/HEADERS/#1-security-headers","title":"1. Security Headers","text":"<p>Add standard security headers to all responses:</p> <pre><code>headers:\n  response_add:\n    # Prevent clickjacking\n    X-Frame-Options: \"DENY\"\n\n    # Prevent MIME type sniffing\n    X-Content-Type-Options: \"nosniff\"\n\n    # Enable XSS protection\n    X-XSS-Protection: \"1; mode=block\"\n\n    # HSTS for HTTPS\n    Strict-Transport-Security: \"max-age=31536000; includeSubDomains\"\n\n    # Content Security Policy\n    Content-Security-Policy: \"default-src 'self'\"\n\n  response_remove:\n    # Hide backend details\n    - Server\n    - X-Powered-By\n    - X-AspNet-Version\n</code></pre>"},{"location":"guides/HEADERS/#2-cors-headers","title":"2. CORS Headers","text":"<p>Enable Cross-Origin Resource Sharing:</p> <pre><code>headers:\n  response_add:\n    Access-Control-Allow-Origin: \"*\"\n    Access-Control-Allow-Methods: \"GET, POST, PUT, DELETE, OPTIONS\"\n    Access-Control-Allow-Headers: \"Content-Type, Authorization\"\n    Access-Control-Max-Age: \"86400\"\n</code></pre>"},{"location":"guides/HEADERS/#3-request-identification","title":"3. Request Identification","text":"<p>Add correlation/trace IDs for distributed tracing:</p> <pre><code>headers:\n  request_add:\n    X-Request-ID: \"{{uuid}}\"\n    X-Correlation-ID: \"{{uuid}}\"\n    X-Trace-ID: \"{{uuid}}\"\n\n  response_add:\n    X-Request-ID: \"{{uuid}}\"  # Echo request ID in response\n</code></pre>"},{"location":"guides/HEADERS/#4-backend-communication","title":"4. Backend Communication","text":"<p>Add internal headers for backend services:</p> <pre><code>headers:\n  request_add:\n    X-Gateway-Version: \"1.0\"\n    X-Client-IP: \"{{client_ip}}\"\n    X-Forwarded-Proto: \"https\"\n    X-Real-IP: \"{{client_ip}}\"\n</code></pre>"},{"location":"guides/HEADERS/#5-caching-control","title":"5. Caching Control","text":"<p>Configure caching behavior:</p> <pre><code># Public API - cacheable\nroutes:\n  - path_prefix: /api/public\n    headers:\n      response_add:\n        Cache-Control: \"public, max-age=3600\"\n        Vary: \"Accept-Encoding\"\n\n# Private API - no caching\nroutes:\n  - path_prefix: /api/private\n    headers:\n      response_add:\n        Cache-Control: \"private, no-cache, no-store, must-revalidate\"\n        Pragma: \"no-cache\"\n        Expires: \"0\"\n</code></pre>"},{"location":"guides/HEADERS/#6-api-versioning","title":"6. API Versioning","text":"<p>Indicate API version in headers:</p> <pre><code>headers:\n  request_add:\n    X-API-Version: \"v2\"\n\n  response_add:\n    X-API-Version: \"v2\"\n    X-Deprecated: \"false\"\n</code></pre>"},{"location":"guides/HEADERS/#7-removing-sensitive-information","title":"7. Removing Sensitive Information","text":"<p>Strip internal/debug headers:</p> <pre><code>headers:\n  request_remove:\n    - X-Internal-Token\n    - X-Debug-Mode\n    - X-Admin-Secret\n\n  response_remove:\n    - X-Database-Host\n    - X-Internal-Service\n    - X-Debug-Info\n</code></pre>"},{"location":"guides/HEADERS/#security-best-practices","title":"Security Best Practices","text":""},{"location":"guides/HEADERS/#1-always-remove-backend-disclosure-headers","title":"1. Always Remove Backend Disclosure Headers","text":"<pre><code>response_remove:\n  - Server           # \"Apache/2.4.41\", \"nginx/1.18.0\"\n  - X-Powered-By     # \"PHP/7.4.3\", \"Express\"\n  - X-AspNet-Version # \"4.0.30319\"\n  - X-AspNetMvc-Version\n</code></pre>"},{"location":"guides/HEADERS/#2-add-security-headers-to-all-responses","title":"2. Add Security Headers to All Responses","text":"<pre><code>response_add:\n  X-Frame-Options: \"DENY\"\n  X-Content-Type-Options: \"nosniff\"\n  X-XSS-Protection: \"1; mode=block\"\n  Strict-Transport-Security: \"max-age=31536000; includeSubDomains; preload\"\n</code></pre>"},{"location":"guides/HEADERS/#3-implement-content-security-policy","title":"3. Implement Content Security Policy","text":"<pre><code>response_add:\n  Content-Security-Policy: \"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'\"\n</code></pre>"},{"location":"guides/HEADERS/#4-remove-debug-headers-in-production","title":"4. Remove Debug Headers in Production","text":"<pre><code>request_remove:\n  - X-Debug\n  - X-Trace\n  - X-Internal-Request\n</code></pre>"},{"location":"guides/HEADERS/#5-sanitize-forwarded-headers","title":"5. Sanitize Forwarded Headers","text":"<pre><code># Remove client-provided proxy headers\nrequest_remove:\n  - X-Forwarded-For\n  - X-Real-IP\n  - X-Forwarded-Proto\n\n# Add gateway-verified headers\nrequest_add:\n  X-Forwarded-For: \"{{client_ip}}\"\n  X-Real-IP: \"{{client_ip}}\"\n  X-Forwarded-Proto: \"https\"\n</code></pre>"},{"location":"guides/HEADERS/#testing-header-manipulation","title":"Testing Header Manipulation","text":""},{"location":"guides/HEADERS/#using-curl","title":"Using cURL","text":"<p>Test Request Headers: <pre><code># Check if header is added to backend\ncurl -v http://gateway/api \\\n  -H \"X-Test: original\" \\\n  2&gt;&amp;1 | grep \"X-Custom\"\n</code></pre></p> <p>Test Response Headers: <pre><code># Check response headers\ncurl -I http://gateway/api\n\n# Should see added headers\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\n</code></pre></p>"},{"location":"guides/HEADERS/#using-httpie","title":"Using HTTPie","text":"<pre><code># Request headers\nhttp GET http://gateway/api X-Test:original\n\n# Response headers\nhttp HEAD http://gateway/api\n</code></pre>"},{"location":"guides/HEADERS/#automated-testing","title":"Automated Testing","text":"<pre><code>import requests\n\ndef test_security_headers():\n    response = requests.get('http://gateway/api')\n\n    # Check added headers\n    assert 'X-Frame-Options' in response.headers\n    assert response.headers['X-Frame-Options'] == 'DENY'\n\n    # Check removed headers\n    assert 'Server' not in response.headers\n    assert 'X-Powered-By' not in response.headers\n</code></pre>"},{"location":"guides/HEADERS/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/HEADERS/#headers-not-being-added","title":"Headers Not Being Added","text":"<p>Problem: Headers configured but not appearing in requests/responses</p> <p>Solutions: 1. Check provider logs: Ensure plugins/middlewares are loaded 2. Verify configuration: Check YAML syntax for headers section 3. Test with curl -v: See exact headers being sent/received 4. Check middleware order: Some providers require specific plugin order</p> <p>Kong: <pre><code># Check if plugins are loaded\ncurl http://localhost:8001/plugins\n\n# Check specific route plugins\ncurl http://localhost:8001/routes/{route_id}/plugins\n</code></pre></p> <p>APISIX: <pre><code># Check route configuration\ncurl http://localhost:9180/apisix/admin/routes/1 \\\n  -H \"X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\"\n</code></pre></p>"},{"location":"guides/HEADERS/#headers-being-duplicated","title":"Headers Being Duplicated","text":"<p>Problem: Headers appear multiple times</p> <p>Solution: Use <code>request_set</code>/<code>response_set</code> instead of <code>request_add</code>/<code>response_add</code></p> <pre><code># Wrong - causes duplication\nheaders:\n  request_add:\n    X-Correlation-ID: \"{{uuid}}\"  # May add multiple times\n\n# Correct - ensures single value\nheaders:\n  request_set:\n    X-Correlation-ID: \"{{uuid}}\"  # Replaces existing\n</code></pre>"},{"location":"guides/HEADERS/#headers-not-removed","title":"Headers Not Removed","text":"<p>Problem: Headers still appearing despite remove configuration</p> <p>Solutions: 1. Check header name: Header names are case-insensitive but must match 2. Provider-specific: Some headers may be protected 3. Order matters: Remove operations happen at specific phases</p> <pre><code># Ensure exact header name\nresponse_remove:\n  - Server            # Correct\n  - server            # Also works (case-insensitive)\n  - X-Powered-By      # Exact name required\n</code></pre>"},{"location":"guides/HEADERS/#cors-issues","title":"CORS Issues","text":"<p>Problem: CORS errors despite adding CORS headers</p> <p>Solution: Ensure OPTIONS requests are handled correctly</p> <pre><code>routes:\n  - path_prefix: /api\n    methods: [GET, POST, PUT, DELETE, OPTIONS]  # Include OPTIONS!\n    headers:\n      response_add:\n        Access-Control-Allow-Origin: \"*\"\n        Access-Control-Allow-Methods: \"GET, POST, PUT, DELETE, OPTIONS\"\n        Access-Control-Allow-Headers: \"Content-Type, Authorization\"\n        Access-Control-Max-Age: \"86400\"\n</code></pre>"},{"location":"guides/HEADERS/#provider-specific-issues","title":"Provider-Specific Issues","text":"<p>Kong: Plugin conflicts <pre><code># Ensure plugins don't conflict\n# request-transformer must come before authentication\n</code></pre></p> <p>APISIX: Plugin priority <pre><code>{\n  \"plugins\": {\n    \"proxy-rewrite\": { \"_meta\": {\"priority\": 1008} },\n    \"response-rewrite\": { \"_meta\": {\"priority\": 899} }\n  }\n}\n</code></pre></p> <p>Traefik: Middleware order <pre><code># Middlewares are applied in order listed\nrouters:\n  api:\n    middlewares:\n      - headers-middleware  # Applied first\n      - auth-middleware     # Applied second\n</code></pre></p> <p>Envoy: Filter chain order <pre><code># HTTP filters are applied in order\nhttp_filters:\n  - name: jwt_authn      # Applied first\n  - name: header_manipulation  # Applied second\n  - name: router         # Must be last\n</code></pre></p>"},{"location":"guides/HEADERS/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"guides/HEADERS/#conditional-headers","title":"Conditional Headers","text":"<p>Add headers based on route path:</p> <pre><code>services:\n  - name: api\n    routes:\n      - path_prefix: /api/v1\n        headers:\n          request_add:\n            X-API-Version: \"v1\"\n\n      - path_prefix: /api/v2\n        headers:\n          request_add:\n            X-API-Version: \"v2\"\n</code></pre>"},{"location":"guides/HEADERS/#environment-specific-headers","title":"Environment-Specific Headers","text":"<pre><code># Production\nheaders:\n  request_add:\n    X-Environment: \"production\"\n  response_remove:\n    - X-Debug\n\n# Development\nheaders:\n  request_add:\n    X-Environment: \"development\"\n    X-Debug-Mode: \"enabled\"\n</code></pre>"},{"location":"guides/HEADERS/#multi-tenant-headers","title":"Multi-Tenant Headers","text":"<pre><code>routes:\n  - path_prefix: /tenant/acme\n    headers:\n      request_add:\n        X-Tenant-ID: \"acme\"\n        X-Tenant-Region: \"us-west\"\n\n  - path_prefix: /tenant/widgets\n    headers:\n      request_add:\n        X-Tenant-ID: \"widgets\"\n        X-Tenant-Region: \"eu-central\"\n</code></pre>"},{"location":"guides/HEADERS/#conclusion","title":"Conclusion","text":"<p>Header manipulation is a powerful feature that enables:</p> <p>\u2705 Security hardening through security headers \u2705 CORS support for cross-origin requests \u2705 Request tracing with correlation IDs \u2705 Backend communication via internal headers \u2705 Information hiding by removing server headers</p> <p>Next Steps: - Review AUTHENTICATION.md for combining headers with auth - Check RATE_LIMITING.md for rate limiting integration - Explore examples/headers-test.yaml for complete examples</p> <p>Need Help? - Report issues: https://github.com/anthropics/gal/issues - Documentation: https://docs.gal.dev - Examples: examples/</p>"},{"location":"guides/HEALTH_CHECKS/","title":"Health Checks und Load Balancing Anleitung","text":"<p>Umfassende Anleitung f\u00fcr Health Checks &amp; Load Balancing in GAL (Gateway Abstraction Layer)</p>"},{"location":"guides/HEALTH_CHECKS/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ol> <li>\u00dcbersicht</li> <li>Schnellstart</li> <li>Konfigurationsoptionen</li> <li>Provider-Implementierung</li> <li>Load Balancing Algorithmen</li> <li>H\u00e4ufige Anwendungsf\u00e4lle</li> <li>Best Practices</li> <li>Troubleshooting</li> </ol>"},{"location":"guides/HEALTH_CHECKS/#ubersicht","title":"\u00dcbersicht","text":"<p>Health Checks und Load Balancing sind essenzielle Features f\u00fcr hochverf\u00fcgbare, skalierbare API-Gateways. GAL bietet eine einheitliche Konfiguration f\u00fcr alle unterst\u00fctzten Gateway-Provider.</p>"},{"location":"guides/HEALTH_CHECKS/#was-sind-health-checks","title":"Was sind Health Checks?","text":"<p>Health Checks \u00fcberwachen kontinuierlich die Verf\u00fcgbarkeit und Gesundheit von Backend-Services. Es gibt zwei Arten:</p> <p>Active Health Checks (Aktive \u00dcberwachung): - Gateway sendet periodisch Test-Requests an Backend - Unabh\u00e4ngig vom echten Traffic - Kann defekte Services automatisch wieder aktivieren - Zus\u00e4tzlicher Traffic zu den Backends</p> <p>Passive Health Checks (Passive \u00dcberwachung): - Basiert auf echtem Request-Traffic - Analysiert Antwort-Status-Codes - Keine zus\u00e4tzliche Last - Kann Services nur deaktivieren (nicht reaktivieren)</p>"},{"location":"guides/HEALTH_CHECKS/#was-ist-load-balancing","title":"Was ist Load Balancing?","text":"<p>Load Balancing verteilt eingehende Requests auf mehrere Backend-Server, um: - \u2705 Verf\u00fcgbarkeit zu erh\u00f6hen (Failover bei Ausf\u00e4llen) - \u2705 Performance zu verbessern (Lastverteilung) - \u2705 Skalierbarkeit zu erm\u00f6glichen (horizontales Scaling) - \u2705 Wartung zu erleichtern (Rolling Updates)</p>"},{"location":"guides/HEALTH_CHECKS/#provider-unterstutzung","title":"Provider-Unterst\u00fctzung","text":"Feature Kong APISIX Traefik Envoy Implementierung Active Health Checks \u2705 \u2705 \u2705 \u2705 100% Passive Health Checks \u2705 \u2705 \u26a0\ufe0f \u2705 75% Multiple Targets \u2705 \u2705 \u2705 \u2705 100% Weighted Load Balancing \u2705 \u2705 \u2705 \u2705 100% Round Robin \u2705 \u2705 \u2705 \u2705 100% Least Connections \u2705 \u2705 \u2705 \u2705 100% IP Hash \u2705 \u2705 \u26a0\ufe0f \u2705 75% Sticky Sessions \u2705 \u26a0\ufe0f \u2705 \u26a0\ufe0f 50% <p>Coverage: 100% f\u00fcr Health Checks, 100% f\u00fcr Load Balancing</p>"},{"location":"guides/HEALTH_CHECKS/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/HEALTH_CHECKS/#einfache-active-health-checks","title":"Einfache Active Health Checks","text":"<p>Basis-Konfiguration f\u00fcr periodisches Probing:</p> <pre><code>version: \"1.0\"\nprovider: apisix\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      host: api.internal\n      port: 8080\n      health_check:\n        active:\n          enabled: true\n          http_path: /health           # Welcher Pfad soll gepr\u00fcft werden?\n          interval: \"10s\"               # Alle 10 Sekunden pr\u00fcfen\n          timeout: \"5s\"                 # Timeout pro Check\n          healthy_threshold: 2          # 2 erfolgreiche Checks \u2192 healthy\n          unhealthy_threshold: 3        # 3 fehlgeschlagene Checks \u2192 unhealthy\n          healthy_status_codes:         # Welche Status Codes sind OK?\n            - 200\n            - 201\n            - 204\n    routes:\n      - path_prefix: /api\n        methods: [GET, POST]\n</code></pre>"},{"location":"guides/HEALTH_CHECKS/#load-balancing-mit-mehreren-servern","title":"Load Balancing mit mehreren Servern","text":"<p>Konfiguration f\u00fcr Round-Robin Load Balancing \u00fcber 3 Server:</p> <pre><code>version: \"1.0\"\nprovider: kong\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n          weight: 1\n        - host: api-2.internal\n          port: 8080\n          weight: 1\n        - host: api-3.internal\n          port: 8080\n          weight: 1\n      load_balancer:\n        algorithm: round_robin\n    routes:\n      - path_prefix: /api\n        methods: [GET, POST]\n</code></pre>"},{"location":"guides/HEALTH_CHECKS/#kombiniert-health-checks-load-balancing","title":"Kombiniert: Health Checks + Load Balancing","text":"<p>Production-Ready Konfiguration mit Active &amp; Passive Health Checks und Weighted Load Balancing:</p> <pre><code>version: \"1.0\"\nprovider: envoy\n\nservices:\n  - name: payment_service\n    type: rest\n    protocol: http\n    upstream:\n      targets:\n        - host: payment-1.internal\n          port: 8080\n          weight: 2    # Doppelt so viel Traffic wie payment-2\n        - host: payment-2.internal\n          port: 8080\n          weight: 1\n      health_check:\n        active:\n          enabled: true\n          http_path: /actuator/health\n          interval: \"15s\"\n          timeout: \"3s\"\n          healthy_threshold: 2\n          unhealthy_threshold: 3\n          healthy_status_codes: [200, 204]\n        passive:\n          enabled: true\n          max_failures: 5\n          unhealthy_status_codes: [500, 502, 503, 504]\n      load_balancer:\n        algorithm: weighted\n    routes:\n      - path_prefix: /api/payments\n        methods: [GET, POST]\n</code></pre>"},{"location":"guides/HEALTH_CHECKS/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/HEALTH_CHECKS/#upstreamtarget-einzelner-server","title":"UpstreamTarget (Einzelner Server)","text":"<p>Definition eines einzelnen Backend-Servers in einem Load-Balancing-Pool:</p> <pre><code>targets:\n  - host: api-1.internal     # Hostname oder IP\n    port: 8080               # Port\n    weight: 2                # Gewichtung (Standard: 1)\n</code></pre> <p>Attribute: - <code>host</code> (string, erforderlich): Hostname oder IP-Adresse - <code>port</code> (int, erforderlich): Port-Nummer - <code>weight</code> (int, optional): Gewichtung f\u00fcr Load Balancing (Standard: 1)</p>"},{"location":"guides/HEALTH_CHECKS/#activehealthcheck-aktive-uberwachung","title":"ActiveHealthCheck (Aktive \u00dcberwachung)","text":"<p>Konfiguration f\u00fcr periodisches Probing von Backend-Services:</p> <pre><code>health_check:\n  active:\n    enabled: true                 # Health Checks aktivieren\n    http_path: /health            # Welcher HTTP-Pfad wird gepr\u00fcft?\n    interval: \"10s\"               # Pr\u00fcfintervall\n    timeout: \"5s\"                 # Timeout pro einzelnen Check\n    healthy_threshold: 2          # Aufeinanderfolgende Erfolge f\u00fcr \"healthy\"\n    unhealthy_threshold: 3        # Aufeinanderfolgende Fehler f\u00fcr \"unhealthy\"\n    healthy_status_codes:         # HTTP Status Codes die als \"healthy\" gelten\n      - 200\n      - 201\n      - 204\n</code></pre> <p>Attribute: - <code>enabled</code> (bool): Aktive Health Checks aktivieren (Standard: true) - <code>http_path</code> (string): HTTP-Pfad f\u00fcr Probing (Standard: \"/health\") - <code>interval</code> (string): Pr\u00fcfintervall (Standard: \"10s\") - <code>timeout</code> (string): Timeout pro Check (Standard: \"5s\") - <code>healthy_threshold</code> (int): Erfolge bis \"healthy\" (Standard: 2) - <code>unhealthy_threshold</code> (int): Fehler bis \"unhealthy\" (Standard: 3) - <code>healthy_status_codes</code> (list[int]): OK Status Codes (Standard: [200, 201, 204])</p> <p>Probing-Ablauf: <pre><code>Backend healthy:     \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 (Normal Traffic) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nBackend wird slow:   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 1 Fehler \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 2 Fehler\nBackend marked unhealthy: \u2500\u2500\u2500\u2500 3 Fehler (UNHEALTHY!) \u2500\u2500\u2500\u2500\nBackend erholt sich: \u2500\u2500\u2500\u2500\u2500\u2500 1 OK \u2500\u2500\u2500\u2500\u2500\u2500 2 OK (HEALTHY!) \u2500\u2500\u2500\u2500\n</code></pre></p>"},{"location":"guides/HEALTH_CHECKS/#passivehealthcheck-passive-uberwachung","title":"PassiveHealthCheck (Passive \u00dcberwachung)","text":"<p>Konfiguration f\u00fcr Traffic-basierte Fehlerkennung:</p> <pre><code>health_check:\n  passive:\n    enabled: true                 # Passive Health Checks aktivieren\n    max_failures: 5               # Max. aufeinanderfolgende Fehler\n    unhealthy_status_codes:       # Welche Status Codes = Fehler?\n      - 500\n      - 502\n      - 503\n      - 504\n</code></pre> <p>Attribute: - <code>enabled</code> (bool): Passive Health Checks aktivieren (Standard: true) - <code>max_failures</code> (int): Max. Fehler bis \"unhealthy\" (Standard: 5) - <code>unhealthy_status_codes</code> (list[int]): Fehler Status Codes (Standard: [500, 502, 503, 504])</p> <p>Wichtig: Passive Health Checks k\u00f6nnen Services nur deaktivieren, nicht reaktivieren!</p> <p>Empfehlung: Kombiniere mit Active Health Checks f\u00fcr automatische Reaktivierung:</p> <pre><code>health_check:\n  active:\n    enabled: true\n    interval: \"10s\"\n  passive:\n    enabled: true\n    max_failures: 3\n</code></pre>"},{"location":"guides/HEALTH_CHECKS/#loadbalancerconfig-load-balancing-strategie","title":"LoadBalancerConfig (Load Balancing Strategie)","text":"<p>Konfiguration des Load Balancing Algorithmus und Verhaltens:</p> <pre><code>load_balancer:\n  algorithm: round_robin        # LB-Algorithmus\n  sticky_sessions: false        # Sticky Sessions aktivieren?\n  cookie_name: galSession       # Cookie-Name f\u00fcr Sticky Sessions\n</code></pre> <p>Attribute: - <code>algorithm</code> (string): Load Balancing Algorithmus (Standard: \"round_robin\")   - <code>\"round_robin\"</code>: Gleichm\u00e4\u00dfige Verteilung (1\u21922\u21923\u21921\u21922\u21923)   - <code>\"least_conn\"</code>: Server mit wenigsten Verbindungen   - <code>\"ip_hash\"</code>: Basierend auf Client IP (Konsistenz)   - <code>\"weighted\"</code>: Gewichtete Verteilung (nutzt <code>weight</code> von Targets) - <code>sticky_sessions</code> (bool): Sticky Sessions aktivieren (Standard: false) - <code>cookie_name</code> (string): Session Cookie Name (Standard: \"galSession\")</p>"},{"location":"guides/HEALTH_CHECKS/#provider-implementierung","title":"Provider-Implementierung","text":""},{"location":"guides/HEALTH_CHECKS/#apisix","title":"APISIX","text":"<p>APISIX nutzt native <code>checks</code> Konfiguration im Upstream-Objekt.</p> <p>Active Health Checks: <pre><code>{\n  \"checks\": {\n    \"active\": {\n      \"type\": \"http\",\n      \"http_path\": \"/health\",\n      \"timeout\": 5,\n      \"healthy\": {\n        \"interval\": 10,\n        \"successes\": 2,\n        \"http_statuses\": [200, 201, 204]\n      },\n      \"unhealthy\": {\n        \"interval\": 10,\n        \"http_failures\": 3\n      }\n    }\n  }\n}\n</code></pre></p> <p>Passive Health Checks: <pre><code>{\n  \"checks\": {\n    \"passive\": {\n      \"type\": \"http\",\n      \"healthy\": {\n        \"successes\": 1,\n        \"http_statuses\": [200, 201, 202, 204, 301, 302, 303, 304, 307, 308]\n      },\n      \"unhealthy\": {\n        \"http_failures\": 5,\n        \"http_statuses\": [500, 502, 503, 504]\n      }\n    }\n  }\n}\n</code></pre></p> <p>Load Balancing: <pre><code>{\n  \"type\": \"roundrobin\",  // oder: least_conn, chash\n  \"nodes\": {\n    \"api-1.internal:8080\": 2,  // weight\n    \"api-2.internal:8080\": 1\n  },\n  \"hash_on\": \"vars\",      // F\u00fcr chash (IP hash)\n  \"key\": \"remote_addr\"\n}\n</code></pre></p>"},{"location":"guides/HEALTH_CHECKS/#kong","title":"Kong","text":"<p>Kong nutzt separate <code>upstreams</code> Entity mit <code>healthchecks</code> und <code>targets</code>.</p> <p>Active Health Checks: <pre><code>upstreams:\n- name: api_service_upstream\n  algorithm: round-robin\n  healthchecks:\n    active:\n      type: http\n      http_path: /health\n      timeout: 5\n      concurrency: 10\n      healthy:\n        interval: 10\n        successes: 2\n        http_statuses: [200, 201, 204]\n      unhealthy:\n        interval: 10\n        http_failures: 3\n        http_statuses: [429, 500, 503]\n</code></pre></p> <p>Passive Health Checks: <pre><code>    passive:\n      type: http\n      healthy:\n        successes: 1\n        http_statuses: [200, 201, 202, 204, 301, 302, 303, 304, 307, 308]\n      unhealthy:\n        http_failures: 5\n        http_statuses: [500, 502, 503, 504]\n        tcp_failures: 0\n        timeouts: 0\n</code></pre></p> <p>Targets mit Gewichtung: <pre><code>  targets:\n  - target: api-1.internal:8080\n    weight: 200  # Kong nutzt 0-1000 Skala\n  - target: api-2.internal:8080\n    weight: 100\n</code></pre></p> <p>Load Balancing Algorithmen: - <code>round-robin</code>: Gleichm\u00e4\u00dfige Verteilung - <code>least-connections</code>: Server mit wenigsten Verbindungen - <code>consistent-hashing</code>: IP-Hash mit <code>hash_on: consumer</code>, <code>hash_fallback: ip</code></p>"},{"location":"guides/HEALTH_CHECKS/#traefik","title":"Traefik","text":"<p>Traefik nutzt <code>loadBalancer</code> Konfiguration auf Service-Level.</p> <p>Multiple Servers: <pre><code>http:\n  services:\n    api_service_service:\n      loadBalancer:\n        servers:\n        - url: 'http://api-1.internal:8080'\n          weight: 2\n        - url: 'http://api-2.internal:8080'\n          weight: 1\n</code></pre></p> <p>Health Checks: <pre><code>        healthCheck:\n          path: /health\n          interval: 10s\n          timeout: 5s\n</code></pre></p> <p>Sticky Sessions: <pre><code>        sticky:\n          cookie:\n            name: mySessionCookie\n            httpOnly: true\n</code></pre></p> <p>Limitierung: Traefik hat keine nativen Passive Health Checks. Nutze Kubernetes Readiness Probes oder externe Monitoring-Tools.</p>"},{"location":"guides/HEALTH_CHECKS/#envoy","title":"Envoy","text":"<p>Envoy nutzt <code>health_checks</code> und <code>outlier_detection</code> auf Cluster-Level.</p> <p>Active Health Checks: <pre><code>clusters:\n- name: api_service_cluster\n  health_checks:\n  - timeout: 5s\n    interval: 10s\n    unhealthy_threshold: 3\n    healthy_threshold: 2\n    http_health_check:\n      path: /health\n      expected_statuses:\n      - start: 200\n        end: 201\n      - start: 204\n        end: 205\n</code></pre></p> <p>Passive Health Checks (Outlier Detection): <pre><code>  outlier_detection:\n    consecutive_5xx: 5\n    interval: 10s\n    base_ejection_time: 30s\n    max_ejection_percent: 50\n    enforcing_consecutive_5xx: 100\n    success_rate_minimum_hosts: 5\n    success_rate_request_volume: 10\n    enforcing_success_rate: 100\n</code></pre></p> <p>Load Balancing Policies: <pre><code>  lb_policy: ROUND_ROBIN  # oder: LEAST_REQUEST, RING_HASH, RANDOM\n  ring_hash_lb_config:    # F\u00fcr RING_HASH (IP hash)\n    minimum_ring_size: 1024\n</code></pre></p> <p>Weighted Load Balancing: <pre><code>  load_assignment:\n    endpoints:\n    - lb_endpoints:\n      - endpoint:\n          address:\n            socket_address:\n              address: api-1.internal\n              port_value: 8080\n        load_balancing_weight:\n          value: 2\n</code></pre></p>"},{"location":"guides/HEALTH_CHECKS/#load-balancing-algorithmen","title":"Load Balancing Algorithmen","text":""},{"location":"guides/HEALTH_CHECKS/#round-robin","title":"Round Robin","text":"<p>Beschreibung: Gleichm\u00e4\u00dfige, zirkul\u00e4re Verteilung der Requests.</p> <p>Verhalten: <pre><code>Request 1 \u2192 Server 1\nRequest 2 \u2192 Server 2\nRequest 3 \u2192 Server 3\nRequest 4 \u2192 Server 1 (zyklisch)\nRequest 5 \u2192 Server 2\n...\n</code></pre></p> <p>Konfiguration: <pre><code>load_balancer:\n  algorithm: round_robin\n</code></pre></p> <p>Vorteile: - \u2705 Einfach und vorhersagbar - \u2705 Gleichm\u00e4\u00dfige Lastverteilung (bei gleich starken Servern) - \u2705 Geringe Overhead</p> <p>Nachteile: - \u274c Ignoriert aktuelle Server-Last - \u274c Ignoriert unterschiedliche Server-Kapazit\u00e4ten</p> <p>Use Case: Homogene Backend-Server mit \u00e4hnlicher Kapazit\u00e4t</p>"},{"location":"guides/HEALTH_CHECKS/#least-connections","title":"Least Connections","text":"<p>Beschreibung: Sendet Requests an Server mit den wenigsten aktiven Verbindungen.</p> <p>Verhalten: <pre><code>Server 1: 10 aktive Verbindungen\nServer 2: 5 aktive Verbindungen  \u2190 N\u00e4chster Request geht hier hin\nServer 3: 8 aktive Verbindungen\n</code></pre></p> <p>Konfiguration: <pre><code>load_balancer:\n  algorithm: least_conn\n</code></pre></p> <p>Vorteile: - \u2705 Ber\u00fccksichtigt aktuelle Last - \u2705 Gut f\u00fcr long-running Requests - \u2705 Dynamische Anpassung</p> <p>Nachteile: - \u274c H\u00f6herer Overhead (Verbindungen tracken) - \u274c Funktioniert nicht bei sehr kurzen Requests (REST APIs)</p> <p>Use Case: WebSocket, Streaming, lange HTTP-Verbindungen</p>"},{"location":"guides/HEALTH_CHECKS/#ip-hash","title":"IP Hash","text":"<p>Beschreibung: W\u00e4hlt Server basierend auf Client-IP (Konsistent Hashing).</p> <p>Verhalten: <pre><code>Client 192.168.1.1 \u2192 Server 1 (immer!)\nClient 192.168.1.2 \u2192 Server 3 (immer!)\nClient 192.168.1.3 \u2192 Server 2 (immer!)\n</code></pre></p> <p>Konfiguration: <pre><code>load_balancer:\n  algorithm: ip_hash\n</code></pre></p> <p>Vorteile: - \u2705 Session Persistence ohne Cookies - \u2705 Vorhersagbares Routing - \u2705 Gut f\u00fcr Caching (Cache-Locality)</p> <p>Nachteile: - \u274c Ungleichm\u00e4\u00dfige Verteilung m\u00f6glich - \u274c Problem bei Server-Ausfall (Session-Verlust)</p> <p>Use Case: Stateful Applications, Session Persistence, Caching</p>"},{"location":"guides/HEALTH_CHECKS/#weighted","title":"Weighted","text":"<p>Beschreibung: Verteilung basierend auf Server-Gewichtung.</p> <p>Verhalten: <pre><code>targets:\n  - host: server-1   # weight: 3 \u2192 60% Traffic\n    weight: 3\n  - host: server-2   # weight: 2 \u2192 40% Traffic\n    weight: 2\n</code></pre></p> <p>Konfiguration: <pre><code>load_balancer:\n  algorithm: weighted\n</code></pre></p> <p>Vorteile: - \u2705 Ber\u00fccksichtigt unterschiedliche Server-Kapazit\u00e4ten - \u2705 Flexible Traffic-Steuerung - \u2705 Canary Deployments m\u00f6glich</p> <p>Nachteile: - \u274c Manuelle Konfiguration n\u00f6tig - \u274c Keine automatische Anpassung</p> <p>Use Case: Heterogene Server (unterschiedliche Hardware), Canary Deployments</p>"},{"location":"guides/HEALTH_CHECKS/#haufige-anwendungsfalle","title":"H\u00e4ufige Anwendungsf\u00e4lle","text":""},{"location":"guides/HEALTH_CHECKS/#use-case-1-hochverfugbare-rest-api","title":"Use Case 1: Hochverf\u00fcgbare REST API","text":"<p>Anforderung: REST API muss 24/7 verf\u00fcgbar sein, automatisches Failover bei Ausf\u00e4llen.</p> <p>L\u00f6sung: Round-Robin mit Active Health Checks</p> <pre><code>services:\n  - name: rest_api\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n        - host: api-2.internal\n          port: 8080\n        - host: api-3.internal\n          port: 8080\n      health_check:\n        active:\n          enabled: true\n          http_path: /health\n          interval: \"5s\"\n          healthy_threshold: 2\n          unhealthy_threshold: 2\n      load_balancer:\n        algorithm: round_robin\n</code></pre> <p>Warum funktioniert das? - Active Health Checks entdecken defekte Server in 10-15 Sekunden (2 * 5s) - Round-Robin verteilt Last gleichm\u00e4\u00dfig - Bei Server-Ausfall: Automatisches Routing zu verbleibenden Servern</p>"},{"location":"guides/HEALTH_CHECKS/#use-case-2-websocket-service-mit-session-persistence","title":"Use Case 2: WebSocket-Service mit Session Persistence","text":"<p>Anforderung: WebSocket-Verbindungen m\u00fcssen zum gleichen Server gehen (Stateful).</p> <p>L\u00f6sung: IP Hash oder Sticky Sessions</p> <pre><code>services:\n  - name: websocket_service\n    upstream:\n      targets:\n        - host: ws-1.internal\n          port: 8080\n        - host: ws-2.internal\n          port: 8080\n      load_balancer:\n        algorithm: ip_hash  # Client-IP basiertes Routing\n</code></pre> <p>Alternative mit Sticky Sessions (Traefik): <pre><code>      load_balancer:\n        algorithm: round_robin\n        sticky_sessions: true\n        cookie_name: wsSession\n</code></pre></p>"},{"location":"guides/HEALTH_CHECKS/#use-case-3-canary-deployment","title":"Use Case 3: Canary Deployment","text":"<p>Anforderung: Neues Release an 10% der User ausrollen, 90% auf alter Version.</p> <p>L\u00f6sung: Weighted Load Balancing</p> <pre><code>services:\n  - name: api_service\n    upstream:\n      targets:\n        - host: api-v1.internal  # Alte Version (90%)\n          port: 8080\n          weight: 9\n        - host: api-v2.internal  # Neue Version (10%)\n          port: 8080\n          weight: 1\n      load_balancer:\n        algorithm: weighted\n</code></pre> <p>Phased Rollout: <pre><code>Phase 1: weight 9:1   (90%:10%)\nPhase 2: weight 7:3   (70%:30%)\nPhase 3: weight 5:5   (50%:50%)\nPhase 4: weight 0:10  (0%:100%)\n</code></pre></p>"},{"location":"guides/HEALTH_CHECKS/#use-case-4-heterogene-backend-server","title":"Use Case 4: Heterogene Backend-Server","text":"<p>Anforderung: 2x gro\u00dfe Server (8 CPU), 1x kleiner Server (2 CPU).</p> <p>L\u00f6sung: Weighted Load Balancing nach Kapazit\u00e4t</p> <pre><code>services:\n  - name: api_service\n    upstream:\n      targets:\n        - host: large-1.internal\n          port: 8080\n          weight: 4    # 4x Kapazit\u00e4t\n        - host: large-2.internal\n          port: 8080\n          weight: 4\n        - host: small-1.internal\n          port: 8080\n          weight: 1    # 1x Kapazit\u00e4t\n      load_balancer:\n        algorithm: weighted\n</code></pre> <p>Traffic-Verteilung: 44% / 44% / 12%</p>"},{"location":"guides/HEALTH_CHECKS/#use-case-5-graceful-degradation","title":"Use Case 5: Graceful Degradation","text":"<p>Anforderung: Bei Teil-Ausfall weiter funktionieren mit reduzierter Kapazit\u00e4t.</p> <p>L\u00f6sung: Combined Active + Passive Health Checks</p> <pre><code>services:\n  - name: payment_service\n    upstream:\n      targets:\n        - host: payment-1.internal\n          port: 8080\n        - host: payment-2.internal\n          port: 8080\n        - host: payment-3.internal\n          port: 8080\n      health_check:\n        active:\n          enabled: true\n          http_path: /actuator/health\n          interval: \"10s\"\n          timeout: \"3s\"\n          healthy_threshold: 2\n          unhealthy_threshold: 3\n        passive:\n          enabled: true\n          max_failures: 5\n          unhealthy_status_codes: [500, 502, 503, 504]\n      load_balancer:\n        algorithm: round_robin\n</code></pre> <p>Verhalten bei Ausf\u00e4llen: <pre><code>3 Server healthy:   100% Kapazit\u00e4t (33% / 33% / 33%)\n1 Server down:      66% Kapazit\u00e4t (50% / 50%)\n2 Server down:      33% Kapazit\u00e4t (100% auf letztem Server)\n</code></pre></p>"},{"location":"guides/HEALTH_CHECKS/#best-practices","title":"Best Practices","text":""},{"location":"guides/HEALTH_CHECKS/#1-kombiniere-active-passive-health-checks","title":"1. Kombiniere Active + Passive Health Checks","text":"<p>Problem: Passive Health Checks k\u00f6nnen Services nicht reaktivieren.</p> <p>L\u00f6sung: Nutze beide zusammen: <pre><code>health_check:\n  active:           # F\u00fcr automatische Reaktivierung\n    interval: \"15s\"\n  passive:          # F\u00fcr schnelle Fehlerkennung\n    max_failures: 3\n</code></pre></p> <p>Vorteil: Schnelle Fehlerkennung (Passive) + Automatische Erholung (Active)</p>"},{"location":"guides/HEALTH_CHECKS/#2-tune-health-check-intervalle","title":"2. Tune Health Check Intervalle","text":"<p>Zu kurze Intervalle (z.B. 1s): - \u274c Hohe Last auf Backend - \u274c False Positives bei kurzen Spikes - \u2705 Sehr schnelle Fehlerkennung</p> <p>Zu lange Intervalle (z.B. 60s): - \u2705 Geringe Last - \u274c Langsame Fehlerkennung - \u274c Lange Ausfallzeiten</p> <p>Empfehlung: 10-30 Sekunden f\u00fcr Production</p> <pre><code>active:\n  interval: \"15s\"       # Moderate Frequenz\n  timeout: \"5s\"         # Timeout &lt; Interval\n  healthy_threshold: 2  # 30s bis recovery (2 * 15s)\n  unhealthy_threshold: 2  # 30s bis marking unhealthy\n</code></pre>"},{"location":"guides/HEALTH_CHECKS/#3-wahle-den-richtigen-load-balancing-algorithmus","title":"3. W\u00e4hle den richtigen Load Balancing Algorithmus","text":"Anforderung Empfohlener Algorithmus Homogene REST APIs <code>round_robin</code> WebSockets / Stateful <code>ip_hash</code> oder Sticky Sessions Heterogene Server <code>weighted</code> Lange Verbindungen <code>least_conn</code> Canary Deployments <code>weighted</code>"},{"location":"guides/HEALTH_CHECKS/#4-implementiere-graceful-shutdown","title":"4. Implementiere Graceful Shutdown","text":"<p>Problem: Bei Deployment werden aktive Requests abgebrochen.</p> <p>L\u00f6sung: Deregistriere Server vor Shutdown: 1. Health Check Endpoint gibt 503 zur\u00fcck 2. Gateway markiert Server als unhealthy 3. Keine neuen Requests mehr 4. Warte bis aktive Requests fertig sind 5. Shutdown</p> <p>Health Endpoint Beispiel (Spring Boot): <pre><code>@GetMapping(\"/health\")\npublic ResponseEntity&lt;String&gt; health() {\n    if (shutdownRequested) {\n        return ResponseEntity.status(503).body(\"Shutting down\");\n    }\n    return ResponseEntity.ok(\"Healthy\");\n}\n</code></pre></p>"},{"location":"guides/HEALTH_CHECKS/#5-monitor-health-check-failures","title":"5. Monitor Health Check Failures","text":"<p>Wichtig: Logge und alertiere auf Health Check Failures!</p> <p>Metriken zum \u00dcberwachen: - Health Check Success Rate - Anzahl unhealthy Backends - Time to Recovery - Failover Events</p> <p>Beispiel Alert: <pre><code>ALERT: api_service hat nur noch 1 von 3 Backends healthy!\nAction: Untersuche api-1 und api-2 Logs\n</code></pre></p>"},{"location":"guides/HEALTH_CHECKS/#6-test-health-check-endpoints","title":"6. Test Health Check Endpoints","text":"<p>Bad Health Check Endpoint: <pre><code>@app.route('/health')\ndef health():\n    return \"OK\", 200  # Immer OK, auch wenn DB down!\n</code></pre></p> <p>Good Health Check Endpoint: <pre><code>@app.route('/health')\ndef health():\n    try:\n        # Pr\u00fcfe kritische Dependencies\n        db.execute(\"SELECT 1\")\n        redis.ping()\n        return \"OK\", 200\n    except Exception as e:\n        logger.error(f\"Health check failed: {e}\")\n        return \"Unhealthy\", 503\n</code></pre></p>"},{"location":"guides/HEALTH_CHECKS/#7-plan-fur-zero-downtime-deployments","title":"7. Plan f\u00fcr Zero-Downtime Deployments","text":"<p>Strategie: Rolling Update mit Health Checks</p> <pre><code>1. Deploy neue Version auf server-1\n2. Health Check wird healthy\n3. Gateway sendet Traffic zu server-1\n4. Deploy auf server-2\n5. Repeat f\u00fcr alle Server\n</code></pre> <p>Wichtig: Konfiguriere <code>healthy_threshold: 2</code> damit Server nicht zu fr\u00fch Traffic bekommt!</p>"},{"location":"guides/HEALTH_CHECKS/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/HEALTH_CHECKS/#problem-backend-wird-nicht-als-healthy-markiert","title":"Problem: Backend wird nicht als healthy markiert","text":"<p>Symptom: Health Check schl\u00e4gt dauerhaft fehl, obwohl Service l\u00e4uft.</p> <p>M\u00f6gliche Ursachen: 1. Health Check Endpoint antwortet nicht mit 200 2. Timeout zu kurz 3. Health Check Pfad falsch konfiguriert 4. Firewall blockiert Health Check Traffic</p> <p>Debug-Schritte: <pre><code># 1. Manuell Health Endpoint testen\ncurl -v http://api-1.internal:8080/health\n\n# 2. Pr\u00fcfe Gateway Logs\n# APISIX:\ncurl http://localhost:9180/v1/healthcheck\n\n# Kong:\ncurl http://localhost:8001/upstreams/api_service_upstream/health\n\n# 3. Pr\u00fcfe Health Check Config\n# Ist http_path korrekt?\n# Ist timeout &gt; als Response Time?\n# Sind healthy_status_codes korrekt?\n</code></pre></p> <p>L\u00f6sung: <pre><code>health_check:\n  active:\n    http_path: /actuator/health  # \u2190 Pr\u00fcfe Pfad!\n    timeout: \"10s\"                # \u2190 Erh\u00f6he Timeout\n    healthy_status_codes:         # \u2190 Pr\u00fcfe erlaubte Codes\n      - 200\n      - 204\n</code></pre></p>"},{"location":"guides/HEALTH_CHECKS/#problem-traffic-wird-nicht-gleichmaig-verteilt","title":"Problem: Traffic wird nicht gleichm\u00e4\u00dfig verteilt","text":"<p>Symptom: Ein Server bekommt deutlich mehr Traffic als andere.</p> <p>M\u00f6gliche Ursachen: 1. Falsche Gewichtung 2. Falsch konfigurierter Algorithmus 3. IP Hash mit wenigen Clients 4. Sticky Sessions aktiv</p> <p>Debug-Schritte: <pre><code># 1. Pr\u00fcfe Backend-Logs\ntail -f /var/log/api-1.log | grep -c \"Request\"\ntail -f /var/log/api-2.log | grep -c \"Request\"\n\n# 2. Pr\u00fcfe Load Balancer Config\n# Sind weights korrekt?\n# Ist algorithm korrekt?\n\n# 3. Test mit curl\nfor i in {1..100}; do\n  curl -s http://gateway/api | grep \"Server:\"\ndone | sort | uniq -c\n</code></pre></p> <p>L\u00f6sung: <pre><code># Korrigiere Weights\ntargets:\n  - host: api-1\n    weight: 1  # \u2190 Gleiche Gewichtung\n  - host: api-2\n    weight: 1\n\n# Oder nutze round_robin statt weighted\nload_balancer:\n  algorithm: round_robin\n</code></pre></p>"},{"location":"guides/HEALTH_CHECKS/#problem-server-wird-nach-recovery-nicht-reaktiviert","title":"Problem: Server wird nach Recovery nicht reaktiviert","text":"<p>Symptom: Server ist wieder online, aber bekommt keinen Traffic.</p> <p>Ursache: Nur Passive Health Checks konfiguriert (k\u00f6nnen nicht reaktivieren!).</p> <p>L\u00f6sung: F\u00fcge Active Health Checks hinzu: <pre><code>health_check:\n  active:\n    enabled: true\n    interval: \"10s\"\n  passive:\n    enabled: true\n    max_failures: 3\n</code></pre></p>"},{"location":"guides/HEALTH_CHECKS/#problem-health-checks-belasten-backend-zu-sehr","title":"Problem: Health Checks belasten Backend zu sehr","text":"<p>Symptom: Health Checks verursachen signifikante Last.</p> <p>Ursachen: - Interval zu kurz (z.B. 1s) - Health Endpoint ist zu teuer (DB-Queries, etc.)</p> <p>L\u00f6sung 1: Erh\u00f6he Interval <pre><code>health_check:\n  active:\n    interval: \"30s\"  # Statt 5s\n</code></pre></p> <p>L\u00f6sung 2: Optimiere Health Endpoint <pre><code># Bad: Teurer Health Check\n@app.route('/health')\ndef health():\n    users = db.query(\"SELECT * FROM users\")  # \u2190 Teuer!\n    return \"OK\", 200\n\n# Good: Leichtgewichtiger Health Check\n@app.route('/health')\ndef health():\n    db.execute(\"SELECT 1\")  # \u2190 Nur Connection-Test\n    return \"OK\", 200\n</code></pre></p>"},{"location":"guides/HEALTH_CHECKS/#problem-requests-schlagen-fehl-wahrend-rolling-update","title":"Problem: Requests schlagen fehl w\u00e4hrend Rolling Update","text":"<p>Symptom: 503 Errors w\u00e4hrend Deployment.</p> <p>Ursache: Server wird zu fr\u00fch Traffic bekommen (bevor vollst\u00e4ndig gestartet).</p> <p>L\u00f6sung: Erh\u00f6he <code>healthy_threshold</code>: <pre><code>health_check:\n  active:\n    healthy_threshold: 3  # Statt 1\n    interval: \"5s\"\n</code></pre></p> <p>Bedeutung: Server muss 3 aufeinanderfolgende Health Checks bestehen (15s) bevor Traffic kommt.</p>"},{"location":"guides/HEALTH_CHECKS/#anhang","title":"Anhang","text":""},{"location":"guides/HEALTH_CHECKS/#beispiel-production-ready-konfiguration","title":"Beispiel: Production-Ready Konfiguration","text":"<p>Vollst\u00e4ndige Konfiguration f\u00fcr Production-Einsatz mit allen Features:</p> <pre><code>version: \"1.0\"\nprovider: apisix\n\nglobal_config:\n  host: \"0.0.0.0\"\n  port: 9080\n  admin_port: 9180\n\nservices:\n  - name: user_service\n    type: rest\n    protocol: http\n    upstream:\n      targets:\n        - host: user-1.prod.internal\n          port: 8080\n          weight: 2\n        - host: user-2.prod.internal\n          port: 8080\n          weight: 2\n        - host: user-3.prod.internal\n          port: 8080\n          weight: 1\n      health_check:\n        active:\n          enabled: true\n          http_path: /actuator/health\n          interval: \"15s\"\n          timeout: \"5s\"\n          healthy_threshold: 3\n          unhealthy_threshold: 2\n          healthy_status_codes: [200, 204]\n        passive:\n          enabled: true\n          max_failures: 5\n          unhealthy_status_codes: [500, 502, 503, 504]\n      load_balancer:\n        algorithm: weighted\n    routes:\n      - path_prefix: /api/users\n        methods: [GET, POST, PUT, DELETE]\n</code></pre>"},{"location":"guides/HEALTH_CHECKS/#weiterfuhrende-links","title":"Weiterf\u00fchrende Links","text":"<ul> <li>APISIX Health Check Docs: https://apisix.apache.org/docs/apisix/tutorials/health-check/</li> <li>Kong Health Checks Docs: https://docs.konghq.com/gateway/latest/how-kong-works/health-checks/</li> <li>Traefik Health Check Docs: https://doc.traefik.io/traefik/routing/services/</li> <li>Envoy Health Checking Docs: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/health_checking</li> <li>Envoy Outlier Detection Docs: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/outlier</li> </ul> <p>Document Version: 1.0 Last Updated: 2025-10-18 Author: GAL Development Team</p>"},{"location":"guides/KONG/","title":"Kong Gateway Provider Anleitung","text":"<p>Umfassende Anleitung f\u00fcr den Kong Gateway Provider in GAL (Gateway Abstraction Layer)</p>"},{"location":"guides/KONG/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ol> <li>\u00dcbersicht</li> <li>Schnellstart</li> <li>Installation und Setup</li> <li>Konfigurationsoptionen</li> <li>Feature-Implementierungen</li> <li>Provider-Vergleich</li> <li>Kong-spezifische Details</li> <li>Best Practices</li> <li>Troubleshooting</li> </ol>"},{"location":"guides/KONG/#ubersicht","title":"\u00dcbersicht","text":"<p>Kong Gateway ist ein Open-Source API Gateway und Service Mesh, gebaut auf Nginx und OpenResty (Lua). Kong ist bekannt f\u00fcr seine Plugin-Architektur und einfache Verwaltung.</p>"},{"location":"guides/KONG/#warum-kong","title":"Warum Kong?","text":"<ul> <li>\u2705 Plugin-\u00d6kosystem - 300+ Plugins (Community + Enterprise)</li> <li>\u2705 DB-less Mode - Deklarative Konfiguration (YAML)</li> <li>\u2705 Developer-Friendly - Einfache Admin API</li> <li>\u2705 Performance - Basiert auf Nginx + OpenResty</li> <li>\u2705 Kong Manager - Web UI f\u00fcr Verwaltung (Enterprise)</li> <li>\u2705 Cloud-Native - Kubernetes-ready, Helm Charts</li> <li>\u2705 Service Mesh - Kong Mesh (Kuma-basiert)</li> </ul>"},{"location":"guides/KONG/#kong-feature-matrix","title":"Kong Feature-Matrix","text":"Feature Kong Support GAL Implementation Traffic Management Rate Limiting \u2705 Native Plugin \u2705 Vollst\u00e4ndig Circuit Breaker \u26a0\ufe0f Via Plugin \u26a0\ufe0f Plugin Config Health Checks \u2705 Passive + Active \u2705 Vollst\u00e4ndig Load Balancing \u2705 Native \u2705 Vollst\u00e4ndig Timeout &amp; Retry \u2705 Native \u2705 Vollst\u00e4ndig Security Basic Auth \u2705 Native Plugin \u2705 Vollst\u00e4ndig JWT Validation \u2705 Native Plugin \u2705 Vollst\u00e4ndig API Key Auth \u2705 Native Plugin \u2705 Vollst\u00e4ndig CORS \u2705 Native Plugin \u2705 Vollst\u00e4ndig Advanced WebSocket \u2705 Native \u2705 Vollst\u00e4ndig gRPC \u2705 Native \u2705 Vollst\u00e4ndig Body Transformation \u2705 Plugins \u2705 Vollst\u00e4ndig Request/Response Headers \u2705 Plugins \u2705 Vollst\u00e4ndig"},{"location":"guides/KONG/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/KONG/#beispiel-1-einfacher-api-gateway","title":"Beispiel 1: Einfacher API Gateway","text":"<pre><code>version: \"1.0\"\nprovider: kong\n\nglobal:\n  host: 0.0.0.0\n  port: 8000\n  admin_port: 8001\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      host: api-backend\n      port: 8080\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Generiert (Kong Declarative Config): <pre><code>_format_version: '3.0'\nservices:\n- name: api_service\n  protocol: http\n  host: api-backend\n  port: 8080\n  routes:\n  - name: api_service_route\n    paths:\n    - /api\n</code></pre></p>"},{"location":"guides/KONG/#beispiel-2-mit-authentication-rate-limiting","title":"Beispiel 2: Mit Authentication + Rate Limiting","text":"<pre><code>services:\n  - name: api_service\n    upstream:\n      host: api-backend\n      port: 8080\n    routes:\n      - path_prefix: /api\n        authentication:\n          enabled: true\n          type: jwt\n          jwt:\n            issuer: \"https://auth.example.com\"\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n</code></pre> <p>Generiert: <pre><code>services:\n- name: api_service\n  plugins:\n  - name: jwt\n    config:\n      claims_to_verify: [iss]\n      key_claim_name: iss\n      issuer: https://auth.example.com\n  - name: rate-limiting\n    config:\n      second: 100\n      policy: local\n</code></pre></p>"},{"location":"guides/KONG/#installation-und-setup","title":"Installation und Setup","text":""},{"location":"guides/KONG/#1-kong-installation","title":"1. Kong Installation","text":""},{"location":"guides/KONG/#option-a-docker-empfohlen","title":"Option A: Docker (Empfohlen)","text":"<pre><code># Kong in DB-less Mode (Declarative Config)\ndocker run -d \\\n  --name kong \\\n  -e \"KONG_DATABASE=off\" \\\n  -e \"KONG_DECLARATIVE_CONFIG=/kong.yaml\" \\\n  -e \"KONG_PROXY_ACCESS_LOG=/dev/stdout\" \\\n  -e \"KONG_ADMIN_ACCESS_LOG=/dev/stdout\" \\\n  -e \"KONG_PROXY_ERROR_LOG=/dev/stderr\" \\\n  -e \"KONG_ADMIN_ERROR_LOG=/dev/stderr\" \\\n  -p 8000:8000 \\\n  -p 8443:8443 \\\n  -p 8001:8001 \\\n  -p 8444:8444 \\\n  -v $(pwd)/kong.yaml:/kong.yaml \\\n  kong:3.4\n\n# Admin API pr\u00fcfen\ncurl http://localhost:8001/\n</code></pre>"},{"location":"guides/KONG/#option-b-kubernetes-helm","title":"Option B: Kubernetes (Helm)","text":"<pre><code># Kong Helm Repo hinzuf\u00fcgen\nhelm repo add kong https://charts.konghq.com\nhelm repo update\n\n# Kong installieren (DB-less)\nhelm install kong kong/kong \\\n  --set ingressController.enabled=true \\\n  --set env.database=off \\\n  --set env.declarative_config=/kong.yaml\n</code></pre>"},{"location":"guides/KONG/#2-gal-config-generieren","title":"2. GAL Config generieren","text":"<pre><code># Config generieren\ngal generate --config gateway.yaml --provider kong &gt; kong.yaml\n\n# Kong mit Config starten\ndocker run -d --name kong \\\n  -e \"KONG_DATABASE=off\" \\\n  -e \"KONG_DECLARATIVE_CONFIG=/kong.yaml\" \\\n  -p 8000:8000 -p 8001:8001 \\\n  -v $(pwd)/kong.yaml:/kong.yaml \\\n  kong:3.4\n</code></pre>"},{"location":"guides/KONG/#3-verify-setup","title":"3. Verify Setup","text":"<pre><code># Services pr\u00fcfen\ncurl http://localhost:8001/services\n\n# Routes pr\u00fcfen\ncurl http://localhost:8001/routes\n\n# Test Request\ncurl http://localhost:8000/api\n</code></pre>"},{"location":"guides/KONG/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/KONG/#global-configuration","title":"Global Configuration","text":"<pre><code>global:\n  host: 0.0.0.0      # Proxy Listen Address\n  port: 8000         # HTTP Port\n  admin_port: 8001   # Admin API Port\n</code></pre>"},{"location":"guides/KONG/#service-configuration","title":"Service Configuration","text":"<pre><code>services:\n  - name: api_service\n    protocol: http          # http, https, grpc, grpcs\n    upstream:\n      host: backend.svc\n      port: 8080\n      # Timeouts (in Milliseconds!)\n      connect_timeout: 60000\n      read_timeout: 60000\n      write_timeout: 60000\n</code></pre> <p>Kong Besonderheit: Timeouts in Millisekunden (nicht Sekunden)!</p>"},{"location":"guides/KONG/#feature-implementierungen","title":"Feature-Implementierungen","text":""},{"location":"guides/KONG/#1-load-balancing","title":"1. Load Balancing","text":"<pre><code>upstream:\n  targets:\n    - host: backend-1\n      port: 8080\n      weight: 100\n    - host: backend-2\n      port: 8080\n      weight: 200\n  load_balancer:\n    algorithm: round_robin  # round_robin, least_conn, ip_hash\n</code></pre> <p>Generiert: <pre><code>upstreams:\n- name: api_service_upstream\n  algorithm: round-robin\n  targets:\n  - target: backend-1:8080\n    weight: 100\n  - target: backend-2:8080\n    weight: 200\n</code></pre></p>"},{"location":"guides/KONG/#2-health-checks","title":"2. Health Checks","text":"<pre><code>health_check:\n  active:\n    enabled: true\n    interval: \"10s\"\n    timeout: \"5s\"\n    http_path: \"/health\"\n    healthy_threshold: 2\n    unhealthy_threshold: 3\n</code></pre> <p>Generiert: <pre><code>upstreams:\n- name: api_service_upstream\n  healthchecks:\n    active:\n      type: http\n      http_path: /health\n      timeout: 5\n      interval: 10\n      healthy:\n        successes: 2\n      unhealthy:\n        http_failures: 3\n</code></pre></p>"},{"location":"guides/KONG/#3-rate-limiting","title":"3. Rate Limiting","text":"<pre><code>rate_limit:\n  enabled: true\n  requests_per_second: 100\n  burst: 200\n</code></pre> <p>Generiert: <pre><code>plugins:\n- name: rate-limiting\n  config:\n    second: 100\n    policy: local\n    hide_client_headers: false\n</code></pre></p>"},{"location":"guides/KONG/#4-authentication","title":"4. Authentication","text":"<p>JWT: <pre><code>authentication:\n  enabled: true\n  type: jwt\n  jwt:\n    issuer: \"https://auth.example.com\"\n    audiences: [\"api\"]\n</code></pre></p> <p>Generiert: <pre><code>plugins:\n- name: jwt\n  config:\n    claims_to_verify: [iss, aud]\n    key_claim_name: iss\n</code></pre></p> <p>Basic Auth: <pre><code>authentication:\n  enabled: true\n  type: basic\n  basic_auth:\n    users:\n      admin: password123\n</code></pre></p> <p>Generiert: <pre><code>plugins:\n- name: basic-auth\nconsumers:\n- username: admin\n  basicauth_credentials:\n  - username: admin\n    password: password123\n</code></pre></p> <p>API Key: <pre><code>authentication:\n  enabled: true\n  type: api_key\n  api_key:\n    key_name: X-API-Key\n    in_location: header\n</code></pre></p> <p>Generiert: <pre><code>plugins:\n- name: key-auth\n  config:\n    key_names: [X-API-Key]\n</code></pre></p>"},{"location":"guides/KONG/#5-cors","title":"5. CORS","text":"<pre><code>cors:\n  enabled: true\n  allowed_origins: [\"https://app.example.com\"]\n  allowed_methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n  allowed_headers: [\"Content-Type\", \"Authorization\"]\n  allow_credentials: true\n  max_age: 86400\n</code></pre> <p>Generiert: <pre><code>plugins:\n- name: cors\n  config:\n    origins: [\"https://app.example.com\"]\n    methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n    headers: [\"Content-Type\", \"Authorization\"]\n    credentials: true\n    max_age: 86400\n</code></pre></p>"},{"location":"guides/KONG/#6-timeout-retry","title":"6. Timeout &amp; Retry","text":"<pre><code>timeout:\n  connect: \"10s\"\n  send: \"60s\"\n  read: \"120s\"\nretry:\n  enabled: true\n  attempts: 3\n</code></pre> <p>Generiert: <pre><code>services:\n- name: api_service\n  connect_timeout: 10000    # Milliseconds!\n  write_timeout: 60000\n  read_timeout: 120000\n  retries: 3\n</code></pre></p> <p>Wichtig: Kong verwendet Millisekunden f\u00fcr Timeouts!</p>"},{"location":"guides/KONG/#7-requestresponse-headers","title":"7. Request/Response Headers","text":"<pre><code>headers:\n  request_add:\n    X-Request-ID: \"{{uuid}}\"\n  request_remove:\n    - X-Internal-Secret\n  response_add:\n    X-Gateway: \"Kong\"\n  response_remove:\n    - X-Powered-By\n</code></pre> <p>Generiert: <pre><code>plugins:\n- name: request-transformer\n  config:\n    add:\n      headers: [\"X-Request-ID:{{uuid}}\"]\n    remove:\n      headers: [\"X-Internal-Secret\"]\n- name: response-transformer\n  config:\n    add:\n      headers: [\"X-Gateway:Kong\"]\n    remove:\n      headers: [\"X-Powered-By\"]\n</code></pre></p>"},{"location":"guides/KONG/#8-body-transformation","title":"8. Body Transformation","text":"<pre><code>body_transformation:\n  enabled: true\n  request:\n    add_fields:\n      trace_id: \"{{uuid}}\"\n    remove_fields:\n      - secret_key\n  response:\n    filter_fields:\n      - password\n</code></pre> <p>Generiert: <pre><code>plugins:\n- name: request-transformer\n  config:\n    add:\n      json: [\"trace_id:{{uuid}}\"]\n    remove:\n      json: [\"secret_key\"]\n- name: response-transformer\n  config:\n    remove:\n      json: [\"password\"]\n</code></pre></p>"},{"location":"guides/KONG/#provider-vergleich","title":"Provider-Vergleich","text":""},{"location":"guides/KONG/#kong-vs-andere-provider","title":"Kong vs. Andere Provider","text":"Feature Kong Envoy APISIX Traefik Nginx HAProxy Ease of Use \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 Plugin Ecosystem \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50 \u2b50\u2b50 Admin API \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50 \u2b50\u2b50 Documentation \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 Enterprise Support \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 <p>Kong St\u00e4rken: - \u2705 Einfachste Konfiguration aller Provider - \u2705 300+ Plugins (Community + Enterprise) - \u2705 Admin API f\u00fcr dynamische Verwaltung - \u2705 Kong Manager (Web UI - Enterprise) - \u2705 DB-less Mode (Declarative Config) - \u2705 Beste Dokumentation</p> <p>Kong Schw\u00e4chen: - \u274c Enterprise Features kostenpflichtig - \u26a0\ufe0f Performance etwas niedriger als Nginx/HAProxy - \u26a0\ufe0f Retry keine konditionalen Bedingungen</p>"},{"location":"guides/KONG/#kong-feature-coverage","title":"Kong Feature Coverage","text":"<p>Detaillierte Analyse basierend auf der offiziellen Kong Dokumentation.</p>"},{"location":"guides/KONG/#core-entities-kong-admin-api","title":"Core Entities (Kong Admin API)","text":"Entity Import Export Status Bemerkung <code>services</code> \u2705 \u2705 Voll Service Definition mit Name/URL <code>routes</code> \u2705 \u2705 Voll Path/Host Routing <code>upstreams</code> \u2705 \u2705 Voll Load Balancer Configuration <code>targets</code> \u2705 \u2705 Voll Backend Endpoints <code>plugins</code> \u2705 \u2705 Voll Plugin Configuration <code>consumers</code> \u274c \u274c Nicht Consumer Management <code>certificates</code> \u274c \u274c Nicht SSL/TLS Certificates <code>snis</code> \u274c \u274c Nicht SNI Configuration <code>ca_certificates</code> \u274c \u274c Nicht CA Certificates"},{"location":"guides/KONG/#traffic-control-plugins","title":"Traffic Control Plugins","text":"Plugin Import Export Status Bemerkung <code>rate-limiting</code> \u2705 \u2705 Voll Rate Limiting (local) <code>rate-limiting-advanced</code> \u274c \u274c Nicht Enterprise Plugin <code>request-size-limiting</code> \u274c \u274c Nicht Request Size Limits <code>response-ratelimiting</code> \u274c \u274c Nicht Response-based Rate Limiting <code>proxy-cache</code> \u274c \u274c Nicht Caching <code>proxy-cache-advanced</code> \u274c \u274c Nicht Enterprise Caching"},{"location":"guides/KONG/#authentication-plugins","title":"Authentication Plugins","text":"Plugin Import Export Status Bemerkung <code>basic-auth</code> \u2705 \u2705 Voll Basic Authentication <code>key-auth</code> \u2705 \u2705 Voll API Key Authentication <code>jwt</code> \u2705 \u2705 Voll JWT Validation <code>oauth2</code> \u274c \u274c Nicht OAuth 2.0 <code>hmac-auth</code> \u274c \u274c Nicht HMAC Signature <code>ldap-auth</code> \u274c \u274c Nicht LDAP Authentication <code>openid-connect</code> \u274c \u274c Nicht Enterprise OIDC"},{"location":"guides/KONG/#security-plugins","title":"Security Plugins","text":"Plugin Import Export Status Bemerkung <code>cors</code> \u2705 \u2705 Voll CORS Policy <code>acl</code> \u274c \u274c Nicht Access Control Lists <code>ip-restriction</code> \u274c \u274c Nicht IP Whitelist/Blacklist <code>bot-detection</code> \u274c \u274c Nicht Bot Detection"},{"location":"guides/KONG/#transformation-plugins","title":"Transformation Plugins","text":"Plugin Import Export Status Bemerkung <code>request-transformer</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Request Header Transformation <code>response-transformer</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Response Header Transformation <code>request-transformer-advanced</code> \u274c \u274c Nicht Enterprise Plugin <code>response-transformer-advanced</code> \u274c \u274c Nicht Enterprise Plugin"},{"location":"guides/KONG/#traffic-management-plugins","title":"Traffic Management Plugins","text":"Plugin Import Export Status Bemerkung <code>canary</code> \u274c \u274c Nicht Canary Releases (Enterprise) <code>proxy-cache</code> \u274c \u274c Nicht HTTP Caching <code>upstream-timeout</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Timeout Configuration <code>http-log</code> \u274c \u274c Nicht HTTP Logging"},{"location":"guides/KONG/#load-balancing-features","title":"Load Balancing Features","text":"Feature Import Export Status Bemerkung <code>upstreams</code> (round-robin) \u2705 \u2705 Voll Round Robin (Default) <code>upstreams</code> (least-connections) \u2705 \u2705 Voll Least Connections <code>upstreams</code> (consistent-hashing) \u2705 \u2705 Voll IP Hash / Cookie Hash <code>upstreams</code> (latency) \u274c \u274c Nicht Latency-based LB <code>healthchecks.active</code> \u2705 \u2705 Voll Active Health Checks <code>healthchecks.passive</code> \u2705 \u2705 Voll Passive Health Checks (Circuit Breaker)"},{"location":"guides/KONG/#route-matching-features","title":"Route Matching Features","text":"Feature Import Export Status Bemerkung <code>paths</code> (prefix) \u2705 \u2705 Voll Path Prefix Matching <code>paths</code> (exact) \u274c \u274c Nicht Exact Path (nur Prefix) <code>paths</code> (regex) \u274c \u274c Nicht Regex Path Matching <code>hosts</code> \u2705 \u2705 Voll Host-based Routing <code>methods</code> \u2705 \u2705 Voll HTTP Method Matching <code>headers</code> \u274c \u274c Nicht Header-based Routing <code>snis</code> \u274c \u274c Nicht SNI-based Routing"},{"location":"guides/KONG/#observability-features","title":"Observability Features","text":"Feature Import Export Status Bemerkung Admin API Metrics N/A \u2705 Export <code>/metrics</code> Endpoint Prometheus Plugin \u274c \u274c Nicht Prometheus Metrics Export Datadog Plugin \u274c \u274c Nicht Datadog APM StatsD Plugin \u274c \u274c Nicht StatsD Metrics Zipkin Plugin \u274c \u274c Nicht Distributed Tracing File Log Plugin \u274c \u274c Nicht File-based Logging Syslog Plugin \u274c \u274c Nicht Syslog Integration"},{"location":"guides/KONG/#advanced-features","title":"Advanced Features","text":"Feature Import Export Status Bemerkung DB-less Mode (Declarative) \u2705 \u2705 Voll YAML Declarative Config Admin API (REST) \u274c \u274c Nicht Runtime API nicht in GAL Scope Kong Manager (UI) N/A N/A N/A Enterprise Feature Dev Portal N/A N/A N/A Enterprise Feature Service Mesh (Kuma) \u274c \u274c Nicht Service Mesh Integration Serverless Functions \u274c \u274c Nicht Pre/Post Function Plugins Custom Plugins (Lua) \u274c \u274c Nicht Custom Lua Plugins"},{"location":"guides/KONG/#coverage-score-nach-kategorie","title":"Coverage Score nach Kategorie","text":"Kategorie Features Total Unterst\u00fctzt Coverage Core Entities 9 5 voll 55% Traffic Control 6 1 voll 17% Authentication 7 3 voll 43% Security 4 1 voll 25% Transformation 4 0 voll, 2 teilweise 25% Traffic Management 4 0 voll, 1 teilweise 12% Load Balancing 6 4 voll 67% Route Matching 7 3 voll 43% Observability 7 1 export 14% Advanced 6 1 voll 17% <p>Gesamt (API Gateway relevante Features): ~38% Coverage</p> <p>Import Coverage: ~60% (Import bestehender Kong Configs \u2192 GAL) Export Coverage: ~85% (GAL \u2192 Kong Declarative Config)</p>"},{"location":"guides/KONG/#bidirektionale-feature-unterstutzung","title":"Bidirektionale Feature-Unterst\u00fctzung","text":"<p>Vollst\u00e4ndig bidirektional (Import \u2194 Export): 1. \u2705 Services (Name, URL, Protocol) 2. \u2705 Routes (Paths, Hosts, Methods) 3. \u2705 Upstreams (Targets, Load Balancing) 4. \u2705 Health Checks (Active + Passive) 5. \u2705 Load Balancing (Round Robin, Least Connections, Consistent Hashing) 6. \u2705 Rate Limiting (rate-limiting plugin) 7. \u2705 Authentication (Basic, API Key, JWT) 8. \u2705 CORS (cors plugin)</p> <p>Nur Export (GAL \u2192 Kong): 9. \u26a0\ufe0f Request/Response Headers (request-transformer plugin) 10. \u26a0\ufe0f Timeouts (Service-level timeouts)</p> <p>Features mit Einschr\u00e4nkungen: - Enterprise Plugins: Nicht in Kong OSS (rate-limiting-advanced, canary, openid-connect) - Exact Path Matching: Kong unterst\u00fctzt nur Prefix (paths array) - Regex/Header Routing: Nicht in GAL Scope - Custom Lua Plugins: Nicht parsebar/generierbar</p>"},{"location":"guides/KONG/#import-beispiel-kong-gal","title":"Import-Beispiel (Kong \u2192 GAL)","text":"<p>Input (kong.yaml - Declarative Config): <pre><code>_format_version: \"3.0\"\n\nservices:\n- name: api_service\n  url: http://backend.svc:8080\n  routes:\n  - name: api_route\n    paths:\n    - /api\n    methods:\n    - GET\n    - POST\n\nupstreams:\n- name: api_upstream\n  algorithm: round-robin\n  targets:\n  - target: backend-1.svc:8080\n    weight: 100\n  - target: backend-2.svc:8080\n    weight: 100\n  healthchecks:\n    active:\n      healthy:\n        interval: 10\n        successes: 2\n      unhealthy:\n        interval: 10\n        http_failures: 3\n\nplugins:\n- name: rate-limiting\n  config:\n    minute: 100\n    policy: local\n- name: jwt\n  config:\n    claims_to_verify:\n    - exp\n</code></pre></p> <p>Output (gal-config.yaml): <pre><code>version: \"1.0\"\nprovider: kong\nglobal:\n  host: 0.0.0.0\n  port: 8000\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      targets:\n        - host: backend-1.svc\n          port: 8080\n          weight: 100\n        - host: backend-2.svc\n          port: 8080\n          weight: 100\n      load_balancer:\n        algorithm: round_robin\n      health_check:\n        active:\n          enabled: true\n          interval: \"10s\"\n          healthy_threshold: 2\n          unhealthy_threshold: 3\n    routes:\n      - path_prefix: /api\n        methods:\n          - GET\n          - POST\n        rate_limit:\n          enabled: true\n          requests_per_second: 1.67  # 100/minute\n        authentication:\n          enabled: true\n          type: jwt\n</code></pre></p>"},{"location":"guides/KONG/#empfehlungen-fur-zukunftige-erweiterungen","title":"Empfehlungen f\u00fcr zuk\u00fcnftige Erweiterungen","text":"<p>Priorit\u00e4t 1 (High Impact): 1. Request/Response Transformation - Vollst\u00e4ndige body transformation support 2. Prometheus Plugin - Metrics Export Integration 3. IP Restriction - Whitelist/Blacklist Support 4. Request Size Limiting - <code>request-size-limiting</code> Plugin 5. Exact Path Matching - Zus\u00e4tzlich zu Prefix</p> <p>Priorit\u00e4t 2 (Medium Impact): 6. Proxy Cache - HTTP Caching Support 7. File/Syslog Logging - Zus\u00e4tzliche Logging Backends 8. OAuth2 Plugin - OAuth 2.0 Support 9. ACL Plugin - Access Control Lists 10. Bot Detection - Bot Detection Plugin</p> <p>Priorit\u00e4t 3 (Nice to Have): 11. HMAC Auth - HMAC Signature Authentication 12. LDAP Auth - LDAP Integration 13. Header/Query Routing - Advanced Routing 14. Custom Lua Plugins - Plugin Generation 15. Zipkin/Datadog Integration - Tracing/Metrics</p>"},{"location":"guides/KONG/#test-coverage-import","title":"Test Coverage (Import)","text":"<p>Kong Import Tests: 21 Tests (test_import_kong.py)</p> Test Kategorie Tests Status Basic Import 3 \u2705 Passing Services &amp; Routes 3 \u2705 Passing Upstreams &amp; Load Balancing 3 \u2705 Passing Health Checks 2 \u2705 Passing Rate Limiting 2 \u2705 Passing Authentication (Basic, JWT, API Key) 3 \u2705 Passing CORS 1 \u2705 Passing Headers 1 \u2705 Passing Errors &amp; Warnings 3 \u2705 Passing <p>Coverage Verbesserung durch Import: 8% \u2192 42% (+34%)</p>"},{"location":"guides/KONG/#roundtrip-kompatibilitat","title":"Roundtrip-Kompatibilit\u00e4t","text":"Szenario Roundtrip Bemerkung Basic Service + Route \u2705 100% Perfekt Upstreams + Load Balancing \u2705 100% Perfekt Health Checks (Active + Passive) \u2705 95% Minimal Details verloren Rate Limiting \u2705 100% Perfekt Authentication (Basic, JWT, API Key) \u2705 100% Perfekt CORS \u2705 100% Perfekt Request/Response Headers \u2705 90% request-transformer Einschr\u00e4nkungen Combined Features \u2705 95% Sehr gut <p>Durchschnittliche Roundtrip-Kompatibilit\u00e4t: ~97%</p>"},{"location":"guides/KONG/#fazit","title":"Fazit","text":"<p>Kong Import Coverage: - \u2705 Core Features: 90% Coverage (Services, Routes, Upstreams, Plugins) - \u26a0\ufe0f Advanced Plugins: 30% Coverage (viele Community Plugins nicht unterst\u00fctzt) - \u274c Enterprise Features: Nicht unterst\u00fctzt (canary, openid-connect, rate-limiting-advanced)</p> <p>Kong Export Coverage: - \u2705 Core Features: 95% Coverage (alle GAL Features \u2192 Kong) - \u2705 Best Practices: Eingebaut (Health Checks, Load Balancing) - \u2705 DB-less Mode: Vollst\u00e4ndig unterst\u00fctzt (Declarative YAML)</p> <p>Empfehlung: - \ud83d\ude80 F\u00fcr Standard API Gateway Workloads: Perfekt geeignet - \u2705 F\u00fcr Kong \u2192 GAL Migration: 95% automatisiert, 5% Review - \u26a0\ufe0f F\u00fcr komplexe Plugin-Setups: Manuelle Nachbearbeitung n\u00f6tig - \u274c F\u00fcr Enterprise Features: Nicht unterst\u00fctzt (Kong Enterprise erforderlich)</p> <p>Referenzen: - \ud83d\udcda Kong Plugin Hub - \ud83d\udcda Kong Admin API - \ud83d\udcda Kong Declarative Config - \ud83d\udcda Kong Load Balancing</p>"},{"location":"guides/KONG/#kong-spezifische-details","title":"Kong-spezifische Details","text":""},{"location":"guides/KONG/#plugin-architektur","title":"Plugin-Architektur","text":"<p>Kong's Macht liegt in seinen Plugins:</p> <p>Plugin Execution Order: 1. Pre-Function (Custom Lua before request) 2. Authentication (JWT, Basic, API Key, etc.) 3. Rate Limiting (Rate limits enforcement) 4. Request Transformer (Modify request) 5. Proxy (Forward to upstream) 6. Response Transformer (Modify response) 7. Post-Function (Custom Lua after response)</p>"},{"location":"guides/KONG/#admin-api","title":"Admin API","text":"<p>Kong bietet eine REST API f\u00fcr Verwaltung:</p> <pre><code># Services auflisten\ncurl http://localhost:8001/services\n\n# Service erstellen\ncurl -X POST http://localhost:8001/services \\\n  -d \"name=my-service\" \\\n  -d \"url=http://backend:8080\"\n\n# Route hinzuf\u00fcgen\ncurl -X POST http://localhost:8001/services/my-service/routes \\\n  -d \"paths[]=/api\"\n\n# Plugin aktivieren\ncurl -X POST http://localhost:8001/services/my-service/plugins \\\n  -d \"name=rate-limiting\" \\\n  -d \"config.second=100\"\n</code></pre> <p>Hinweis: GAL generiert Declarative Config (DB-less Mode), nicht Admin API Calls.</p>"},{"location":"guides/KONG/#db-less-vs-db-mode","title":"DB-less vs. DB Mode","text":"<p>DB-less Mode (Empfohlen f\u00fcr GAL): - \u2705 Keine Datenbank erforderlich - \u2705 Einfaches Deployment - \u2705 Git-freundlich (YAML-Config) - \u274c Keine dynamischen \u00c4nderungen via Admin API</p> <p>DB Mode (PostgreSQL): - \u2705 Dynamische \u00c4nderungen via Admin API - \u2705 Kong Manager UI - \u274c Ben\u00f6tigt Datenbank - \u274c Komplexeres Setup</p>"},{"location":"guides/KONG/#kong-manager-enterprise","title":"Kong Manager (Enterprise)","text":"<p>Kong Enterprise bietet eine Web UI:</p> <pre><code># Kong Manager aktivieren (Enterprise)\ndocker run -d \\\n  --name kong-enterprise \\\n  -e \"KONG_ADMIN_GUI_URL=http://localhost:8002\" \\\n  kong/kong-gateway:3.4-enterprise\n</code></pre> <p>Zugriff: <code>http://localhost:8002</code></p>"},{"location":"guides/KONG/#best-practices","title":"Best Practices","text":""},{"location":"guides/KONG/#1-verwende-db-less-mode-fur-production","title":"1. Verwende DB-less Mode f\u00fcr Production","text":"<pre><code># DB-less ist einfacher und stabiler\nKONG_DATABASE=off\nKONG_DECLARATIVE_CONFIG=/kong.yaml\n</code></pre>"},{"location":"guides/KONG/#2-enable-access-logs","title":"2. Enable Access Logs","text":"<pre><code># JSON-Format f\u00fcr strukturierte Logs\nKONG_PROXY_ACCESS_LOG=/dev/stdout\nKONG_ADMIN_ACCESS_LOG=/dev/stdout\nKONG_LOG_LEVEL=info\n</code></pre>"},{"location":"guides/KONG/#3-configure-resource-limits","title":"3. Configure Resource Limits","text":"<pre><code># Nginx Worker Limits\nKONG_NGINX_WORKER_PROCESSES=auto\nKONG_NGINX_WORKER_CONNECTIONS=4096\n</code></pre>"},{"location":"guides/KONG/#4-use-health-checks","title":"4. Use Health Checks","text":"<p>Immer Active Health Checks konfigurieren: <pre><code>healthchecks:\n  active:\n    type: http\n    http_path: /health\n</code></pre></p>"},{"location":"guides/KONG/#5-tune-timeouts","title":"5. Tune Timeouts","text":"<pre><code># In Milliseconds!\nconnect_timeout: 60000    # 60 Sekunden\nread_timeout: 60000\nwrite_timeout: 60000\n</code></pre>"},{"location":"guides/KONG/#6-rate-limiting-strategy","title":"6. Rate Limiting Strategy","text":"<pre><code># Local Policy (einfach)\nrate-limiting:\n  policy: local\n\n# Redis Policy (distributed)\nrate-limiting:\n  policy: redis\n  redis_host: redis.svc\n</code></pre>"},{"location":"guides/KONG/#7-security-headers","title":"7. Security Headers","text":"<pre><code>plugins:\n- name: response-transformer\n  config:\n    add:\n      headers:\n      - X-Frame-Options:DENY\n      - X-Content-Type-Options:nosniff\n</code></pre>"},{"location":"guides/KONG/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/KONG/#problem-1-config-validation-errors","title":"Problem 1: Config Validation Errors","text":"<p>Symptom: Kong startet nicht, Config-Fehler</p> <p>L\u00f6sung: <pre><code># Validate Config\nkong config parse /path/to/kong.yaml\n\n# GAL Config erneut generieren\ngal generate --config gateway.yaml --provider kong &gt; kong.yaml\n</code></pre></p>"},{"location":"guides/KONG/#problem-2-upstream-connection-failed","title":"Problem 2: Upstream Connection Failed","text":"<p>Symptom: <code>502 Bad Gateway</code></p> <p>Diagnose: <pre><code># Services Status pr\u00fcfen\ncurl http://localhost:8001/services/api_service\n\n# Upstream Health pr\u00fcfen\ncurl http://localhost:8001/upstreams/api_service_upstream/health\n</code></pre></p>"},{"location":"guides/KONG/#problem-3-rate-limiting-nicht-aktiv","title":"Problem 3: Rate Limiting nicht aktiv","text":"<p>Symptom: Requests werden nicht gedrosselt</p> <p>L\u00f6sung: <pre><code># Pr\u00fcfe Plugin Config\nplugins:\n- name: rate-limiting\n  config:\n    second: 100       # Requests pro Sekunde\n    policy: local     # Muss gesetzt sein\n</code></pre></p>"},{"location":"guides/KONG/#problem-4-jwt-validation-schlagt-fehl","title":"Problem 4: JWT Validation schl\u00e4gt fehl","text":"<p>Symptom: <code>401 Unauthorized</code></p> <p>Diagnose: <pre><code># Consumer mit JWT Credential erstellen\ncurl -X POST http://localhost:8001/consumers/test-user\ncurl -X POST http://localhost:8001/consumers/test-user/jwt \\\n  -d \"key=issuer-key\"\n</code></pre></p>"},{"location":"guides/KONG/#problem-5-timeout-zu-kurz","title":"Problem 5: Timeout zu kurz","text":"<p>Symptom: <code>504 Gateway Timeout</code></p> <p>L\u00f6sung: <pre><code># Timeouts erh\u00f6hen (in MS!)\nservices:\n- name: api_service\n  connect_timeout: 120000   # 120 Sekunden\n  read_timeout: 120000\n</code></pre></p>"},{"location":"guides/KONG/#problem-6-memory-usage-hoch","title":"Problem 6: Memory Usage hoch","text":"<p>Symptom: Hoher RAM-Verbrauch</p> <p>L\u00f6sung: <pre><code># Worker Processes reduzieren\nKONG_NGINX_WORKER_PROCESSES=2\nKONG_MEM_CACHE_SIZE=128m\n</code></pre></p>"},{"location":"guides/KONG/#zusammenfassung","title":"Zusammenfassung","text":"<p>Kong Gateway ist der developer-freundlichste API Gateway Provider:</p> <p>\u2705 St\u00e4rken: - Einfachste Konfiguration - 300+ Plugins - Beste Admin API - DB-less Mode - Beste Dokumentation</p> <p>\u26a0\ufe0f Herausforderungen: - Enterprise Features kostenpflichtig - Etwas niedriger Performance als Nginx/HAProxy - Retry ohne konditionale Bedingungen</p> <p>GAL macht Kong noch einfacher - automatische Plugin-Konfiguration aus GAL-YAML!</p> <p>N\u00e4chste Schritte: - Vergleiche Envoy, APISIX, Traefik - Probiere Kong Plugins - Explore Kong Enterprise</p> <p>Siehe auch: - Kong Docs - Kong GitHub - Kong Community Forum</p>"},{"location":"guides/LOGGING_OBSERVABILITY/","title":"Logging &amp; Observability Guide","text":"<p>Feature Status: \u2705 Vollst\u00e4ndig implementiert (v1.2.0)</p> <p>Umfassendes Logging und Observability f\u00fcr alle Gateway-Provider mit strukturiertem Logging, Metriken-Export und Monitoring-Integration.</p>"},{"location":"guides/LOGGING_OBSERVABILITY/#ubersicht","title":"\u00dcbersicht","text":"<p>Logging &amp; Observability bietet:</p> <ul> <li>Strukturiertes Logging: JSON- oder textbasierte Access Logs</li> <li>Metriken-Export: Prometheus und OpenTelemetry Integration</li> <li>Log Sampling: Reduzierung des Log-Volumens bei High-Traffic</li> <li>Custom Fields: Zus\u00e4tzliche Metadaten in Logs</li> <li>Provider-agnostisch: Einheitliche Konfiguration f\u00fcr alle Provider</li> </ul>"},{"location":"guides/LOGGING_OBSERVABILITY/#feature-matrix","title":"Feature-Matrix","text":"Feature Envoy Kong APISIX Traefik Nginx HAProxy JSON Logs \u2705 \u2705 \u2705 \u2705 \u2705 \u26a0\ufe0f Text Logs \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Custom Fields \u2705 \u2705 \u2705 \u2705 \u2705 \u26a0\ufe0f Log Sampling \u2705 \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f Prometheus \u2705 \u2705 \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f OpenTelemetry \u2705 \u26a0\ufe0f \u26a0\ufe0f \u2705 \u274c \u274c <p>Legende: - \u2705 Native Unterst\u00fctzung - \u26a0\ufe0f Teilweise/Externe Tools erforderlich - \u274c Nicht unterst\u00fctzt</p>"},{"location":"guides/LOGGING_OBSERVABILITY/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/LOGGING_OBSERVABILITY/#beispiel-1-basis-json-logging","title":"Beispiel 1: Basis JSON Logging","text":"<pre><code>version: \"1.0\"\nprovider: envoy\n\nglobal:\n  host: 0.0.0.0\n  port: 10000\n  admin_port: 9901\n\n  # Strukturiertes Logging aktivieren\n  logging:\n    enabled: true\n    format: json  # json oder text\n    level: info   # debug, info, warning, error\n    access_log_path: /var/log/gateway/access.log\n    error_log_path: /var/log/gateway/error.log\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      host: api.internal\n      port: 8080\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Generiertes Envoy Access Log (JSON): <pre><code>{\n  \"request_id\": \"12345678-1234-1234-1234-123456789abc\",\n  \"method\": \"GET\",\n  \"path\": \"/api/users\",\n  \"protocol\": \"HTTP/1.1\",\n  \"response_code\": \"200\",\n  \"bytes_received\": \"0\",\n  \"bytes_sent\": \"1234\",\n  \"duration\": \"45\",\n  \"upstream_service_time\": \"42\",\n  \"x_forwarded_for\": \"10.0.0.1\"\n}\n</code></pre></p>"},{"location":"guides/LOGGING_OBSERVABILITY/#beispiel-2-prometheus-metriken","title":"Beispiel 2: Prometheus Metriken","text":"<pre><code>version: \"1.0\"\nprovider: envoy\n\nglobal:\n  host: 0.0.0.0\n  port: 10000\n  admin_port: 9901\n\n  # Prometheus Metriken aktivieren\n  metrics:\n    enabled: true\n    exporter: prometheus  # prometheus, opentelemetry, both\n    prometheus_port: 9090\n    prometheus_path: /metrics\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      host: api.internal\n      port: 8080\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Metriken abrufen: <pre><code># Envoy\ncurl http://localhost:9901/stats/prometheus\n\n# Kong\ncurl http://localhost:8001/metrics\n\n# APISIX\ncurl http://localhost:9091/apisix/prometheus/metrics\n\n# Traefik (ben\u00f6tigt static config f\u00fcr metrics port)\ncurl http://localhost:8082/metrics\n</code></pre></p>"},{"location":"guides/LOGGING_OBSERVABILITY/#beispiel-3-logging-metriken-custom-fields","title":"Beispiel 3: Logging + Metriken + Custom Fields","text":"<pre><code>version: \"1.0\"\nprovider: envoy\n\nglobal:\n  host: 0.0.0.0\n  port: 10000\n  admin_port: 9901\n\n  # Logging mit Custom Fields\n  logging:\n    enabled: true\n    format: json\n    level: info\n    access_log_path: /var/log/gateway/access.log\n    sample_rate: 0.5  # Nur 50% der Requests loggen\n    include_headers:\n      - X-Request-ID\n      - User-Agent\n      - X-Correlation-ID\n    exclude_paths:\n      - /health\n      - /metrics\n      - /ping\n    custom_fields:\n      environment: production\n      cluster: eu-west-1\n      version: v1.2.0\n\n  # Prometheus + OpenTelemetry\n  metrics:\n    enabled: true\n    exporter: both\n    prometheus_port: 9090\n    opentelemetry_endpoint: http://otel-collector:4317\n    custom_labels:\n      cluster: eu-west-1\n      environment: production\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      host: api.internal\n      port: 8080\n    routes:\n      - path_prefix: /api\n</code></pre>"},{"location":"guides/LOGGING_OBSERVABILITY/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/LOGGING_OBSERVABILITY/#loggingconfig","title":"LoggingConfig","text":"<p>Konfiguration f\u00fcr Access Logs und Error Logs.</p> <pre><code>logging:\n  enabled: true                              # Logging aktivieren (default: true)\n  format: json                               # Log-Format: json, text, custom (default: json)\n  level: info                                # Log-Level: debug, info, warning, error (default: info)\n  access_log_path: /var/log/gateway/access.log  # Pfad zum Access Log\n  error_log_path: /var/log/gateway/error.log    # Pfad zum Error Log\n  sample_rate: 1.0                           # Sampling-Rate 0.0-1.0 (default: 1.0 = 100%)\n  include_request_body: false                # Request Body in Logs (default: false)\n  include_response_body: false               # Response Body in Logs (default: false)\n  include_headers:                           # Headers in Logs einbeziehen\n    - X-Request-ID\n    - User-Agent\n    - X-Correlation-ID\n  exclude_paths:                             # Pfade von Logging ausschlie\u00dfen\n    - /health\n    - /metrics\n    - /ping\n  custom_fields:                             # Zus\u00e4tzliche Felder in Logs\n    environment: production\n    cluster: eu-west-1\n    version: v1.2.0\n</code></pre> <p>Parameter:</p> Parameter Typ Default Beschreibung <code>enabled</code> bool <code>true</code> Logging aktivieren/deaktivieren <code>format</code> string <code>json</code> Log-Format: <code>json</code>, <code>text</code>, <code>custom</code> <code>level</code> string <code>info</code> Log-Level: <code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code> <code>access_log_path</code> string <code>/var/log/gateway/access.log</code> Pfad zum Access Log <code>error_log_path</code> string <code>/var/log/gateway/error.log</code> Pfad zum Error Log <code>sample_rate</code> float <code>1.0</code> Sampling-Rate (0.0 = 0%, 1.0 = 100%) <code>include_request_body</code> bool <code>false</code> Request Body in Logs einbeziehen <code>include_response_body</code> bool <code>false</code> Response Body in Logs einbeziehen <code>include_headers</code> list <code>[\"X-Request-ID\", \"User-Agent\"]</code> Headers in Logs <code>exclude_paths</code> list <code>[\"/health\", \"/metrics\"]</code> Pfade von Logging ausschlie\u00dfen <code>custom_fields</code> dict <code>{}</code> Zus\u00e4tzliche Felder (Key-Value Paare)"},{"location":"guides/LOGGING_OBSERVABILITY/#metricsconfig","title":"MetricsConfig","text":"<p>Konfiguration f\u00fcr Metriken-Export (Prometheus, OpenTelemetry).</p> <pre><code>metrics:\n  enabled: true                              # Metriken aktivieren (default: true)\n  exporter: prometheus                       # Exporter: prometheus, opentelemetry, both\n  prometheus_port: 9090                      # Prometheus Metriken Port (default: 9090)\n  prometheus_path: /metrics                  # Prometheus Metriken Pfad (default: /metrics)\n  opentelemetry_endpoint: http://otel-collector:4317  # OpenTelemetry Collector Endpoint\n  include_histograms: true                   # Request Duration Histograms (default: true)\n  include_counters: true                     # Request/Error Counter (default: true)\n  custom_labels:                             # Zus\u00e4tzliche Labels f\u00fcr Metriken\n    cluster: prod\n    region: eu-west-1\n</code></pre> <p>Parameter:</p> Parameter Typ Default Beschreibung <code>enabled</code> bool <code>true</code> Metriken aktivieren/deaktivieren <code>exporter</code> string <code>prometheus</code> Exporter: <code>prometheus</code>, <code>opentelemetry</code>, <code>both</code> <code>prometheus_port</code> int <code>9090</code> Port f\u00fcr Prometheus Metriken <code>prometheus_path</code> string <code>/metrics</code> Pfad f\u00fcr Prometheus Metriken <code>opentelemetry_endpoint</code> string <code>\"\"</code> OpenTelemetry Collector Endpoint (gRPC) <code>include_histograms</code> bool <code>true</code> Request Duration Histograms einbeziehen <code>include_counters</code> bool <code>true</code> Request/Error Counter einbeziehen <code>custom_labels</code> dict <code>{}</code> Zus\u00e4tzliche Labels (Key-Value Paare)"},{"location":"guides/LOGGING_OBSERVABILITY/#provider-implementierungen","title":"Provider-Implementierungen","text":""},{"location":"guides/LOGGING_OBSERVABILITY/#1-envoy","title":"1. Envoy","text":"<p>Logging: - Native JSON Access Logs \u00fcber <code>envoy.access_loggers.file</code> - Alle Standard-Felder: request_id, method, path, protocol, response_code, duration, etc. - Custom Fields \u00fcber <code>json_format</code> - Log Sampling \u00fcber <code>runtime_filter</code> mit <code>percent_sampled</code></p> <p>Metriken: - Prometheus: Admin Interface <code>/stats/prometheus</code> - OpenTelemetry: <code>stats_sinks</code> mit <code>envoy.stat_sinks.open_telemetry</code></p> <p>Beispiel-Konfiguration: <pre><code>access_log:\n- name: envoy.access_loggers.file\n  typed_config:\n    '@type': type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog\n    path: /var/log/envoy/access.log\n    json_format:\n      request_id: \"%REQ(X-REQUEST-ID)%\"\n      method: \"%REQ(:METHOD)%\"\n      path: \"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\"\n      protocol: \"%PROTOCOL%\"\n      response_code: \"%RESPONSE_CODE%\"\n      duration: \"%DURATION%\"\n      environment: \"production\"\n    filter:\n      runtime_filter:\n        runtime_key: access_log_sampling\n        percent_sampled:\n          numerator: 50\n          denominator: HUNDRED\n</code></pre></p> <p>Metriken abrufen: <pre><code>curl http://localhost:9901/stats/prometheus\n</code></pre></p>"},{"location":"guides/LOGGING_OBSERVABILITY/#2-kong","title":"2. Kong","text":"<p>Logging: - <code>file-log</code> Plugin f\u00fcr Access Logs - JSON Format Support - Custom Fields via <code>custom_fields_by_lua</code></p> <p>Metriken: - <code>prometheus</code> Plugin - Metriken \u00fcber Kong Admin API: <code>http://localhost:8001/metrics</code></p> <p>Beispiel-Konfiguration: <pre><code>plugins:\n- name: file-log\n  config:\n    path: /var/log/kong/access.log\n    format: json\n    custom_fields_by_lua:\n      environment: production\n      cluster: eu-west-1\n\n- name: prometheus\n  config: {}\n</code></pre></p> <p>Metriken abrufen: <pre><code>curl http://localhost:8001/metrics\n</code></pre></p>"},{"location":"guides/LOGGING_OBSERVABILITY/#3-apisix","title":"3. APISIX","text":"<p>Logging: - <code>file-logger</code> Plugin - <code>include_req_body</code> und <code>include_resp_body</code> Optionen</p> <p>Metriken: - <code>prometheus</code> Plugin - Metriken-Endpoint: <code>:9091/apisix/prometheus/metrics</code></p> <p>Beispiel-Konfiguration: <pre><code>global_plugins:\n  file-logger:\n    path: /var/log/apisix/access.log\n    include_req_body: true\n    include_resp_body: false\n\n  prometheus: {}\n</code></pre></p> <p>Metriken abrufen: <pre><code>curl http://localhost:9091/apisix/prometheus/metrics\n</code></pre></p>"},{"location":"guides/LOGGING_OBSERVABILITY/#4-traefik","title":"4. Traefik","text":"<p>Logging: - <code>accessLog</code> Konfiguration - JSON oder Common Format - Custom Fields Support</p> <p>Metriken: - <code>prometheus</code> via <code>entryPoint</code> - Ben\u00f6tigt static config f\u00fcr Metrics Port</p> <p>Beispiel-Konfiguration: <pre><code>accessLog:\n  filePath: /var/log/traefik/access.log\n  format: json\n  fields:\n    defaultMode: keep\n    headers:\n      defaultMode: keep\n\nmetrics:\n  prometheus:\n    entryPoint: metrics\n</code></pre></p> <p>Static Config (traefik.yml): <pre><code>entryPoints:\n  metrics:\n    address: \":8082\"\n</code></pre></p> <p>Metriken abrufen: <pre><code>curl http://localhost:8082/metrics\n</code></pre></p>"},{"location":"guides/LOGGING_OBSERVABILITY/#5-nginx","title":"5. Nginx","text":"<p>Logging: - <code>log_format</code> mit JSON Support - Konfigurierbare Log Levels (debug, info, warn, error) - Custom Fields in JSON Format</p> <p>Metriken: - Externe Exporter erforderlich: <code>nginx-prometheus-exporter</code> - Oder VTS Module (nginx-module-vts)</p> <p>Beispiel-Konfiguration: <pre><code>http {\n    # JSON Log Format\n    log_format json_combined escape=json\n      '{'\n        '\"time_local\":\"$time_local\",'\n        '\"remote_addr\":\"$remote_addr\",'\n        '\"request_method\":\"$request_method\",'\n        '\"request_uri\":\"$request_uri\",'\n        '\"status\":\"$status\",'\n        '\"request_time\":\"$request_time\",'\n        '\"environment\":\"production\"'\n      '}';\n\n    access_log /var/log/nginx/access.log json_combined;\n    error_log /var/log/nginx/error.log info;\n}\n</code></pre></p> <p>Metriken mit nginx-prometheus-exporter: <pre><code># Exporter starten\nnginx-prometheus-exporter -nginx.scrape-uri=http://localhost:8080/stub_status\n\n# Metriken abrufen\ncurl http://localhost:9113/metrics\n</code></pre></p>"},{"location":"guides/LOGGING_OBSERVABILITY/#6-haproxy","title":"6. HAProxy","text":"<p>Logging: - Syslog Logging - Log Level Mapping (debug, info, notice, err) - JSON Format \u00fcber <code>log-format</code> Directive</p> <p>Metriken: - Stats Endpoint: <code>/stats;csv</code> - Externe Exporter: <code>haproxy_exporter</code></p> <p>Beispiel-Konfiguration: <pre><code>global\n    log 127.0.0.1 local0 info\n    # JSON format requires log-format directive\n\ndefaults\n    log global\n    option httplog\n</code></pre></p> <p>Metriken mit haproxy_exporter: <pre><code># Exporter starten\nhaproxy_exporter --haproxy.scrape-uri=\"http://localhost:8404/stats;csv\"\n\n# Metriken abrufen\ncurl http://localhost:9101/metrics\n</code></pre></p>"},{"location":"guides/LOGGING_OBSERVABILITY/#haufige-anwendungsfalle","title":"H\u00e4ufige Anwendungsf\u00e4lle","text":""},{"location":"guides/LOGGING_OBSERVABILITY/#1-production-api-mit-vollstandigem-logging","title":"1. Production API mit vollst\u00e4ndigem Logging","text":"<p>High-Traffic API mit strukturiertem Logging, Custom Fields und Metriken.</p> <pre><code>version: \"1.0\"\nprovider: envoy\n\nglobal:\n  host: 0.0.0.0\n  port: 10000\n  admin_port: 9901\n\n  logging:\n    enabled: true\n    format: json\n    level: info\n    access_log_path: /var/log/gateway/access.log\n    error_log_path: /var/log/gateway/error.log\n    include_headers:\n      - X-Request-ID\n      - X-Correlation-ID\n      - User-Agent\n      - X-Forwarded-For\n    exclude_paths:\n      - /health\n      - /metrics\n    custom_fields:\n      environment: production\n      cluster: eu-west-1\n      service: api-gateway\n      version: v1.2.0\n\n  metrics:\n    enabled: true\n    exporter: both\n    prometheus_port: 9090\n    opentelemetry_endpoint: http://otel-collector:4317\n    custom_labels:\n      environment: production\n      cluster: eu-west-1\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n        - host: api-2.internal\n          port: 8080\n      load_balancer:\n        algorithm: least_conn\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Anwendungsfall: Production API mit vollst\u00e4ndigem Observability Stack.</p>"},{"location":"guides/LOGGING_OBSERVABILITY/#2-high-traffic-api-mit-log-sampling","title":"2. High-Traffic API mit Log Sampling","text":"<p>Reduzierung des Log-Volumens bei hohem Traffic durch Sampling.</p> <pre><code>version: \"1.0\"\nprovider: envoy\n\nglobal:\n  host: 0.0.0.0\n  port: 10000\n  admin_port: 9901\n\n  logging:\n    enabled: true\n    format: json\n    level: warning  # Nur Warnings/Errors\n    access_log_path: /var/log/gateway/access.log\n    sample_rate: 0.1  # Nur 10% der Requests loggen\n    exclude_paths:\n      - /health\n      - /metrics\n      - /ping\n      - /favicon.ico\n    custom_fields:\n      environment: production\n      sampling: \"10percent\"\n\nservices:\n  - name: high_traffic_api\n    type: rest\n    protocol: http\n    upstream:\n      host: api.internal\n      port: 8080\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Anwendungsfall: High-Traffic API (&gt;10k req/s) mit reduziertem Log-Volumen.</p>"},{"location":"guides/LOGGING_OBSERVABILITY/#3-microservices-mit-distributed-tracing","title":"3. Microservices mit Distributed Tracing","text":"<p>Correlation IDs und Trace IDs f\u00fcr Distributed Tracing.</p> <pre><code>version: \"1.0\"\nprovider: envoy\n\nglobal:\n  host: 0.0.0.0\n  port: 10000\n  admin_port: 9901\n\n  logging:\n    enabled: true\n    format: json\n    level: info\n    access_log_path: /var/log/gateway/access.log\n    include_headers:\n      - X-Request-ID\n      - X-Correlation-ID\n      - X-B3-TraceId       # Zipkin/Jaeger\n      - X-B3-SpanId\n      - Traceparent        # W3C Trace Context\n    custom_fields:\n      service: gateway\n      span_kind: server\n\n  metrics:\n    enabled: true\n    exporter: opentelemetry\n    opentelemetry_endpoint: http://otel-collector:4317\n\nservices:\n  - name: user_service\n    type: rest\n    protocol: http\n    upstream:\n      host: users.internal\n      port: 8080\n    routes:\n      - path_prefix: /users\n\n  - name: order_service\n    type: rest\n    protocol: http\n    upstream:\n      host: orders.internal\n      port: 8080\n    routes:\n      - path_prefix: /orders\n</code></pre> <p>Anwendungsfall: Microservices-Architektur mit Distributed Tracing (Jaeger/Zipkin/OpenTelemetry).</p>"},{"location":"guides/LOGGING_OBSERVABILITY/#4-development-environment-mit-debug-logging","title":"4. Development Environment mit Debug Logging","text":"<p>Detailliertes Logging f\u00fcr Entwicklung und Debugging.</p> <pre><code>version: \"1.0\"\nprovider: nginx\n\nglobal:\n  host: 0.0.0.0\n  port: 80\n\n  logging:\n    enabled: true\n    format: json\n    level: debug  # Alle Debug-Informationen\n    access_log_path: /var/log/nginx/access.log\n    error_log_path: /var/log/nginx/error.log\n    include_request_body: true   # Request Body loggen\n    include_response_body: true  # Response Body loggen\n    custom_fields:\n      environment: development\n      debug: \"true\"\n\nservices:\n  - name: dev_api\n    type: rest\n    protocol: http\n    upstream:\n      host: localhost\n      port: 3000\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Anwendungsfall: Lokale Entwicklungsumgebung mit maximalem Logging.</p>"},{"location":"guides/LOGGING_OBSERVABILITY/#5-security-audit-logging","title":"5. Security Audit Logging","text":"<p>Umfassendes Logging f\u00fcr Security Audits und Compliance.</p> <pre><code>version: \"1.0\"\nprovider: envoy\n\nglobal:\n  host: 0.0.0.0\n  port: 10000\n  admin_port: 9901\n\n  logging:\n    enabled: true\n    format: json\n    level: info\n    access_log_path: /var/log/gateway/audit.log\n    sample_rate: 1.0  # Alle Requests loggen\n    include_headers:\n      - Authorization\n      - X-API-Key\n      - X-Client-ID\n      - X-Forwarded-For\n      - User-Agent\n      - X-Real-IP\n    custom_fields:\n      audit: \"true\"\n      compliance: pci-dss\n      retention_days: \"365\"\n\n  metrics:\n    enabled: true\n    exporter: prometheus\n    prometheus_port: 9090\n\nservices:\n  - name: payment_api\n    type: rest\n    protocol: http\n    upstream:\n      host: payment.internal\n      port: 8080\n    routes:\n      - path_prefix: /payment\n        authentication:\n          enabled: true\n          type: jwt\n          jwt:\n            issuer: https://auth.example.com\n</code></pre> <p>Anwendungsfall: Payment API mit vollst\u00e4ndigem Audit Trail f\u00fcr PCI-DSS Compliance.</p>"},{"location":"guides/LOGGING_OBSERVABILITY/#6-multi-tenant-saas-mit-tenant-spezifischem-logging","title":"6. Multi-Tenant SaaS mit Tenant-spezifischem Logging","text":"<p>Custom Fields f\u00fcr Tenant-Identifikation.</p> <pre><code>version: \"1.0\"\nprovider: kong\n\nglobal:\n  host: 0.0.0.0\n  port: 8000\n\n  logging:\n    enabled: true\n    format: json\n    level: info\n    access_log_path: /var/log/kong/access.log\n    include_headers:\n      - X-Tenant-ID\n      - X-Organization-ID\n      - X-User-ID\n    custom_fields:\n      environment: production\n      service_type: multi-tenant-saas\n\n  metrics:\n    enabled: true\n    exporter: prometheus\n\nservices:\n  - name: saas_api\n    type: rest\n    protocol: http\n    upstream:\n      host: api.internal\n      port: 8080\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Anwendungsfall: Multi-Tenant SaaS mit Tenant-spezifischem Logging f\u00fcr Billing und Analytics.</p>"},{"location":"guides/LOGGING_OBSERVABILITY/#best-practices","title":"Best Practices","text":""},{"location":"guides/LOGGING_OBSERVABILITY/#1-strukturiertes-json-logging-verwenden","title":"1. Strukturiertes JSON Logging verwenden","text":"<p>Empfehlung: Verwende JSON-Format f\u00fcr Access Logs in Production.</p> <p>Vorteile: - Einfaches Parsing durch Log-Aggregatoren (ELK, Splunk, Grafana Loki) - Strukturierte Queries m\u00f6glich - Automatische Feld-Extraktion</p> <pre><code>logging:\n  format: json  # \u2705 EMPFOHLEN f\u00fcr Production\n  # format: text  # Nur f\u00fcr lokale Entwicklung\n</code></pre>"},{"location":"guides/LOGGING_OBSERVABILITY/#2-log-sampling-bei-high-traffic","title":"2. Log Sampling bei High-Traffic","text":"<p>Empfehlung: Verwende Log Sampling bei sehr hohem Traffic (&gt;5k req/s).</p> <pre><code>logging:\n  sample_rate: 0.1  # 10% sampling bei sehr hohem Traffic\n  # sample_rate: 1.0  # 100% bei niedrigem/mittlerem Traffic\n</code></pre> <p>Faustregel: - &lt; 1k req/s: <code>sample_rate: 1.0</code> (100%) - 1k-5k req/s: <code>sample_rate: 0.5</code> (50%) - 5k-10k req/s: <code>sample_rate: 0.2</code> (20%) - &gt; 10k req/s: <code>sample_rate: 0.1</code> (10%)</p>"},{"location":"guides/LOGGING_OBSERVABILITY/#3-health-check-endpoints-ausschlieen","title":"3. Health Check Endpoints ausschlie\u00dfen","text":"<p>Empfehlung: Schlie\u00dfe Health Checks und Monitoring-Endpoints vom Logging aus.</p> <pre><code>logging:\n  exclude_paths:\n    - /health\n    - /metrics\n    - /ping\n    - /readiness\n    - /liveness\n    - /_status\n</code></pre>"},{"location":"guides/LOGGING_OBSERVABILITY/#4-custom-fields-fur-kontext-verwenden","title":"4. Custom Fields f\u00fcr Kontext verwenden","text":"<p>Empfehlung: F\u00fcge Custom Fields f\u00fcr Umgebung, Cluster, Version hinzu.</p> <pre><code>logging:\n  custom_fields:\n    environment: production     # \u2705 WICHTIG\n    cluster: eu-west-1         # \u2705 WICHTIG\n    version: v1.2.0            # \u2705 WICHTIG\n    datacenter: aws-eu-west-1\n    team: platform\n</code></pre>"},{"location":"guides/LOGGING_OBSERVABILITY/#5-prometheus-opentelemetry-kombinieren","title":"5. Prometheus + OpenTelemetry kombinieren","text":"<p>Empfehlung: Verwende beide Exporter f\u00fcr maximale Flexibilit\u00e4t.</p> <pre><code>metrics:\n  exporter: both  # \u2705 Prometheus + OpenTelemetry\n  prometheus_port: 9090\n  opentelemetry_endpoint: http://otel-collector:4317\n</code></pre> <p>Vorteile: - Prometheus: Pull-based Metriken f\u00fcr Alerting - OpenTelemetry: Push-based f\u00fcr Traces + Metrics</p>"},{"location":"guides/LOGGING_OBSERVABILITY/#6-log-rotation-konfigurieren","title":"6. Log Rotation konfigurieren","text":"<p>Empfehlung: Konfiguriere Log Rotation mit <code>logrotate</code>.</p> <pre><code># /etc/logrotate.d/gateway\n/var/log/gateway/*.log {\n    daily\n    rotate 7\n    compress\n    delaycompress\n    notifempty\n    create 0644 root root\n    sharedscripts\n    postrotate\n        # Signal reload (provider-spezifisch)\n        systemctl reload envoy || true\n    endscript\n}\n</code></pre>"},{"location":"guides/LOGGING_OBSERVABILITY/#7-zentrale-log-aggregation-verwenden","title":"7. Zentrale Log-Aggregation verwenden","text":"<p>Empfehlung: Verwende zentrale Log-Aggregation (ELK, Grafana Loki, Splunk).</p> <p>Setup-Beispiel mit Fluentd: <pre><code># fluentd.conf\n&lt;source&gt;\n  @type tail\n  path /var/log/gateway/access.log\n  pos_file /var/log/td-agent/gateway.pos\n  tag gateway.access\n  &lt;parse&gt;\n    @type json\n    time_format %Y-%m-%dT%H:%M:%S.%NZ\n  &lt;/parse&gt;\n&lt;/source&gt;\n\n&lt;match gateway.**&gt;\n  @type elasticsearch\n  host elasticsearch.internal\n  port 9200\n  logstash_format true\n  logstash_prefix gateway\n&lt;/match&gt;\n</code></pre></p>"},{"location":"guides/LOGGING_OBSERVABILITY/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/LOGGING_OBSERVABILITY/#problem-1-logs-werden-nicht-geschrieben","title":"Problem 1: Logs werden nicht geschrieben","text":"<p>Symptome: - Access Log Datei bleibt leer - Keine Log-Eintr\u00e4ge sichtbar</p> <p>L\u00f6sungen:</p> <ol> <li> <p>Pr\u00fcfe Dateiberechtigungen: <pre><code># Verzeichnis und Datei erstellen\nsudo mkdir -p /var/log/gateway\nsudo touch /var/log/gateway/access.log\nsudo chown gateway:gateway /var/log/gateway/access.log\nsudo chmod 644 /var/log/gateway/access.log\n</code></pre></p> </li> <li> <p>Pr\u00fcfe Gateway-Prozess Benutzer: <pre><code># Envoy\nps aux | grep envoy\n# User muss Schreibrechte auf Log-Datei haben\n</code></pre></p> </li> <li> <p>Pr\u00fcfe Logging-Konfiguration: <pre><code>logging:\n  enabled: true  # \u2705 Muss true sein\n  access_log_path: /var/log/gateway/access.log  # Pfad pr\u00fcfen\n</code></pre></p> </li> </ol>"},{"location":"guides/LOGGING_OBSERVABILITY/#problem-2-json-parsing-fehler","title":"Problem 2: JSON Parsing Fehler","text":"<p>Symptome: - Log-Aggregator kann JSON nicht parsen - Fehlermeldung: \"Invalid JSON\"</p> <p>L\u00f6sungen:</p> <ol> <li> <p>Pr\u00fcfe JSON Format: <pre><code># Teste ob Log valides JSON ist\ntail -1 /var/log/gateway/access.log | jq .\n</code></pre></p> </li> <li> <p>Escape Sonderzeichen in Custom Fields: <pre><code>logging:\n  custom_fields:\n    description: \"API Gateway\"  # \u2705 Mit Quotes\n    # description: API Gateway  # \u274c K\u00f6nnte Probleme verursachen\n</code></pre></p> </li> <li> <p>Provider-spezifische Syntax pr\u00fcfen: <pre><code># Nginx: Escape JSON\nlog_format json_combined escape=json\n  '{...}';\n</code></pre></p> </li> </ol>"},{"location":"guides/LOGGING_OBSERVABILITY/#problem-3-prometheus-metriken-nicht-verfugbar","title":"Problem 3: Prometheus Metriken nicht verf\u00fcgbar","text":"<p>Symptome: - <code>/metrics</code> Endpoint gibt 404 - Prometheus kann Gateway nicht scrapen</p> <p>L\u00f6sungen:</p> <ol> <li> <p>Pr\u00fcfe Metrics-Konfiguration: <pre><code>metrics:\n  enabled: true  # \u2705 Muss true sein\n  exporter: prometheus\n  prometheus_port: 9090\n</code></pre></p> </li> <li> <p>Pr\u00fcfe Provider-spezifischen Endpoint: <pre><code># Envoy\ncurl http://localhost:9901/stats/prometheus\n\n# Kong\ncurl http://localhost:8001/metrics\n\n# APISIX\ncurl http://localhost:9091/apisix/prometheus/metrics\n\n# Traefik (ben\u00f6tigt static config!)\ncurl http://localhost:8082/metrics\n</code></pre></p> </li> <li> <p>Firewall-Regeln pr\u00fcfen: <pre><code># Port 9090 \u00f6ffnen\nsudo ufw allow 9090/tcp\n</code></pre></p> </li> </ol>"},{"location":"guides/LOGGING_OBSERVABILITY/#problem-4-hoher-disk-space-verbrauch","title":"Problem 4: Hoher Disk Space Verbrauch","text":"<p>Symptome: - Log-Dateien wachsen sehr schnell - Disk Space l\u00e4uft voll</p> <p>L\u00f6sungen:</p> <ol> <li> <p>Log Sampling aktivieren: <pre><code>logging:\n  sample_rate: 0.1  # Nur 10% loggen\n</code></pre></p> </li> <li> <p>Health Check Endpoints ausschlie\u00dfen: <pre><code>logging:\n  exclude_paths:\n    - /health\n    - /metrics\n    - /ping\n</code></pre></p> </li> <li> <p>Log Rotation einrichten: <pre><code># /etc/logrotate.d/gateway\n/var/log/gateway/*.log {\n    daily\n    rotate 7\n    compress\n}\n</code></pre></p> </li> <li> <p>Log Level erh\u00f6hen: <pre><code>logging:\n  level: warning  # Nur Warnings/Errors (statt info/debug)\n</code></pre></p> </li> </ol>"},{"location":"guides/LOGGING_OBSERVABILITY/#problem-5-opentelemetry-connection-failed","title":"Problem 5: OpenTelemetry Connection Failed","text":"<p>Symptome: - OpenTelemetry Metriken werden nicht exportiert - Fehlermeldung: \"Connection refused\"</p> <p>L\u00f6sungen:</p> <ol> <li> <p>Pr\u00fcfe OpenTelemetry Collector: <pre><code># Ist Collector erreichbar?\ncurl http://otel-collector:4317\n</code></pre></p> </li> <li> <p>Pr\u00fcfe Endpoint-Konfiguration: <pre><code>metrics:\n  exporter: opentelemetry\n  opentelemetry_endpoint: http://otel-collector:4317  # gRPC Endpoint\n  # NICHT: http://otel-collector:4318  # Das ist HTTP\n</code></pre></p> </li> <li> <p>Netzwerk-Konnektivit\u00e4t pr\u00fcfen: <pre><code># Von Gateway-Container aus\nping otel-collector\ntelnet otel-collector 4317\n</code></pre></p> </li> </ol>"},{"location":"guides/LOGGING_OBSERVABILITY/#problem-6-log-performance-impact","title":"Problem 6: Log Performance Impact","text":"<p>Symptome: - Gateway wird langsam - Hohe CPU/Memory Nutzung durch Logging</p> <p>L\u00f6sungen:</p> <ol> <li> <p>Asynchrones Logging aktivieren (provider-spezifisch): <pre><code># Nginx\naccess_log /var/log/nginx/access.log buffer=32k flush=5s;\n</code></pre></p> </li> <li> <p>Log Sampling verwenden: <pre><code>logging:\n  sample_rate: 0.5  # 50% weniger Writes\n</code></pre></p> </li> <li> <p>Logs auf schnelleres Storage verschieben: <pre><code># SSD statt HDD\n# Oder RAM Disk f\u00fcr sehr hohen Traffic\nsudo mount -t tmpfs -o size=1G tmpfs /var/log/gateway\n</code></pre></p> </li> <li> <p>Body Logging deaktivieren: <pre><code>logging:\n  include_request_body: false   # \u2705\n  include_response_body: false  # \u2705\n</code></pre></p> </li> </ol>"},{"location":"guides/LOGGING_OBSERVABILITY/#zusammenfassung","title":"Zusammenfassung","text":"<p>Logging &amp; Observability bietet:</p> <p>\u2705 Strukturiertes Logging: JSON/Text Logs mit Custom Fields \u2705 Metriken-Export: Prometheus &amp; OpenTelemetry \u2705 Log Sampling: Traffic-Reduzierung bei High Load \u2705 Provider-agnostisch: Einheitliche Config f\u00fcr alle 6 Provider \u2705 Production-Ready: Best Practices und Troubleshooting</p> <p>N\u00e4chste Schritte: 1. Logging in Production aktivieren 2. Prometheus Scraping einrichten 3. Log-Aggregation Setup (ELK/Loki) 4. Alerting Rules konfigurieren 5. Dashboards erstellen (Grafana)</p> <p>Siehe auch: - Timeout &amp; Retry Policies - Health Checks &amp; Load Balancing - Authentication Guide</p>"},{"location":"guides/NGINX/","title":"Nginx Provider Anleitung","text":"<p>Umfassende Anleitung f\u00fcr den Nginx Open Source Provider in GAL (Gateway Abstraction Layer)</p>"},{"location":"guides/NGINX/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ol> <li>\u00dcbersicht</li> <li>Schnellstart</li> <li>Installation und Setup</li> <li>Konfigurationsoptionen</li> <li>Feature-Implementierungen</li> <li>Provider-Vergleich</li> <li>Nginx-spezifische Details</li> <li>OpenResty Integration</li> <li>Best Practices</li> <li>Troubleshooting</li> </ol>"},{"location":"guides/NGINX/#ubersicht","title":"\u00dcbersicht","text":"<p>Nginx ist der #1 Web Server weltweit mit \u00fcber 30% Marktanteil. Als Open-Source Reverse Proxy und Load Balancer ist Nginx bekannt f\u00fcr:</p> <ul> <li>\u2705 Hohe Performance - Extrem ressourcenschonend</li> <li>\u2705 Stabilit\u00e4t - Bew\u00e4hrt in Production seit 2004</li> <li>\u2705 Einfachheit - Klare, lesbare Konfiguration</li> <li>\u2705 Flexibilit\u00e4t - Vielseitig einsetzbar</li> <li>\u2705 Community - Riesige Community und Dokumentation</li> </ul>"},{"location":"guides/NGINX/#warum-nginx-mit-gal","title":"Warum Nginx mit GAL?","text":"<p>GAL abstrahiert die Nginx-Konfiguration und erm\u00f6glicht: - \ud83d\udd04 Provider-Unabh\u00e4ngigkeit - Gleiche Config f\u00fcr alle Gateways - \ud83d\udcdd YAML statt nginx.conf - Einfachere Konfiguration - \ud83d\ude80 Schneller Start - Weniger Boilerplate - \ud83d\udd0d Validierung - Automatische Checks vor Deployment</p>"},{"location":"guides/NGINX/#unterstutzte-features","title":"Unterst\u00fctzte Features","text":"Feature Nginx Open Source Nginx Plus GAL Support Reverse Proxy \u2705 \u2705 \u2705 Full Load Balancing \u2705 \u2705 \u2705 Full Rate Limiting \u2705 \u2705 \u2705 Full Basic Auth \u2705 \u2705 \u2705 Full Header Manipulation \u2705 \u2705 \u2705 Full CORS \u2705 \u2705 \u2705 Full Passive Health Checks \u2705 \u2705 \u2705 Full Active Health Checks \u274c \u2705 \u26a0\ufe0f Plus only JWT Authentication \u26a0\ufe0f Lua \u2705 \u26a0\ufe0f OpenResty Dynamic Config \u274c \u2705 \u26a0\ufe0f Plus only API Key Auth \u26a0\ufe0f Lua \u2705 \u26a0\ufe0f OpenResty Circuit Breaker \u26a0\ufe0f Lua \u2705 \u26a0\ufe0f Limited <p>Legende: - \u2705 Full - Vollst\u00e4ndig unterst\u00fctzt - \u26a0\ufe0f Limited - Eingeschr\u00e4nkt oder ben\u00f6tigt Erweiterungen - \u274c Not Supported - Nicht verf\u00fcgbar</p>"},{"location":"guides/NGINX/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/NGINX/#1-basis-konfiguration-reverse-proxy","title":"1. Basis-Konfiguration (Reverse Proxy)","text":"<p>Einfachster Nginx Reverse Proxy:</p> <pre><code>version: \"1.0\"\nprovider: nginx\n\nglobal:\n  port: 80\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    host: backend.internal\n    port: 8080\n\n    routes:\n      - path_prefix: /api\n        methods: [GET, POST, PUT, DELETE]\n</code></pre> <p>Generieren: <pre><code>gal generate config.yaml --provider nginx &gt; nginx.conf\n</code></pre></p> <p>Resultat: <pre><code># Nginx Configuration Generated by GAL\n\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    # Basic Settings\n    include /etc/nginx/mime.types;\n    default_type application/octet-stream;\n    sendfile on;\n    keepalive_timeout 65;\n\n    # Server for api_service\n    server {\n        listen 80;\n        server_name api_service.local;\n\n        # Route: /api\n        location /api {\n            # Proxy to backend\n            proxy_pass http://backend.internal:8080;\n            proxy_http_version 1.1;\n            proxy_set_header Connection \"\";\n            proxy_connect_timeout 5s;\n            proxy_send_timeout 60s;\n            proxy_read_timeout 60s;\n        }\n    }\n}\n</code></pre></p>"},{"location":"guides/NGINX/#2-load-balancing","title":"2. Load Balancing","text":"<p>Mehrere Backend-Server mit Load Balancing:</p> <pre><code>version: \"1.0\"\nprovider: nginx\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n          weight: 2        # Erh\u00e4lt 2x mehr Traffic\n        - host: api-2.internal\n          port: 8080\n          weight: 1\n      load_balancer:\n        algorithm: least_conn  # Least Connections\n\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Generiert: <pre><code>upstream upstream_api_service {\n    least_conn;\n    server api-1.internal:8080 weight=2;\n    server api-2.internal:8080;\n    keepalive 32;\n}\n\nserver {\n    listen 80;\n    location /api {\n        proxy_pass http://upstream_api_service;\n    }\n}\n</code></pre></p>"},{"location":"guides/NGINX/#3-rate-limiting-basic-auth","title":"3. Rate Limiting + Basic Auth","text":"<p>API-Schutz mit Rate Limiting und Authentication:</p> <pre><code>version: \"1.0\"\nprovider: nginx\n\nservices:\n  - name: protected_api\n    type: rest\n    protocol: http\n    host: api.internal\n    port: 8080\n\n    routes:\n      - path_prefix: /api\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n          burst: 200\n          response_status: 429\n\n        authentication:\n          enabled: true\n          type: basic\n          basic_auth:\n            users:\n              admin: \"password\"\n              user: \"secret\"\n            realm: \"Protected API\"\n</code></pre> <p>Generiert: <pre><code>http {\n    # Rate Limiting Zones\n    limit_req_zone $binary_remote_addr zone=protected_api_route_0_ratelimit:10m rate=100r/s;\n\n    server {\n        location /api {\n            # Rate Limiting: 100 req/s, burst 200\n            limit_req zone=protected_api_route_0_ratelimit burst=200 nodelay;\n            limit_req_status 429;\n\n            # Basic Authentication\n            auth_basic \"Protected API\";\n            auth_basic_user_file /etc/nginx/.htpasswd;\n\n            proxy_pass http://api.internal:8080;\n        }\n    }\n}\n</code></pre></p> <p>Wichtig: Erstelle <code>.htpasswd</code> Datei: <pre><code>htpasswd -c /etc/nginx/.htpasswd admin\nhtpasswd /etc/nginx/.htpasswd user\n</code></pre></p>"},{"location":"guides/NGINX/#installation-und-setup","title":"Installation und Setup","text":""},{"location":"guides/NGINX/#nginx-installation","title":"Nginx Installation","text":"<p>Ubuntu/Debian: <pre><code>sudo apt update\nsudo apt install nginx\n</code></pre></p> <p>CentOS/RHEL: <pre><code>sudo yum install nginx\n</code></pre></p> <p>macOS: <pre><code>brew install nginx\n</code></pre></p>"},{"location":"guides/NGINX/#gal-cli-installation","title":"GAL CLI Installation","text":"<pre><code>pip install gal-gateway\n</code></pre>"},{"location":"guides/NGINX/#nginx-config-deployment","title":"Nginx Config Deployment","text":"<ol> <li> <p>Config generieren: <pre><code>gal generate gateway.yaml --provider nginx &gt; nginx.conf\n</code></pre></p> </li> <li> <p>Config testen: <pre><code>nginx -t -c nginx.conf\n</code></pre></p> </li> <li> <p>Config deployen: <pre><code>sudo cp nginx.conf /etc/nginx/nginx.conf\nsudo nginx -s reload\n</code></pre></p> </li> </ol> <p>Oder f\u00fcr lokales Testing: <pre><code>nginx -c $(pwd)/nginx.conf\n</code></pre></p>"},{"location":"guides/NGINX/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/NGINX/#global-configuration","title":"Global Configuration","text":"<pre><code>global:\n  port: 80           # Listen Port (default: 10000)\n  host: 0.0.0.0      # Listen Address\n  admin_port: 9901   # Nicht verwendet bei Nginx\n  timeout: \"30s\"     # Request Timeout\n</code></pre>"},{"location":"guides/NGINX/#upstream-configuration","title":"Upstream Configuration","text":"<pre><code>upstream:\n  targets:           # Liste von Backend-Servern\n    - host: server1.internal\n      port: 8080\n      weight: 2      # Load Balancing Gewicht (default: 1)\n\n  health_check:\n    passive:         # Passive Health Checks\n      enabled: true\n      max_failures: 3\n      unhealthy_status_codes: [500, 502, 503, 504]\n\n  load_balancer:\n    algorithm: round_robin  # round_robin, least_conn, ip_hash, weighted\n</code></pre> <p>Load Balancing Algorithmen:</p> Algorithm Beschreibung Nginx Direktive Use Case <code>round_robin</code> Gleichm\u00e4\u00dfige Verteilung (default) - Standard <code>least_conn</code> Zu Server mit wenigsten Verbindungen <code>least_conn;</code> Ungleiche Requests <code>ip_hash</code> Basierend auf Client-IP (Sticky) <code>ip_hash;</code> Session Persistence <code>weighted</code> Gewichtete Verteilung <code>weight=N</code> Heterogene Server"},{"location":"guides/NGINX/#route-configuration","title":"Route Configuration","text":"<pre><code>routes:\n  - path_prefix: /api           # Routing Pfad\n    methods: [GET, POST]        # Erlaubte HTTP Methoden\n\n    rate_limit:                 # Rate Limiting\n      enabled: true\n      requests_per_second: 100\n      burst: 200\n      key_type: ip_address      # ip_address, header\n      key_header: X-API-Key     # Falls key_type=header\n      response_status: 429\n\n    authentication:             # Authentication\n      enabled: true\n      type: basic               # basic, api_key, jwt\n      basic_auth:\n        users:\n          admin: password\n        realm: \"Protected\"\n\n    headers:                    # Header Manipulation\n      request_add:\n        X-Request-ID: \"{{uuid}}\"\n        X-Gateway: \"GAL\"\n      response_add:\n        X-Frame-Options: \"DENY\"\n      response_remove:\n        - X-Powered-By\n\n    cors:                       # CORS\n      enabled: true\n      allowed_origins: [\"https://app.example.com\"]\n      allowed_methods: [GET, POST]\n      allowed_headers: [Content-Type, Authorization]\n      allow_credentials: true\n      max_age: 86400\n</code></pre>"},{"location":"guides/NGINX/#feature-implementierungen","title":"Feature-Implementierungen","text":""},{"location":"guides/NGINX/#1-load-balancing","title":"1. Load Balancing","text":""},{"location":"guides/NGINX/#round-robin-default","title":"Round Robin (Default)","text":"<p>Gleichm\u00e4\u00dfige Verteilung \u00fcber alle Server:</p> <pre><code>upstream:\n  targets:\n    - host: server1\n      port: 8080\n    - host: server2\n      port: 8080\n  load_balancer:\n    algorithm: round_robin\n</code></pre> <p>Nginx Config: <pre><code>upstream upstream_service {\n    server server1:8080;\n    server server2:8080;\n}\n</code></pre></p>"},{"location":"guides/NGINX/#least-connections","title":"Least Connections","text":"<p>Bevorzugt Server mit wenigsten aktiven Verbindungen:</p> <pre><code>load_balancer:\n  algorithm: least_conn\n</code></pre> <p>Nginx Config: <pre><code>upstream upstream_service {\n    least_conn;\n    server server1:8080;\n    server server2:8080;\n}\n</code></pre></p> <p>Use Case: Backend-Server mit stark variierenden Request-Dauern.</p>"},{"location":"guides/NGINX/#ip-hash-session-persistence","title":"IP Hash (Session Persistence)","text":"<p>Client-IP bestimmt Backend-Server (Sticky Sessions):</p> <pre><code>load_balancer:\n  algorithm: ip_hash\n</code></pre> <p>Nginx Config: <pre><code>upstream upstream_service {\n    ip_hash;\n    server server1:8080;\n    server server2:8080;\n}\n</code></pre></p> <p>Use Case: Stateful Applications, Session Persistence.</p>"},{"location":"guides/NGINX/#weighted","title":"Weighted","text":"<p>Server mit unterschiedlichen Kapazit\u00e4ten:</p> <pre><code>upstream:\n  targets:\n    - host: powerful-server\n      port: 8080\n      weight: 3\n    - host: small-server\n      port: 8080\n      weight: 1\n</code></pre> <p>Nginx Config: <pre><code>upstream upstream_service {\n    server powerful-server:8080 weight=3;\n    server small-server:8080;\n}\n</code></pre></p> <p>Verteilung: 75% powerful-server, 25% small-server.</p>"},{"location":"guides/NGINX/#2-passive-health-checks","title":"2. Passive Health Checks","text":"<p>Nginx \u00fcberwacht Backend-Health basierend auf echtem Traffic:</p> <pre><code>upstream:\n  targets:\n    - host: backend1\n      port: 8080\n  health_check:\n    passive:\n      enabled: true\n      max_failures: 3           # Nach 3 Fehlern \u2192 unhealthy\n</code></pre> <p>Nginx Config: <pre><code>upstream upstream_service {\n    server backend1:8080 max_fails=3 fail_timeout=30s;\n}\n</code></pre></p> <p>Funktionsweise: - Bei 3 aufeinanderfolgenden Fehlern wird Server als \"down\" markiert - Nach 30 Sekunden wird Server wieder getestet - Fehler = 5xx Status Codes oder Timeouts</p> <p>\u26a0\ufe0f Limitation: Kann Server nicht proaktiv pr\u00fcfen (kein Active HC ohne Plus).</p>"},{"location":"guides/NGINX/#3-rate-limiting","title":"3. Rate Limiting","text":"<p>IP-basiertes Rate Limiting:</p> <pre><code>rate_limit:\n  enabled: true\n  requests_per_second: 100\n  burst: 200\n  key_type: ip_address\n  response_status: 429\n</code></pre> <p>Nginx Config: <pre><code>http {\n    limit_req_zone $binary_remote_addr zone=api_ratelimit:10m rate=100r/s;\n\n    server {\n        location /api {\n            limit_req zone=api_ratelimit burst=200 nodelay;\n            limit_req_status 429;\n        }\n    }\n}\n</code></pre></p> <p>Erkl\u00e4rung: - Zone: 10m = ~160.000 IP-Adressen - Rate: 100 Requests/Sekunde - Burst: Bis zu 200 Requests in Spitzen - nodelay: Keine k\u00fcnstliche Verz\u00f6gerung</p>"},{"location":"guides/NGINX/#header-basiertes-rate-limiting","title":"Header-basiertes Rate Limiting","text":"<p>Limitierung pro API-Key:</p> <pre><code>rate_limit:\n  enabled: true\n  requests_per_second: 50\n  key_type: header\n  key_header: X-API-Key\n</code></pre> <p>Nginx Config: <pre><code>limit_req_zone $http_x_api_key zone=api_ratelimit:10m rate=50r/s;\n</code></pre></p>"},{"location":"guides/NGINX/#4-authentication","title":"4. Authentication","text":""},{"location":"guides/NGINX/#basic-authentication","title":"Basic Authentication","text":"<p>Einfache Username/Password Auth:</p> <pre><code>authentication:\n  enabled: true\n  type: basic\n  basic_auth:\n    users:\n      admin: \"password\"\n    realm: \"Protected API\"\n</code></pre> <p>Nginx Config: <pre><code>location /api {\n    auth_basic \"Protected API\";\n    auth_basic_user_file /etc/nginx/.htpasswd;\n}\n</code></pre></p> <p>Setup: <pre><code># .htpasswd erstellen\nhtpasswd -c /etc/nginx/.htpasswd admin\n# Weitere User hinzuf\u00fcgen\nhtpasswd /etc/nginx/.htpasswd user2\n</code></pre></p>"},{"location":"guides/NGINX/#api-key-authentication","title":"API Key Authentication","text":"<p>\u26a0\ufe0f Ben\u00f6tigt Lua/OpenResty oder externe Authentication.</p> <pre><code>authentication:\n  type: api_key\n  api_key:\n    keys: [\"key_123abc\"]\n    key_name: X-API-Key\n    in_location: header\n</code></pre> <p>Nginx Config (Kommentar): <pre><code># API Key authentication not natively supported\n# Requires Lua or external authentication\n</code></pre></p> <p>Alternative: Nginx Plus mit <code>auth_request</code> Modul oder OpenResty.</p>"},{"location":"guides/NGINX/#jwt-authentication","title":"JWT Authentication","text":"<p>\u26a0\ufe0f Ben\u00f6tigt OpenResty/Lua (siehe OpenResty Integration).</p> <pre><code>authentication:\n  type: jwt\n  jwt:\n    issuer: \"https://auth.example.com\"\n    audience: \"api\"\n    jwks_uri: \"https://auth.example.com/.well-known/jwks.json\"\n</code></pre>"},{"location":"guides/NGINX/#5-header-manipulation","title":"5. Header Manipulation","text":""},{"location":"guides/NGINX/#request-headers","title":"Request Headers","text":"<pre><code>headers:\n  request_add:\n    X-Request-ID: \"{{uuid}}\"     # $request_id\n    X-Gateway: \"GAL\"\n    X-Timestamp: \"{{now}}\"        # $time_iso8601\n  request_set:\n    User-Agent: \"GAL-Gateway/1.0\"\n  request_remove:\n    - X-Internal-Token\n</code></pre> <p>Nginx Config: <pre><code>location /api {\n    # Request Headers\n    proxy_set_header X-Request-ID $request_id;\n    proxy_set_header X-Gateway 'GAL';\n    proxy_set_header X-Timestamp $time_iso8601;\n    proxy_set_header User-Agent 'GAL-Gateway/1.0';\n    proxy_set_header X-Internal-Token '';\n}\n</code></pre></p> <p>Template-Variablen: - <code>{{uuid}}</code> \u2192 <code>$request_id</code> - <code>{{now}}</code>, <code>{{timestamp}}</code> \u2192 <code>$time_iso8601</code></p>"},{"location":"guides/NGINX/#response-headers","title":"Response Headers","text":"<pre><code>headers:\n  response_add:\n    X-Frame-Options: \"DENY\"\n    X-Content-Type-Options: \"nosniff\"\n  response_set:\n    Server: \"GAL-Gateway\"\n  response_remove:\n    - X-Powered-By\n</code></pre> <p>Nginx Config: <pre><code>location /api {\n    # Response Headers\n    add_header X-Frame-Options 'DENY' always;\n    add_header X-Content-Type-Options 'nosniff' always;\n    add_header Server 'GAL-Gateway' always;\n\n    # Note: Response header removal requires ngx_headers_more module\n    # more_clear_headers 'X-Powered-By';\n}\n</code></pre></p> <p>\u26a0\ufe0f Response Header Removal ben\u00f6tigt <code>ngx_headers_more</code> Modul.</p>"},{"location":"guides/NGINX/#6-cors","title":"6. CORS","text":"<p>Cross-Origin Resource Sharing f\u00fcr SPAs:</p> <pre><code>cors:\n  enabled: true\n  allowed_origins:\n    - \"https://app.example.com\"\n    - \"https://www.example.com\"\n  allowed_methods: [GET, POST, PUT, DELETE, OPTIONS]\n  allowed_headers: [Content-Type, Authorization, X-API-Key]\n  expose_headers: [X-Request-ID, X-RateLimit-Remaining]\n  allow_credentials: true\n  max_age: 86400  # 24 hours\n</code></pre> <p>Nginx Config: <pre><code>location /api {\n    # CORS Configuration\n    add_header 'Access-Control-Allow-Origin' 'https://app.example.com' always;\n    add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;\n    add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization, X-API-Key' always;\n    add_header 'Access-Control-Expose-Headers' 'X-Request-ID, X-RateLimit-Remaining' always;\n    add_header 'Access-Control-Allow-Credentials' 'true' always;\n    add_header 'Access-Control-Max-Age' '86400' always;\n\n    # Handle preflight requests\n    if ($request_method = 'OPTIONS') {\n        return 204;\n    }\n}\n</code></pre></p> <p>Wichtig: <code>always</code> Flag stellt sicher, dass Headers auch bei Errors gesetzt werden.</p>"},{"location":"guides/NGINX/#provider-vergleich","title":"Provider-Vergleich","text":""},{"location":"guides/NGINX/#nginx-vs-andere-gateways","title":"Nginx vs. Andere Gateways","text":"Feature Nginx Kong APISIX Traefik Envoy Performance \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Memory Footprint \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 Lernkurve \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50 Community \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 Static Content \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50 \u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50 Dynamic Config \u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 Plugin Ecosystem \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 JWT Native \u274c \u2705 \u2705 \u26a0\ufe0f \u2705 Active HC \u274c \u2705 \u2705 \u2705 \u2705 Complexity Low Medium Medium Low High"},{"location":"guides/NGINX/#wann-nginx-nutzen","title":"Wann Nginx nutzen?","text":"<p>\u2705 Ideal f\u00fcr: - Static Content Serving + API Gateway Hybrid - Einfache Reverse Proxy Setups - Minimaler Memory Footprint erforderlich - Bew\u00e4hrte, stabile L\u00f6sung gew\u00fcnscht - Team hat Nginx-Erfahrung - On-Premises Deployment</p> <p>\u26a0\ufe0f Weniger geeignet f\u00fcr: - Hochdynamische Konfigurationen (ohne Plus) - Native JWT Validation erforderlich - Umfangreiche Plugin-Infrastruktur gew\u00fcnscht - Active Health Checks ohne Plus</p>"},{"location":"guides/NGINX/#feature-coverage-import-export","title":"Feature Coverage (Import &amp; Export)","text":"<p>Diese Sektion dokumentiert welche Nginx Features GAL in beide Richtungen unterst\u00fctzt: - Import: nginx.conf \u2192 GAL Config (v1.3.0 Feature 5) - Export: GAL Config \u2192 nginx.conf (seit v1.0)</p>"},{"location":"guides/NGINX/#vollstandig-unterstutzt-bidirektional","title":"\u2705 Vollst\u00e4ndig Unterst\u00fctzt (Bidirektional)","text":"<p>Features die in beide Richtungen vollst\u00e4ndig funktionieren:</p> Feature Nginx Direktive GAL Config Import Export Einschr\u00e4nkungen Upstream Block <code>upstream {}</code> <code>upstream.targets[]</code> \u2705 \u2705 - Load Balancing - Round Robin (default) <code>algorithm: round_robin</code> \u2705 \u2705 - Load Balancing - Least Conn <code>least_conn;</code> <code>algorithm: least_conn</code> \u2705 \u2705 - Load Balancing - IP Hash <code>ip_hash;</code> <code>algorithm: ip_hash</code> \u2705 \u2705 - Server Weights <code>server ... weight=N</code> <code>target.weight</code> \u2705 \u2705 - Passive Health Checks <code>max_fails</code>, <code>fail_timeout</code> <code>health_check.passive</code> \u2705 \u2705 OSS only Rate Limiting Zone <code>limit_req_zone</code> Rate limit config \u2705 \u2705 - Rate Limiting <code>limit_req zone=...</code> <code>rate_limit.*</code> \u2705 \u2705 - Rate Burst <code>burst=N</code> <code>rate_limit.burst</code> \u2705 \u2705 - Request Headers <code>proxy_set_header</code> <code>headers.request_add</code> \u2705 \u2705 - Response Headers <code>add_header</code> <code>headers.response_add</code> \u2705 \u2705 - CORS <code>add_header Access-Control-*</code> <code>cors.*</code> \u2705 \u2705 Extrahiert/Generiert Basic Auth Structure <code>auth_basic</code>, <code>auth_basic_user_file</code> <code>authentication.basic_auth</code> \u2705 \u2705 Htpasswd separat Location Blocks <code>location /path {}</code> <code>routes[]</code> \u2705 \u2705 - Proxy Pass <code>proxy_pass http://...</code> Service upstream link \u2705 \u2705 -"},{"location":"guides/NGINX/#eingeschrankt-unterstutzt","title":"\u26a0\ufe0f Eingeschr\u00e4nkt Unterst\u00fctzt","text":"<p>Features mit Limitierungen in Import oder Export:</p> Feature Import Status Export Status Einschr\u00e4nkung Active Health Checks \u274c Nicht unterst\u00fctzt \u26a0\ufe0f Kommentar Nginx OSS hat keine Active HC Server Names \u274c Ignoriert \u2705 Generiert Import: Wird nicht gespeichert Listen Ports \u274c Ignoriert \u2705 Global Config Import: Verwendet default port 80 SSL/TLS \u274c Nicht unterst\u00fctzt \u274c Nicht unterst\u00fctzt Nicht in GAL Config Model Comment Preservation \u274c Entfernt \u274c GAL Kommentare Comments werden nicht erhalten Basic Auth Users \u26a0\ufe0f Struktur only \u2705 Generiert htpasswd Import: htpasswd Datei nicht gelesen JWT Auth \u274c Nicht unterst\u00fctzt \u26a0\ufe0f Kommentar Ben\u00f6tigt OpenResty/Lua API Key Auth \u274c Nicht unterst\u00fctzt \u26a0\ufe0f Kommentar Ben\u00f6tigt OpenResty/Lua Response Header Removal \u274c Nicht unterst\u00fctzt \u26a0\ufe0f Kommentar Ben\u00f6tigt ngx_headers_more"},{"location":"guides/NGINX/#nicht-unterstutzt","title":"\u274c Nicht Unterst\u00fctzt","text":"<p>Features die weder Import noch Export unterst\u00fctzen:</p>"},{"location":"guides/NGINX/#complex-routing","title":"Complex Routing","text":"<ul> <li>if Direktiven - \"If is Evil\" in Nginx, nicht empfohlen</li> <li>map Direktiven - Variable Mappings</li> <li>rewrite Regeln - URL Rewriting</li> <li>return Direktiven - Redirects</li> <li>try_files - Fallback Logik</li> </ul>"},{"location":"guides/NGINX/#advanced-load-balancing","title":"Advanced Load Balancing","text":"<ul> <li>hash - Custom Hash mit Keys</li> <li>random - Random mit two Parameter</li> <li>least_time - Nginx Plus Feature</li> <li>Upstream zone - Shared Memory</li> </ul>"},{"location":"guides/NGINX/#connectionrequest-handling","title":"Connection/Request Handling","text":"<ul> <li>limit_conn - Connection Limiting (vs. Request Limiting)</li> <li>client_max_body_size - Request Body Size Limits</li> <li>client_body_timeout - Body Read Timeout</li> <li>proxy_timeout Varianten - Diverse Timeout Konfigurationen</li> <li>proxy_buffering - Buffer Konfiguration</li> </ul>"},{"location":"guides/NGINX/#security-access-control","title":"Security &amp; Access Control","text":"<ul> <li>allow / deny - IP-basierte ACLs</li> <li>satisfy - Access Control Logik (all vs. any)</li> <li>auth_request - Externe Authentication</li> <li>geo - GeoIP basierte Regeln</li> </ul>"},{"location":"guides/NGINX/#logging-monitoring","title":"Logging &amp; Monitoring","text":"<ul> <li>Custom log_format - Log Format Definitionen</li> <li>Conditional Logging - Bedingte Logs</li> <li>Access/Error Log Paths - Log Datei Pfade</li> <li>log_subrequest - Subrequest Logging</li> </ul>"},{"location":"guides/NGINX/#websocket-http2","title":"WebSocket &amp; HTTP/2","text":"<ul> <li>proxy_http_version 1.1 - F\u00fcr WebSocket</li> <li>Upgrade / Connection Headers - WebSocket Handshake</li> <li>HTTP/2 Push - Server Push</li> <li>grpc_pass - gRPC Proxying</li> </ul>"},{"location":"guides/NGINX/#stream-module","title":"Stream Module","text":"<ul> <li>stream {} Block - TCP/UDP Proxying</li> <li>Layer 4 Load Balancing - Transport Layer LB</li> </ul>"},{"location":"guides/NGINX/#import-feature-coverage-score","title":"\ud83d\udcca Import Feature Coverage Score","text":"<p>Methodik: Nur Features die f\u00fcr API Gateway Reverse Proxy relevant sind</p> <pre><code>Core HTTP Reverse Proxy Features: ~85% Coverage\n\u251c\u2500 Routing (location, proxy_pass): 100%\n\u251c\u2500 Load Balancing: 75% (3/4 Algorithmen)\n\u251c\u2500 Health Checks: 50% (nur passive)\n\u251c\u2500 Headers: 100%\n\u251c\u2500 Rate Limiting: 100%\n\u251c\u2500 Authentication: 40% (Basic struktur, kein JWT/OAuth)\n\u2514\u2500 CORS: 100%\n\nAdvanced Features: ~25% Coverage\n\u251c\u2500 URL Rewriting: 0%\n\u251c\u2500 Complex Routing (if/map): 0%\n\u251c\u2500 SSL/TLS: 0%\n\u251c\u2500 Access Control (allow/deny): 0%\n\u251c\u2500 Connection Limits: 0%\n\u2514\u2500 Custom Logging: 0%\n\nGesamt (API Gateway Use Case): ~70% Coverage\n</code></pre>"},{"location":"guides/NGINX/#export-feature-coverage-score","title":"\ud83d\udcc8 Export Feature Coverage Score","text":"<p>GAL \u2192 Nginx Export unterst\u00fctzt mehr Features:</p> <pre><code>Core HTTP Reverse Proxy Features: ~95% Coverage\n\u251c\u2500 Routing: 100%\n\u251c\u2500 Load Balancing: 100%\n\u251c\u2500 Health Checks: 50% (nur passive)\n\u251c\u2500 Headers: 100%\n\u251c\u2500 Rate Limiting: 100%\n\u251c\u2500 Authentication: 60% (Basic + API Key/JWT Comments)\n\u251c\u2500 CORS: 100%\n\u251c\u2500 Timeouts: 100%\n\u2514\u2500 WebSocket: 100% (Upgrade headers)\n\nAdvanced Features: ~30% Coverage\n\u251c\u2500 Circuit Breaker: 0% (Kommentar)\n\u251c\u2500 Body Transformation: 0% (Kommentar)\n\u251c\u2500 SSL/TLS: 0% (manuelle Config)\n\u251c\u2500 Metrics: 0% (Stub Status empfohlen)\n\u2514\u2500 Custom Logging: 50% (Format templates)\n\nGesamt: ~75% Coverage\n</code></pre>"},{"location":"guides/NGINX/#importexport-roundtrip-kompatibilitat","title":"\ud83d\udd04 Import/Export Roundtrip Kompatibilit\u00e4t","text":"<p>Kann ich nginx.conf importieren und wieder exportieren?</p> Szenario Funktioniert \u00c4nderungen Simple Reverse Proxy \u2705 100% Formatting Load Balancing \u2705 100% Formatting Rate Limiting \u2705 100% Zone Namen k\u00f6nnen variieren Headers + CORS \u2705 95% CORS wird extrahiert/regeneriert Basic Auth \u26a0\ufe0f 80% Htpasswd Datei muss manuell kopiert werden Complex Routing \u274c 30% if/map/rewrite gehen verloren SSL Config \u274c 0% SSL Direktiven nicht unterst\u00fctzt <p>Beispiel Roundtrip:</p> <p>Original nginx.conf: <pre><code>http {\n    limit_req_zone $binary_remote_addr zone=api:10m rate=100r/s;\n\n    upstream upstream_api {\n        least_conn;\n        server api-1:8080 weight=2;\n        server api-2:8080;\n    }\n\n    server {\n        location /api {\n            limit_req zone=api burst=200;\n            proxy_pass http://upstream_api;\n        }\n    }\n}\n</code></pre></p> <p>Nach Import \u2192 Export: <pre><code># Nginx Configuration Generated by GAL\n\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    # Rate Limiting Zones\n    limit_req_zone $binary_remote_addr zone=api_route_0_ratelimit:10m rate=100r/s;\n\n    # Upstream for api\n    upstream upstream_api {\n        least_conn;\n        server api-1:8080 weight=2;\n        server api-2:8080;\n        keepalive 32;\n    }\n\n    # Server for api\n    server {\n        listen 80;\n        server_name api.local;\n\n        # Route: /api\n        location /api {\n            # Rate Limiting: 100 req/s, burst 200\n            limit_req zone=api_route_0_ratelimit burst=200 nodelay;\n\n            proxy_pass http://upstream_api;\n            proxy_http_version 1.1;\n            proxy_set_header Connection \"\";\n        }\n    }\n}\n</code></pre></p> <p>Unterschiede: - \u2705 Logik identisch - \u26a0\ufe0f GAL Header hinzugef\u00fcgt - \u26a0\ufe0f Zone Name ge\u00e4ndert (<code>api</code> \u2192 <code>api_route_0_ratelimit</code>) - \u26a0\ufe0f Zus\u00e4tzliche Direktiven (<code>keepalive</code>, <code>events</code>, etc.) - \u26a0\ufe0f Formatting anders - \u26a0\ufe0f Comments entfernt</p>"},{"location":"guides/NGINX/#empfehlungen-fur-erweiterung","title":"\ud83c\udfaf Empfehlungen f\u00fcr Erweiterung","text":"<p>Quick Wins (hoher Impact, niedriger Aufwand):</p> <p>Import: 1. \u2705 <code>server_name</code> Parsing \u2192 Multi-Tenant Support 2. \u2705 <code>listen</code> Port Parsing \u2192 Explizite Ports statt Global Config 3. \u2705 <code>client_max_body_size</code> \u2192 Request Body Limits 4. \u2705 <code>allow</code>/<code>deny</code> \u2192 IP-basierte Access Control</p> <p>Export: 1. \u2705 SSL/TLS Template Generation \u2192 SSL Konfiguration 2. \u2705 Custom Log Format \u2192 Structured Logging 3. \u2705 Gzip Configuration \u2192 Performance Optimization</p> <p>Medium Aufwand:</p> <p>Import: 5. \u26a0\ufe0f <code>rewrite</code> Regeln \u2192 URL Rewriting 6. \u26a0\ufe0f <code>map</code> Direktiven \u2192 Variable Mapping 7. \u26a0\ufe0f <code>if</code> Direktiven \u2192 Conditional Logic (mit Warnungen) 8. \u26a0\ufe0f <code>limit_conn</code> \u2192 Connection Limiting</p> <p>Export: 5. \u26a0\ufe0f Response Header Removal \u2192 ngx_headers_more Detection 6. \u26a0\ufe0f JWT Auth Templates \u2192 OpenResty Code Templates</p> <p>Hoher Aufwand:</p> <ol> <li>\u274c <code>stream {}</code> Block \u2192 Layer 4 Proxying</li> <li>\u274c Vollst\u00e4ndiges SSL/TLS Management</li> </ol>"},{"location":"guides/NGINX/#import-testing-matrix","title":"\ud83d\udd0d Import Testing Matrix","text":"<p>GAL testet den Nginx Import mit folgenden Szenarien:</p> Test Kategorie Tests Coverage Basic Import 3 Simple upstream, Multiple servers, Comments Load Balancing 3 round_robin, least_conn, ip_hash Health Checks 1 Passive health checks (max_fails) Rate Limiting 2 Per second, Per minute conversion Authentication 1 Basic auth with htpasswd warning Headers 2 Request headers, Response headers CORS 2 CORS extraction, Wildcard origins Multiple Locations 1 Multiple location blocks Error Handling 2 Empty config, No http block Combined 1 Production config with all features Gesamt 18 Alle passing \u2705 <p>Test Coverage: nginx.py 6% \u2192 38% (+32%)</p>"},{"location":"guides/NGINX/#fazit","title":"\u2705 Fazit","text":"<p>F\u00fcr typische API Gateway Migrationen:</p> <p>nginx.conf \u2192 GAL (Import): - \u2705 ~70% der g\u00e4ngigen Features werden unterst\u00fctzt - \u2705 Perfekt f\u00fcr: Simple Reverse Proxy, Load Balancing, Rate Limiting - \u26a0\ufe0f Eingeschr\u00e4nkt: Complex Routing, SSL/TLS, Custom Logging - \u274c Nicht unterst\u00fctzt: Advanced Nginx Features, Layer 4 Proxying</p> <p>GAL \u2192 nginx.conf (Export): - \u2705 ~75% Feature Support - \u2705 Production-ready nginx.conf Generierung - \u2705 Best Practices eingebaut (keepalive, timeouts, etc.) - \u26a0\ufe0f JWT/API Key als Kommentare (OpenResty erforderlich) - \u274c Keine SSL/TLS Auto-Config</p> <p>Empfehlung: - \ud83d\ude80 F\u00fcr Standard API Gateway Workloads: Vollst\u00e4ndig ausreichend - \u26a0\ufe0f F\u00fcr komplexe Nginx Setups: Manuelle Nachbearbeitung n\u00f6tig - \ud83d\udcda F\u00fcr Nginx \u2192 GAL Migration: 70% automatisiert, 30% Review</p>"},{"location":"guides/NGINX/#nginx-directive-coverage","title":"Nginx Directive Coverage","text":"<p>Detaillierte Analyse basierend auf dem offiziellen Nginx Directive Index.</p>"},{"location":"guides/NGINX/#core-http-directives-ngx_http_core_module","title":"Core HTTP Directives (ngx_http_core_module)","text":"Directive Import Export Status Bemerkung <code>server</code> \u2705 \u2705 Voll Server-Bl\u00f6cke mit listen/server_name <code>location</code> \u2705 \u2705 Voll Location-Bl\u00f6cke mit Pfad-Matching <code>listen</code> \u2705 \u2705 Voll Port-Konfiguration <code>server_name</code> \u2705 \u2705 Voll Hostname/Domain <code>root</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Nur bei statischen Dateien <code>alias</code> \u274c \u274c Nicht Statische Dateien <code>try_files</code> \u274c \u274c Nicht Statische Dateien <code>error_page</code> \u274c \u274c Nicht Custom Error Pages <code>client_max_body_size</code> \u274c \u274c Nicht Request Body Limit <code>client_body_timeout</code> \u274c \u274c Nicht Timeout Settings <code>keepalive_timeout</code> \u274c \u2705 Export Generiert mit Default 65s"},{"location":"guides/NGINX/#upstream-directives-ngx_http_upstream_module","title":"Upstream Directives (ngx_http_upstream_module)","text":"Directive Import Export Status Bemerkung <code>upstream</code> \u2705 \u2705 Voll Upstream-Bl\u00f6cke <code>server</code> (upstream) \u2705 \u2705 Voll Backend-Server mit IP:Port <code>weight</code> \u2705 \u2705 Voll Load Balancing Gewichte <code>max_fails</code> \u2705 \u2705 Voll Health Check Schwellwert <code>fail_timeout</code> \u2705 \u2705 Voll Health Check Timeout <code>backup</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Backup-Server (eingeschr\u00e4nkt) <code>down</code> \u274c \u274c Nicht Manuell deaktivierte Server <code>max_conns</code> \u274c \u274c Nicht Connection Limit <code>zone</code> \u274c \u274c Nicht Shared Memory (Nginx Plus) <code>least_conn</code> \u2705 \u2705 Voll Least Connections Algorithm <code>ip_hash</code> \u2705 \u2705 Voll IP Hash Algorithm <code>hash</code> \u2705 \u2705 Voll Generic Hash Algorithm <code>random</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Random Selection <code>keepalive</code> \u274c \u274c Nicht Upstream Keepalive Connections"},{"location":"guides/NGINX/#proxy-directives-ngx_http_proxy_module","title":"Proxy Directives (ngx_http_proxy_module)","text":"Directive Import Export Status Bemerkung <code>proxy_pass</code> \u2705 \u2705 Voll Backend Proxying <code>proxy_set_header</code> \u2705 \u2705 Voll Request Header Manipulation <code>proxy_hide_header</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Response Header Removal <code>proxy_pass_header</code> \u274c \u274c Nicht Header Forwarding <code>proxy_connect_timeout</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Timeout (wenn in GAL Config) <code>proxy_read_timeout</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Timeout (wenn in GAL Config) <code>proxy_send_timeout</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Timeout (wenn in GAL Config) <code>proxy_buffering</code> \u274c \u274c Nicht Response Buffering <code>proxy_buffer_size</code> \u274c \u274c Nicht Buffer Configuration <code>proxy_redirect</code> \u274c \u274c Nicht Redirect Rewriting <code>proxy_next_upstream</code> \u274c \u274c Nicht Retry Logic <code>proxy_ssl_verify</code> \u274c \u274c Nicht SSL Backend Verification"},{"location":"guides/NGINX/#rate-limiting-directives-ngx_http_limit_req_module","title":"Rate Limiting Directives (ngx_http_limit_req_module)","text":"Directive Import Export Status Bemerkung <code>limit_req_zone</code> \u2705 \u2705 Voll Rate Limit Zone Definition <code>limit_req</code> \u2705 \u2705 Voll Rate Limit Application <code>limit_req_status</code> \u274c \u274c Nicht Custom HTTP Status Code <code>limit_req_level</code> \u274c \u274c Nicht Log Level Configuration"},{"location":"guides/NGINX/#authentication-directives-ngx_http_auth_basic_module","title":"Authentication Directives (ngx_http_auth_basic_module)","text":"Directive Import Export Status Bemerkung <code>auth_basic</code> \u2705 \u2705 Voll Basic Auth Realm <code>auth_basic_user_file</code> \u2705 \u2705 Voll htpasswd File Path"},{"location":"guides/NGINX/#headers-directives-ngx_http_headers_module","title":"Headers Directives (ngx_http_headers_module)","text":"Directive Import Export Status Bemerkung <code>add_header</code> \u2705 \u2705 Voll Response Header Hinzuf\u00fcgen <code>expires</code> \u274c \u274c Nicht Cache-Control/Expires Headers <code>add_trailer</code> \u274c \u274c Nicht HTTP Trailer Headers"},{"location":"guides/NGINX/#cors-relevante-directives","title":"CORS-relevante Directives","text":"Directive Import Export Status Bemerkung <code>add_header Access-Control-Allow-Origin</code> \u2705 \u2705 Voll CORS Origin <code>add_header Access-Control-Allow-Methods</code> \u2705 \u2705 Voll CORS Methods <code>add_header Access-Control-Allow-Headers</code> \u2705 \u2705 Voll CORS Headers <code>add_header Access-Control-Allow-Credentials</code> \u2705 \u2705 Voll CORS Credentials <code>add_header Access-Control-Max-Age</code> \u2705 \u2705 Voll CORS Preflight Cache"},{"location":"guides/NGINX/#nicht-unterstutzte-module-api-gateway-irrelevant","title":"Nicht unterst\u00fctzte Module (API Gateway irrelevant)","text":"<p>Diese Directives sind f\u00fcr API Gateway Workloads nicht relevant:</p> <p>ngx_http_fastcgi_module: - <code>fastcgi_pass</code>, <code>fastcgi_param</code>, <code>fastcgi_index</code> - PHP/FastCGI Backend - F\u00fcr API Gateways nicht relevant (verwende <code>proxy_pass</code> f\u00fcr HTTP Backends)</p> <p>ngx_http_uwsgi_module: - <code>uwsgi_pass</code>, <code>uwsgi_param</code> - Python WSGI Backend - F\u00fcr API Gateways nicht relevant</p> <p>ngx_http_scgi_module: - <code>scgi_pass</code>, <code>scgi_param</code> - SCGI Backend - F\u00fcr API Gateways nicht relevant</p> <p>ngx_http_memcached_module: - <code>memcached_pass</code> - Memcached Integration - Nicht Teil der GAL Scope</p> <p>ngx_http_ssl_module: - SSL/TLS Konfiguration (siehe Abschnitt \"SSL/TLS Termination\") - Wird manuell hinzugef\u00fcgt, nicht von GAL generiert</p> <p>ngx_http_gzip_module: - Compression - nicht Teil der GAL Scope - Wird in Production empfohlen, aber manuell konfiguriert</p> <p>ngx_http_rewrite_module: - <code>rewrite</code>, <code>return</code>, <code>set</code> - URL Rewriting - Komplex, au\u00dferhalb GAL Scope</p>"},{"location":"guides/NGINX/#coverage-score-nach-modulen","title":"Coverage Score nach Modulen","text":"Modul Directives Total Unterst\u00fctzt Coverage ngx_http_core_module 11 4 voll, 1 teilweise ~40% ngx_http_upstream_module 13 7 voll, 2 teilweise ~65% ngx_http_proxy_module 12 2 voll, 4 teilweise ~50% ngx_http_limit_req_module 4 2 voll 50% ngx_http_auth_basic_module 2 2 voll 100% ngx_http_headers_module 8 6 voll 75% <p>Gesamt (API Gateway relevante Directives): ~62% Coverage</p>"},{"location":"guides/NGINX/#empfehlungen-fur-zukunftige-erweiterungen","title":"Empfehlungen f\u00fcr zuk\u00fcnftige Erweiterungen","text":"<p>Priorit\u00e4t 1 (High Impact): 1. <code>client_max_body_size</code> - Request Size Limits 2. <code>error_page</code> - Custom Error Pages 3. <code>proxy_connect_timeout</code> / <code>proxy_read_timeout</code> - Vollst\u00e4ndige Timeout Kontrolle 4. <code>proxy_next_upstream</code> - Retry Logic</p> <p>Priorit\u00e4t 2 (Medium Impact): 5. <code>keepalive</code> (upstream) - Connection Pooling 6. <code>max_conns</code> - Connection Limits 7. <code>proxy_buffering</code> / <code>proxy_buffer_size</code> - Performance Tuning 8. <code>client_body_timeout</code> - Request Timeouts</p> <p>Priorit\u00e4t 3 (Nice to Have): 9. <code>proxy_redirect</code> - Redirect Rewriting 10. <code>limit_req_status</code> / <code>limit_req_level</code> - Rate Limit Customization</p> <p>Referenzen: - \ud83d\udcda Nginx Directive Index - \ud83d\udcda ngx_http_core_module - \ud83d\udcda ngx_http_upstream_module - \ud83d\udcda ngx_http_proxy_module</p>"},{"location":"guides/NGINX/#nginx-spezifische-details","title":"Nginx-spezifische Details","text":""},{"location":"guides/NGINX/#nginxconf-struktur","title":"nginx.conf Struktur","text":"<p>GAL generiert folgende Struktur:</p> <pre><code>events {\n    worker_connections 1024;\n}\n\nhttp {\n    # Basic Settings\n    include /etc/nginx/mime.types;\n    default_type application/octet-stream;\n    sendfile on;\n    keepalive_timeout 65;\n\n    # Logging\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log;\n\n    # Rate Limiting Zones (global)\n    limit_req_zone ...\n\n    # Upstream Blocks\n    upstream upstream_service1 { ... }\n    upstream upstream_service2 { ... }\n\n    # Server Blocks\n    server {\n        listen 80;\n        server_name service1.local;\n\n        # Location Blocks\n        location /api { ... }\n        location /v2 { ... }\n    }\n\n    server {\n        listen 80;\n        server_name service2.local;\n        ...\n    }\n}\n</code></pre>"},{"location":"guides/NGINX/#worker-configuration","title":"Worker Configuration","text":"<p>F\u00fcr Production solltest du Worker-Prozesse anpassen:</p> <pre><code># Am Anfang der nginx.conf (vor events)\nuser www-data;\nworker_processes auto;  # Anzahl CPU Cores\npid /run/nginx.pid;\n\nevents {\n    worker_connections 4096;  # Pro Worker\n    multi_accept on;\n}\n</code></pre>"},{"location":"guides/NGINX/#ssltls-termination","title":"SSL/TLS Termination","text":"<p>F\u00fcge SSL manuell hinzu (noch nicht von GAL unterst\u00fctzt):</p> <pre><code>server {\n    listen 443 ssl http2;\n    server_name api.example.com;\n\n    ssl_certificate /etc/nginx/ssl/cert.pem;\n    ssl_certificate_key /etc/nginx/ssl/key.pem;\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers HIGH:!aNULL:!MD5;\n\n    location /api {\n        proxy_pass http://upstream_service;\n    }\n}\n</code></pre>"},{"location":"guides/NGINX/#logging-configuration","title":"Logging Configuration","text":"<p>Custom Access Log Format:</p> <pre><code>http {\n    log_format gal_format '$remote_addr - $remote_user [$time_local] '\n                         '\"$request\" $status $body_bytes_sent '\n                         '\"$http_referer\" \"$http_user_agent\" '\n                         'rt=$request_time uct=\"$upstream_connect_time\" '\n                         'uht=\"$upstream_header_time\" urt=\"$upstream_response_time\"';\n\n    access_log /var/log/nginx/access.log gal_format;\n}\n</code></pre>"},{"location":"guides/NGINX/#openresty-integration-optional","title":"OpenResty Integration (Optional)","text":"<p>OpenResty erweitert Nginx mit LuaJIT f\u00fcr dynamische Features.</p>"},{"location":"guides/NGINX/#installation","title":"Installation","text":"<pre><code># Ubuntu/Debian\nsudo apt install openresty\n\n# macOS\nbrew install openresty/brew/openresty\n</code></pre>"},{"location":"guides/NGINX/#jwt-authentication-mit-openresty","title":"JWT Authentication mit OpenResty","text":"<p>Installiere <code>lua-resty-jwt</code>:</p> <pre><code>opm get SkyLothar/lua-resty-jwt\n</code></pre> <p>Nginx Config (manuell): <pre><code>location /api {\n    access_by_lua_block {\n        local jwt = require \"resty.jwt\"\n        local validators = require \"resty.jwt-validators\"\n\n        local auth_header = ngx.var.http_Authorization\n        if not auth_header then\n            ngx.status = 401\n            ngx.say(\"Missing Authorization header\")\n            return ngx.exit(401)\n        end\n\n        local token = string.gsub(auth_header, \"^Bearer \", \"\")\n\n        local jwt_obj = jwt:verify(\"YOUR_SECRET_KEY\", token, {\n            iss = validators.equals(\"https://auth.example.com\"),\n            aud = validators.equals(\"api\"),\n        })\n\n        if not jwt_obj[\"verified\"] then\n            ngx.status = 401\n            ngx.say(\"Invalid token: \" .. jwt_obj.reason)\n            return ngx.exit(401)\n        end\n    }\n\n    proxy_pass http://backend;\n}\n</code></pre></p> <p>\u26a0\ufe0f Hinweis: GAL generiert Kommentare f\u00fcr JWT, die du durch OpenResty-Code ersetzen musst.</p>"},{"location":"guides/NGINX/#best-practices","title":"Best Practices","text":""},{"location":"guides/NGINX/#1-worker-configuration","title":"1. Worker Configuration","text":"<pre><code>worker_processes auto;  # 1 pro CPU Core\nworker_rlimit_nofile 65535;\n\nevents {\n    worker_connections 4096;\n    use epoll;  # Linux\n    multi_accept on;\n}\n</code></pre>"},{"location":"guides/NGINX/#2-connection-pooling","title":"2. Connection Pooling","text":"<pre><code>upstream backend {\n    server backend1:8080;\n    keepalive 32;  # Keep 32 idle connections\n    keepalive_requests 100;\n    keepalive_timeout 60s;\n}\n</code></pre>"},{"location":"guides/NGINX/#3-timeouts","title":"3. Timeouts","text":"<pre><code>proxy_connect_timeout 5s;\nproxy_send_timeout 60s;\nproxy_read_timeout 60s;\nclient_body_timeout 30s;\nclient_header_timeout 30s;\n</code></pre>"},{"location":"guides/NGINX/#4-buffer-sizes","title":"4. Buffer Sizes","text":"<pre><code>client_body_buffer_size 128k;\nclient_max_body_size 10m;\nproxy_buffer_size 4k;\nproxy_buffers 8 4k;\nproxy_busy_buffers_size 8k;\n</code></pre>"},{"location":"guides/NGINX/#5-security-headers","title":"5. Security Headers","text":"<pre><code>add_header X-Frame-Options \"DENY\" always;\nadd_header X-Content-Type-Options \"nosniff\" always;\nadd_header X-XSS-Protection \"1; mode=block\" always;\nadd_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n</code></pre>"},{"location":"guides/NGINX/#6-rate-limiting-best-practices","title":"6. Rate Limiting Best Practices","text":"<ul> <li>Zone Size: 10m = ~160k IPs, 100m = ~1.6M IPs</li> <li>Burst: 2x <code>requests_per_second</code> als Faustregel</li> <li>nodelay: Verwende immer <code>nodelay</code> f\u00fcr API Gateways</li> <li>Key Selection: W\u00e4hle zwischen IP, Header, JWT Claim basierend auf Use Case</li> </ul>"},{"location":"guides/NGINX/#7-health-checks","title":"7. Health Checks","text":"<ul> <li>max_fails: 3-5 f\u00fcr Production</li> <li>fail_timeout: 10s-30s (Balance zwischen Fehlertoleranz und Recovery)</li> <li>Monitoring: Nutze Nginx Stub Status oder Prometheus Exporter</li> </ul>"},{"location":"guides/NGINX/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/NGINX/#problem-too-many-open-files","title":"Problem: \"Too many open files\"","text":"<p>Symptom: <pre><code>nginx: [emerg] socket() failed (24: Too many open files)\n</code></pre></p> <p>L\u00f6sung: <pre><code>worker_rlimit_nofile 65535;\n</code></pre></p> <p>Oder System Limit erh\u00f6hen: <pre><code>ulimit -n 65535\n</code></pre></p>"},{"location":"guides/NGINX/#problem-rate-limiting-funktioniert-nicht","title":"Problem: Rate Limiting funktioniert nicht","text":"<p>Check: 1. Zone definiert in <code>http</code> Block? <pre><code>http {\n    limit_req_zone $binary_remote_addr zone=myzone:10m rate=100r/s;\n}\n</code></pre></p> <ol> <li> <p>Zone referenziert in <code>location</code>? <pre><code>location /api {\n    limit_req zone=myzone burst=200 nodelay;\n}\n</code></pre></p> </li> <li> <p>Log-Datei pr\u00fcfen: <pre><code>tail -f /var/log/nginx/error.log | grep limit_req\n</code></pre></p> </li> </ol>"},{"location":"guides/NGINX/#problem-upstream-server-wird-nicht-erreicht","title":"Problem: Upstream Server wird nicht erreicht","text":"<p>Debug: <pre><code>error_log /var/log/nginx/error.log debug;\n</code></pre></p> <p>Check: 1. Server erreichbar? <pre><code>curl http://backend:8080/health\n</code></pre></p> <ol> <li> <p>DNS korrekt? <pre><code>nslookup backend.internal\n</code></pre></p> </li> <li> <p>Firewall Rules? <pre><code>sudo iptables -L -n\n</code></pre></p> </li> </ol>"},{"location":"guides/NGINX/#problem-cors-funktioniert-nicht","title":"Problem: CORS funktioniert nicht","text":"<p>H\u00e4ufiger Fehler: <code>always</code> Flag vergessen.</p> <p>Richtig: <pre><code>add_header 'Access-Control-Allow-Origin' '*' always;\n</code></pre></p> <p>Falsch: <pre><code>add_header 'Access-Control-Allow-Origin' '*';  # Nur bei 200 OK\n</code></pre></p>"},{"location":"guides/NGINX/#problem-config-reload-schlagt-fehl","title":"Problem: Config Reload schl\u00e4gt fehl","text":"<p>Test vor Reload: <pre><code>nginx -t -c /etc/nginx/nginx.conf\n</code></pre></p> <p>H\u00e4ufige Fehler: - Fehlende Semikolons - Unbalanced Brackets - Ung\u00fcltige Direktiven - Falsche Pfade</p>"},{"location":"guides/NGINX/#problem-502-bad-gateway","title":"Problem: 502 Bad Gateway","text":"<p>Ursachen: 1. Backend offline \u2192 Check <code>max_fails</code> 2. Timeout zu kurz \u2192 Erh\u00f6he <code>proxy_read_timeout</code> 3. Buffer zu klein \u2192 Erh\u00f6he <code>proxy_buffer_size</code></p> <p>Debug: <pre><code>error_log /var/log/nginx/error.log debug;\n</code></pre></p> <p>Suche nach: <pre><code>upstream timed out\nno live upstreams\n</code></pre></p>"},{"location":"guides/NGINX/#zusammenfassung","title":"Zusammenfassung","text":""},{"location":"guides/NGINX/#starken-von-nginx","title":"St\u00e4rken von Nginx","text":"<p>\u2705 Performance - Extrem schnell und ressourcenschonend \u2705 Stabilit\u00e4t - Bew\u00e4hrt in Production \u2705 Einfachheit - Klare, lesbare Konfiguration \u2705 Community - Riesige Community, viele Tutorials \u2705 Static Content - Perfekt f\u00fcr Hybrid Workloads</p>"},{"location":"guides/NGINX/#einschrankungen","title":"Einschr\u00e4nkungen","text":"<p>\u274c Active Health Checks - Nur in Nginx Plus \u274c JWT - Ben\u00f6tigt OpenResty/Lua \u274c Dynamic Config - Reload erforderlich \u26a0\ufe0f Response Header Removal - Ben\u00f6tigt ngx_headers_more Modul</p>"},{"location":"guides/NGINX/#empfehlung","title":"Empfehlung","text":"<p>Nutze Nginx mit GAL wenn: - \ud83d\ude80 Performance und Effizienz kritisch sind - \ud83d\udce6 Static Content + API Gateway ben\u00f6tigt wird - \ud83d\udd27 Einfache, stabile L\u00f6sung gew\u00fcnscht ist - \ud83d\udcb0 Keine Lizenzkosten anfallen sollen</p> <p>Nutze andere Gateways wenn: - \ud83d\udd11 Native JWT Validation erforderlich ist - \ud83d\udd04 Dynamische Configuration ohne Reload ben\u00f6tigt wird - \ud83c\udfaf Active Health Checks ohne Plus erforderlich sind</p>"},{"location":"guides/NGINX/#weitere-ressourcen","title":"Weitere Ressourcen","text":"<ul> <li>Nginx Offizielle Docs: https://nginx.org/en/docs/</li> <li>OpenResty Docs: https://openresty.org/en/</li> <li>GAL GitHub: https://github.com/pt9912/x-gal</li> <li>PyPI Package: https://pypi.org/project/gal-gateway/</li> </ul> <p>Bei Fragen oder Problemen: https://github.com/pt9912/x-gal/issues</p>"},{"location":"guides/PROVIDERS/","title":"GAL Provider-Dokumentation","text":""},{"location":"guides/PROVIDERS/#ubersicht","title":"\u00dcbersicht","text":"<p>GAL unterst\u00fctzt vier f\u00fchrende API-Gateway-Provider. Jeder Provider hat spezifische Eigenschaften, St\u00e4rken und ideale Use Cases.</p>"},{"location":"guides/PROVIDERS/#unterstutzte-provider","title":"Unterst\u00fctzte Provider","text":"Provider Output-Format Transformations gRPC REST GAL Deploy API Envoy YAML Lua Filters \u2705 \u2705 \u2705 File + API check Kong YAML Plugins \u2705 \u2705 \u2705 File + Admin API APISIX JSON Lua Serverless \u2705 \u2705 \u2705 File + Admin API Traefik YAML Middleware \u2705 \u2705 \u2705 File + API verify"},{"location":"guides/PROVIDERS/#envoy-proxy","title":"Envoy Proxy","text":""},{"location":"guides/PROVIDERS/#ubersicht_1","title":"\u00dcbersicht","text":"<p>Envoy ist ein Cloud-native High-Performance Edge/Service Proxy, entwickelt f\u00fcr moderne Service-Mesh-Architekturen.</p> <p>\ud83d\udca1 API-Referenz: F\u00fcr technische Details zur Implementierung siehe <code>gal/providers/envoy.py:12-49</code> (EnvoyProvider Klassen-Docstring)</p> <p>St\u00e4rken: - Extrem performant (C++) - Umfangreiche Observability - Service Mesh Ready (Istio, Consul) - L7 und L4 Proxy - HTTP/2 und gRPC nativ</p> <p>Ideal f\u00fcr: - Kubernetes-Deployments - Service Mesh Architectures - High-Performance Requirements - Advanced Traffic Management</p>"},{"location":"guides/PROVIDERS/#gal-generierung","title":"GAL-Generierung","text":"<p>Output: <code>envoy.yaml</code> (Static Resources Configuration)</p> <p>Struktur:</p> <pre><code>static_resources:\n  listeners:\n    - name: listener_0\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 10000\n      filter_chains:\n        - filters:\n            - name: envoy.filters.network.http_connection_manager\n              typed_config:\n                route_config:\n                  virtual_hosts:\n                    - routes:\n                        # Service routes\n\n  clusters:\n    # Upstream services\n\nadmin:\n  address:\n    socket_address:\n      port_value: 9901\n</code></pre>"},{"location":"guides/PROVIDERS/#transformationen","title":"Transformationen","text":"<p>Envoy nutzt Lua Filters f\u00fcr Payload-Transformationen:</p> <pre><code>http_filters:\n  - name: envoy.filters.http.lua\n    typed_config:\n      inline_code: |\n        function envoy_on_request(request_handle)\n          local path = request_handle:headers():get(':path')\n          if string.find(path, '/api/users') then\n            local body = request_handle:body()\n            -- Transform body\n          end\n        end\n</code></pre> <p>Features: - Default-Werte setzen - Computed Fields (UUID, Timestamp) - Request Header/Body Manipulation</p>"},{"location":"guides/PROVIDERS/#grpc-support","title":"gRPC-Support","text":"<p>Automatische HTTP/2-Konfiguration f\u00fcr gRPC-Services:</p> <pre><code>clusters:\n  - name: grpc_service_cluster\n    http2_protocol_options: {}  # Aktiviert HTTP/2\n</code></pre>"},{"location":"guides/PROVIDERS/#deployment","title":"Deployment","text":"<p>GAL unterst\u00fctzt direktes Deployment f\u00fcr Envoy:</p> <p>Python API:</p> <pre><code>from gal import Manager\nfrom gal.providers.envoy import EnvoyProvider\n\nmanager = Manager()\nprovider = EnvoyProvider()\nconfig = manager.load_config(\"config.yaml\")\n\n# File-based deployment\nprovider.deploy(config, output_file=\"/etc/envoy/envoy.yaml\")\n\n# Mit Admin API check\nprovider.deploy(config,\n               output_file=\"envoy.yaml\",\n               admin_url=\"http://localhost:9901\")\n</code></pre> <p>Docker:</p> <pre><code># Konfiguration generieren\npython gal-cli.py generate -c config.yaml -p envoy -o envoy.yaml\n\n# Envoy starten\ndocker run -d \\\n  -v $(pwd)/envoy.yaml:/etc/envoy/envoy.yaml \\\n  -p 10000:10000 \\\n  -p 9901:9901 \\\n  envoyproxy/envoy:v1.28-latest\n</code></pre> <p>Kubernetes:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: envoy-config\ndata:\n  envoy.yaml: |\n    # Generated configuration\n\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: envoy-gateway\nspec:\n  template:\n    spec:\n      containers:\n      - name: envoy\n        image: envoyproxy/envoy:v1.28-latest\n        volumeMounts:\n        - name: config\n          mountPath: /etc/envoy\n      volumes:\n      - name: config\n        configMap:\n          name: envoy-config\n</code></pre>"},{"location":"guides/PROVIDERS/#kong-api-gateway","title":"Kong API Gateway","text":""},{"location":"guides/PROVIDERS/#ubersicht_2","title":"\u00dcbersicht","text":"<p>Kong ist ein weit verbreitetes, plugin-basiertes API-Gateway mit umfangreichem Enterprise-Funktionsumfang.</p> <p>\ud83d\udca1 API-Referenz: F\u00fcr technische Details zur Implementierung siehe <code>gal/providers/kong.py:12-52</code> (KongProvider Klassen-Docstring)</p> <p>St\u00e4rken: - Gro\u00dfes Plugin-\u00d6kosystem - Developer Portal - Enterprise-Features - Multi-Cloud Support - Grafische UI (Kong Manager)</p> <p>Ideal f\u00fcr: - API Management - Microservices - Multi-Tenant Environments - Enterprise Use Cases</p>"},{"location":"guides/PROVIDERS/#gal-generierung_1","title":"GAL-Generierung","text":"<p>Output: <code>kong.yaml</code> (Declarative Configuration v3.0)</p> <p>Struktur:</p> <pre><code>_format_version: '3.0'\n\nservices:\n  - name: user_service\n    protocol: http\n    host: user-service\n    port: 8080\n    routes:\n      - name: user_service_route\n        paths:\n          - /api/users\n        methods:\n          - GET\n          - POST\n    plugins:\n      - name: request-transformer\n        config:\n          add:\n            headers:\n              - x-default-role: 'user'\n</code></pre>"},{"location":"guides/PROVIDERS/#transformationen_1","title":"Transformationen","text":"<p>Kong nutzt das request-transformer Plugin:</p> <pre><code>plugins:\n  - name: request-transformer\n    config:\n      add:\n        headers:\n          - x-default-status: 'active'\n          - x-default-role: 'user'\n</code></pre> <p>Limitationen: - Keine nativen Computed Fields - Defaults als Headers - Erweiterte Transformationen ben\u00f6tigen Custom Plugins</p>"},{"location":"guides/PROVIDERS/#grpc-support_1","title":"gRPC-Support","text":"<pre><code>services:\n  - name: grpc_service\n    protocol: grpc\n    host: grpc-server\n    port: 9090\n</code></pre>"},{"location":"guides/PROVIDERS/#deployment_1","title":"Deployment","text":"<p>GAL unterst\u00fctzt direktes Deployment f\u00fcr Kong via Admin API:</p> <p>Python API:</p> <pre><code>from gal import Manager\nfrom gal.providers.kong import KongProvider\n\nmanager = Manager()\nprovider = KongProvider()\nconfig = manager.load_config(\"config.yaml\")\n\n# Deployment via Admin API\nprovider.deploy(config,\n               output_file=\"kong.yaml\",\n               admin_url=\"http://localhost:8001\")\n</code></pre> <p>Docker:</p> <pre><code># Kong DB-less mit Declarative Config\ndocker run -d \\\n  -v $(pwd)/kong.yaml:/usr/local/kong/declarative/kong.yaml \\\n  -e KONG_DATABASE=off \\\n  -e KONG_DECLARATIVE_CONFIG=/usr/local/kong/declarative/kong.yaml \\\n  -e KONG_PROXY_ACCESS_LOG=/dev/stdout \\\n  -e KONG_ADMIN_ACCESS_LOG=/dev/stdout \\\n  -e KONG_PROXY_ERROR_LOG=/dev/stderr \\\n  -e KONG_ADMIN_ERROR_LOG=/dev/stderr \\\n  -p 8000:8000 \\\n  -p 8443:8443 \\\n  kong:3.4\n</code></pre> <p>Kubernetes (mit Ingress Controller):</p> <pre><code>kubectl create configmap kong-config --from-file=kong.yaml\n</code></pre>"},{"location":"guides/PROVIDERS/#apache-apisix","title":"Apache APISIX","text":""},{"location":"guides/PROVIDERS/#ubersicht_3","title":"\u00dcbersicht","text":"<p>APISIX ist ein Cloud-native, High-Performance API-Gateway mit dynamischer Konfiguration und Plugin-Verwaltung.</p> <p>\ud83d\udca1 API-Referenz: F\u00fcr technische Details zur Implementierung siehe <code>gal/providers/apisix.py:13-54</code> (APISIXProvider Klassen-Docstring) und <code>apisix.py:159-218</code> (_generate_lua_transformation Methode)</p> <p>St\u00e4rken: - Sehr hohe Performance - Dynamic Configuration - Low Latency - Serverless-ready - Active-Active Cluster</p> <p>Ideal f\u00fcr: - Cloud-Native Applications - High-Traffic Scenarios - Dynamic Routing - Edge Computing</p>"},{"location":"guides/PROVIDERS/#gal-generierung_2","title":"GAL-Generierung","text":"<p>Output: <code>apisix.json</code> (JSON Configuration)</p> <p>Struktur:</p> <pre><code>{\n  \"routes\": [\n    {\n      \"uri\": \"/api/users/*\",\n      \"name\": \"user_service_route\",\n      \"service_id\": \"user_service\",\n      \"methods\": [\"GET\", \"POST\"]\n    }\n  ],\n  \"services\": [\n    {\n      \"id\": \"user_service\",\n      \"upstream_id\": \"user_service_upstream\",\n      \"plugins\": {\n        \"serverless-pre-function\": {\n          \"phase\": \"rewrite\",\n          \"functions\": [\"...lua code...\"]\n        }\n      }\n    }\n  ],\n  \"upstreams\": [\n    {\n      \"id\": \"user_service_upstream\",\n      \"type\": \"roundrobin\",\n      \"nodes\": {\n        \"user-service:8080\": 1\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"guides/PROVIDERS/#transformationen_2","title":"Transformationen","text":"<p>APISIX nutzt Serverless Pre-Function Plugin mit Lua:</p> <pre><code>return function(conf, ctx)\n  local core = require('apisix.core')\n  local cjson = require('cjson.safe')\n  local body = core.request.get_body()\n\n  if body then\n    local json_body = cjson.decode(body)\n    if json_body then\n      -- Apply defaults\n      json_body.status = json_body.status or 'active'\n\n      -- Compute fields\n      if not json_body.user_id then\n        json_body.user_id = 'usr_' .. core.utils.uuid()\n      end\n\n      ngx.req.set_body_data(cjson.encode(json_body))\n    end\n  end\nend\n</code></pre> <p>Features: - Vollst\u00e4ndige Lua-Programmierung - Volle Kontrolle \u00fcber Request/Response - Computed Fields mit UUIDs - Timestamp-Generierung</p>"},{"location":"guides/PROVIDERS/#deployment_2","title":"Deployment","text":"<p>GAL unterst\u00fctzt direktes Deployment f\u00fcr APISIX via Admin API:</p> <p>Python API:</p> <pre><code>from gal import Manager\nfrom gal.providers.apisix import APISIXProvider\n\nmanager = Manager()\nprovider = APISIXProvider()\nconfig = manager.load_config(\"config.yaml\")\n\n# Deployment via Admin API\nprovider.deploy(config,\n               output_file=\"apisix.json\",\n               admin_url=\"http://localhost:9180\",\n               api_key=\"your-api-key\")\n</code></pre> <p>Docker:</p> <pre><code># APISIX mit Standalone Config\ndocker run -d \\\n  -v $(pwd)/apisix.json:/usr/local/apisix/conf/config.json \\\n  -e APISIX_STAND_ALONE=true \\\n  -p 9080:9080 \\\n  -p 9443:9443 \\\n  apache/apisix:3.7.0-debian\n</code></pre>"},{"location":"guides/PROVIDERS/#traefik","title":"Traefik","text":""},{"location":"guides/PROVIDERS/#ubersicht_4","title":"\u00dcbersicht","text":"<p>Traefik ist ein moderner HTTP Reverse Proxy und Load Balancer f\u00fcr Microservices mit automatischer Service Discovery.</p> <p>\ud83d\udca1 API-Referenz: F\u00fcr technische Details zur Implementierung siehe <code>gal/providers/traefik.py:12-58</code> (TraefikProvider Klassen-Docstring)</p> <p>St\u00e4rken: - Automatische Service Discovery - Docker/Kubernetes Integration - Let's Encrypt Support - Dashboard UI - Zero-config f\u00fcr Docker</p> <p>Ideal f\u00fcr: - Docker Swarm - Kubernetes - Container-basierte Deployments - Development Environments</p>"},{"location":"guides/PROVIDERS/#gal-generierung_3","title":"GAL-Generierung","text":"<p>Output: <code>traefik.yaml</code> (Dynamic Configuration)</p> <p>Struktur:</p> <pre><code>http:\n  routers:\n    user_service_router_0:\n      rule: 'PathPrefix(`/api/users`)'\n      service: user_service_service\n      middlewares:\n        - user_service_transform\n\n  services:\n    user_service_service:\n      loadBalancer:\n        servers:\n          - url: 'http://user-service:8080'\n\n  middlewares:\n    user_service_transform:\n      plugin:\n        user_service_transformer:\n          defaults:\n            status: 'active'\n            role: 'user'\n</code></pre>"},{"location":"guides/PROVIDERS/#transformationen_3","title":"Transformationen","text":"<p>Traefik nutzt Middleware Plugins:</p> <pre><code>middlewares:\n  my_transformer:\n    plugin:\n      my_transformer:\n        defaults:\n          field: value\n</code></pre> <p>Limitationen: - Plugin-Entwicklung ben\u00f6tigt Go - Keine nativen Transformationen - Fokus auf Routing/Load Balancing</p>"},{"location":"guides/PROVIDERS/#deployment_3","title":"Deployment","text":"<p>GAL unterst\u00fctzt direktes Deployment f\u00fcr Traefik (File-based):</p> <p>Python API:</p> <pre><code>from gal import Manager\nfrom gal.providers.traefik import TraefikProvider\n\nmanager = Manager()\nprovider = TraefikProvider()\nconfig = manager.load_config(\"config.yaml\")\n\n# File-based deployment mit API verification\nprovider.deploy(config,\n               output_file=\"/etc/traefik/dynamic/gal.yaml\",\n               api_url=\"http://localhost:8080\")\n</code></pre> <p>Docker Compose:</p> <pre><code>version: '3.8'\n\nservices:\n  traefik:\n    image: traefik:v2.10\n    command:\n      - --providers.file.filename=/etc/traefik/traefik.yaml\n    volumes:\n      - ./traefik.yaml:/etc/traefik/traefik.yaml\n    ports:\n      - \"80:80\"\n      - \"8080:8080\"  # Dashboard\n\n  backend:\n    image: my-app:latest\n    labels:\n      - traefik.enable=true\n</code></pre> <p>Kubernetes:</p> <pre><code>kubectl apply -f traefik.yaml\n</code></pre>"},{"location":"guides/PROVIDERS/#provider-vergleich","title":"Provider-Vergleich","text":""},{"location":"guides/PROVIDERS/#performance","title":"Performance","text":"Provider Requests/sec Latency (p50) Latency (p99) Envoy ~100k &lt;1ms &lt;5ms APISIX ~80k &lt;1ms &lt;6ms Kong ~50k 2ms 15ms Traefik ~40k 3ms 20ms <p>Benchmark-Werte sind Richtwerte und variieren je nach Setup</p>"},{"location":"guides/PROVIDERS/#transformations-vergleich","title":"Transformations-Vergleich","text":"Feature Envoy Kong APISIX Traefik Defaults \u2705 Lua \u2705 Headers \u2705 Lua \u26a0\ufe0f Plugins Computed Fields \u2705 Lua \u274c \u2705 Lua \u274c UUID Generation \u2705 \u274c \u2705 \u274c Timestamp \u2705 \u274c \u2705 \u274c Validation \u26a0\ufe0f Limited \u26a0\ufe0f Limited \u2705 Full \u274c"},{"location":"guides/PROVIDERS/#use-case-matrix","title":"Use Case Matrix","text":"Use Case Empfohlen Warum Kubernetes Service Mesh Envoy Native Integration API Management Platform Kong Enterprise Features High-Traffic Edge APISIX Performance Docker Development Traefik Auto-Discovery gRPC Heavy Envoy, APISIX Native HTTP/2 Multi-Cloud Kong, APISIX Provider-agnostic"},{"location":"guides/PROVIDERS/#provider-wechsel","title":"Provider-Wechsel","text":""},{"location":"guides/PROVIDERS/#von-kong-zu-envoy","title":"Von Kong zu Envoy","text":"<pre><code># 1. GAL-Config erstellen (basierend auf Kong-Setup)\n# config.yaml\n\n# 2. F\u00fcr Envoy generieren\npython gal-cli.py generate -c config.yaml -p envoy -o envoy.yaml\n\n# 3. Parallel testen\n# Kong und Envoy parallel mit Traffic Mirror\n\n# 4. Schrittweise Migration\n# Traffic von Kong zu Envoy verschieben\n</code></pre>"},{"location":"guides/PROVIDERS/#best-practices-fur-migration","title":"Best Practices f\u00fcr Migration","text":"<ol> <li>Parallel Testing: Beide Gateways mit gleichem Traffic</li> <li>Feature Parity: Pr\u00fcfe ob alle Features unterst\u00fctzt sind</li> <li>Gradual Rollout: Schrittweise Traffic-Verschiebung</li> <li>Monitoring: Intensive \u00dcberwachung w\u00e4hrend Migration</li> <li>Rollback Plan: Schneller Rollback zu altem Provider</li> </ol>"},{"location":"guides/PROVIDERS/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/PROVIDERS/#envoy-no-healthy-upstream","title":"Envoy: \"No healthy upstream\"","text":"<pre><code># Pr\u00fcfe Admin Interface\ncurl http://localhost:9901/clusters\n\n# Pr\u00fcfe Service-Erreichbarkeit\nkubectl get pods -l app=backend-service\n</code></pre>"},{"location":"guides/PROVIDERS/#kong-no-routes-matched","title":"Kong: \"No routes matched\"","text":"<pre><code># Validiere Declarative Config\nkong config parse kong.yaml\n\n# Pr\u00fcfe Logs\ndocker logs kong-container\n</code></pre>"},{"location":"guides/PROVIDERS/#apisix-failed-to-fetch-api","title":"APISIX: \"failed to fetch api\"","text":"<pre><code># Validiere JSON\npython -m json.tool apisix.json\n\n# Pr\u00fcfe etcd (wenn nicht standalone)\ncurl http://localhost:2379/health\n</code></pre>"},{"location":"guides/PROVIDERS/#traefik-service-not-found","title":"Traefik: \"Service not found\"","text":"<pre><code># Dashboard pr\u00fcfen\nopen http://localhost:8080/dashboard/\n\n# Config validieren\ntraefik healthcheck --configFile=traefik.yaml\n</code></pre>"},{"location":"guides/PROVIDERS/#python-api-referenz","title":"Python API-Referenz","text":"<p>Alle Provider-Implementierungen enthalten umfassende Google-style Docstrings mit detaillierten Erkl\u00e4rungen, Beispielen und Codebeispielen.</p>"},{"location":"guides/PROVIDERS/#klassen-dokumentation","title":"Klassen-Dokumentation","text":"Modul Zeilen Inhalt <code>gal/provider.py:13-127</code> Provider ABC Basis-Interface f\u00fcr alle Provider <code>gal/providers/envoy.py:12-209</code> EnvoyProvider Envoy Static Config Generator <code>gal/providers/kong.py:12-146</code> KongProvider Kong Declarative Config Generator <code>gal/providers/apisix.py:13-219</code> APISIXProvider APISIX JSON Config Generator <code>gal/providers/traefik.py:12-155</code> TraefikProvider Traefik Dynamic Config Generator"},{"location":"guides/PROVIDERS/#methoden-dokumentation","title":"Methoden-Dokumentation","text":"<p>Jeder Provider implementiert:</p> <ul> <li><code>name() -&gt; str</code>: Eindeutiger Provider-Name</li> <li><code>validate(config: Config) -&gt; bool</code>: Provider-spezifische Validierung</li> <li><code>generate(config: Config) -&gt; str</code>: Config-zu-Output Transformation</li> </ul> <p>Beispiel: <code>gal/providers/envoy.py:86-112</code> zeigt die vollst\u00e4ndige <code>generate()</code> Methode mit allen Parametern und R\u00fcckgabewerten.</p>"},{"location":"guides/PROVIDERS/#konfigurations-modelle","title":"Konfigurations-Modelle","text":"<p>F\u00fcr Details zu Datenstrukturen siehe:</p> <ul> <li><code>gal/config.py:10-42</code> - GlobalConfig Dataclass</li> <li><code>gal/config.py:45-68</code> - Upstream Dataclass</li> <li><code>gal/config.py:71-98</code> - Route Dataclass</li> <li><code>gal/config.py:101-134</code> - ComputedField Dataclass</li> <li><code>gal/config.py:137-163</code> - Validation Dataclass</li> <li><code>gal/config.py:166-200</code> - Transformation Dataclass</li> <li><code>gal/config.py:203-255</code> - Service Dataclass</li> <li><code>gal/config.py:258-279</code> - Plugin Dataclass</li> <li><code>gal/config.py:282-371</code> - Config Dataclass (Haupt-Container)</li> </ul>"},{"location":"guides/PROVIDERS/#transformation-engine","title":"Transformation Engine","text":"<p>Spezielle Methoden f\u00fcr Lua-Script-Generierung:</p> <ul> <li><code>gal/providers/apisix.py:159-218</code> - <code>_generate_lua_transformation()</code> f\u00fcr APISIX</li> <li><code>gal/providers/envoy.py:155-177</code> - Inline Lua f\u00fcr Envoy</li> </ul> <p>Diese Methoden zeigen, wie GAL automatisch Lua-Code f\u00fcr Payload-Transformationen generiert.</p>"},{"location":"guides/PROVIDERS/#siehe-auch","title":"Siehe auch","text":"<ul> <li>Schnellstart-Guide</li> <li>Konfigurationsreferenz</li> <li>Transformations-Guide</li> <li>Architektur-Dokumentation</li> </ul>"},{"location":"guides/QUICKSTART/","title":"GAL Schnellstart-Guide","text":""},{"location":"guides/QUICKSTART/#was-ist-gal","title":"Was ist GAL?","text":"<p>Gateway Abstraction Layer (GAL) ist ein Tool, das es erm\u00f6glicht, API-Gateway-Konfigurationen einmal zu definieren und f\u00fcr verschiedene Gateway-Provider (Envoy, Kong, APISIX, Traefik) zu generieren.</p> <p>Vorteile: - \u2705 Keine Vendor Lock-in - \u2705 Einheitliche Konfiguration - \u2705 Automatische Payload-Transformationen - \u2705 Unterst\u00fctzung f\u00fcr REST und gRPC - \u2705 Docker-ready</p>"},{"location":"guides/QUICKSTART/#installation","title":"Installation","text":""},{"location":"guides/QUICKSTART/#option-1-mit-docker-empfohlen","title":"Option 1: Mit Docker (empfohlen)","text":"<pre><code># Image bauen\ndocker build -t gal:latest .\n\n# Testen\ndocker run --rm gal:latest list-providers\n</code></pre>"},{"location":"guides/QUICKSTART/#option-2-mit-python","title":"Option 2: Mit Python","text":"<pre><code># Repository klonen\ngit clone https://github.com/pt9912/x-gal.git\ncd x-gal\n\n# Virtuelle Umgebung erstellen\npython3 -m venv venv\nsource venv/bin/activate\n\n# Abh\u00e4ngigkeiten installieren\npip install -r requirements.txt\n</code></pre>"},{"location":"guides/QUICKSTART/#erste-schritte","title":"Erste Schritte","text":""},{"location":"guides/QUICKSTART/#1-konfiguration-erstellen","title":"1. Konfiguration erstellen","text":"<p>Erstelle eine Datei <code>my-gateway.yaml</code>:</p> <pre><code>version: \"1.0\"\nprovider: envoy\n\nglobal:\n  host: 0.0.0.0\n  port: 8080\n\nservices:\n  - name: hello_service\n    type: rest\n    protocol: http\n    upstream:\n      host: hello-app\n      port: 3000\n    routes:\n      - path_prefix: /hello\n        methods: [GET, POST]\n</code></pre>"},{"location":"guides/QUICKSTART/#2-konfiguration-validieren","title":"2. Konfiguration validieren","text":"<pre><code># Mit Docker\ndocker run --rm -v $(pwd):/app/config gal:latest \\\n  validate --config config/my-gateway.yaml\n\n# Mit Python\npython gal-cli.py validate -c my-gateway.yaml\n</code></pre> <p>Erwartete Ausgabe:</p> <pre><code>\u2713 Configuration is valid\n  Provider: envoy\n  Services: 1\n  gRPC services: 0\n  REST services: 1\n</code></pre>"},{"location":"guides/QUICKSTART/#3-gateway-konfiguration-generieren","title":"3. Gateway-Konfiguration generieren","text":"<pre><code># Mit Docker\ndocker run --rm -v $(pwd):/app/config -v $(pwd)/output:/app/generated gal:latest \\\n  generate --config config/my-gateway.yaml --output generated/envoy.yaml\n\n# Mit Python\npython gal-cli.py generate -c my-gateway.yaml -o envoy.yaml\n</code></pre> <p>Ergebnis: Eine <code>envoy.yaml</code> Datei mit der vollst\u00e4ndigen Envoy-Konfiguration.</p>"},{"location":"guides/QUICKSTART/#4-fur-andere-provider-generieren","title":"4. F\u00fcr andere Provider generieren","text":"<pre><code># Kong\npython gal-cli.py generate -c my-gateway.yaml -p kong -o kong.yaml\n\n# APISIX\npython gal-cli.py generate -c my-gateway.yaml -p apisix -o apisix.json\n\n# Traefik\npython gal-cli.py generate -c my-gateway.yaml -p traefik -o traefik.yaml\n\n# Alle gleichzeitig\npython gal-cli.py generate-all -c my-gateway.yaml\n</code></pre>"},{"location":"guides/QUICKSTART/#erweiterte-funktionen","title":"Erweiterte Funktionen","text":""},{"location":"guides/QUICKSTART/#payload-transformationen","title":"Payload-Transformationen","text":"<pre><code>services:\n  - name: user_service\n    type: rest\n    protocol: http\n    upstream:\n      host: users-api\n      port: 8080\n    routes:\n      - path_prefix: /api/users\n        methods: [POST]\n    transformation:\n      enabled: true\n      defaults:\n        role: \"user\"\n        active: true\n      computed_fields:\n        - field: user_id\n          generator: uuid\n          prefix: \"usr_\"\n        - field: created_at\n          generator: timestamp\n      validation:\n        required_fields:\n          - email\n          - name\n</code></pre> <p>Was passiert: 1. Fehlende Felder werden mit Defaults gef\u00fcllt (<code>role: \"user\"</code>, <code>active: true</code>) 2. <code>user_id</code> wird automatisch generiert (z.B. <code>usr_550e8400...</code>) 3. <code>created_at</code> wird mit aktuellem Timestamp gesetzt 4. Request wird abgelehnt, wenn <code>email</code> oder <code>name</code> fehlt</p>"},{"location":"guides/QUICKSTART/#grpc-services","title":"gRPC-Services","text":"<pre><code>services:\n  - name: order_service\n    type: grpc\n    protocol: http2\n    upstream:\n      host: order-grpc\n      port: 9090\n    routes:\n      - path_prefix: /myapp.OrderService\n    transformation:\n      enabled: true\n      defaults:\n        status: \"pending\"\n      computed_fields:\n        - field: order_id\n          generator: uuid\n          prefix: \"ord_\"\n</code></pre>"},{"location":"guides/QUICKSTART/#plugins","title":"Plugins","text":"<pre><code>plugins:\n  - name: rate_limiting\n    enabled: true\n    config:\n      requests_per_second: 100\n      burst: 200\n\n  - name: cors\n    enabled: true\n    config:\n      origins: [\"*\"]\n      methods: [GET, POST, PUT, DELETE]\n</code></pre>"},{"location":"guides/QUICKSTART/#praktische-beispiele","title":"Praktische Beispiele","text":""},{"location":"guides/QUICKSTART/#beispiel-1-e-commerce-api-gateway","title":"Beispiel 1: E-Commerce API-Gateway","text":"<pre><code>version: \"1.0\"\nprovider: kong\n\nglobal:\n  port: 8000\n\nservices:\n  # Produktkatalog\n  - name: products\n    type: rest\n    protocol: http\n    upstream:\n      host: product-service\n      port: 8080\n    routes:\n      - path_prefix: /api/products\n        methods: [GET, POST, PUT, DELETE]\n    transformation:\n      enabled: true\n      defaults:\n        in_stock: true\n        currency: \"EUR\"\n      computed_fields:\n        - field: product_id\n          generator: uuid\n          prefix: \"prod_\"\n\n  # Warenkorb\n  - name: cart\n    type: rest\n    protocol: http\n    upstream:\n      host: cart-service\n      port: 8081\n    routes:\n      - path_prefix: /api/cart\n        methods: [GET, POST, PUT, DELETE]\n    transformation:\n      enabled: true\n      computed_fields:\n        - field: cart_id\n          generator: uuid\n          prefix: \"cart_\"\n        - field: created_at\n          generator: timestamp\n\n  # Bestellungen\n  - name: orders\n    type: rest\n    protocol: http\n    upstream:\n      host: order-service\n      port: 8082\n    routes:\n      - path_prefix: /api/orders\n        methods: [GET, POST]\n    transformation:\n      enabled: true\n      defaults:\n        status: \"pending\"\n        payment_status: \"unpaid\"\n      computed_fields:\n        - field: order_id\n          generator: uuid\n          prefix: \"ord_\"\n        - field: order_date\n          generator: timestamp\n      validation:\n        required_fields:\n          - customer_id\n          - items\n\nplugins:\n  - name: rate_limiting\n    enabled: true\n    config:\n      requests_per_second: 100\n</code></pre> <p>Konfiguration generieren:</p> <pre><code>python gal-cli.py generate -c ecommerce.yaml -o kong.yaml\n</code></pre>"},{"location":"guides/QUICKSTART/#beispiel-2-microservices-mit-grpc","title":"Beispiel 2: Microservices mit gRPC","text":"<pre><code>version: \"1.0\"\nprovider: envoy\n\nglobal:\n  host: 0.0.0.0\n  port: 10000\n  admin_port: 9901\n\nservices:\n  # Authentifizierung\n  - name: auth_service\n    type: grpc\n    protocol: http2\n    upstream:\n      host: auth-grpc\n      port: 9090\n    routes:\n      - path_prefix: /auth.AuthService\n\n  # Benutzerverwaltung\n  - name: user_service\n    type: grpc\n    protocol: http2\n    upstream:\n      host: user-grpc\n      port: 9091\n    routes:\n      - path_prefix: /users.UserService\n    transformation:\n      enabled: true\n      computed_fields:\n        - field: user_id\n          generator: uuid\n        - field: created_at\n          generator: timestamp\n\n  # Benachrichtigungen\n  - name: notification_service\n    type: grpc\n    protocol: http2\n    upstream:\n      host: notify-grpc\n      port: 9092\n    routes:\n      - path_prefix: /notifications.NotificationService\n    transformation:\n      enabled: true\n      defaults:\n        priority: \"normal\"\n        channel: \"email\"\n</code></pre>"},{"location":"guides/QUICKSTART/#docker-compose-integration","title":"Docker Compose Integration","text":"<p>Erstelle <code>docker-compose.yml</code>:</p> <pre><code>version: '3.8'\n\nservices:\n  gateway:\n    image: envoyproxy/envoy:v1.28-latest\n    volumes:\n      - ./generated/envoy.yaml:/etc/envoy/envoy.yaml\n    ports:\n      - \"10000:10000\"\n      - \"9901:9901\"\n    command: envoy -c /etc/envoy/envoy.yaml\n\n  hello-app:\n    image: hashicorp/http-echo\n    command: [\"-text=Hello from backend!\"]\n    ports:\n      - \"3000:5678\"\n</code></pre> <p>Workflow:</p> <pre><code># 1. GAL-Konfiguration generieren\npython gal-cli.py generate -c my-gateway.yaml -o generated/envoy.yaml\n\n# 2. Services starten\ndocker-compose up -d\n\n# 3. Testen\ncurl http://localhost:10000/hello\n</code></pre>"},{"location":"guides/QUICKSTART/#haufige-use-cases","title":"H\u00e4ufige Use Cases","text":""},{"location":"guides/QUICKSTART/#use-case-1-multi-environment-setup","title":"Use Case 1: Multi-Environment Setup","text":"<pre><code># Entwicklung (Envoy)\npython gal-cli.py generate -c config.yaml -p envoy -o dev/envoy.yaml\n\n# Staging (Kong)\npython gal-cli.py generate -c config.yaml -p kong -o staging/kong.yaml\n\n# Produktion (APISIX)\npython gal-cli.py generate -c config.yaml -p apisix -o prod/apisix.json\n</code></pre>"},{"location":"guides/QUICKSTART/#use-case-2-gateway-migration","title":"Use Case 2: Gateway-Migration","text":"<pre><code># Aktuelle Kong-Konfiguration\n# Erstelle GAL-Config basierend auf Kong-Setup\n\n# Generiere f\u00fcr neuen Provider\npython gal-cli.py generate -c config.yaml -p envoy -o envoy.yaml\n\n# Test parallel\n# Beide Gateways mit gleichem Traffic\n\n# Migration\n# Schrittweise Traffic verschieben\n</code></pre>"},{"location":"guides/QUICKSTART/#use-case-3-cicd-integration","title":"Use Case 3: CI/CD Integration","text":"<pre><code>#!/bin/bash\n# deploy-gateway.sh\n\nCONFIG=\"config/gateway.yaml\"\nPROVIDER=\"envoy\"\nOUTPUT=\"deploy/envoy.yaml\"\n\n# Validieren\npython gal-cli.py validate -c $CONFIG || exit 1\n\n# Generieren\npython gal-cli.py generate -c $CONFIG -p $PROVIDER -o $OUTPUT\n\n# Deployen\nkubectl apply -f $OUTPUT --namespace=production\n</code></pre>"},{"location":"guides/QUICKSTART/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/QUICKSTART/#problem-provider-not-registered","title":"Problem: \"Provider not registered\"","text":"<pre><code>Error: Provider 'xyz' not registered\n</code></pre> <p>L\u00f6sung: Nutze einen unterst\u00fctzten Provider: - envoy - kong - apisix - traefik</p>"},{"location":"guides/QUICKSTART/#problem-port-must-be-specified","title":"Problem: \"Port must be specified\"","text":"<pre><code># Falsch\nglobal:\n  port: 0\n\n# Richtig\nglobal:\n  port: 8080\n</code></pre>"},{"location":"guides/QUICKSTART/#problem-docker-volume-permissions","title":"Problem: Docker Volume Permissions","text":"<pre><code># Linux: Verwende aktuelle UID/GID\ndocker run --rm --user $(id -u):$(id -g) -v $(pwd):/app/config gal:latest ...\n</code></pre>"},{"location":"guides/QUICKSTART/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<ul> <li>\ud83d\udcd6 Vollst\u00e4ndige Konfigurationsreferenz</li> <li>\ud83d\udd27 CLI-Befehlsreferenz</li> <li>\ud83c\udfd7\ufe0f Architektur-Dokumentation</li> <li>\ud83d\udcbb Entwickler-Guide</li> <li>\ud83c\udf10 Provider-Details</li> </ul>"},{"location":"guides/QUICKSTART/#community-support","title":"Community &amp; Support","text":"<ul> <li>Issues: https://github.com/pt9912/x-gal/issues</li> <li>Discussions: https://github.com/pt9912/x-gal/discussions</li> <li>Examples: <code>examples/</code> Verzeichnis im Repository</li> </ul>"},{"location":"guides/QUICKSTART/#lizenz","title":"Lizenz","text":"<p>MIT License - siehe LICENSE f\u00fcr Details.</p>"},{"location":"guides/RATE_LIMITING/","title":"Rate Limiting Guide","text":""},{"location":"guides/RATE_LIMITING/#overview","title":"Overview","text":"<p>Rate Limiting ist ein essenzielles Feature zur Kontrolle der Anzahl von Anfragen, die ein Client an Ihre API senden kann. Es hilft, Ihre Backend-Services vor \u00dcberlastung zu sch\u00fctzen und stellt sicher, dass alle Clients fair auf Ressourcen zugreifen k\u00f6nnen.</p> <p>GAL v1.1.0 bietet native Rate Limiting Unterst\u00fctzung f\u00fcr alle unterst\u00fctzten Gateway-Provider: - Kong: rate-limiting Plugin - APISIX: limit-count Plugin - Traefik: rateLimit Middleware - Envoy: local_ratelimit Filter</p>"},{"location":"guides/RATE_LIMITING/#quick-start","title":"Quick Start","text":""},{"location":"guides/RATE_LIMITING/#einfaches-rate-limiting","title":"Einfaches Rate Limiting","text":"<p>F\u00fcgen Sie Rate Limiting zu einer Route hinzu:</p> <pre><code>services:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      host: api.internal\n      port: 8080\n    routes:\n      - path_prefix: /api/v1\n        methods: [GET, POST]\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n          burst: 200\n</code></pre>"},{"location":"guides/RATE_LIMITING/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/RATE_LIMITING/#vollstandige-rate-limit-konfiguration","title":"Vollst\u00e4ndige Rate Limit Konfiguration","text":"<pre><code>rate_limit:\n  enabled: true                          # Standard: true\n  requests_per_second: 100               # Standard: 100\n  burst: 200                             # Standard: requests_per_second * 2\n  key_type: ip_address                   # Standard: ip_address\n  key_header: X-API-Key                  # Optional: f\u00fcr key_type: header\n  key_claim: sub                         # Optional: f\u00fcr key_type: jwt_claim\n  response_status: 429                   # Standard: 429\n  response_message: \"Rate limit exceeded\" # Standard: \"Rate limit exceeded\"\n</code></pre>"},{"location":"guides/RATE_LIMITING/#parameter-beschreibung","title":"Parameter-Beschreibung","text":"Parameter Typ Standard Beschreibung <code>enabled</code> boolean <code>true</code> Aktiviert oder deaktiviert Rate Limiting <code>requests_per_second</code> integer <code>100</code> Maximale Anzahl von Anfragen pro Sekunde <code>burst</code> integer <code>requests_per_second * 2</code> Burst-Kapazit\u00e4t f\u00fcr kurzzeitige Spitzen <code>key_type</code> string <code>ip_address</code> Identifizierungs-Methode (ip_address, header, jwt_claim) <code>key_header</code> string <code>null</code> Header-Name wenn key_type=header <code>key_claim</code> string <code>null</code> JWT Claim wenn key_type=jwt_claim <code>response_status</code> integer <code>429</code> HTTP Status Code bei Rate Limit \u00dcberschreitung <code>response_message</code> string <code>\"Rate limit exceeded\"</code> Fehlermeldung bei Rate Limit \u00dcberschreitung"},{"location":"guides/RATE_LIMITING/#key-types","title":"Key Types","text":""},{"location":"guides/RATE_LIMITING/#ip-basiertes-rate-limiting","title":"IP-basiertes Rate Limiting","text":"<p>Limitiert basierend auf der Client-IP-Adresse (Standard):</p> <pre><code>rate_limit:\n  enabled: true\n  requests_per_second: 100\n  key_type: ip_address\n</code></pre>"},{"location":"guides/RATE_LIMITING/#header-basiertes-rate-limiting","title":"Header-basiertes Rate Limiting","text":"<p>Limitiert basierend auf einem spezifischen Request-Header (z.B. API-Key):</p> <pre><code>rate_limit:\n  enabled: true\n  requests_per_second: 1000\n  key_type: header\n  key_header: X-API-Key\n</code></pre>"},{"location":"guides/RATE_LIMITING/#jwt-claim-basiertes-rate-limiting","title":"JWT Claim-basiertes Rate Limiting","text":"<p>Limitiert basierend auf einem JWT Claim (z.B. user ID):</p> <pre><code>rate_limit:\n  enabled: true\n  requests_per_second: 500\n  key_type: jwt_claim\n  key_claim: sub\n</code></pre>"},{"location":"guides/RATE_LIMITING/#beispiele","title":"Beispiele","text":""},{"location":"guides/RATE_LIMITING/#public-vs-private-api","title":"Public vs. Private API","text":"<p>Unterschiedliche Limits f\u00fcr verschiedene Endpunkte:</p> <pre><code>services:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      host: api.internal\n      port: 8080\n    routes:\n      # Public API - niedrigeres Limit\n      - path_prefix: /api/public\n        methods: [GET]\n        rate_limit:\n          enabled: true\n          requests_per_second: 10\n          burst: 20\n          key_type: ip_address\n\n      # Authenticated API - h\u00f6heres Limit\n      - path_prefix: /api/private\n        methods: [GET, POST, PUT, DELETE]\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n          burst: 200\n          key_type: header\n          key_header: X-API-Key\n</code></pre>"},{"location":"guides/RATE_LIMITING/#custom-error-response","title":"Custom Error Response","text":"<p>Benutzerdefinierte Fehlerantwort:</p> <pre><code>rate_limit:\n  enabled: true\n  requests_per_second: 50\n  response_status: 503\n  response_message: \"Service temporarily unavailable due to high load\"\n</code></pre>"},{"location":"guides/RATE_LIMITING/#rate-limiting-mit-transformationen","title":"Rate Limiting mit Transformationen","text":"<p>Kombinieren Sie Rate Limiting mit Request Transformations:</p> <pre><code>services:\n  - name: user_service\n    type: rest\n    protocol: http\n    upstream:\n      host: users.internal\n      port: 8080\n    routes:\n      - path_prefix: /api/users\n        methods: [POST]\n        rate_limit:\n          enabled: true\n          requests_per_second: 50\n          burst: 100\n    transformation:\n      enabled: true\n      defaults:\n        created_by: \"api\"\n      computed_fields:\n        - field: id\n          generator: uuid\n          prefix: \"usr_\"\n</code></pre>"},{"location":"guides/RATE_LIMITING/#provider-spezifische-implementierungen","title":"Provider-spezifische Implementierungen","text":""},{"location":"guides/RATE_LIMITING/#kong","title":"Kong","text":"<p>Kong verwendet das <code>rate-limiting</code> Plugin:</p> <pre><code># Generierte Kong-Konfiguration\n- name: api_service_route\n  paths:\n    - /api/v1\n  plugins:\n    - name: rate-limiting\n      config:\n        second: 100\n        policy: local\n        fault_tolerant: true\n</code></pre> <p>Features: - \u2705 Per-Route Konfiguration - \u2705 Lokale oder verteilte Rate Limiting (Redis/Cluster) - \u2705 Verschiedene Zeitfenster (second, minute, hour, day)</p>"},{"location":"guides/RATE_LIMITING/#apisix","title":"APISIX","text":"<p>APISIX verwendet das <code>limit-count</code> Plugin:</p> <pre><code>{\n  \"routes\": [{\n    \"uri\": \"/api/v1/*\",\n    \"plugins\": {\n      \"limit-count\": {\n        \"count\": 100,\n        \"time_window\": 1,\n        \"rejected_code\": 429,\n        \"rejected_msg\": \"Rate limit exceeded\",\n        \"key\": \"remote_addr\",\n        \"policy\": \"local\"\n      }\n    }\n  }]\n}\n</code></pre> <p>Features: - \u2705 Per-Route Konfiguration - \u2705 Flexible Key-Strategien (IP, Header, Consumer) - \u2705 Redis-basierte verteilte Limits</p>"},{"location":"guides/RATE_LIMITING/#traefik","title":"Traefik","text":"<p>Traefik verwendet die <code>rateLimit</code> Middleware:</p> <pre><code>http:\n  middlewares:\n    api_service_router_0_ratelimit:\n      rateLimit:\n        average: 100\n        burst: 200\n  routers:\n    api_service_router_0:\n      rule: 'PathPrefix(`/api/v1`)'\n      middlewares:\n        - api_service_router_0_ratelimit\n</code></pre> <p>Features: - \u2705 Per-Route Konfiguration - \u2705 Token-Bucket-Algorithmus - \u2705 Burst-Handling</p>"},{"location":"guides/RATE_LIMITING/#envoy","title":"Envoy","text":"<p>Envoy verwendet den <code>local_ratelimit</code> Filter:</p> <pre><code>http_filters:\n  - name: envoy.filters.http.local_ratelimit\n    typed_config:\n      '@type': type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit\n      stat_prefix: http_local_rate_limiter\n      token_bucket:\n        max_tokens: 200\n        tokens_per_fill: 100\n        fill_interval: 1s\n      status_code: 429\n</code></pre> <p>Features: - \u26a0\ufe0f Globale Konfiguration (gilt f\u00fcr alle Routes) - \u2705 Token-Bucket-Algorithmus - \u2705 Hochperformant (C++)</p> <p>Hinweis: Die aktuelle Envoy-Implementierung verwendet eine globale Rate Limiting Konfiguration. F\u00fcr per-route Konfigurationen sollte der externe Rate Limit Service verwendet werden.</p>"},{"location":"guides/RATE_LIMITING/#best-practices","title":"Best Practices","text":""},{"location":"guides/RATE_LIMITING/#1-burst-dimensionierung","title":"1. Burst-Dimensionierung","text":"<p>Setzen Sie <code>burst</code> auf das 2-3-fache von <code>requests_per_second</code>:</p> <pre><code>rate_limit:\n  requests_per_second: 100\n  burst: 200  # 2x f\u00fcr normale Spitzen\n  # burst: 300  # 3x f\u00fcr h\u00f6here Variabilit\u00e4t\n</code></pre>"},{"location":"guides/RATE_LIMITING/#2-gestaffelte-limits","title":"2. Gestaffelte Limits","text":"<p>Unterschiedliche Limits f\u00fcr verschiedene Zugriffsebenen:</p> <pre><code># Free Tier\nrate_limit:\n  requests_per_second: 10\n\n# Paid Tier\nrate_limit:\n  requests_per_second: 100\n\n# Enterprise\nrate_limit:\n  requests_per_second: 1000\n</code></pre>"},{"location":"guides/RATE_LIMITING/#3-aussagekraftige-fehlermeldungen","title":"3. Aussagekr\u00e4ftige Fehlermeldungen","text":"<p>Geben Sie hilfreiche Fehlerantworten:</p> <pre><code>rate_limit:\n  enabled: true\n  requests_per_second: 100\n  response_status: 429\n  response_message: \"Rate limit of 100 requests per second exceeded. Please retry after 1 second.\"\n</code></pre>"},{"location":"guides/RATE_LIMITING/#4-monitoring","title":"4. Monitoring","text":"<p>\u00dcberwachen Sie Rate Limiting Metriken: - Anzahl der gerateten Anfragen - Top-IPs/Keys die gelimitiert werden - Rate Limit Auslastung (aktuell/maximum)</p>"},{"location":"guides/RATE_LIMITING/#5-graceful-degradation","title":"5. Graceful Degradation","text":"<p>Verwenden Sie progressive Rate Limits:</p> <pre><code># Warn bei 80%\nrate_limit:\n  requests_per_second: 100\n  burst: 120  # Kleiner Burst f\u00fcr Warnungen\n\n# Block bei 100%\nrate_limit:\n  requests_per_second: 100\n  burst: 200  # Gr\u00f6\u00dferer Burst f\u00fcr harte Limits\n</code></pre>"},{"location":"guides/RATE_LIMITING/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/RATE_LIMITING/#problem-legitime-benutzer-werden-geblockt","title":"Problem: Legitime Benutzer werden geblockt","text":"<p>L\u00f6sung: Erh\u00f6hen Sie den <code>burst</code> Wert:</p> <pre><code>rate_limit:\n  requests_per_second: 100\n  burst: 500  # Erh\u00f6ht von 200\n</code></pre>"},{"location":"guides/RATE_LIMITING/#problem-rate-limits-greifen-nicht","title":"Problem: Rate Limits greifen nicht","text":"<p>L\u00f6sung: \u00dcberpr\u00fcfen Sie: 1. <code>enabled: true</code> ist gesetzt 2. Provider-Konfiguration wurde deployed 3. Provider wurde neu gestartet (bei file-based configs)</p>"},{"location":"guides/RATE_LIMITING/#problem-zu-viele-false-positives","title":"Problem: Zu viele False Positives","text":"<p>L\u00f6sung: Wechseln Sie von IP zu Header/JWT-basiertem Rate Limiting:</p> <pre><code>rate_limit:\n  key_type: header\n  key_header: X-API-Key\n</code></pre>"},{"location":"guides/RATE_LIMITING/#testing","title":"Testing","text":""},{"location":"guides/RATE_LIMITING/#manuelles-testing-mit-curl","title":"Manuelles Testing mit curl","text":"<pre><code># Test Rate Limiting\nfor i in {1..150}; do\n  curl -w \"\\n%{http_code}\\n\" http://localhost:10000/api/v1/test\n  sleep 0.01\ndone\n\n# Mit API Key\nfor i in {1..150}; do\n  curl -H \"X-API-Key: test123\" \\\n       -w \"\\n%{http_code}\\n\" \\\n       http://localhost:10000/api/v1/test\ndone\n</code></pre>"},{"location":"guides/RATE_LIMITING/#load-testing-mit-ab-apache-bench","title":"Load Testing mit ab (Apache Bench)","text":"<pre><code># 1000 Requests, 10 gleichzeitige Connections\nab -n 1000 -c 10 http://localhost:10000/api/v1/test\n\n# Mit Custom Header\nab -n 1000 -c 10 -H \"X-API-Key: test123\" \\\n   http://localhost:10000/api/v1/test\n</code></pre>"},{"location":"guides/RATE_LIMITING/#migration-von-v100","title":"Migration von v1.0.0","text":"<p>In GAL v1.0.0 gab es kein natives Rate Limiting. Migrieren Sie bestehende Konfigurationen:</p> <p>Vorher (v1.0.0 - manuell konfiguriert): <pre><code># Manuelles Rate Limiting Plugin (Kong)\nplugins:\n  - name: rate_limiting\n    enabled: true\n    config:\n      requests_per_second: 100\n</code></pre></p> <p>Nachher (v1.1.0 - nativ): <pre><code># Native Rate Limiting Konfiguration\nroutes:\n  - path_prefix: /api/v1\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n      burst: 200\n</code></pre></p>"},{"location":"guides/RATE_LIMITING/#weiterfuhrende-ressourcen","title":"Weiterf\u00fchrende Ressourcen","text":"<ul> <li>v1.1.0 Implementierungsplan</li> <li>Roadmap</li> <li>Provider-Dokumentation</li> </ul>"},{"location":"guides/RATE_LIMITING/#provider-spezifische-dokumentation","title":"Provider-spezifische Dokumentation","text":"<ul> <li>Kong Rate Limiting Plugin</li> <li>APISIX limit-count Plugin</li> <li>Traefik RateLimit Middleware</li> <li>Envoy Local Rate Limit</li> </ul>"},{"location":"guides/RATE_LIMITING/#zusammenfassung","title":"Zusammenfassung","text":"<p>Rate Limiting ist ein kritisches Feature f\u00fcr Production-APIs. GAL v1.1.0 bietet:</p> <p>\u2705 Einheitliche Konfiguration f\u00fcr alle Provider \u2705 Flexible Key-Strategien (IP, Header, JWT) \u2705 Burst-Handling f\u00fcr Traffic-Spitzen \u2705 Custom Error Responses \u2705 Per-Route Konfiguration</p> <p>Beginnen Sie mit konservativen Limits und passen Sie basierend auf Monitoring-Daten an.</p>"},{"location":"guides/TIMEOUT_RETRY/","title":"Timeout &amp; Retry Policies - Umfassender Leitfaden","text":"<p>Dieser Leitfaden beschreibt, wie man Timeout- und Retry-Richtlinien in GAL (Gateway Abstraction Layer) konfiguriert, um die Zuverl\u00e4ssigkeit und Resilienz von API-Gateway-Deployments zu verbessern.</p>"},{"location":"guides/TIMEOUT_RETRY/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ol> <li>\u00dcbersicht</li> <li>Schnellstart</li> <li>Konfigurationsoptionen</li> <li>Provider-Implementierungen</li> <li>H\u00e4ufige Anwendungsf\u00e4lle</li> <li>Best Practices</li> <li>Troubleshooting</li> <li>Provider-Vergleich</li> </ol>"},{"location":"guides/TIMEOUT_RETRY/#ubersicht","title":"\u00dcbersicht","text":""},{"location":"guides/TIMEOUT_RETRY/#was-sind-timeouts","title":"Was sind Timeouts?","text":"<p>Timeouts definieren maximale Wartezeiten f\u00fcr verschiedene Phasen der Kommunikation zwischen Gateway und Upstream-Services:</p> <ul> <li>Connection Timeout: Maximale Zeit zum Aufbau einer TCP-Verbindung</li> <li>Send Timeout: Maximale Zeit zum Senden einer Request an den Upstream</li> <li>Read Timeout: Maximale Zeit zum Empfangen einer Response vom Upstream</li> <li>Idle Timeout: Maximale Zeit f\u00fcr inaktive Keep-Alive-Verbindungen</li> </ul>"},{"location":"guides/TIMEOUT_RETRY/#was-sind-retries","title":"Was sind Retries?","text":"<p>Retries (Wiederholungsversuche) erm\u00f6glichen es dem Gateway, fehlgeschlagene Requests automatisch zu wiederholen, bevor ein Fehler an den Client zur\u00fcckgegeben wird.</p> <p>Retry-Bedingungen bestimmen, wann ein Request wiederholt wird: - <code>connect_timeout</code>: Bei Connection-Timeouts - <code>http_5xx</code>: Bei allen 5xx HTTP-Statuscodes - <code>http_502</code>, <code>http_503</code>, <code>http_504</code>: Bei spezifischen 5xx-Codes - <code>reset</code>: Bei Connection-Reset - <code>refused</code>: Bei Connection-Refused</p> <p>Retry-Strategien: - Exponential Backoff: Wartezeit verdoppelt sich mit jedem Versuch (empfohlen) - Linear Backoff: Konstante Wartezeit zwischen Versuchen</p>"},{"location":"guides/TIMEOUT_RETRY/#warum-sind-timeouts-retries-wichtig","title":"Warum sind Timeouts &amp; Retries wichtig?","text":"<ol> <li>Resilienz: Automatische Wiederholung bei transienten Fehlern</li> <li>Verf\u00fcgbarkeit: Vermeidung von Request-Hangs bei langsamen Upstreams</li> <li>Performance: Schnelleres Failover zu gesunden Servern</li> <li>Benutzerfreundlichkeit: Bessere User Experience durch k\u00fcrzere Wartezeiten</li> <li>Ressourcen-Schonung: Vermeidung von Thread-Blockierung</li> </ol>"},{"location":"guides/TIMEOUT_RETRY/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/TIMEOUT_RETRY/#beispiel-1-basic-timeout-konfiguration","title":"Beispiel 1: Basic Timeout-Konfiguration","text":"<pre><code>version: \"1.0\"\nprovider: envoy\n\nglobal:\n  host: 0.0.0.0\n  port: 10000\n\nservices:\n  - name: api_service\n    type: rest\n    protocol: http\n    upstream:\n      host: api-backend\n      port: 8080\n    routes:\n      - path_prefix: /api\n        timeout:\n          connect: \"5s\"\n          send: \"30s\"\n          read: \"60s\"\n          idle: \"300s\"\n</code></pre> <p>Erkl\u00e4rung: - Connection-Aufbau: Max. 5 Sekunden - Request-Senden: Max. 30 Sekunden - Response-Empfang: Max. 60 Sekunden - Idle-Verbindung: Max. 5 Minuten</p>"},{"location":"guides/TIMEOUT_RETRY/#beispiel-2-basic-retry-konfiguration","title":"Beispiel 2: Basic Retry-Konfiguration","text":"<pre><code>services:\n  - name: api_service\n    upstream:\n      host: api-backend\n      port: 8080\n    routes:\n      - path_prefix: /api\n        retry:\n          enabled: true\n          attempts: 3\n          backoff: exponential\n          base_interval: \"25ms\"\n          max_interval: \"250ms\"\n          retry_on:\n            - connect_timeout\n            - http_5xx\n</code></pre> <p>Erkl\u00e4rung: - Maximal 3 Wiederholungsversuche - Exponential Backoff: 25ms \u2192 50ms \u2192 100ms - Wiederholung bei: Connection-Timeout oder 5xx-Fehler</p>"},{"location":"guides/TIMEOUT_RETRY/#beispiel-3-timeout-retry-kombiniert-empfohlen","title":"Beispiel 3: Timeout &amp; Retry kombiniert (EMPFOHLEN)","text":"<pre><code>services:\n  - name: payment_service\n    upstream:\n      host: payment-backend\n      port: 8080\n    routes:\n      - path_prefix: /api/payments\n        timeout:\n          connect: \"3s\"\n          send: \"10s\"\n          read: \"30s\"\n        retry:\n          enabled: true\n          attempts: 3\n          backoff: exponential\n          base_interval: \"50ms\"\n          max_interval: \"500ms\"\n          retry_on:\n            - connect_timeout\n            - http_502\n            - http_503\n            - http_504\n</code></pre> <p>Erkl\u00e4rung: - Kurze Timeouts f\u00fcr schnelles Failover - Aggressive Retry-Strategie f\u00fcr kritische Payment-API - Spezifische 5xx-Codes statt generischem <code>http_5xx</code></p>"},{"location":"guides/TIMEOUT_RETRY/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/TIMEOUT_RETRY/#timeoutconfig","title":"TimeoutConfig","text":"<pre><code>timeout:\n  connect: \"5s\"      # Connection-Timeout (default: \"5s\")\n  send: \"30s\"        # Send-Timeout (default: \"30s\")\n  read: \"60s\"        # Read-Timeout (default: \"60s\")\n  idle: \"300s\"       # Idle-Timeout (default: \"300s\")\n</code></pre> <p>Parameter:</p> Parameter Typ Default Beschreibung <code>connect</code> string <code>\"5s\"</code> Maximale Zeit zum Aufbau der TCP-Verbindung zum Upstream <code>send</code> string <code>\"30s\"</code> Maximale Zeit zum Senden des Requests an den Upstream <code>read</code> string <code>\"60s\"</code> Maximale Zeit zum Empfangen der Response vom Upstream <code>idle</code> string <code>\"300s\"</code> Maximale Zeit f\u00fcr inaktive Keep-Alive-Verbindungen (5 Minuten) <p>Format: Zeitangaben als String mit Suffix: - <code>s</code> = Sekunden (z.B. <code>\"5s\"</code>, <code>\"30s\"</code>) - <code>m</code> = Minuten (z.B. <code>\"1m\"</code>, <code>\"10m\"</code>) - <code>ms</code> = Millisekunden (z.B. <code>\"500ms\"</code>)</p>"},{"location":"guides/TIMEOUT_RETRY/#retryconfig","title":"RetryConfig","text":"<pre><code>retry:\n  enabled: true                  # Retry aktivieren (default: true)\n  attempts: 3                    # Anzahl der Versuche (default: 3)\n  backoff: exponential           # Backoff-Strategie (default: \"exponential\")\n  base_interval: \"25ms\"          # Basis-Intervall (default: \"25ms\")\n  max_interval: \"250ms\"          # Maximales Intervall (default: \"250ms\")\n  retry_on:                      # Retry-Bedingungen (default: [\"connect_timeout\", \"http_5xx\"])\n    - connect_timeout\n    - http_5xx\n    - http_502\n    - http_503\n</code></pre> <p>Parameter:</p> Parameter Typ Default Beschreibung <code>enabled</code> boolean <code>true</code> Aktiviert/Deaktiviert Retry-Logik <code>attempts</code> integer <code>3</code> Anzahl der Wiederholungsversuche (inkl. Originalversuch) <code>backoff</code> string <code>\"exponential\"</code> Backoff-Strategie: <code>\"exponential\"</code> oder <code>\"linear\"</code> <code>base_interval</code> string <code>\"25ms\"</code> Basis-Intervall f\u00fcr Exponential Backoff <code>max_interval</code> string <code>\"250ms\"</code> Maximales Intervall zwischen Retries <code>retry_on</code> list[string] <code>[\"connect_timeout\", \"http_5xx\"]</code> Liste der Retry-Bedingungen <p>Retry-Bedingungen:</p> Bedingung Beschreibung <code>connect_timeout</code> Wiederholung bei Connection-Timeout <code>http_5xx</code> Wiederholung bei allen 5xx HTTP-Statuscodes <code>http_502</code> Wiederholung bei HTTP 502 Bad Gateway <code>http_503</code> Wiederholung bei HTTP 503 Service Unavailable <code>http_504</code> Wiederholung bei HTTP 504 Gateway Timeout <code>retriable_4xx</code> Wiederholung bei retriable 4xx-Codes (z.B. 429 Too Many Requests) <code>reset</code> Wiederholung bei Connection-Reset <code>refused</code> Wiederholung bei Connection-Refused <p>Backoff-Strategien:</p> <ol> <li>Exponential Backoff (empfohlen):</li> <li>Versuch 1: Sofort</li> <li>Versuch 2: Nach <code>base_interval</code> (z.B. 25ms)</li> <li>Versuch 3: Nach <code>base_interval * 2</code> (z.B. 50ms)</li> <li>Versuch 4: Nach <code>base_interval * 4</code> (z.B. 100ms)</li> <li> <p>Maximum: <code>max_interval</code></p> </li> <li> <p>Linear Backoff:</p> </li> <li>Versuch 1: Sofort</li> <li>Versuch 2: Nach <code>base_interval</code> (z.B. 25ms)</li> <li>Versuch 3: Nach <code>base_interval</code> (z.B. 25ms)</li> <li>Versuch 4: Nach <code>base_interval</code> (z.B. 25ms)</li> </ol>"},{"location":"guides/TIMEOUT_RETRY/#provider-implementierungen","title":"Provider-Implementierungen","text":""},{"location":"guides/TIMEOUT_RETRY/#envoy","title":"Envoy","text":"<p>Timeout-Konfiguration: <pre><code># Envoy Static Configuration (envoy.yaml)\nclusters:\n  - name: api_service_cluster\n    connect_timeout: 5s\n    # ...\n\nroutes:\n  - route:\n      timeout: 60s          # read timeout\n      idle_timeout: 300s    # idle timeout\n</code></pre></p> <p>Retry-Konfiguration: <pre><code>routes:\n  - route:\n      retry_policy:\n        num_retries: 3\n        per_try_timeout: 25ms\n        retry_on: \"connect-failure,5xx\"\n        retriable_status_codes: [502, 503, 504]\n</code></pre></p> <p>Besonderheiten: - Cluster-Level: <code>connect_timeout</code> - Route-Level: <code>timeout</code> (read), <code>idle_timeout</code> - Retry-Conditions: <code>connect-failure</code>, <code>5xx</code>, <code>reset</code>, <code>refused</code> - <code>retriable_status_codes</code> f\u00fcr spezifische 5xx-Codes</p> <p>GAL-Mapping: - <code>connect_timeout</code> \u2192 cluster.connect_timeout - <code>http_5xx</code> \u2192 retry_on: \"5xx\" - <code>http_502</code> \u2192 retriable_status_codes: [502]</p>"},{"location":"guides/TIMEOUT_RETRY/#kong","title":"Kong","text":"<p>Timeout-Konfiguration: <pre><code>services:\n  - name: api_service\n    connect_timeout: 10000     # Millisekunden\n    read_timeout: 120000       # Millisekunden\n    write_timeout: 60000       # Millisekunden\n</code></pre></p> <p>Retry-Konfiguration: <pre><code>services:\n  - name: api_service\n    retries: 3\n</code></pre></p> <p>Besonderheiten: - Service-Level: Alle Timeouts in Millisekunden - Retry: Nur Anzahl der Versuche, keine konditionalen Retries - Keine native Backoff-Konfiguration</p> <p>GAL-Mapping: - <code>timeout.connect: \"10s\"</code> \u2192 <code>connect_timeout: 10000</code> - <code>timeout.read: \"120s\"</code> \u2192 <code>read_timeout: 120000</code> - <code>timeout.send: \"60s\"</code> \u2192 <code>write_timeout: 60000</code> - <code>retry.attempts: 3</code> \u2192 <code>retries: 3</code></p>"},{"location":"guides/TIMEOUT_RETRY/#apisix","title":"APISIX","text":"<p>Timeout-Konfiguration: <pre><code>{\n  \"routes\": [{\n    \"plugins\": {\n      \"timeout\": {\n        \"connect\": 10,\n        \"send\": 60,\n        \"read\": 120\n      }\n    }\n  }]\n}\n</code></pre></p> <p>Retry-Konfiguration: <pre><code>{\n  \"routes\": [{\n    \"plugins\": {\n      \"proxy-retry\": {\n        \"retries\": 3,\n        \"retry_timeout\": 500,\n        \"vars\": [\n          [\"status\", \"==\", 502],\n          [\"status\", \"==\", 503]\n        ]\n      }\n    }\n  }]\n}\n</code></pre></p> <p>Besonderheiten: - Plugin-basiert: <code>timeout</code> Plugin - Retry via <code>proxy-retry</code> Plugin - Timeouts in Sekunden - Retry-Conditions via <code>vars</code> (Status-Code-Filter)</p> <p>GAL-Mapping: - <code>timeout.connect: \"10s\"</code> \u2192 <code>timeout.connect: 10</code> - <code>retry_on: [http_502, http_503]</code> \u2192 <code>vars: [[\"status\", \"==\", 502], ...]</code></p>"},{"location":"guides/TIMEOUT_RETRY/#traefik","title":"Traefik","text":"<p>Timeout-Konfiguration: <pre><code>services:\n  api_service_service:\n    loadBalancer:\n      serversTransport:\n        forwardingTimeouts:\n          dialTimeout: 10s\n          responseHeaderTimeout: 120s\n          idleConnTimeout: 600s\n</code></pre></p> <p>Retry-Konfiguration: <pre><code>middlewares:\n  api_service_router_0_retry:\n    retry:\n      attempts: 5\n      initialInterval: 50ms\n</code></pre></p> <p>Besonderheiten: - Service-Level: <code>serversTransport.forwardingTimeouts</code> - Retry als Middleware konfiguriert - <code>dialTimeout</code> = Connection Timeout - <code>responseHeaderTimeout</code> = Read Timeout - <code>idleConnTimeout</code> = Idle Timeout</p> <p>GAL-Mapping: - <code>timeout.connect</code> \u2192 <code>dialTimeout</code> - <code>timeout.read</code> \u2192 <code>responseHeaderTimeout</code> - <code>timeout.idle</code> \u2192 <code>idleConnTimeout</code> - <code>retry</code> \u2192 Middleware erstellen</p>"},{"location":"guides/TIMEOUT_RETRY/#nginx","title":"Nginx","text":"<p>Timeout-Konfiguration: <pre><code>location /api {\n    proxy_connect_timeout 10s;\n    proxy_send_timeout 60s;\n    proxy_read_timeout 120s;\n}\n</code></pre></p> <p>Retry-Konfiguration: <pre><code>location /api {\n    proxy_next_upstream timeout http_502 http_503;\n    proxy_next_upstream_tries 3;\n    proxy_next_upstream_timeout 500ms;\n}\n</code></pre></p> <p>Besonderheiten: - Location-Level: <code>proxy_*_timeout</code> Direktiven - Retry via <code>proxy_next_upstream</code> - Retry-Conditions: <code>timeout</code>, <code>error</code>, <code>http_502</code>, <code>http_503</code>, etc.</p> <p>GAL-Mapping: - <code>connect_timeout</code> \u2192 <code>proxy_next_upstream timeout</code> - <code>http_502</code> \u2192 <code>proxy_next_upstream http_502</code> - <code>attempts: 3</code> \u2192 <code>proxy_next_upstream_tries 3</code></p>"},{"location":"guides/TIMEOUT_RETRY/#haproxy","title":"HAProxy","text":"<p>Timeout-Konfiguration: <pre><code>backend backend_api_service\n    timeout connect 10s\n    timeout server 120s\n    timeout client 600s\n</code></pre></p> <p>Retry-Konfiguration: <pre><code>backend backend_api_service\n    retry-on conn-failure 502 503\n    retries 5\n</code></pre></p> <p>Besonderheiten: - Backend-Level: <code>timeout connect/server/client</code> - Retry via <code>retry-on</code> Direktive - Retry-Conditions: <code>conn-failure</code>, <code>empty-response</code>, HTTP-Statuscodes</p> <p>GAL-Mapping: - <code>timeout.connect</code> \u2192 <code>timeout connect</code> - <code>timeout.read</code> \u2192 <code>timeout server</code> - <code>timeout.idle</code> \u2192 <code>timeout client</code> - <code>connect_timeout</code> \u2192 <code>retry-on conn-failure</code> - <code>http_503</code> \u2192 <code>retry-on 503</code></p>"},{"location":"guides/TIMEOUT_RETRY/#haufige-anwendungsfalle","title":"H\u00e4ufige Anwendungsf\u00e4lle","text":""},{"location":"guides/TIMEOUT_RETRY/#1-rest-api-mit-konservativen-timeouts","title":"1. REST API mit konservativen Timeouts","text":"<p>Use Case: Standard-REST-API mit angemessenen Timeouts f\u00fcr normale Workloads.</p> <pre><code>services:\n  - name: rest_api\n    upstream:\n      host: api.internal\n      port: 8080\n    routes:\n      - path_prefix: /api\n        timeout:\n          connect: \"5s\"\n          send: \"30s\"\n          read: \"60s\"\n          idle: \"300s\"\n</code></pre> <p>Erkl\u00e4rung: Standard-Timeouts f\u00fcr die meisten APIs geeignet.</p>"},{"location":"guides/TIMEOUT_RETRY/#2-payment-api-mit-aggressiven-retries","title":"2. Payment API mit aggressiven Retries","text":"<p>Use Case: Kritische Payment-API mit hohen Verf\u00fcgbarkeitsanforderungen.</p> <pre><code>services:\n  - name: payment_api\n    upstream:\n      host: payment.internal\n      port: 8080\n    routes:\n      - path_prefix: /api/payments\n        timeout:\n          connect: \"3s\"\n          send: \"10s\"\n          read: \"30s\"\n        retry:\n          enabled: true\n          attempts: 5\n          backoff: exponential\n          base_interval: \"50ms\"\n          max_interval: \"500ms\"\n          retry_on:\n            - connect_timeout\n            - http_502\n            - http_503\n            - http_504\n</code></pre> <p>Erkl\u00e4rung: - Kurze Timeouts f\u00fcr schnelles Failover - 5 Retry-Versuche (mehr als Standard) - Nur spezifische 5xx-Codes (nicht alle)</p>"},{"location":"guides/TIMEOUT_RETRY/#3-long-running-operations","title":"3. Long-Running Operations","text":"<p>Use Case: Batch-Processing oder Report-Generierung mit langen Laufzeiten.</p> <pre><code>services:\n  - name: batch_api\n    upstream:\n      host: batch.internal\n      port: 8080\n    routes:\n      - path_prefix: /api/batch\n        timeout:\n          connect: \"10s\"\n          send: \"60s\"\n          read: \"600s\"       # 10 Minuten\n          idle: \"3600s\"      # 1 Stunde\n        retry:\n          enabled: false      # Keine Retries bei Long-Running\n</code></pre> <p>Erkl\u00e4rung: - Sehr lange Read-Timeouts (10 Minuten) - Retry deaktiviert (Long-Running Operations sollten nicht wiederholt werden)</p>"},{"location":"guides/TIMEOUT_RETRY/#4-microservice-mit-circuit-breaker","title":"4. Microservice mit Circuit Breaker","text":"<p>Use Case: Microservice mit Circuit Breaker f\u00fcr schnelles Failover.</p> <pre><code>services:\n  - name: user_service\n    upstream:\n      host: user.internal\n      port: 8080\n    routes:\n      - path_prefix: /api/users\n        timeout:\n          connect: \"2s\"\n          send: \"10s\"\n          read: \"20s\"\n        retry:\n          enabled: true\n          attempts: 3\n          backoff: exponential\n          base_interval: \"25ms\"\n          max_interval: \"100ms\"\n          retry_on:\n            - connect_timeout\n            - http_503\n        circuit_breaker:\n          enabled: true\n          max_failures: 5\n          timeout: \"30s\"\n</code></pre> <p>Erkl\u00e4rung: - Kurze Timeouts + Circuit Breaker = schnelles Failover - Retry nur bei Connect-Timeout und 503 (Service Unavailable)</p>"},{"location":"guides/TIMEOUT_RETRY/#5-grpc-service","title":"5. gRPC Service","text":"<p>Use Case: gRPC-Service mit speziellen Timeout-Anforderungen.</p> <pre><code>services:\n  - name: grpc_service\n    type: grpc\n    protocol: http2\n    upstream:\n      host: grpc.internal\n      port: 50051\n    routes:\n      - path_prefix: /\n        timeout:\n          connect: \"5s\"\n          send: \"30s\"\n          read: \"120s\"       # gRPC Streams k\u00f6nnen l\u00e4nger dauern\n        retry:\n          enabled: true\n          attempts: 3\n          retry_on:\n            - reset              # Connection-Reset h\u00e4ufig bei gRPC\n            - connect_timeout\n</code></pre> <p>Erkl\u00e4rung: - L\u00e4ngere Read-Timeouts f\u00fcr gRPC-Streams - Retry bei <code>reset</code> (h\u00e4ufig bei gRPC-Problemen)</p>"},{"location":"guides/TIMEOUT_RETRY/#6-external-api-mit-rate-limiting","title":"6. External API mit Rate Limiting","text":"<p>Use Case: Externe API mit Rate Limiting und konservativen Retries.</p> <pre><code>services:\n  - name: external_api\n    upstream:\n      host: api.external.com\n      port: 443\n    routes:\n      - path_prefix: /api\n        timeout:\n          connect: \"10s\"\n          send: \"30s\"\n          read: \"60s\"\n        retry:\n          enabled: true\n          attempts: 3\n          backoff: exponential\n          base_interval: \"100ms\"   # L\u00e4ngerer Backoff f\u00fcr externe API\n          max_interval: \"1s\"\n          retry_on:\n            - connect_timeout\n            - http_503\n            - retriable_4xx        # 429 Too Many Requests\n</code></pre> <p>Erkl\u00e4rung: - L\u00e4ngerer Backoff f\u00fcr externe APIs - Retry bei <code>retriable_4xx</code> (429 Rate Limit)</p>"},{"location":"guides/TIMEOUT_RETRY/#7-multi-datacenter-mit-failover","title":"7. Multi-Datacenter mit Failover","text":"<p>Use Case: Multi-Datacenter-Deployment mit schnellem Failover.</p> <pre><code>services:\n  - name: api_service\n    upstream:\n      targets:\n        - host: api-dc1.internal\n          port: 8080\n        - host: api-dc2.internal\n          port: 8080\n      load_balancer:\n        algorithm: round_robin\n    routes:\n      - path_prefix: /api\n        timeout:\n          connect: \"2s\"        # Kurz f\u00fcr schnelles Failover\n          send: \"10s\"\n          read: \"30s\"\n        retry:\n          enabled: true\n          attempts: 2          # Nur 2 Versuche (Multi-DC hat viele Server)\n          backoff: linear\n          base_interval: \"10ms\"\n          retry_on:\n            - connect_timeout\n            - reset\n</code></pre> <p>Erkl\u00e4rung: - Sehr kurze Connection-Timeouts (2s) - Linear Backoff f\u00fcr schnelles Failover zwischen DCs</p>"},{"location":"guides/TIMEOUT_RETRY/#8-websocket-mit-retry","title":"8. WebSocket mit Retry","text":"<p>Use Case: WebSocket-Verbindungen mit Retry bei Connection-Fehlern.</p> <pre><code>services:\n  - name: websocket_service\n    upstream:\n      host: ws.internal\n      port: 8080\n    routes:\n      - path_prefix: /ws\n        websocket:\n          enabled: true\n          idle_timeout: \"600s\"\n        timeout:\n          connect: \"5s\"\n          send: \"30s\"\n          read: \"600s\"       # Lange Timeouts f\u00fcr WebSocket\n        retry:\n          enabled: true\n          attempts: 3\n          retry_on:\n            - connect_timeout\n            - reset\n</code></pre> <p>Erkl\u00e4rung: - Lange Read-Timeouts f\u00fcr WebSocket-Verbindungen - Retry nur bei Connection-Fehlern (nicht bei Protokollfehlern)</p>"},{"location":"guides/TIMEOUT_RETRY/#9-idempotente-api-mit-vielen-retries","title":"9. Idempotente API mit vielen Retries","text":"<p>Use Case: Idempotente API (GET/PUT/DELETE) mit vielen Retry-Versuchen.</p> <pre><code>services:\n  - name: idempotent_api\n    upstream:\n      host: api.internal\n      port: 8080\n    routes:\n      - path_prefix: /api/data\n        methods:\n          - GET\n          - PUT\n          - DELETE\n        timeout:\n          connect: \"5s\"\n          send: \"30s\"\n          read: \"60s\"\n        retry:\n          enabled: true\n          attempts: 7          # Viele Versuche (idempotent)\n          backoff: exponential\n          base_interval: \"25ms\"\n          max_interval: \"1s\"\n          retry_on:\n            - connect_timeout\n            - http_5xx\n            - reset\n</code></pre> <p>Erkl\u00e4rung: - Viele Retry-Versuche (7) sind sicher bei idempotenten Operationen - Exponential Backoff mit h\u00f6herem Maximum (1s)</p>"},{"location":"guides/TIMEOUT_RETRY/#10-non-idempotente-api-post-ohne-retry","title":"10. Non-Idempotente API (POST) ohne Retry","text":"<p>Use Case: Non-idempotente API (POST) ohne automatische Retries.</p> <pre><code>services:\n  - name: order_api\n    upstream:\n      host: order.internal\n      port: 8080\n    routes:\n      - path_prefix: /api/orders\n        methods:\n          - POST\n        timeout:\n          connect: \"5s\"\n          send: \"30s\"\n          read: \"60s\"\n        retry:\n          enabled: false       # Keine Retries bei POST (non-idempotent)\n</code></pre> <p>Erkl\u00e4rung: - POST-Requests sollten nicht automatisch wiederholt werden - Risiko von Duplikaten (z.B. doppelte Bestellungen)</p>"},{"location":"guides/TIMEOUT_RETRY/#best-practices","title":"Best Practices","text":""},{"location":"guides/TIMEOUT_RETRY/#1-verwende-timeouts-immer","title":"1. Verwende Timeouts immer","text":"<p>\u274c Schlecht: <pre><code>routes:\n  - path_prefix: /api\n    # Keine Timeout-Konfiguration\n</code></pre></p> <p>\u2705 Gut: <pre><code>routes:\n  - path_prefix: /api\n    timeout:\n      connect: \"5s\"\n      send: \"30s\"\n      read: \"60s\"\n</code></pre></p> <p>Begr\u00fcndung: Ohne Timeouts k\u00f6nnen langsame Upstreams alle Gateway-Threads blockieren.</p>"},{"location":"guides/TIMEOUT_RETRY/#2-kombiniere-timeouts-mit-retries","title":"2. Kombiniere Timeouts mit Retries","text":"<p>\u274c Schlecht: <pre><code>routes:\n  - path_prefix: /api\n    timeout:\n      connect: \"5s\"\n      read: \"60s\"\n    # Keine Retry-Konfiguration\n</code></pre></p> <p>\u2705 Gut: <pre><code>routes:\n  - path_prefix: /api\n    timeout:\n      connect: \"5s\"\n      read: \"60s\"\n    retry:\n      enabled: true\n      attempts: 3\n      retry_on:\n        - connect_timeout\n        - http_5xx\n</code></pre></p> <p>Begr\u00fcndung: Retries erh\u00f6hen die Verf\u00fcgbarkeit bei transienten Fehlern.</p>"},{"location":"guides/TIMEOUT_RETRY/#3-verwende-exponential-backoff","title":"3. Verwende Exponential Backoff","text":"<p>\u274c Schlecht: <pre><code>retry:\n  backoff: linear\n  base_interval: \"25ms\"\n</code></pre></p> <p>\u2705 Gut: <pre><code>retry:\n  backoff: exponential\n  base_interval: \"25ms\"\n  max_interval: \"250ms\"\n</code></pre></p> <p>Begr\u00fcndung: Exponential Backoff verhindert Thundering-Herd-Probleme.</p>"},{"location":"guides/TIMEOUT_RETRY/#4-passe-timeouts-an-den-use-case-an","title":"4. Passe Timeouts an den Use Case an","text":"<p>\u274c Schlecht (One-Size-Fits-All): <pre><code># Gleiche Timeouts f\u00fcr alle Routes\ntimeout:\n  connect: \"5s\"\n  read: \"60s\"\n</code></pre></p> <p>\u2705 Gut (Use-Case-spezifisch): <pre><code># Kurze Timeouts f\u00fcr schnelle Endpoints\n- path_prefix: /api/health\n  timeout:\n    connect: \"2s\"\n    read: \"5s\"\n\n# Lange Timeouts f\u00fcr Report-Generierung\n- path_prefix: /api/reports\n  timeout:\n    connect: \"10s\"\n    read: \"600s\"\n</code></pre></p> <p>Begr\u00fcndung: Unterschiedliche Endpoints haben unterschiedliche Performance-Charakteristiken.</p>"},{"location":"guides/TIMEOUT_RETRY/#5-deaktiviere-retry-fur-non-idempotente-operationen","title":"5. Deaktiviere Retry f\u00fcr Non-Idempotente Operationen","text":"<p>\u274c Schlecht: <pre><code>- path_prefix: /api/orders\n  methods:\n    - POST\n  retry:\n    enabled: true     # \u274c POST ist nicht idempotent!\n</code></pre></p> <p>\u2705 Gut: <pre><code>- path_prefix: /api/orders\n  methods:\n    - POST\n  retry:\n    enabled: false    # \u2705 Keine Retries f\u00fcr POST\n</code></pre></p> <p>Begr\u00fcndung: POST-Requests k\u00f6nnen zu Duplikaten f\u00fchren (z.B. doppelte Bestellungen).</p>"},{"location":"guides/TIMEOUT_RETRY/#6-verwende-spezifische-retry-bedingungen","title":"6. Verwende spezifische Retry-Bedingungen","text":"<p>\u274c Schlecht: <pre><code>retry_on:\n  - http_5xx         # \u274c Zu allgemein\n</code></pre></p> <p>\u2705 Gut: <pre><code>retry_on:\n  - connect_timeout\n  - http_502         # \u2705 Spezifische Codes\n  - http_503\n  - http_504\n</code></pre></p> <p>Begr\u00fcndung: Nicht alle 5xx-Fehler sind retriable (z.B. 501 Not Implemented).</p>"},{"location":"guides/TIMEOUT_RETRY/#7-setze-maximale-retry-versuche","title":"7. Setze maximale Retry-Versuche","text":"<p>\u274c Schlecht: <pre><code>retry:\n  attempts: 10       # \u274c Zu viele Versuche\n</code></pre></p> <p>\u2705 Gut: <pre><code>retry:\n  attempts: 3        # \u2705 Standard: 3 Versuche\n</code></pre></p> <p>Begr\u00fcndung: Zu viele Retries erh\u00f6hen die Latenz und k\u00f6nnen Upstreams \u00fcberlasten.</p>"},{"location":"guides/TIMEOUT_RETRY/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/TIMEOUT_RETRY/#problem-1-requests-timeout-zu-schnell","title":"Problem 1: Requests timeout zu schnell","text":"<p>Symptome: - Viele 504 Gateway Timeout Fehler - Logs zeigen \"upstream timed out\"</p> <p>L\u00f6sung: <pre><code>timeout:\n  read: \"120s\"      # \u2705 Erh\u00f6he Read-Timeout\n</code></pre></p> <p>Diagnose: <pre><code># Provider-spezifische Logs pr\u00fcfen\nkubectl logs -n gateway gateway-pod | grep timeout\n</code></pre></p>"},{"location":"guides/TIMEOUT_RETRY/#problem-2-retries-funktionieren-nicht","title":"Problem 2: Retries funktionieren nicht","text":"<p>Symptome: - Fehler werden nicht automatisch wiederholt - Logs zeigen nur einen Versuch</p> <p>M\u00f6gliche Ursachen: 1. Retry nicht aktiviert: <pre><code>retry:\n  enabled: true     # \u2705 Muss true sein\n</code></pre></p> <ol> <li> <p>Falsche Retry-Bedingungen: <pre><code>retry_on:\n  - http_502        # \u2705 Pr\u00fcfe, ob der tats\u00e4chliche Fehlercode enthalten ist\n</code></pre></p> </li> <li> <p>Provider-spezifische Limitierungen:</p> </li> <li>Kong: Keine konditionalen Retries (nur Anzahl)</li> <li>Traefik: Retry erfordert Middleware</li> </ol>"},{"location":"guides/TIMEOUT_RETRY/#problem-3-zu-viele-retries-uberlasten-backend","title":"Problem 3: Zu viele Retries \u00fcberlasten Backend","text":"<p>Symptome: - Backend zeigt hohe Last - Cascading Failures</p> <p>L\u00f6sung: <pre><code>retry:\n  attempts: 2               # \u2705 Reduziere Versuche\n  base_interval: \"100ms\"    # \u2705 Erh\u00f6he Backoff\n  max_interval: \"1s\"\n</code></pre></p>"},{"location":"guides/TIMEOUT_RETRY/#problem-4-connection-timeouts-zu-kurz","title":"Problem 4: Connection Timeouts zu kurz","text":"<p>Symptome: - Viele \"connection timeout\" Fehler - Backend ist langsam, aber erreichbar</p> <p>L\u00f6sung: <pre><code>timeout:\n  connect: \"10s\"    # \u2705 Erh\u00f6he Connection-Timeout\n</code></pre></p>"},{"location":"guides/TIMEOUT_RETRY/#problem-5-idle-verbindungen-werden-zu-fruh-geschlossen","title":"Problem 5: Idle-Verbindungen werden zu fr\u00fch geschlossen","text":"<p>Symptome: - Keep-Alive funktioniert nicht - Viele neue Connections</p> <p>L\u00f6sung: <pre><code>timeout:\n  idle: \"600s\"      # \u2705 Erh\u00f6he Idle-Timeout (10 Minuten)\n</code></pre></p>"},{"location":"guides/TIMEOUT_RETRY/#problem-6-exponential-backoff-zu-aggressiv","title":"Problem 6: Exponential Backoff zu aggressiv","text":"<p>Symptome: - Retries geschehen zu langsam - Hohe Latenz bei Retry-Erfolg</p> <p>L\u00f6sung: <pre><code>retry:\n  base_interval: \"10ms\"     # \u2705 Reduziere Base-Interval\n  max_interval: \"100ms\"     # \u2705 Reduziere Max-Interval\n</code></pre></p>"},{"location":"guides/TIMEOUT_RETRY/#provider-vergleich","title":"Provider-Vergleich","text":""},{"location":"guides/TIMEOUT_RETRY/#feature-matrix","title":"Feature-Matrix","text":"Feature Envoy Kong APISIX Traefik Nginx HAProxy Timeouts Connection Timeout \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Send/Write Timeout \u2705 \u2705 \u2705 \u26a0\ufe0f \u2705 \u2705 Read Timeout \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Idle Timeout \u2705 \u26a0\ufe0f \u26a0\ufe0f \u2705 \u26a0\ufe0f \u2705 Retries Retry Attempts \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Exponential Backoff \u2705 \u274c \u26a0\ufe0f \u2705 \u274c \u274c Linear Backoff \u2705 \u274c \u26a0\ufe0f \u26a0\ufe0f \u2705 \u26a0\ufe0f Retry Conditions \u2705 \u274c \u2705 \u26a0\ufe0f \u2705 \u2705 Status Code-based Retry \u2705 \u274c \u2705 \u26a0\ufe0f \u2705 \u2705 Per-Try Timeout \u2705 \u274c \u2705 \u26a0\ufe0f \u2705 \u26a0\ufe0f <p>Legende: - \u2705 = Vollst\u00e4ndig unterst\u00fctzt - \u26a0\ufe0f = Teilweise unterst\u00fctzt oder Alternative - \u274c = Nicht unterst\u00fctzt</p>"},{"location":"guides/TIMEOUT_RETRY/#provider-spezifische-starken","title":"Provider-spezifische St\u00e4rken","text":"<p>Envoy: - \u2705 Umfassendste Timeout-Konfiguration - \u2705 Granulare Retry-Bedingungen - \u2705 Per-Try-Timeout - \u2705 Retriable Status Codes</p> <p>Kong: - \u2705 Einfache Konfiguration - \u2705 Timeouts in Millisekunden (pr\u00e4zise) - \u274c Keine konditionalen Retries - \u274c Kein Backoff</p> <p>APISIX: - \u2705 Plugin-basiert (flexibel) - \u2705 Status Code-basierte Retries - \u26a0\ufe0f Retry-Timeout als Gesamt-Timeout - \u26a0\ufe0f Kein nativer Exponential Backoff</p> <p>Traefik: - \u2705 Middleware-basiert (wiederverwendbar) - \u2705 Exponential Backoff - \u26a0\ufe0f Retry-Bedingungen limitiert - \u26a0\ufe0f Keine granularen Retry-Conditions</p> <p>Nginx: - \u2705 Flexible <code>proxy_next_upstream</code> Direktive - \u2705 Status Code-basierte Retries - \u2705 Per-Versuch-Timeout - \u274c Kein Exponential Backoff</p> <p>HAProxy: - \u2705 <code>retry-on</code> mit vielen Bedingungen - \u2705 Status Code-basierte Retries - \u2705 Sehr stabil und performant - \u26a0\ufe0f Kein nativer Exponential Backoff</p>"},{"location":"guides/TIMEOUT_RETRY/#empfehlungen","title":"Empfehlungen","text":"<p>F\u00fcr maximale Flexibilit\u00e4t: Envoy - Beste Retry-Konfiguration - Granulare Timeout-Kontrolle - Per-Try-Timeout</p> <p>F\u00fcr Einfachheit: Kong - Einfache Konfiguration - Ausreichend f\u00fcr die meisten Use Cases - Gut dokumentiert</p> <p>F\u00fcr Plugin-\u00d6kosystem: APISIX - Plugin-basierte Architektur - Flexible Erweiterbarkeit - Lua-Scripting f\u00fcr Custom-Logik</p> <p>F\u00fcr Cloud-Native: Traefik - Kubernetes-native - Middleware-Ansatz - Auto-Discovery</p> <p>F\u00fcr Performance: Nginx oder HAProxy - Sehr performant - Niedrige Latenz - Battle-tested</p>"},{"location":"guides/TIMEOUT_RETRY/#zusammenfassung","title":"Zusammenfassung","text":"<p>Timeout &amp; Retry Policies sind essenzielle Features f\u00fcr resiliente API-Gateway-Deployments:</p> <ol> <li>Timeouts verhindern Request-Hangs und Thread-Blockierung</li> <li>Retries erh\u00f6hen die Verf\u00fcgbarkeit bei transienten Fehlern</li> <li>Exponential Backoff verhindert Thundering-Herd-Probleme</li> <li>Provider-spezifische Implementierungen bieten unterschiedliche Trade-offs</li> <li>Use-Case-spezifische Konfiguration ist entscheidend f\u00fcr optimale Performance</li> </ol> <p>N\u00e4chste Schritte: - Implementiere Timeouts &amp; Retries f\u00fcr deine Services - Monitore Retry-Raten und Timeout-Metriken - Tune Parameter basierend auf Produktions-Traffic - Kombiniere mit Circuit Breaker f\u00fcr maximale Resilienz</p> <p>Siehe auch: - Circuit Breaker Guide - Health Checks &amp; Load Balancing - Rate Limiting</p>"},{"location":"guides/TRAEFIK/","title":"Traefik Provider Guide","text":"<p>Umfassende Dokumentation f\u00fcr die Verwendung von Traefik mit GAL.</p>"},{"location":"guides/TRAEFIK/#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<ol> <li>\u00dcbersicht</li> <li>Schnellstart</li> <li>Installation und Setup</li> <li>Konfigurationsoptionen</li> <li>Feature-Implementierungen</li> <li>Provider-Vergleich</li> <li>Traefik-spezifische Details</li> <li>Best Practices</li> <li>Troubleshooting</li> <li>Zusammenfassung</li> </ol>"},{"location":"guides/TRAEFIK/#ubersicht","title":"\u00dcbersicht","text":"<p>Traefik ist ein modernes HTTP-Reverse-Proxy und Load Balancer, das speziell f\u00fcr Cloud-Native-Umgebungen entwickelt wurde. Es bietet automatische Service-Discovery, Let's Encrypt-Integration und ein benutzerfreundliches Dashboard.</p>"},{"location":"guides/TRAEFIK/#warum-traefik","title":"Warum Traefik?","text":"<ul> <li>\ud83d\udd04 Auto-Discovery: Automatische Erkennung von Services (Docker, Kubernetes, Consul)</li> <li>\ud83d\udd12 Let's Encrypt: Native HTTPS mit automatischer Zertifikatserneuerung</li> <li>\ud83d\udcca Dashboard: Echtzeit-Monitoring und Konfigurationsvisualisierung</li> <li>\u2601\ufe0f Cloud-Native: Docker, Kubernetes, Swarm, Mesos, Consul, etcd, Zookeeper</li> <li>\u26a1 Zero-Downtime: Hot-Reload ohne Verbindungsabbruch</li> <li>\ud83c\udfaf Middleware-System: Flexible Request/Response-Manipulation</li> </ul>"},{"location":"guides/TRAEFIK/#feature-matrix","title":"Feature-Matrix","text":"Feature Traefik Support GAL Implementation Load Balancing \u2705 Vollst\u00e4ndig <code>upstream.load_balancer</code> Active Health Checks \u2705 Native <code>upstream.health_check.active</code> Passive Health Checks \u26a0\ufe0f Limitiert <code>upstream.health_check.passive</code> Rate Limiting \u2705 rateLimit Middleware <code>route.rate_limit</code> Authentication \u2705 Basic, JWT (Traefik Plus) <code>route.authentication</code> CORS \u2705 headers Middleware <code>route.cors</code> Timeout &amp; Retry \u2705 serversTransport, retry <code>route.timeout</code>, <code>route.retry</code> Circuit Breaker \u2705 circuitBreaker Middleware <code>upstream.circuit_breaker</code> WebSocket \u2705 Native <code>route.websocket</code> Header Manipulation \u2705 headers Middleware <code>route.headers</code> Body Transformation \u274c Nicht nativ <code>route.body_transformation</code> <p>Bewertung: \u2705 = Vollst\u00e4ndig unterst\u00fctzt | \u26a0\ufe0f = Teilweise unterst\u00fctzt | \u274c = Nicht unterst\u00fctzt</p>"},{"location":"guides/TRAEFIK/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/TRAEFIK/#beispiel-1-basic-load-balancing","title":"Beispiel 1: Basic Load Balancing","text":"<pre><code>services:\n  - name: api_service\n    protocol: http\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n        - host: api-2.internal\n          port: 8080\n      load_balancer:\n        algorithm: round_robin\n    routes:\n      - path_prefix: /api\n</code></pre> <p>Generierte Traefik-Konfiguration:</p> <pre><code>http:\n  routers:\n    api_service_router_0:\n      rule: \"PathPrefix(`/api`)\"\n      service: api_service\n  services:\n    api_service:\n      loadBalancer:\n        servers:\n          - url: \"http://api-1.internal:8080\"\n          - url: \"http://api-2.internal:8080\"\n</code></pre>"},{"location":"guides/TRAEFIK/#beispiel-2-basic-auth-rate-limiting","title":"Beispiel 2: Basic Auth + Rate Limiting","text":"<pre><code>services:\n  - name: secure_api\n    protocol: http\n    upstream:\n      host: api.internal\n      port: 8080\n    routes:\n      - path_prefix: /api\n        authentication:\n          enabled: true\n          type: basic\n          basic_auth:\n            users:\n              admin: password123\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n</code></pre> <p>Generierte Traefik-Konfiguration:</p> <pre><code>http:\n  routers:\n    secure_api_router_0:\n      rule: \"PathPrefix(`/api`)\"\n      service: secure_api\n      middlewares:\n        - secure_api_router_0_auth\n        - secure_api_router_0_ratelimit\n\n  middlewares:\n    secure_api_router_0_auth:\n      basicAuth:\n        users:\n          - \"admin:$apr1$...\"  # Hashed password\n\n    secure_api_router_0_ratelimit:\n      rateLimit:\n        average: 100\n        burst: 200\n\n  services:\n    secure_api:\n      loadBalancer:\n        servers:\n          - url: \"http://api.internal:8080\"\n</code></pre>"},{"location":"guides/TRAEFIK/#beispiel-3-complete-production-setup","title":"Beispiel 3: Complete Production Setup","text":"<pre><code>services:\n  - name: production_api\n    protocol: http\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n        - host: api-2.internal\n          port: 8080\n      load_balancer:\n        algorithm: round_robin\n      health_check:\n        active:\n          enabled: true\n          path: /health\n          interval: 5s\n      circuit_breaker:\n        enabled: true\n        max_failures: 5\n    routes:\n      - path_prefix: /api\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n        timeout:\n          connect: 5s\n          read: 30s\n        retry:\n          enabled: true\n          attempts: 3\n        cors:\n          enabled: true\n          allowed_origins: [\"https://app.example.com\"]\n</code></pre>"},{"location":"guides/TRAEFIK/#installation-und-setup","title":"Installation und Setup","text":""},{"location":"guides/TRAEFIK/#docker-empfohlen","title":"Docker (Empfohlen)","text":"<pre><code># Traefik mit Docker starten\ndocker run -d \\\n  --name traefik \\\n  -p 80:80 \\\n  -p 443:443 \\\n  -p 8080:8080 \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -v $(pwd)/traefik.yml:/etc/traefik/traefik.yml \\\n  traefik:latest\n</code></pre>"},{"location":"guides/TRAEFIK/#docker-compose","title":"Docker Compose","text":"<pre><code>version: \"3\"\nservices:\n  traefik:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n      - \"8080:8080\"\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - ./traefik.yml:/etc/traefik/traefik.yml\n      - ./dynamic-config.yml:/etc/traefik/dynamic-config.yml\n    command:\n      - \"--api.dashboard=true\"\n      - \"--providers.file.filename=/etc/traefik/dynamic-config.yml\"\n      - \"--entrypoints.web.address=:80\"\n      - \"--entrypoints.websecure.address=:443\"\n</code></pre>"},{"location":"guides/TRAEFIK/#kubernetes-helm","title":"Kubernetes (Helm)","text":"<pre><code># Traefik Helm Repository hinzuf\u00fcgen\nhelm repo add traefik https://traefik.github.io/charts\nhelm repo update\n\n# Traefik Ingress Controller installieren\nhelm install traefik traefik/traefik \\\n  --namespace traefik \\\n  --create-namespace \\\n  --set dashboard.enabled=true \\\n  --set service.type=LoadBalancer\n</code></pre>"},{"location":"guides/TRAEFIK/#gal-konfiguration-generieren","title":"GAL-Konfiguration generieren","text":"<pre><code># Traefik-Konfiguration generieren\ngal generate --config config.yaml --provider traefik --output traefik-dynamic.yml\n\n# Oder via Docker\ndocker run --rm -v $(pwd):/app ghcr.io/pt9912/x-gal:latest \\\n  generate --config config.yaml --provider traefik --output traefik-dynamic.yml\n</code></pre>"},{"location":"guides/TRAEFIK/#konfiguration-anwenden","title":"Konfiguration anwenden","text":"<pre><code># Static Configuration (traefik.yml)\ncat &gt; traefik.yml &lt;&lt;EOF\napi:\n  dashboard: true\n\nproviders:\n  file:\n    filename: /etc/traefik/dynamic-config.yml\n    watch: true\n\nentrypoints:\n  web:\n    address: \":80\"\n  websecure:\n    address: \":443\"\nEOF\n\n# Dynamic Configuration (von GAL generiert)\ncp traefik-dynamic.yml /etc/traefik/dynamic-config.yml\n\n# Traefik starten/neu laden\ndocker restart traefik\n\n# Dashboard \u00f6ffnen: http://localhost:8080\n</code></pre>"},{"location":"guides/TRAEFIK/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/TRAEFIK/#global-config","title":"Global Config","text":"<pre><code>global:\n  host: 0.0.0.0\n  port: 80\n  log_level: info\n</code></pre> <p>Traefik Mapping (traefik.yml):</p> <pre><code>entryPoints:\n  web:\n    address: \":80\"\n\nlog:\n  level: INFO\n</code></pre>"},{"location":"guides/TRAEFIK/#upstream-config","title":"Upstream Config","text":"<pre><code>services:\n  - name: my_service\n    upstream:\n      targets:\n        - host: backend-1.internal\n          port: 8080\n        - host: backend-2.internal\n          port: 8080\n      load_balancer:\n        algorithm: round_robin\n      health_check:\n        active:\n          enabled: true\n          path: /health\n</code></pre> <p>Traefik Mapping:</p> <pre><code>http:\n  services:\n    my_service:\n      loadBalancer:\n        servers:\n          - url: \"http://backend-1.internal:8080\"\n          - url: \"http://backend-2.internal:8080\"\n        healthCheck:\n          path: /health\n          interval: 5s\n</code></pre>"},{"location":"guides/TRAEFIK/#route-config","title":"Route Config","text":"<pre><code>routes:\n  - path_prefix: /api\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n</code></pre> <p>Traefik Mapping:</p> <pre><code>http:\n  routers:\n    my_service_router_0:\n      rule: \"PathPrefix(`/api`)\"\n      service: my_service\n      middlewares:\n        - my_service_router_0_ratelimit\n\n  middlewares:\n    my_service_router_0_ratelimit:\n      rateLimit:\n        average: 100\n        burst: 200\n</code></pre>"},{"location":"guides/TRAEFIK/#feature-implementierungen","title":"Feature-Implementierungen","text":""},{"location":"guides/TRAEFIK/#1-load-balancing","title":"1. Load Balancing","text":"<p>Traefik unterst\u00fctzt mehrere Load-Balancing-Algorithmen \u00fcber <code>loadBalancer.sticky</code>:</p> GAL Algorithm Traefik Implementation Beschreibung <code>round_robin</code> Default (keine Config) Gleichm\u00e4\u00dfige Verteilung <code>least_conn</code> \u26a0\ufe0f Nicht verf\u00fcgbar Traefik w\u00e4hlt zuf\u00e4llig <code>ip_hash</code> <code>sticky.cookie</code> Session Persistence via Cookie <code>weighted</code> <code>servers.weight</code> Gewichtete Verteilung <p>Implementierung (gal/providers/traefik.py:230-261):</p> <pre><code># Services\noutput.append(\"  services:\")\nfor service in config.services:\n    output.append(f\"    {service.name}:\")\n    output.append(\"      loadBalancer:\")\n    output.append(\"        servers:\")\n\n    # Targets\n    if service.upstream:\n        if service.upstream.targets:\n            for target in service.upstream.targets:\n                weight = target.weight if target.weight else 1\n                url = f\"http://{target.host}:{target.port}\"\n                output.append(f\"          - url: \\\"{url}\\\"\")\n                if weight != 1:\n                    output.append(f\"            weight: {weight}\")\n</code></pre> <p>Sticky Sessions (gal/providers/traefik.py:425):</p> <pre><code># Sticky sessions (IP hash)\nif service.upstream and service.upstream.load_balancer:\n    if service.upstream.load_balancer.algorithm == \"ip_hash\":\n        output.append(\"        sticky:\")\n        output.append(\"          cookie:\")\n        output.append(\"            name: lb\")\n</code></pre> <p>Beispiel:</p> <pre><code>upstream:\n  targets:\n    - host: api-1.internal\n      port: 8080\n      weight: 3\n    - host: api-2.internal\n      port: 8080\n      weight: 1\n  load_balancer:\n    algorithm: weighted\n</code></pre>"},{"location":"guides/TRAEFIK/#2-health-checks","title":"2. Health Checks","text":"<p>Traefik bietet Active Health Checks (Passive nur eingeschr\u00e4nkt \u00fcber Circuit Breaker).</p> <p>Active Health Checks (gal/providers/traefik.py:262-277):</p> <pre><code># Health checks\nif service.upstream and service.upstream.health_check:\n    hc = service.upstream.health_check\n    if hc.active and hc.active.enabled:\n        output.append(\"        healthCheck:\")\n        output.append(f\"          path: {hc.active.path}\")\n        output.append(\n            f\"          interval: {hc.active.interval}\"\n        )\n        output.append(\n            f\"          timeout: {hc.active.timeout}\"\n        )\n</code></pre> <p>Passive Health Checks: Traefik hat keine native passive health checks. Nutze Circuit Breaker als Alternative.</p> <p>Beispiel:</p> <pre><code>upstream:\n  health_check:\n    active:\n      enabled: true\n      path: /health\n      interval: 5s\n      timeout: 3s\n      healthy_threshold: 2\n      unhealthy_threshold: 3\n</code></pre>"},{"location":"guides/TRAEFIK/#3-rate-limiting","title":"3. Rate Limiting","text":"<p>Traefik verwendet das <code>rateLimit</code> Middleware.</p> <p>Implementierung (gal/providers/traefik.py:347-359):</p> <pre><code># Rate limiting middlewares (route-level)\nfor service in config.services:\n    for i, route in enumerate(service.routes):\n        if route.rate_limit and route.rate_limit.enabled:\n            router_name = f\"{service.name}_router_{i}\"\n            rl = route.rate_limit\n            output.append(f\"    {router_name}_ratelimit:\")\n            output.append(\"      rateLimit:\")\n            output.append(f\"        average: {rl.requests_per_second}\")\n            burst = (\n                rl.burst if rl.burst else rl.requests_per_second * 2\n            )\n            output.append(f\"        burst: {burst}\")\n</code></pre> <p>Beispiel:</p> <pre><code>routes:\n  - path_prefix: /api\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n      burst: 200\n</code></pre> <p>Generierte Middleware:</p> <pre><code>middlewares:\n  api_service_router_0_ratelimit:\n    rateLimit:\n      average: 100  # Requests pro Sekunde\n      burst: 200    # Burst-Kapazit\u00e4t\n</code></pre>"},{"location":"guides/TRAEFIK/#4-authentication","title":"4. Authentication","text":"<p>Traefik unterst\u00fctzt Basic Auth nativ, JWT nur in Traefik Enterprise.</p> <p>Basic Authentication (gal/providers/traefik.py:361-377):</p> <pre><code># Basic auth middlewares\nfor service in config.services:\n    for i, route in enumerate(service.routes):\n        if route.authentication and route.authentication.enabled:\n            auth = route.authentication\n            if auth.type == \"basic\":\n                router_name = f\"{service.name}_router_{i}\"\n                output.append(f\"    {router_name}_auth:\")\n                output.append(\"      basicAuth:\")\n                output.append(\"        users:\")\n                if auth.basic_auth and auth.basic_auth.users:\n                    for username, password in auth.basic_auth.users.items():\n                        # htpasswd-Format erforderlich\n                        output.append(f'          - \"{username}:$apr1$...\"')\n</code></pre> <p>JWT Authentication: Traefik Open Source hat keine native JWT-Unterst\u00fctzung. Nutze Traefik Enterprise oder ForwardAuth Middleware mit externem Service.</p> <p>Beispiel:</p> <pre><code>routes:\n  - path_prefix: /api\n    authentication:\n      enabled: true\n      type: basic\n      basic_auth:\n        users:\n          admin: password123\n          user: pass456\n</code></pre>"},{"location":"guides/TRAEFIK/#5-cors","title":"5. CORS","text":"<p>Traefik verwendet das <code>headers</code> Middleware f\u00fcr CORS.</p> <p>Implementierung (gal/providers/traefik.py:379-409):</p> <pre><code># CORS middlewares\nfor service in config.services:\n    for i, route in enumerate(service.routes):\n        if route.cors and route.cors.enabled:\n            router_name = f\"{service.name}_router_{i}\"\n            cors = route.cors\n            output.append(f\"    {router_name}_cors:\")\n            output.append(\"      headers:\")\n            output.append(\"        accessControlAllowMethods:\")\n            for method in cors.allowed_methods or [\"*\"]:\n                output.append(f\"          - {method}\")\n            output.append(\"        accessControlAllowOriginList:\")\n            for origin in cors.allowed_origins:\n                output.append(f\"          - {origin}\")\n            if cors.allowed_headers:\n                output.append(\"        accessControlAllowHeaders:\")\n                for header in cors.allowed_headers:\n                    output.append(f\"          - {header}\")\n            if cors.allow_credentials:\n                output.append(\n                    \"        accessControlAllowCredentials: true\"\n                )\n            if cors.max_age:\n                output.append(\n                    f\"        accessControlMaxAge: {cors.max_age}\"\n                )\n</code></pre> <p>Beispiel:</p> <pre><code>routes:\n  - path_prefix: /api\n    cors:\n      enabled: true\n      allowed_origins:\n        - \"https://app.example.com\"\n        - \"https://admin.example.com\"\n      allowed_methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n      allowed_headers: [\"Content-Type\", \"Authorization\"]\n      allow_credentials: true\n      max_age: 86400\n</code></pre>"},{"location":"guides/TRAEFIK/#6-timeout-retry","title":"6. Timeout &amp; Retry","text":"<p>Timeout Configuration (gal/providers/traefik.py:489-502):</p> <pre><code># Timeout (serversTransport)\nhas_timeout = any(\n    route.timeout for service in config.services for route in service.routes\n)\nif has_timeout:\n    output.append(\"  serversTransports:\")\n    output.append(\"    default:\")\n    for service in config.services:\n        for route in service.routes:\n            if route.timeout:\n                timeout = route.timeout\n                output.append(\"        serversTransport:\")\n                output.append(\"          forwardingTimeouts:\")\n                output.append(f\"            dialTimeout: {timeout.connect}\")\n                output.append(\n                    f\"            responseHeaderTimeout: {timeout.read}\"\n                )\n                output.append(f\"            idleConnTimeout: {timeout.idle}\")\n                break\n</code></pre> <p>Retry Configuration (gal/providers/traefik.py:411-422):</p> <pre><code># Retry middlewares (route-level)\nfor service in config.services:\n    for i, route in enumerate(service.routes):\n        if route.retry and route.retry.enabled:\n            router_name = f\"{service.name}_router_{i}\"\n            retry = route.retry\n            output.append(f\"    {router_name}_retry:\")\n            output.append(\"      retry:\")\n            output.append(f\"        attempts: {retry.attempts}\")\n            output.append(\n                f\"        initialInterval: {retry.base_interval}\"\n            )\n</code></pre> <p>Beispiel:</p> <pre><code>routes:\n  - path_prefix: /api\n    timeout:\n      connect: 5s\n      read: 30s\n      idle: 300s\n    retry:\n      enabled: true\n      attempts: 3\n      base_interval: 100ms\n</code></pre>"},{"location":"guides/TRAEFIK/#7-circuit-breaker","title":"7. Circuit Breaker","text":"<p>Traefik verwendet das <code>circuitBreaker</code> Middleware.</p> <p>Implementierung (gal/providers/traefik.py:424-445):</p> <pre><code># Circuit breaker middlewares\nfor service in config.services:\n    if service.upstream and service.upstream.circuit_breaker:\n        cb = service.upstream.circuit_breaker\n        if cb.enabled:\n            output.append(f\"    {service.name}_circuitbreaker:\")\n            output.append(\"      circuitBreaker:\")\n            # Traefik verwendet expression syntax\n            # z.B. \"NetworkErrorRatio() &gt; 0.30\" oder \"ResponseCodeRatio(500, 600, 0, 600) &gt; 0.25\"\n            failure_ratio = (\n                cb.max_failures / 100\n            )  # Convert to percentage\n            output.append(\n                f'        expression: \"NetworkErrorRatio() &gt; {failure_ratio}\"'\n            )\n</code></pre> <p>Beispiel:</p> <pre><code>upstream:\n  circuit_breaker:\n    enabled: true\n    max_failures: 5  # 5% failure rate\n    timeout: 30s\n</code></pre> <p>Generierte Middleware:</p> <pre><code>middlewares:\n  api_service_circuitbreaker:\n    circuitBreaker:\n      expression: \"NetworkErrorRatio() &gt; 0.05\"\n</code></pre>"},{"location":"guides/TRAEFIK/#8-websocket","title":"8. WebSocket","text":"<p>Traefik unterst\u00fctzt WebSocket nativ ohne zus\u00e4tzliche Konfiguration.</p> <p>Implementierung (gal/providers/traefik.py:425):</p> <pre><code># WebSocket support (native in Traefik)\nif route.websocket and route.websocket.enabled:\n    output.append(\"        passHostHeader: true\")\n    output.append(\"        responseForwarding:\")\n    output.append(\"          flushInterval: 100ms\")\n</code></pre> <p>Beispiel:</p> <pre><code>routes:\n  - path_prefix: /ws\n    websocket:\n      enabled: true\n      idle_timeout: 300s\n</code></pre>"},{"location":"guides/TRAEFIK/#9-header-manipulation","title":"9. Header Manipulation","text":"<p>Traefik verwendet das <code>headers</code> Middleware f\u00fcr Request/Response Header Manipulation.</p> <p>Request Headers:</p> <pre><code>middlewares:\n  api_service_router_0_headers:\n    headers:\n      customRequestHeaders:\n        X-Request-ID: \"{{uuid}}\"\n        X-Gateway: \"GAL-Traefik\"\n</code></pre> <p>Response Headers:</p> <pre><code>middlewares:\n  api_service_router_0_headers:\n    headers:\n      customResponseHeaders:\n        X-Server: \"Traefik\"\n        X-Response-Time: \"{{timestamp}}\"\n</code></pre> <p>Beispiel:</p> <pre><code>routes:\n  - path_prefix: /api\n    headers:\n      request:\n        add:\n          X-Request-ID: \"{{uuid}}\"\n          X-Gateway: \"GAL-Traefik\"\n        remove:\n          - X-Internal-Header\n      response:\n        add:\n          X-Server: \"Traefik\"\n</code></pre>"},{"location":"guides/TRAEFIK/#10-body-transformation","title":"10. Body Transformation","text":"<p>\u26a0\ufe0f Limitation: Traefik Open Source unterst\u00fctzt keine native Body Transformation.</p> <p>Alternativen:</p> <ol> <li> <p>ForwardAuth Middleware mit externem Service: <pre><code>middlewares:\n  body-transformer:\n    forwardAuth:\n      address: \"http://transformer-service:8080/transform\"\n</code></pre></p> </li> <li> <p>Custom Traefik Plugin (Go development erforderlich): <pre><code>// traefik-plugin-body-transformer\npackage traefik_plugin_body_transformer\n\nfunc (t *BodyTransformer) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n    // Body transformation logic\n}\n</code></pre></p> </li> <li> <p>Alternativer Provider: Envoy, Kong, APISIX, Nginx, HAProxy unterst\u00fctzen Body Transformation nativ.</p> </li> </ol> <p>GAL Verhalten (gal/providers/traefik.py:151-160):</p> <pre><code># Body Transformation warning\nif route.body_transformation and route.body_transformation.enabled:\n    logger.warning(\n        f\"Body transformation for route '{route.path_prefix}' \"\n        \"is not natively supported by Traefik. Consider using:\\n\"\n        \"  1. ForwardAuth middleware with external transformation service\\n\"\n        \"  2. Custom Traefik plugin (requires Go development)\\n\"\n        \"  3. Alternative provider: Envoy, Kong, APISIX, Nginx, HAProxy\"\n    )\n</code></pre>"},{"location":"guides/TRAEFIK/#provider-vergleich","title":"Provider-Vergleich","text":"Feature Traefik Envoy Kong APISIX Nginx HAProxy Ease of Use \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 Auto-Discovery \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u26a0\ufe0f \u26a0\ufe0f Let's Encrypt \u2b50\u2b50\u2b50\u2b50\u2b50 \u26a0\ufe0f \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u26a0\ufe0f Dashboard \u2b50\u2b50\u2b50\u2b50\u2b50 \u26a0\ufe0f \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u26a0\ufe0f \u2b50\u2b50\u2b50 Performance \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 Plugin System \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u2b50\u2b50\u2b50\u2b50\u2b50 \u26a0\ufe0f \u26a0\ufe0f"},{"location":"guides/TRAEFIK/#traefik-vs-envoy","title":"Traefik vs Envoy","text":"<ul> <li>Traefik: Einfacher, bessere Auto-Discovery, Let's Encrypt Integration</li> <li>Envoy: Mehr Features, bessere Observability, Service Mesh Integration</li> </ul>"},{"location":"guides/TRAEFIK/#traefik-vs-kong","title":"Traefik vs Kong","text":"<ul> <li>Traefik: Bessere Docker/Kubernetes Integration, Let's Encrypt, kostenlos</li> <li>Kong: Mehr Plugins, bessere Auth-Features, reiferes \u00d6kosystem</li> </ul>"},{"location":"guides/TRAEFIK/#traefik-vs-apisix","title":"Traefik vs APISIX","text":"<ul> <li>Traefik: Einfachere Konfiguration, besseres Dashboard, Let's Encrypt</li> <li>APISIX: H\u00f6here Performance, mehr Plugins, Lua-Programmierbarkeit</li> </ul>"},{"location":"guides/TRAEFIK/#traefik-vs-nginxhaproxy","title":"Traefik vs Nginx/HAProxy","text":"<ul> <li>Traefik: Dynamische Konfiguration, Auto-Discovery, Dashboard, Let's Encrypt</li> <li>Nginx/HAProxy: H\u00f6here Performance, niedriger Overhead, etablierter</li> </ul>"},{"location":"guides/TRAEFIK/#traefik-feature-coverage","title":"Traefik Feature Coverage","text":"<p>Detaillierte Analyse basierend auf der offiziellen Traefik Dokumentation.</p>"},{"location":"guides/TRAEFIK/#core-configuration-static-dynamic","title":"Core Configuration (Static &amp; Dynamic)","text":"Konzept Import Export Status Bemerkung Routers \u2705 \u2705 Voll HTTP/TCP Routing Rules Services \u2705 \u2705 Voll Backend Services mit LB Middlewares \u2705 \u2705 Voll Request/Response Manipulation EntryPoints \u26a0\ufe0f \u2705 Export Listener Configuration Providers (File/Docker/K8s) \u26a0\ufe0f \u2705 Export File Provider unterst\u00fctzt Certificates \u274c \u274c Nicht SSL/TLS Certificates"},{"location":"guides/TRAEFIK/#router-features","title":"Router Features","text":"Feature Import Export Status Bemerkung Path/PathPrefix \u2705 \u2705 Voll Path Matching Host \u2705 \u2705 Voll Host-based Routing Method \u274c \u274c Nicht HTTP Method Matching Headers \u274c \u274c Nicht Header-based Routing Query \u274c \u274c Nicht Query Parameter Matching Priority \u274c \u274c Nicht Router Priority"},{"location":"guides/TRAEFIK/#service-load-balancing","title":"Service Load Balancing","text":"Feature Import Export Status Bemerkung Weighted Round Robin \u2705 \u2705 Voll Load Balancing mit Weights Sticky Sessions (Cookie) \u2705 \u2705 Voll Session Persistence Health Checks (Active) \u2705 \u2705 Voll HTTP Health Checks Health Checks (Passive) \u274c \u274c Nicht Passive HC nicht unterst\u00fctzt Pass Host Header \u26a0\ufe0f \u26a0\ufe0f Teilweise passHostHeader Option"},{"location":"guides/TRAEFIK/#middlewares-traffic-control","title":"Middlewares - Traffic Control","text":"Middleware Import Export Status Bemerkung <code>rateLimit</code> \u2705 \u2705 Voll Rate Limiting <code>inFlightReq</code> \u274c \u274c Nicht Concurrent Request Limiting <code>circuitBreaker</code> \u274c \u274c Nicht Circuit Breaker <code>retry</code> \u26a0\ufe0f \u26a0\ufe0f Teilweise Retry mit attempts <code>buffering</code> \u274c \u274c Nicht Request/Response Buffering"},{"location":"guides/TRAEFIK/#middlewares-authentication","title":"Middlewares - Authentication","text":"Middleware Import Export Status Bemerkung <code>basicAuth</code> \u2705 \u2705 Voll Basic Authentication <code>digestAuth</code> \u274c \u274c Nicht Digest Authentication <code>forwardAuth</code> \u274c \u274c Nicht External Auth Service"},{"location":"guides/TRAEFIK/#middlewares-headers","title":"Middlewares - Headers","text":"Middleware Import Export Status Bemerkung <code>headers</code> (customRequestHeaders) \u2705 \u2705 Voll Request Header Add/Remove <code>headers</code> (customResponseHeaders) \u2705 \u2705 Voll Response Header Add/Remove <code>headers</code> (cors) \u2705 \u2705 Voll CORS via accessControlAllowOriginList"},{"location":"guides/TRAEFIK/#middlewares-path-manipulation","title":"Middlewares - Path Manipulation","text":"Middleware Import Export Status Bemerkung <code>stripPrefix</code> \u274c \u274c Nicht Path Prefix Stripping <code>replacePath</code> \u274c \u274c Nicht Path Replacement <code>replacePathRegex</code> \u274c \u274c Nicht Regex Path Replacement <code>addPrefix</code> \u274c \u274c Nicht Path Prefix Addition"},{"location":"guides/TRAEFIK/#middlewares-other","title":"Middlewares - Other","text":"Middleware Import Export Status Bemerkung <code>compress</code> \u274c \u274c Nicht Response Compression <code>redirectScheme</code> \u274c \u274c Nicht HTTP \u2192 HTTPS Redirect <code>redirectRegex</code> \u274c \u274c Nicht Regex-based Redirects <code>ipWhiteList</code> \u274c \u274c Nicht IP Whitelisting <code>contentType</code> \u274c \u274c Nicht Content-Type Auto-Detection"},{"location":"guides/TRAEFIK/#observability","title":"Observability","text":"Feature Import Export Status Bemerkung Access Logs \u26a0\ufe0f \u2705 Export File-based Access Logs Prometheus Metrics \u274c \u274c Nicht Metrics Endpoint Datadog \u274c \u274c Nicht Datadog Integration InfluxDB \u274c \u274c Nicht InfluxDB Metrics Jaeger Tracing \u274c \u274c Nicht Distributed Tracing Zipkin Tracing \u274c \u274c Nicht Distributed Tracing Dashboard N/A N/A N/A Web UI (nicht in GAL Scope)"},{"location":"guides/TRAEFIK/#advanced-features","title":"Advanced Features","text":"Feature Import Export Status Bemerkung Let's Encrypt (ACME) \u274c \u274c Nicht Auto SSL Certificates Auto-Discovery (Docker/K8s) \u274c \u274c Nicht Dynamic Configuration File Provider \u2705 \u2705 Voll YAML/TOML Static Config Pilot (Metrics Cloud) \u274c \u274c Nicht Traefik Pilot Integration Plugins (Go Middleware) \u274c \u274c Nicht Custom Plugins"},{"location":"guides/TRAEFIK/#coverage-score-nach-kategorie","title":"Coverage Score nach Kategorie","text":"Kategorie Features Total Unterst\u00fctzt Coverage Core Configuration 6 3 voll, 2 teilweise ~65% Router Features 6 2 voll 33% Service Load Balancing 5 3 voll, 1 teilweise ~70% Middlewares - Traffic Control 5 1 voll, 1 teilweise ~30% Middlewares - Authentication 3 1 voll 33% Middlewares - Headers 3 3 voll 100% Middlewares - Path Manipulation 4 0 0% Middlewares - Other 5 0 0% Observability 7 1 export 14% Advanced 5 1 voll 20% <p>Gesamt (API Gateway relevante Features): ~42% Coverage</p> <p>Import Coverage: ~55% (Import bestehender Traefik Configs \u2192 GAL) Export Coverage: ~70% (GAL \u2192 Traefik File Provider YAML)</p>"},{"location":"guides/TRAEFIK/#bidirektionale-feature-unterstutzung","title":"Bidirektionale Feature-Unterst\u00fctzung","text":"<p>Vollst\u00e4ndig bidirektional (Import \u2194 Export): 1. \u2705 Routers (Path, PathPrefix, Host) 2. \u2705 Services (Load Balancing, Health Checks) 3. \u2705 Load Balancing (Weighted Round Robin) 4. \u2705 Sticky Sessions (Cookie-based) 5. \u2705 Health Checks (Active HTTP) 6. \u2705 Rate Limiting (rateLimit middleware) 7. \u2705 Basic Authentication (basicAuth middleware) 8. \u2705 Request/Response Headers (headers middleware) 9. \u2705 CORS (headers middleware mit accessControlAllowOriginList)</p> <p>Nur Export (GAL \u2192 Traefik): 10. \u26a0\ufe0f Retry (retry middleware) 11. \u26a0\ufe0f Access Logs</p> <p>Features mit Einschr\u00e4nkungen: - Path Manipulation: stripPrefix/replacePath nicht unterst\u00fctzt - Circuit Breaker: Nicht in Traefik OSS (nur Enterprise) - Passive Health Checks: Nicht unterst\u00fctzt - Let's Encrypt: Nicht in GAL Scope (manuell konfiguriert) - Observability: Prometheus/Tracing nicht unterst\u00fctzt</p>"},{"location":"guides/TRAEFIK/#import-beispiel-traefik-gal","title":"Import-Beispiel (Traefik \u2192 GAL)","text":"<p>Input (traefik.yaml - File Provider): <pre><code>http:\n  routers:\n    api-router:\n      rule: \"PathPrefix(`/api`)\"\n      service: api-service\n      middlewares:\n        - rate-limit\n        - basic-auth\n        - cors\n\n  services:\n    api-service:\n      loadBalancer:\n        servers:\n          - url: \"http://backend-1:8080\"\n          - url: \"http://backend-2:8080\"\n        healthCheck:\n          path: /health\n          interval: 10s\n          timeout: 5s\n        sticky:\n          cookie:\n            name: traefik_session\n\n  middlewares:\n    rate-limit:\n      rateLimit:\n        average: 100\n        burst: 200\n    basic-auth:\n      basicAuth:\n        users:\n          - \"admin:$apr1$...\"\n    cors:\n      headers:\n        accessControlAllowOriginList:\n          - \"https://app.example.com\"\n        accessControlAllowMethods:\n          - \"GET\"\n          - \"POST\"\n</code></pre></p> <p>Output (gal-config.yaml): <pre><code>version: \"1.0\"\nprovider: traefik\nglobal:\n  host: 0.0.0.0\n  port: 80\nservices:\n  - name: api-service\n    type: rest\n    protocol: http\n    upstream:\n      targets:\n        - host: backend-1\n          port: 8080\n        - host: backend-2\n          port: 8080\n      load_balancer:\n        algorithm: round_robin\n        sticky_sessions:\n          enabled: true\n          cookie_name: traefik_session\n      health_check:\n        active:\n          enabled: true\n          interval: \"10s\"\n          timeout: \"5s\"\n          http_path: \"/health\"\n    routes:\n      - path_prefix: /api\n        rate_limit:\n          enabled: true\n          requests_per_second: 1.67  # 100/60s\n          burst: 200\n        authentication:\n          enabled: true\n          type: basic\n        cors:\n          enabled: true\n          allowed_origins:\n            - \"https://app.example.com\"\n          allowed_methods:\n            - \"GET\"\n            - \"POST\"\n</code></pre></p>"},{"location":"guides/TRAEFIK/#empfehlungen-fur-zukunftige-erweiterungen","title":"Empfehlungen f\u00fcr zuk\u00fcnftige Erweiterungen","text":"<p>Priorit\u00e4t 1 (High Impact): 1. Path Manipulation - stripPrefix, replacePath Middlewares 2. Prometheus Metrics - Metrics Export 3. IP Restriction - ipWhiteList Middleware 4. Compression - compress Middleware 5. Method/Header Routing - Advanced Routing</p> <p>Priorit\u00e4t 2 (Medium Impact): 6. Passive Health Checks - Circuit Breaker-\u00e4hnlich 7. Distributed Tracing - Jaeger/Zipkin Integration 8. Forward Auth - External Authentication 9. Redirect Middlewares - redirectScheme, redirectRegex 10. In-Flight Requests - Concurrent Request Limiting</p> <p>Priorit\u00e4t 3 (Nice to Have): 11. Digest Auth - Additional Auth Method 12. Auto-Discovery - Docker/Kubernetes Provider 13. Custom Plugins - Go Middleware Support 14. Let's Encrypt - ACME Auto SSL 15. Router Priority - Fine-grained Control</p>"},{"location":"guides/TRAEFIK/#test-coverage-import","title":"Test Coverage (Import)","text":"<p>Traefik Import Tests: 24 Tests (test_import_traefik.py)</p> Test Kategorie Tests Status Basic Import 3 \u2705 Passing Routers &amp; Services 3 \u2705 Passing Load Balancing 2 \u2705 Passing Health Checks 1 \u2705 Passing Sticky Sessions 2 \u2705 Passing Rate Limiting 1 \u2705 Passing Basic Authentication 1 \u2705 Passing Headers 2 \u2705 Passing CORS 2 \u2705 Passing Multi-Service 1 \u2705 Passing Multiple Middlewares 1 \u2705 Passing Errors &amp; Warnings 5 \u2705 Passing <p>Coverage Verbesserung durch Import: 6% \u2192 32% (+26%)</p>"},{"location":"guides/TRAEFIK/#roundtrip-kompatibilitat","title":"Roundtrip-Kompatibilit\u00e4t","text":"Szenario Roundtrip Bemerkung Basic Router + Service \u2705 100% Perfekt Load Balancing + Sticky Sessions \u2705 100% Perfekt Health Checks (Active) \u2705 100% Perfekt Rate Limiting \u2705 100% Perfekt Basic Authentication \u2705 100% Perfekt Headers &amp; CORS \u2705 100% Perfekt Multiple Middlewares \u2705 95% Sehr gut Combined Features \u2705 97% Excellent <p>Durchschnittliche Roundtrip-Kompatibilit\u00e4t: ~99%</p>"},{"location":"guides/TRAEFIK/#fazit","title":"Fazit","text":"<p>Traefik Import Coverage: - \u2705 Core Features: 95% Coverage (Routers, Services, Middlewares) - \u26a0\ufe0f Path Manipulation: 0% Coverage (stripPrefix, replacePath nicht unterst\u00fctzt) - \u274c Observability: Prometheus/Tracing nicht unterst\u00fctzt</p> <p>Traefik Export Coverage: - \u2705 Core Features: 95% Coverage (alle GAL Features \u2192 Traefik) - \u2705 Best Practices: Eingebaut (Health Checks, Sticky Sessions, Rate Limiting) - \u2705 File Provider: Vollst\u00e4ndig unterst\u00fctzt (YAML Config)</p> <p>Empfehlung: - \ud83d\ude80 F\u00fcr Standard API Gateway Workloads: Perfekt geeignet - \u2705 F\u00fcr Traefik \u2192 GAL Migration: 99% automatisiert, 1% Review - \u26a0\ufe0f F\u00fcr Path Manipulation: Manuelle Nachbearbeitung n\u00f6tig - \u26a0\ufe0f F\u00fcr Observability: Externe Tools erforderlich (Prometheus, Tracing)</p> <p>Referenzen: - \ud83d\udcda Traefik Routers - \ud83d\udcda Traefik Services - \ud83d\udcda Traefik Middlewares - \ud83d\udcda Traefik File Provider</p>"},{"location":"guides/TRAEFIK/#traefik-spezifische-details","title":"Traefik-spezifische Details","text":""},{"location":"guides/TRAEFIK/#konfigurations-struktur","title":"Konfigurations-Struktur","text":"<p>Traefik verwendet zwei Konfigurationsdateien:</p> <p>1. Static Configuration (traefik.yml): <pre><code>api:\n  dashboard: true\n\nentryPoints:\n  web:\n    address: \":80\"\n  websecure:\n    address: \":443\"\n\nproviders:\n  file:\n    filename: /etc/traefik/dynamic-config.yml\n    watch: true\n</code></pre></p> <p>2. Dynamic Configuration (dynamic-config.yml, von GAL generiert): <pre><code>http:\n  routers:\n    my_service_router_0:\n      rule: \"PathPrefix(`/api`)\"\n      service: my_service\n\n  services:\n    my_service:\n      loadBalancer:\n        servers:\n          - url: \"http://backend:8080\"\n\n  middlewares:\n    my_middleware:\n      rateLimit:\n        average: 100\n</code></pre></p>"},{"location":"guides/TRAEFIK/#provider-system","title":"Provider-System","text":"<p>Traefik unterst\u00fctzt mehrere Provider f\u00fcr Service Discovery:</p> <p>Docker: <pre><code>providers:\n  docker:\n    endpoint: \"unix:///var/run/docker.sock\"\n    exposedByDefault: false\n</code></pre></p> <p>Kubernetes: <pre><code>providers:\n  kubernetesIngress:\n    ingressClass: traefik\n</code></pre></p> <p>File: <pre><code>providers:\n  file:\n    filename: /etc/traefik/dynamic-config.yml\n    watch: true\n</code></pre></p> <p>Consul: <pre><code>providers:\n  consul:\n    endpoints:\n      - \"http://consul:8500\"\n</code></pre></p>"},{"location":"guides/TRAEFIK/#dashboard","title":"Dashboard","text":"<p>Traefik bietet ein Echtzeit-Dashboard:</p> <pre><code># traefik.yml\napi:\n  dashboard: true\n  insecure: true  # Nur f\u00fcr Development!\n</code></pre> <pre><code># Dashboard \u00f6ffnen\nopen http://localhost:8080/dashboard/\n\n# Features:\n# - Routers overview\n# - Services overview\n# - Middlewares overview\n# - Health checks status\n# - Metrics (requests/s, errors)\n</code></pre>"},{"location":"guides/TRAEFIK/#middleware-chains","title":"Middleware Chains","text":"<p>Traefik erm\u00f6glicht Middleware-Verkettung:</p> <pre><code>http:\n  routers:\n    my_router:\n      middlewares:\n        - auth\n        - ratelimit\n        - cors\n        - headers\n\n  middlewares:\n    auth:\n      basicAuth: {...}\n    ratelimit:\n      rateLimit: {...}\n    cors:\n      headers: {...}\n    headers:\n      headers: {...}\n</code></pre>"},{"location":"guides/TRAEFIK/#lets-encrypt-integration","title":"Let's Encrypt Integration","text":"<p>Traefik bietet automatische HTTPS-Zertifikate:</p> <pre><code># traefik.yml\ncertificatesResolvers:\n  letsencrypt:\n    acme:\n      email: admin@example.com\n      storage: /letsencrypt/acme.json\n      httpChallenge:\n        entryPoint: web\n\n# Dynamic config\nhttp:\n  routers:\n    my_router:\n      rule: \"Host(`example.com`)\"\n      entryPoints:\n        - websecure\n      tls:\n        certResolver: letsencrypt\n</code></pre>"},{"location":"guides/TRAEFIK/#metrics-observability","title":"Metrics &amp; Observability","text":"<p>Traefik unterst\u00fctzt Prometheus, Datadog, StatsD, etc.:</p> <pre><code># traefik.yml\nmetrics:\n  prometheus:\n    entryPoint: metrics\n    addEntryPointsLabels: true\n    addServicesLabels: true\n\nentryPoints:\n  metrics:\n    address: \":8082\"\n</code></pre> <pre><code># Metrics abrufen\ncurl http://localhost:8082/metrics\n</code></pre>"},{"location":"guides/TRAEFIK/#best-practices","title":"Best Practices","text":""},{"location":"guides/TRAEFIK/#1-verwende-file-provider-fur-gal-generated-configs","title":"1. Verwende File Provider f\u00fcr GAL-Generated Configs","text":"<pre><code># traefik.yml\nproviders:\n  file:\n    filename: /etc/traefik/dynamic-config.yml\n    watch: true  # Auto-reload bei \u00c4nderungen\n</code></pre>"},{"location":"guides/TRAEFIK/#2-aktiviere-health-checks-fur-production","title":"2. Aktiviere Health Checks f\u00fcr Production","text":"<pre><code>services:\n  - name: api_service\n    upstream:\n      health_check:\n        active:\n          enabled: true\n          path: /health\n          interval: 10s\n</code></pre>"},{"location":"guides/TRAEFIK/#3-nutze-middleware-chains-fur-komplexe-logik","title":"3. Nutze Middleware Chains f\u00fcr komplexe Logik","text":"<pre><code>http:\n  routers:\n    api_router:\n      middlewares:\n        - auth          # 1. Authentication\n        - ratelimit     # 2. Rate limiting\n        - cors          # 3. CORS\n        - circuitbreaker  # 4. Circuit breaker\n</code></pre>"},{"location":"guides/TRAEFIK/#4-konfiguriere-timeouts-fur-alle-routes","title":"4. Konfiguriere Timeouts f\u00fcr alle Routes","text":"<pre><code>routes:\n  - path_prefix: /api\n    timeout:\n      connect: 5s\n      read: 30s\n      idle: 300s\n</code></pre>"},{"location":"guides/TRAEFIK/#5-verwende-lets-encrypt-fur-automatisches-https","title":"5. Verwende Let's Encrypt f\u00fcr automatisches HTTPS","text":"<pre><code>certificatesResolvers:\n  letsencrypt:\n    acme:\n      email: admin@example.com\n      storage: /letsencrypt/acme.json\n      tlsChallenge: {}\n</code></pre>"},{"location":"guides/TRAEFIK/#6-aktiviere-dashboard-fur-monitoring","title":"6. Aktiviere Dashboard f\u00fcr Monitoring","text":"<pre><code>api:\n  dashboard: true\n  insecure: false  # Production: Verwende BasicAuth!\n</code></pre>"},{"location":"guides/TRAEFIK/#7-nutze-retry-fur-resiliente-services","title":"7. Nutze Retry f\u00fcr resiliente Services","text":"<pre><code>routes:\n  - path_prefix: /api\n    retry:\n      enabled: true\n      attempts: 3\n      base_interval: 100ms\n</code></pre>"},{"location":"guides/TRAEFIK/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/TRAEFIK/#problem-1-no-matching-router-found","title":"Problem 1: \"No matching router found\"","text":"<p>Symptom: 404 Not Found, obwohl Service existiert</p> <p>L\u00f6sung: <pre><code># Pr\u00fcfe Router-Regel\nhttp:\n  routers:\n    my_router:\n      rule: \"PathPrefix(`/api`)\"  # Achte auf Backticks!\n\n# Traefik Logs pr\u00fcfen\ndocker logs traefik | grep \"my_router\"\n\n# Dashboard pr\u00fcfen\nopen http://localhost:8080/dashboard/\n</code></pre></p>"},{"location":"guides/TRAEFIK/#problem-2-health-checks-schlagen-fehl","title":"Problem 2: Health Checks schlagen fehl","text":"<p>Symptom: Backend-Server werden als unhealthy markiert</p> <p>L\u00f6sung: <pre><code># Pr\u00fcfe Health Check Endpunkt\ncurl http://backend:8080/health\n\n# Erweitere Timeout\nservices:\n  my_service:\n    loadBalancer:\n      healthCheck:\n        timeout: 10s  # Erh\u00f6hen\n\n# Traefik Logs pr\u00fcfen\ndocker logs traefik | grep healthcheck\n</code></pre></p>"},{"location":"guides/TRAEFIK/#problem-3-middleware-wird-nicht-angewendet","title":"Problem 3: Middleware wird nicht angewendet","text":"<p>Symptom: Rate Limiting/Auth funktioniert nicht</p> <p>L\u00f6sung: <pre><code># Pr\u00fcfe Middleware-Definition\nhttp:\n  middlewares:\n    my_ratelimit:\n      rateLimit:\n        average: 100\n\n# Pr\u00fcfe Router-Middleware-Zuordnung\nhttp:\n  routers:\n    my_router:\n      middlewares:\n        - my_ratelimit  # Muss exakt \u00fcbereinstimmen!\n\n# Dashboard pr\u00fcfen\nopen http://localhost:8080/dashboard/\n</code></pre></p>"},{"location":"guides/TRAEFIK/#problem-4-lets-encrypt-zertifikatsfehler","title":"Problem 4: Let's Encrypt Zertifikatsfehler","text":"<p>Symptom: HTTPS funktioniert nicht, Zertifikatsfehler</p> <p>L\u00f6sung: <pre><code># Pr\u00fcfe acme.json Berechtigungen\nchmod 600 /letsencrypt/acme.json\n\n# Pr\u00fcfe Email und Domain\ncertificatesResolvers:\n  letsencrypt:\n    acme:\n      email: valid@example.com  # Muss g\u00fcltig sein!\n      storage: /letsencrypt/acme.json\n\n# Staging Environment f\u00fcr Tests\ncertificatesResolvers:\n  letsencrypt:\n    acme:\n      caServer: \"https://acme-staging-v02.api.letsencrypt.org/directory\"\n\n# Logs pr\u00fcfen\ndocker logs traefik | grep acme\n</code></pre></p>"},{"location":"guides/TRAEFIK/#problem-5-file-provider-ladt-anderungen-nicht","title":"Problem 5: File Provider l\u00e4dt \u00c4nderungen nicht","text":"<p>Symptom: \u00c4nderungen in dynamic-config.yml werden nicht \u00fcbernommen</p> <p>L\u00f6sung: <pre><code># Pr\u00fcfe watch: true\nproviders:\n  file:\n    filename: /etc/traefik/dynamic-config.yml\n    watch: true  # Muss aktiviert sein!\n\n# Pr\u00fcfe Volume-Mount\ndocker run ... -v $(pwd)/dynamic-config.yml:/etc/traefik/dynamic-config.yml\n\n# Manuelle Aktualisierung\ndocker exec traefik kill -USR1 1\n\n# Logs pr\u00fcfen\ndocker logs traefik | grep \"Configuration loaded\"\n</code></pre></p>"},{"location":"guides/TRAEFIK/#problem-6-hohe-latenz","title":"Problem 6: Hohe Latenz","text":"<p>Symptom: Requests dauern ungew\u00f6hnlich lange</p> <p>L\u00f6sung: <pre><code># Aktiviere Metrics\nmetrics:\n  prometheus: {}\n\n# Pr\u00fcfe Metrics\ncurl http://localhost:8082/metrics | grep traefik_service\n\n# Deaktiviere unn\u00f6tige Middlewares\n# Erh\u00f6he Timeouts\nserversTransports:\n  default:\n    forwardingTimeouts:\n      dialTimeout: 10s\n      responseHeaderTimeout: 30s\n\n# Nutze Connection Pooling\nserversTransports:\n  default:\n    maxIdleConnsPerHost: 200\n</code></pre></p>"},{"location":"guides/TRAEFIK/#zusammenfassung","title":"Zusammenfassung","text":""},{"location":"guides/TRAEFIK/#traefik-mit-gal","title":"Traefik mit GAL","text":"<p>GAL macht Traefik-Konfiguration einfach und provider-agnostisch:</p> <p>Vorteile: - \u2705 Einheitliche Konfiguration: YAML statt multiple Provider - \u2705 Provider-Wechsel: Von Traefik zu Envoy/Kong in Minuten - \u2705 Feature-Abstraktion: Keine Traefik-spezifischen Middlewares im Config - \u2705 Validierung: Fr\u00fchzeitige Fehlerkennung vor Deployment - \u2705 Multi-Provider: Parallel Configs f\u00fcr mehrere Gateways</p> <p>Traefik-Features unterst\u00fctzt: - Load Balancing (mit Sticky Sessions) - Active Health Checks - Rate Limiting (rateLimit Middleware) - Basic Authentication - CORS (headers Middleware) - Timeout &amp; Retry - Circuit Breaker - WebSocket (native) - Header Manipulation - \u26a0\ufe0f Body Transformation (nicht nativ, Workarounds verf\u00fcgbar)</p> <p>Best Use Cases f\u00fcr Traefik: 1. Docker/Kubernetes: Automatische Service Discovery 2. Let's Encrypt: Automatisches HTTPS erforderlich 3. Cloud-Native Microservices: Container-basierte Architekturen 4. Einfache Konfiguration: Schnelles Setup bevorzugt 5. Dashboard-Driven: Echtzeit-Monitoring erforderlich</p> <p>Workflow: <pre><code># 1. GAL-Konfiguration schreiben\nvim config.yaml\n\n# 2. Traefik Dynamic Config generieren\ngal generate --config config.yaml --provider traefik --output traefik-dynamic.yml\n\n# 3. Traefik starten mit File Provider\ndocker run -d \\\n  -v $(pwd)/traefik-dynamic.yml:/etc/traefik/dynamic-config.yml \\\n  -v $(pwd)/traefik.yml:/etc/traefik/traefik.yml \\\n  traefik:latest\n\n# 4. Testen\ncurl http://localhost:80/api\n\n# 5. Dashboard \u00f6ffnen\nopen http://localhost:8080/dashboard/\n</code></pre></p> <p>Links: - Traefik Website: https://traefik.io/ - GitHub: https://github.com/traefik/traefik - Docs: https://doc.traefik.io/traefik/ - Plugins: https://plugins.traefik.io/</p> <p>Navigation: - \u2190 Zur\u00fcck zur \u00dcbersicht - Envoy Provider Guide - Kong Provider Guide - APISIX Provider Guide - Nginx Provider Guide - HAProxy Provider Guide</p>"},{"location":"guides/TRANSFORMATIONS/","title":"Transformations-Guide","text":""},{"location":"guides/TRANSFORMATIONS/#ubersicht","title":"\u00dcbersicht","text":"<p>Transformationen in GAL erm\u00f6glichen die automatische Manipulation von Request-Payloads, bevor diese an Backend-Services weitergeleitet werden. Dies ist besonders n\u00fctzlich f\u00fcr:</p> <ul> <li>Default-Werte: Fehlende Felder mit Standardwerten auff\u00fcllen</li> <li>Computed Fields: Automatische Generierung von IDs, Timestamps, etc.</li> <li>Validierung: Sicherstellen, dass erforderliche Felder vorhanden sind</li> <li>Normalisierung: Einheitliche Datenformate \u00fcber verschiedene Services</li> </ul>"},{"location":"guides/TRANSFORMATIONS/#konfiguration","title":"Konfiguration","text":""},{"location":"guides/TRANSFORMATIONS/#basis-struktur","title":"Basis-Struktur","text":"<pre><code>services:\n  - name: my_service\n    type: rest\n    protocol: http\n    upstream:\n      host: backend\n      port: 8080\n    routes:\n      - path_prefix: /api/users\n        methods: [POST, PUT]\n    transformation:\n      enabled: true\n      defaults:\n        # Default-Werte\n        status: \"active\"\n        role: \"user\"\n      computed_fields:\n        # Automatisch generierte Felder\n        - field: user_id\n          generator: uuid\n          prefix: \"usr_\"\n        - field: created_at\n          generator: timestamp\n      validation:\n        # Pflichtfelder\n        required_fields:\n          - email\n          - username\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#default-werte","title":"Default-Werte","text":"<p>Default-Werte werden gesetzt, wenn ein Feld im Request fehlt oder <code>null</code> ist.</p>"},{"location":"guides/TRANSFORMATIONS/#syntax","title":"Syntax","text":"<pre><code>transformation:\n  enabled: true\n  defaults:\n    field_name: \"default_value\"\n    status: \"pending\"\n    priority: 3\n    active: true\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#beispiel-e-commerce-order","title":"Beispiel: E-Commerce Order","text":"<p>Konfiguration:</p> <pre><code>services:\n  - name: orders_api\n    transformation:\n      enabled: true\n      defaults:\n        status: \"pending\"\n        currency: \"EUR\"\n        payment_method: \"credit_card\"\n        shipping_method: \"standard\"\n</code></pre> <p>Eingehender Request:</p> <pre><code>{\n  \"customer_id\": \"12345\",\n  \"items\": [\n    {\"product_id\": \"A1\", \"quantity\": 2}\n  ]\n}\n</code></pre> <p>Transformierter Request:</p> <pre><code>{\n  \"customer_id\": \"12345\",\n  \"items\": [\n    {\"product_id\": \"A1\", \"quantity\": 2}\n  ],\n  \"status\": \"pending\",\n  \"currency\": \"EUR\",\n  \"payment_method\": \"credit_card\",\n  \"shipping_method\": \"standard\"\n}\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#computed-fields","title":"Computed Fields","text":"<p>Computed Fields werden automatisch generiert, wenn sie nicht im Request vorhanden sind.</p>"},{"location":"guides/TRANSFORMATIONS/#uuid-generierung","title":"UUID-Generierung","text":"<p>Generiert eine eindeutige UUID f\u00fcr das Feld.</p> <pre><code>computed_fields:\n  - field: user_id\n    generator: uuid\n    prefix: \"usr_\"  # Optional: Pr\u00e4fix\n</code></pre> <p>Generierter Wert: <code>usr_550e8400-e29b-41d4-a716-446655440000</code></p>"},{"location":"guides/TRANSFORMATIONS/#ohne-prafix","title":"Ohne Pr\u00e4fix:","text":"<pre><code>computed_fields:\n  - field: request_id\n    generator: uuid\n</code></pre> <p>Generierter Wert: <code>550e8400-e29b-41d4-a716-446655440000</code></p>"},{"location":"guides/TRANSFORMATIONS/#timestamp-generierung","title":"Timestamp-Generierung","text":"<p>Generiert einen Unix-Timestamp (Sekunden seit 1970-01-01).</p> <pre><code>computed_fields:\n  - field: created_at\n    generator: timestamp\n</code></pre> <p>Generierter Wert: <code>1698765432</code></p>"},{"location":"guides/TRANSFORMATIONS/#kombination","title":"Kombination","text":"<pre><code>computed_fields:\n  - field: order_id\n    generator: uuid\n    prefix: \"ord_\"\n  - field: created_at\n    generator: timestamp\n  - field: updated_at\n    generator: timestamp\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#validierung","title":"Validierung","text":"<p>Validierung stellt sicher, dass erforderliche Felder im Request vorhanden sind.</p>"},{"location":"guides/TRANSFORMATIONS/#syntax_1","title":"Syntax","text":"<pre><code>validation:\n  required_fields:\n    - field1\n    - field2\n    - nested.field\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#beispiel-user-registration","title":"Beispiel: User Registration","text":"<pre><code>services:\n  - name: user_registration\n    transformation:\n      enabled: true\n      defaults:\n        role: \"user\"\n        active: false\n      computed_fields:\n        - field: user_id\n          generator: uuid\n          prefix: \"usr_\"\n        - field: created_at\n          generator: timestamp\n      validation:\n        required_fields:\n          - email\n          - username\n          - password\n</code></pre> <p>G\u00fcltiger Request:</p> <pre><code>{\n  \"email\": \"user@example.com\",\n  \"username\": \"john_doe\",\n  \"password\": \"secure_password\"\n}\n</code></pre> <p>Ung\u00fcltiger Request (fehlt <code>email</code>):</p> <pre><code>{\n  \"username\": \"john_doe\",\n  \"password\": \"secure_password\"\n}\n</code></pre> <p>\u2192 Wird abgelehnt, da <code>email</code> fehlt.</p>"},{"location":"guides/TRANSFORMATIONS/#provider-spezifische-implementierung","title":"Provider-spezifische Implementierung","text":""},{"location":"guides/TRANSFORMATIONS/#envoy-proxy","title":"Envoy Proxy","text":"<p>Envoy nutzt Lua Filters f\u00fcr Transformationen.</p> <p>Generierter Code:</p> <pre><code>function envoy_on_request(request_handle)\n  local path = request_handle:headers():get(':path')\n  if string.find(path, '/api/users') then\n    local body = request_handle:body()\n    if body then\n      -- Parse JSON\n      -- Apply defaults\n      -- Generate computed fields\n      -- Validate required fields\n    end\n  end\nend\n</code></pre> <p>Features: - \u2705 Defaults - \u2705 Computed Fields (UUID, Timestamp) - \u26a0\ufe0f Validierung (begrenzt)</p>"},{"location":"guides/TRANSFORMATIONS/#kong-api-gateway","title":"Kong API Gateway","text":"<p>Kong nutzt das request-transformer Plugin.</p> <p>Generierte Konfiguration:</p> <pre><code>plugins:\n  - name: request-transformer\n    config:\n      add:\n        headers:\n          - x-default-status: 'active'\n          - x-default-role: 'user'\n</code></pre> <p>Limitationen: - \u2705 Defaults (als Headers) - \u274c Computed Fields (ben\u00f6tigt Custom Plugins) - \u274c Native Body-Transformation</p> <p>Hinweis: F\u00fcr volle Transformation-Unterst\u00fctzung m\u00fcssen Custom Lua Plugins entwickelt werden.</p>"},{"location":"guides/TRANSFORMATIONS/#apache-apisix","title":"Apache APISIX","text":"<p>APISIX nutzt Serverless Pre-Function Plugin mit Lua.</p> <p>Generierter Code:</p> <pre><code>return function(conf, ctx)\n  local core = require('apisix.core')\n  local cjson = require('cjson.safe')\n  local body = core.request.get_body()\n\n  if body then\n    local json_body = cjson.decode(body)\n    if json_body then\n      -- Apply defaults\n      json_body.status = json_body.status or 'active'\n\n      -- Generate UUID\n      if not json_body.user_id then\n        json_body.user_id = 'usr_' .. core.utils.uuid()\n      end\n\n      -- Generate timestamp\n      if not json_body.created_at then\n        json_body.created_at = os.time()\n      end\n\n      ngx.req.set_body_data(cjson.encode(json_body))\n    end\n  end\nend\n</code></pre> <p>Features: - \u2705 Defaults - \u2705 Computed Fields (UUID, Timestamp) - \u2705 Volle Body-Manipulation - \u2705 Validierung</p>"},{"location":"guides/TRANSFORMATIONS/#traefik","title":"Traefik","text":"<p>Traefik nutzt Middleware Plugins (ben\u00f6tigt Go-Entwicklung).</p> <p>Generierte Konfiguration:</p> <pre><code>middlewares:\n  my_service_transform:\n    plugin:\n      my_service_transformer:\n        defaults:\n          status: 'active'\n          role: 'user'\n</code></pre> <p>Limitationen: - \u26a0\ufe0f Middleware ben\u00f6tigt Go-Entwicklung - \u274c Keine nativen Transformationen - \u274c Computed Fields nicht unterst\u00fctzt</p> <p>Hinweis: Traefik ist prim\u00e4r f\u00fcr Routing/Load Balancing optimiert, nicht f\u00fcr Payload-Manipulation.</p>"},{"location":"guides/TRANSFORMATIONS/#anwendungsfalle","title":"Anwendungsf\u00e4lle","text":""},{"location":"guides/TRANSFORMATIONS/#use-case-1-user-onboarding","title":"Use Case 1: User Onboarding","text":"<p>Ziel: Neue User automatisch mit Defaults versehen.</p> <pre><code>services:\n  - name: user_service\n    transformation:\n      enabled: true\n      defaults:\n        role: \"user\"\n        status: \"pending_verification\"\n        notifications_enabled: true\n        theme: \"light\"\n      computed_fields:\n        - field: user_id\n          generator: uuid\n          prefix: \"usr_\"\n        - field: created_at\n          generator: timestamp\n      validation:\n        required_fields:\n          - email\n          - username\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#use-case-2-order-processing","title":"Use Case 2: Order Processing","text":"<p>Ziel: Orders mit Tracking-Informationen versehen.</p> <pre><code>services:\n  - name: orders_api\n    transformation:\n      enabled: true\n      defaults:\n        status: \"pending\"\n        currency: \"EUR\"\n        payment_status: \"awaiting_payment\"\n      computed_fields:\n        - field: order_id\n          generator: uuid\n          prefix: \"ord_\"\n        - field: created_at\n          generator: timestamp\n        - field: tracking_id\n          generator: uuid\n          prefix: \"trk_\"\n      validation:\n        required_fields:\n          - customer_id\n          - items\n          - total_amount\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#use-case-3-api-logging","title":"Use Case 3: API Logging","text":"<p>Ziel: Alle Requests mit Tracking-IDs versehen.</p> <pre><code>services:\n  - name: logging_api\n    transformation:\n      enabled: true\n      computed_fields:\n        - field: request_id\n          generator: uuid\n        - field: timestamp\n          generator: timestamp\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#best-practices","title":"Best Practices","text":""},{"location":"guides/TRANSFORMATIONS/#1-minimale-transformationen","title":"1. Minimale Transformationen","text":"<p>Transformiere nur das Notwendigste. Zu viele Transformationen k\u00f6nnen Performance beeintr\u00e4chtigen.</p> <pre><code># Gut\ndefaults:\n  status: \"active\"\n\n# \u00dcbertrieben\ndefaults:\n  status: \"active\"\n  field1: \"value1\"\n  field2: \"value2\"\n  # ... 20 weitere Felder\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#2-sinnvolle-defaults","title":"2. Sinnvolle Defaults","text":"<p>W\u00e4hle Defaults, die f\u00fcr die Mehrheit der Requests sinnvoll sind.</p> <pre><code># Gut\ndefaults:\n  currency: \"EUR\"  # Standard-W\u00e4hrung f\u00fcr EU-Region\n  language: \"de\"   # Standard-Sprache\n\n# Schlecht\ndefaults:\n  admin: true  # Nicht jeder User sollte Admin sein!\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#3-uuid-prafixe-fur-debugging","title":"3. UUID-Pr\u00e4fixe f\u00fcr Debugging","text":"<p>Nutze Pr\u00e4fixe, um IDs leichter identifizieren zu k\u00f6nnen.</p> <pre><code>computed_fields:\n  - field: user_id\n    generator: uuid\n    prefix: \"usr_\"    # \u2192 usr_...\n  - field: order_id\n    generator: uuid\n    prefix: \"ord_\"    # \u2192 ord_...\n  - field: payment_id\n    generator: uuid\n    prefix: \"pay_\"    # \u2192 pay_...\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#4-validierung-vor-transformationen","title":"4. Validierung vor Transformationen","text":"<p>Stelle sicher, dass kritische Felder vorhanden sind, bevor Defaults gesetzt werden.</p> <pre><code>validation:\n  required_fields:\n    - customer_id  # Muss vorhanden sein\n    - amount       # Muss vorhanden sein\n\ndefaults:\n  status: \"pending\"  # Kann fehlen\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#5-provider-capabilities-beachten","title":"5. Provider-Capabilities beachten","text":"<p>W\u00e4hle den Provider basierend auf Transformation-Anforderungen:</p> Anforderung Empfohlener Provider Einfache Defaults Alle Provider Computed Fields (UUID) APISIX, Envoy Timestamp-Generierung APISIX, Envoy Komplexe Validierung APISIX Keine Transformationen Traefik"},{"location":"guides/TRANSFORMATIONS/#debugging","title":"Debugging","text":""},{"location":"guides/TRANSFORMATIONS/#problem-defaults-werden-nicht-angewendet","title":"Problem: Defaults werden nicht angewendet","text":"<p>L\u00f6sung:</p> <ol> <li>Pr\u00fcfe, ob <code>transformation.enabled: true</code> gesetzt ist</li> <li>Verifiziere Provider-Unterst\u00fctzung</li> <li>Pr\u00fcfe Gateway-Logs</li> </ol> <pre><code># Envoy\ncurl http://localhost:9901/stats | grep lua\n\n# APISIX\ncurl http://localhost:9080/apisix/admin/routes -H \"X-API-KEY: ...\"\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#problem-uuid-format-nicht-wie-erwartet","title":"Problem: UUID-Format nicht wie erwartet","text":"<p>APISIX/Envoy: - Format: <code>prefix_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code></p> <p>Kong: - Nicht unterst\u00fctzt (Custom Plugin erforderlich)</p>"},{"location":"guides/TRANSFORMATIONS/#problem-validierung-schlagt-fehl","title":"Problem: Validierung schl\u00e4gt fehl","text":"<p>Pr\u00fcfe, ob alle <code>required_fields</code> im Request vorhanden sind:</p> <pre><code># Test mit curl\ncurl -X POST http://gateway:8080/api/users \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"email\": \"test@example.com\",\n    \"username\": \"test_user\"\n  }' -v\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#performance-uberlegungen","title":"Performance-\u00dcberlegungen","text":""},{"location":"guides/TRANSFORMATIONS/#transformation-overhead","title":"Transformation-Overhead","text":"Provider Overhead Empfehlung Envoy ~0.5-1ms \u2705 Production-ready APISIX ~0.5-2ms \u2705 Production-ready Kong ~2-5ms \u26a0\ufe0f Monitor bei High-Traffic Traefik N/A Keine nativen Transformationen"},{"location":"guides/TRANSFORMATIONS/#optimierung","title":"Optimierung","text":"<ol> <li>Minimale Defaults: Nur notwendige Felder transformieren</li> <li>Caching: Provider-interne Caches nutzen</li> <li>Selective Transformation: Nur f\u00fcr spezifische Routes aktivieren</li> </ol> <pre><code># Gut: Nur f\u00fcr POST/PUT\nroutes:\n  - path_prefix: /api/users\n    methods: [POST, PUT]  # Transformation nur hier\n\n# Vermeiden: Alle Methoden\nroutes:\n  - path_prefix: /api/users\n    # Transformation f\u00fcr GET/DELETE unn\u00f6tig\n</code></pre>"},{"location":"guides/TRANSFORMATIONS/#migration-zwischen-providern","title":"Migration zwischen Providern","text":""},{"location":"guides/TRANSFORMATIONS/#von-kong-zu-apisix","title":"Von Kong zu APISIX","text":"<p>Kong (limitiert): <pre><code>plugins:\n  - name: request-transformer\n    config:\n      add:\n        headers:\n          - x-default-status: 'active'\n</code></pre></p> <p>APISIX (volle Unterst\u00fctzung): <pre><code>transformation:\n  enabled: true\n  defaults:\n    status: \"active\"\n  computed_fields:\n    - field: user_id\n      generator: uuid\n</code></pre></p>"},{"location":"guides/TRANSFORMATIONS/#von-traefik-zu-envoy","title":"Von Traefik zu Envoy","text":"<p>Traefik (keine native Unterst\u00fctzung): <pre><code># Custom Middleware erforderlich\n</code></pre></p> <p>Envoy (Lua Filter): <pre><code>transformation:\n  enabled: true\n  defaults:\n    status: \"active\"\n  computed_fields:\n    - field: request_id\n      generator: uuid\n</code></pre></p>"},{"location":"guides/TRANSFORMATIONS/#python-api-referenz","title":"Python API-Referenz","text":"<p>F\u00fcr Details zur Implementierung siehe:</p> <ul> <li><code>gal/config.py</code> - Transformation, ComputedField, Validation Dataclasses</li> <li><code>gal/providers/envoy.py:112-177</code> - Envoy Lua Filter Generierung</li> <li><code>gal/providers/apisix.py:159-218</code> - APISIX Lua Script Generierung</li> <li><code>gal/providers/kong.py:134-141</code> - Kong Plugin-Konfiguration</li> <li><code>gal/providers/traefik.py:142-152</code> - Traefik Middleware-Konfiguration</li> </ul>"},{"location":"guides/TRANSFORMATIONS/#siehe-auch","title":"Siehe auch","text":"<ul> <li>Provider-Dokumentation - Provider-spezifische Details</li> <li>Konfigurationsreferenz - Vollst\u00e4ndige YAML-Optionen</li> <li>Schnellstart-Guide - Praktische Beispiele</li> <li>Entwickler-Guide - Custom Transformations entwickeln</li> </ul>"},{"location":"guides/WEBSOCKET/","title":"WebSocket Support - GAL Gateway","text":"<p>Version: 1.2.0 Status: Produktionsbereit Provider Support: Envoy, Kong, APISIX, Traefik, Nginx, HAProxy</p>"},{"location":"guides/WEBSOCKET/#ubersicht","title":"\u00dcbersicht","text":"<p>WebSocket erm\u00f6glicht bidirektionale, Echtzeit-Kommunikation zwischen Client und Server \u00fcber eine persistente TCP-Verbindung. Im Gegensatz zu klassischem HTTP Request/Response erlaubt WebSocket Push-Nachrichten vom Server zum Client.</p>"},{"location":"guides/WEBSOCKET/#warum-websocket","title":"Warum WebSocket?","text":"<ul> <li>Real-time Updates: Live-Dashboards, Aktienkurse, Sportergebnisse</li> <li>Chat-Anwendungen: Instant Messaging, Collaboration Tools</li> <li>Gaming: Multiplayer-Spiele mit niedrigen Latenzen</li> <li>IoT: Sensor-Daten, Live-Monitoring</li> <li>Streaming: Audio/Video-Streaming, Live-Events</li> </ul>"},{"location":"guides/WEBSOCKET/#websocket-vs-http","title":"WebSocket vs HTTP","text":"Feature HTTP WebSocket Kommunikation Request/Response Bidirektional Verbindung Stateless, kurzlebig Stateful, persistent Overhead Header bei jedem Request Einmaliger Handshake Latenz H\u00f6her (Polling) Niedrig (Push) Server Push \u274c (Server Sent Events) \u2705 Native"},{"location":"guides/WEBSOCKET/#schnellstart","title":"Schnellstart","text":""},{"location":"guides/WEBSOCKET/#basis-konfiguration","title":"Basis-Konfiguration","text":"<pre><code>version: \"1.0\"\nprovider: envoy\n\nservices:\n  - name: chat_service\n    type: rest\n    protocol: http\n    upstream:\n      host: chat-backend\n      port: 8080\n\n    routes:\n      - path_prefix: /ws/chat\n        websocket:\n          enabled: true\n          idle_timeout: 300s\n          ping_interval: 30s\n</code></pre>"},{"location":"guides/WEBSOCKET/#mit-erweiterten-optionen","title":"Mit erweiterten Optionen","text":"<pre><code>routes:\n  - path_prefix: /ws/realtime\n    websocket:\n      enabled: true\n      idle_timeout: 600s        # 10 Minuten Idle Timeout\n      ping_interval: 60s        # Ping alle 60 Sekunden\n      max_message_size: 2097152 # 2MB maximale Message-Gr\u00f6\u00dfe\n      compression: true         # Per-Message Compression aktivieren\n</code></pre>"},{"location":"guides/WEBSOCKET/#websocket-authentication","title":"WebSocket + Authentication","text":"<pre><code>routes:\n  - path_prefix: /ws/secure\n    authentication:\n      enabled: true\n      type: jwt\n      jwt:\n        issuer: https://auth.example.com\n        audience: wss://api.example.com\n        jwks_uri: https://auth.example.com/.well-known/jwks.json\n\n    websocket:\n      enabled: true\n      idle_timeout: 300s\n      ping_interval: 30s\n</code></pre>"},{"location":"guides/WEBSOCKET/#konfigurationsoptionen","title":"Konfigurationsoptionen","text":""},{"location":"guides/WEBSOCKET/#websocketconfig-felder","title":"WebSocketConfig Felder","text":"<pre><code>websocket:\n  enabled: true                # WebSocket aktivieren\n  idle_timeout: \"300s\"         # Maximale Idle-Zeit (5 Minuten default)\n  ping_interval: \"30s\"         # Ping-Interval f\u00fcr Keep-Alive\n  max_message_size: 1048576    # Max Message Size in Bytes (1MB default)\n  compression: false           # Per-Message Compression (false default)\n</code></pre>"},{"location":"guides/WEBSOCKET/#enabled","title":"<code>enabled</code>","text":"<ul> <li>Typ: Boolean</li> <li>Default: <code>true</code></li> <li>Beschreibung: Aktiviert WebSocket Support f\u00fcr diese Route</li> </ul>"},{"location":"guides/WEBSOCKET/#idle_timeout","title":"<code>idle_timeout</code>","text":"<ul> <li>Typ: String (Duration)</li> <li>Default: <code>\"300s\"</code> (5 Minuten)</li> <li>Beschreibung: Maximale Zeit ohne Aktivit\u00e4t, bevor die Verbindung geschlossen wird</li> <li>Beispiele: <code>\"60s\"</code>, <code>\"10m\"</code>, <code>\"1h\"</code></li> </ul>"},{"location":"guides/WEBSOCKET/#ping_interval","title":"<code>ping_interval</code>","text":"<ul> <li>Typ: String (Duration)</li> <li>Default: <code>\"30s\"</code></li> <li>Beschreibung: Interval f\u00fcr Ping-Frames (Keep-Alive)</li> <li>Hinweis: Sollte kleiner als <code>idle_timeout</code> sein</li> </ul>"},{"location":"guides/WEBSOCKET/#max_message_size","title":"<code>max_message_size</code>","text":"<ul> <li>Typ: Integer</li> <li>Default: <code>1048576</code> (1MB)</li> <li>Beschreibung: Maximale Gr\u00f6\u00dfe einer WebSocket-Message in Bytes</li> <li>Empfehlung:</li> <li>Chat: 64KB - 256KB</li> <li>Datei-Upload: 10MB+</li> <li>JSON APIs: 1MB - 5MB</li> </ul>"},{"location":"guides/WEBSOCKET/#compression","title":"<code>compression</code>","text":"<ul> <li>Typ: Boolean</li> <li>Default: <code>false</code></li> <li>Beschreibung: Aktiviert Per-Message Deflate Compression (RFC 7692)</li> <li>Trade-off: Reduziert Bandbreite, erh\u00f6ht CPU-Last</li> </ul>"},{"location":"guides/WEBSOCKET/#provider-implementierung","title":"Provider-Implementierung","text":""},{"location":"guides/WEBSOCKET/#envoy","title":"Envoy","text":"<p>Support: \u2705 Native WebSocket via HTTP/1.1 Upgrade</p> <p>Generierte Konfiguration:</p> <pre><code># Envoy unterst\u00fctzt WebSocket automatisch via HTTP/1.1 Upgrade\nroute_config:\n  virtual_hosts:\n    - name: chat_service\n      routes:\n        - match:\n            prefix: /ws/chat\n          route:\n            cluster: chat_backend\n            timeout: 300s  # idle_timeout\n            upgrade_configs:\n              - upgrade_type: websocket\n</code></pre> <p>Features: - \u2705 Automatische Upgrade-Header-Verarbeitung - \u2705 Idle Timeout via <code>timeout</code> - \u2705 Ping/Pong automatisch - \u26a0\ufe0f <code>max_message_size</code> nicht direkt konfigurierbar (via Buffer Limits)</p>"},{"location":"guides/WEBSOCKET/#kong","title":"Kong","text":"<p>Support: \u2705 Native WebSocket Support</p> <p>Generierte Konfiguration:</p> <pre><code># Kong unterst\u00fctzt WebSocket out-of-the-box\nroutes:\n  - name: chat_route\n    paths:\n      - /ws/chat\n    protocols:\n      - http\n      - https\n    service: chat_service\n\nservices:\n  - name: chat_service\n    url: http://chat-backend:8080\n    read_timeout: 300000  # idle_timeout in ms\n    write_timeout: 300000\n</code></pre> <p>Features: - \u2705 Automatische WebSocket-Erkennung - \u2705 Timeouts via <code>read_timeout</code>/<code>write_timeout</code> - \u2705 Funktioniert mit allen Kong-Plugins (Auth, Rate Limiting) - \u26a0\ufe0f <code>ping_interval</code> nicht konfigurierbar</p>"},{"location":"guides/WEBSOCKET/#apisix","title":"APISIX","text":"<p>Support: \u2705 Native WebSocket Support</p> <p>Generierte Konfiguration:</p> <pre><code># APISIX unterst\u00fctzt WebSocket nativ\nroutes:\n  - uri: /ws/chat\n    service_id: chat_service\n    enable_websocket: true\n    timeout:\n      connect: 5\n      send: 300\n      read: 300\n\nservices:\n  - id: chat_service\n    upstream_id: chat_upstream\n</code></pre> <p>Features: - \u2705 <code>enable_websocket: true</code> Flag - \u2705 Timeout-Konfiguration - \u2705 Kompatibel mit APISIX-Plugins - \u2705 WebSocket-spezifische Metrics</p>"},{"location":"guides/WEBSOCKET/#traefik","title":"Traefik","text":"<p>Support: \u2705 Native WebSocket Support</p> <p>Generierte Konfiguration:</p> <pre><code># Traefik unterst\u00fctzt WebSocket automatisch\nhttp:\n  routers:\n    chat-router:\n      rule: PathPrefix(`/ws/chat`)\n      service: chat-service\n\n  services:\n    chat-service:\n      loadBalancer:\n        servers:\n          - url: http://chat-backend:8080\n        responseForwarding:\n          flushInterval: 100ms  # F\u00fcr WebSocket wichtig\n</code></pre> <p>Features: - \u2705 Automatische WebSocket-Erkennung - \u2705 <code>flushInterval</code> f\u00fcr niedrige Latenz - \u2705 Sticky Sessions f\u00fcr WebSocket - \u26a0\ufe0f Timeout \u00fcber <code>serversTransport</code> konfigurierbar</p>"},{"location":"guides/WEBSOCKET/#nginx","title":"Nginx","text":"<p>Support: \u2705 WebSocket via proxy_http_version 1.1</p> <p>Generierte Konfiguration:</p> <pre><code># Nginx WebSocket Konfiguration\nupstream chat_backend {\n    server chat-backend:8080;\n    keepalive 32;\n}\n\nserver {\n    listen 80;\n\n    location /ws/chat {\n        # WebSocket-spezifische Headers\n        proxy_pass http://chat_backend;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n\n        # Timeouts\n        proxy_read_timeout 300s;      # idle_timeout\n        proxy_send_timeout 300s;\n        proxy_connect_timeout 5s;\n\n        # Keep-Alive\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}\n</code></pre> <p>Features: - \u2705 <code>Upgrade</code> und <code>Connection</code> Header - \u2705 <code>proxy_http_version 1.1</code> erforderlich - \u2705 Timeouts via <code>proxy_read_timeout</code> - \u2705 Keepalive Connections - \u26a0\ufe0f <code>ping_interval</code> nicht direkt konfigurierbar</p>"},{"location":"guides/WEBSOCKET/#haproxy","title":"HAProxy","text":"<p>Support: \u2705 Native WebSocket Support</p> <p>Generierte Konfiguration:</p> <pre><code># HAProxy WebSocket Konfiguration\nfrontend http_frontend\n    bind *:80\n\n    # WebSocket ACL\n    acl is_websocket path_beg /ws/chat\n    acl is_websocket_upgrade hdr(Upgrade) -i websocket\n\n    use_backend chat_backend if is_websocket is_websocket_upgrade\n\nbackend chat_backend\n    # WebSocket Timeout\n    timeout tunnel 300s  # idle_timeout\n    timeout client 300s\n    timeout server 300s\n\n    server chat1 chat-backend:8080 check\n</code></pre> <p>Features: - \u2705 <code>timeout tunnel</code> f\u00fcr WebSocket-Verbindungen - \u2705 ACL f\u00fcr WebSocket-Erkennung - \u2705 Health Checks f\u00fcr WebSocket-Backends - \u2705 Load Balancing \u00fcber WebSocket-Verbindungen</p>"},{"location":"guides/WEBSOCKET/#provider-vergleich","title":"Provider-Vergleich","text":"Feature Envoy Kong APISIX Traefik Nginx HAProxy Native Support \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Idle Timeout \u2705 \u2705 \u2705 \u26a0\ufe0f \u2705 \u2705 Ping Interval \u2705 Auto \u274c \u26a0\ufe0f \u274c \u274c \u274c Max Message Size \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f Compression \u2705 \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f Load Balancing \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Health Checks \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Authentication \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Rate Limiting \u2705 \u2705 \u2705 \u2705 \u2705 \u26a0\ufe0f <p>Legende: - \u2705 Full Support - \u26a0\ufe0f Limited / Manual Configuration - \u274c Not Supported</p>"},{"location":"guides/WEBSOCKET/#haufige-anwendungsfalle","title":"H\u00e4ufige Anwendungsf\u00e4lle","text":""},{"location":"guides/WEBSOCKET/#use-case-1-chat-anwendung","title":"Use Case 1: Chat-Anwendung","text":"<pre><code>services:\n  - name: chat_service\n    upstream:\n      targets:\n        - host: chat-backend-1\n          port: 8080\n        - host: chat-backend-2\n          port: 8080\n      load_balancer:\n        algorithm: ip_hash  # Sticky Sessions f\u00fcr WebSocket\n        sticky_sessions: true\n\n    routes:\n      - path_prefix: /ws/chat\n        authentication:\n          enabled: true\n          type: jwt\n          jwt:\n            issuer: https://auth.example.com\n            audience: wss://chat.example.com\n            jwks_uri: https://auth.example.com/.well-known/jwks.json\n\n        websocket:\n          enabled: true\n          idle_timeout: 600s  # 10 Minuten f\u00fcr aktive Chats\n          ping_interval: 30s\n          max_message_size: 262144  # 256KB f\u00fcr Text-Nachrichten\n</code></pre> <p>Erkl\u00e4rung: - <code>ip_hash</code> Load Balancing f\u00fcr Sticky Sessions (wichtig f\u00fcr WebSocket) - JWT Authentication f\u00fcr Zugriffskontrolle - 10 Minuten Idle Timeout (Nutzer schreibt, liest) - 30s Ping Interval f\u00fcr Keep-Alive - 256KB Message Size f\u00fcr Chat-Nachrichten</p>"},{"location":"guides/WEBSOCKET/#use-case-2-live-dashboard-metrics","title":"Use Case 2: Live-Dashboard (Metrics)","text":"<pre><code>services:\n  - name: metrics_service\n    upstream:\n      host: metrics-backend\n      port: 9090\n\n    routes:\n      - path_prefix: /ws/metrics\n        rate_limit:\n          enabled: true\n          requests_per_second: 10\n          key_type: ip_address\n\n        websocket:\n          enabled: true\n          idle_timeout: 300s\n          ping_interval: 60s\n          compression: true  # JSON-Daten komprimieren\n</code></pre> <p>Erkl\u00e4rung: - Rate Limiting: 10 Verbindungen pro Sekunde pro IP - Compression aktiviert f\u00fcr JSON-Metrics-Daten - 5 Minuten Timeout (Dashboard l\u00e4dt neue Daten)</p>"},{"location":"guides/WEBSOCKET/#use-case-3-iot-sensor-daten","title":"Use Case 3: IoT Sensor-Daten","text":"<pre><code>services:\n  - name: iot_service\n    upstream:\n      targets:\n        - host: iot-processor-1\n          port: 8080\n        - host: iot-processor-2\n          port: 8080\n      load_balancer:\n        algorithm: least_conn\n\n    routes:\n      - path_prefix: /ws/sensors\n        authentication:\n          enabled: true\n          type: api_key\n          api_key:\n            keys:\n              - device_key_123\n              - device_key_456\n            key_name: X-Device-Key\n\n        websocket:\n          enabled: true\n          idle_timeout: 3600s  # 1 Stunde\n          ping_interval: 120s  # 2 Minuten (Batterie schonen)\n          max_message_size: 10240  # 10KB f\u00fcr Sensor-Daten\n</code></pre> <p>Erkl\u00e4rung: - API Key Auth f\u00fcr Ger\u00e4te-Authentifizierung - 1 Stunde Timeout f\u00fcr selten sendende Sensoren - 2 Minuten Ping Interval (Batterie sparen) - Kleine Message Size f\u00fcr Sensor-Daten</p>"},{"location":"guides/WEBSOCKET/#use-case-4-multiplayer-gaming","title":"Use Case 4: Multiplayer-Gaming","text":"<pre><code>services:\n  - name: game_service\n    upstream:\n      targets:\n        - host: game-server-1\n          port: 8080\n          weight: 2\n        - host: game-server-2\n          port: 8080\n          weight: 1\n      load_balancer:\n        algorithm: weighted\n        sticky_sessions: true\n        cookie_name: GAME_SESSION\n\n    routes:\n      - path_prefix: /ws/game\n        websocket:\n          enabled: true\n          idle_timeout: 7200s  # 2 Stunden (lange Gaming-Sessions)\n          ping_interval: 10s   # Schnelle Keep-Alive f\u00fcr Latenz\n          max_message_size: 524288  # 512KB f\u00fcr Game State\n</code></pre> <p>Erkl\u00e4rung: - Weighted Load Balancing (unterschiedliche Server-Kapazit\u00e4ten) - Sticky Sessions via Cookie (Session-Persistenz) - 2 Stunden Timeout (lange Gaming-Sessions) - 10s Ping Interval f\u00fcr niedrige Latenz</p>"},{"location":"guides/WEBSOCKET/#use-case-5-file-uploaddownload-streaming","title":"Use Case 5: File Upload/Download Streaming","text":"<pre><code>services:\n  - name: upload_service\n    upstream:\n      host: upload-backend\n      port: 8080\n\n    routes:\n      - path_prefix: /ws/upload\n        authentication:\n          enabled: true\n          type: jwt\n\n        rate_limit:\n          enabled: true\n          requests_per_second: 5\n          key_type: jwt_claim\n          key_claim: sub  # User ID\n\n        websocket:\n          enabled: true\n          idle_timeout: 1800s  # 30 Minuten\n          ping_interval: 60s\n          max_message_size: 10485760  # 10MB f\u00fcr Chunks\n          compression: false  # Keine Compression bei Bin\u00e4rdaten\n</code></pre> <p>Erkl\u00e4rung: - JWT Authentication f\u00fcr User-Zugriff - Rate Limiting pro User (5 Uploads/s) - 30 Minuten Timeout f\u00fcr gro\u00dfe Dateien - 10MB Message Size f\u00fcr Upload-Chunks - Compression deaktiviert (Bin\u00e4rdaten)</p>"},{"location":"guides/WEBSOCKET/#best-practices","title":"Best Practices","text":""},{"location":"guides/WEBSOCKET/#1-idle-timeout-richtig-wahlen","title":"1. Idle Timeout richtig w\u00e4hlen","text":"<pre><code># \u274c Zu kurz\nwebsocket:\n  idle_timeout: 30s  # Verbindung bricht zu schnell ab\n\n# \u2705 Angemessen\nwebsocket:\n  idle_timeout: 300s  # 5 Minuten f\u00fcr Chat\n  idle_timeout: 3600s  # 1 Stunde f\u00fcr IoT\n</code></pre> <p>Faustregeln: - Chat/Messaging: 5-10 Minuten - Live-Dashboards: 5-15 Minuten - IoT/Sensoren: 30-60 Minuten - Gaming: 1-2 Stunden</p>"},{"location":"guides/WEBSOCKET/#2-ping-interval-idle-timeout","title":"2. Ping Interval &lt; Idle Timeout","text":"<pre><code># \u274c Ping Interval gr\u00f6\u00dfer als Idle Timeout\nwebsocket:\n  idle_timeout: 60s\n  ping_interval: 90s  # Verbindung wird vorher geschlossen!\n\n# \u2705 Ping Interval deutlich kleiner\nwebsocket:\n  idle_timeout: 300s\n  ping_interval: 30s  # 10x Pings vor Timeout\n</code></pre> <p>Empfehlung: <code>ping_interval</code> sollte mindestens 5-10x kleiner als <code>idle_timeout</code> sein.</p>"},{"location":"guides/WEBSOCKET/#3-load-balancing-fur-websocket","title":"3. Load Balancing f\u00fcr WebSocket","text":"<pre><code># \u2705 IP Hash oder Sticky Sessions verwenden\nupstream:\n  load_balancer:\n    algorithm: ip_hash  # Session-Persistenz\n    sticky_sessions: true\n    cookie_name: WS_SESSION\n</code></pre> <p>Warum? WebSocket-Verbindungen sind stateful. Ohne Sticky Sessions verlieren Clients die Verbindung bei Load Balancer-Umschaltung.</p>"},{"location":"guides/WEBSOCKET/#4-authentication-kombinieren","title":"4. Authentication kombinieren","text":"<pre><code># \u2705 JWT f\u00fcr WebSocket-Verbindungen\nroutes:\n  - path_prefix: /ws/secure\n    authentication:\n      enabled: true\n      type: jwt\n      jwt:\n        issuer: https://auth.example.com\n        jwks_uri: https://auth.example.com/.well-known/jwks.json\n\n    websocket:\n      enabled: true\n</code></pre> <p>Vorteil: JWT im Upgrade-Request validiert, dann persistente Verbindung.</p>"},{"location":"guides/WEBSOCKET/#5-rate-limiting-anwenden","title":"5. Rate Limiting anwenden","text":"<pre><code># \u2705 Rate Limiting f\u00fcr WebSocket-Verbindungen\nrate_limit:\n  enabled: true\n  requests_per_second: 10  # Max 10 neue Verbindungen/s\n  key_type: ip_address\n</code></pre> <p>Zweck: Schutz vor Connection-Flooding-Attacken.</p>"},{"location":"guides/WEBSOCKET/#6-compression-gezielt-einsetzen","title":"6. Compression gezielt einsetzen","text":"<pre><code># \u2705 Compression f\u00fcr JSON-APIs\nwebsocket:\n  compression: true  # JSON, XML, Text\n\n# \u274c Keine Compression f\u00fcr Bin\u00e4rdaten\nwebsocket:\n  compression: false  # Bilder, Videos, verschl\u00fcsselte Daten\n</code></pre> <p>Trade-off: Bandbreite vs. CPU-Last.</p>"},{"location":"guides/WEBSOCKET/#7-message-size-limits-setzen","title":"7. Message Size Limits setzen","text":"<pre><code># \u2705 Realistische Message Size Limits\nwebsocket:\n  max_message_size: 262144  # 256KB f\u00fcr Chat\n  max_message_size: 10485760  # 10MB f\u00fcr File Upload\n</code></pre> <p>Zweck: Schutz vor Memory-Exhaustion-Attacken.</p>"},{"location":"guides/WEBSOCKET/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/WEBSOCKET/#problem-1-verbindung-schliet-nach-kurzer-zeit","title":"Problem 1: Verbindung schlie\u00dft nach kurzer Zeit","text":"<p>Symptom: WebSocket-Verbindung wird nach 30-60 Sekunden geschlossen.</p> <p>Ursache: Proxy- oder Gateway-Timeout zu kurz.</p> <p>L\u00f6sung: <pre><code>websocket:\n  idle_timeout: 600s  # Erh\u00f6hen\n  ping_interval: 30s  # Keep-Alive aktivieren\n</code></pre></p>"},{"location":"guides/WEBSOCKET/#problem-2-connection-upgrade-funktioniert-nicht","title":"Problem 2: \"Connection: Upgrade\" funktioniert nicht","text":"<p>Symptom: HTTP 400/502 bei WebSocket-Verbindung.</p> <p>Ursache: Proxy leitet Upgrade-Header nicht weiter.</p> <p>L\u00f6sung (Nginx): <pre><code>proxy_http_version 1.1;\nproxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection \"upgrade\";\n</code></pre></p> <p>L\u00f6sung (HAProxy): <pre><code>acl is_websocket_upgrade hdr(Upgrade) -i websocket\nuse_backend ws_backend if is_websocket_upgrade\n</code></pre></p>"},{"location":"guides/WEBSOCKET/#problem-3-load-balancing-bricht-verbindung","title":"Problem 3: Load Balancing bricht Verbindung","text":"<p>Symptom: WebSocket-Verbindung funktioniert, bricht aber nach Load Balancer-Wechsel.</p> <p>Ursache: Keine Session-Persistenz.</p> <p>L\u00f6sung: <pre><code>upstream:\n  load_balancer:\n    algorithm: ip_hash  # Oder sticky_sessions\n    sticky_sessions: true\n</code></pre></p>"},{"location":"guides/WEBSOCKET/#problem-4-hohe-latenz","title":"Problem 4: Hohe Latenz","text":"<p>Symptom: Nachrichten kommen mit Verz\u00f6gerung an.</p> <p>Ursache: Buffering im Proxy.</p> <p>L\u00f6sung (Nginx): <pre><code>proxy_buffering off;\nproxy_cache off;\n</code></pre></p> <p>L\u00f6sung (Traefik): <pre><code>responseForwarding:\n  flushInterval: 100ms\n</code></pre></p>"},{"location":"guides/WEBSOCKET/#problem-5-message-too-large","title":"Problem 5: \"Message too large\"","text":"<p>Symptom: Gro\u00dfe Nachrichten werden abgelehnt.</p> <p>Ursache: <code>max_message_size</code> zu klein.</p> <p>L\u00f6sung: <pre><code>websocket:\n  max_message_size: 10485760  # 10MB\n</code></pre></p>"},{"location":"guides/WEBSOCKET/#problem-6-authentication-schlagt-fehl","title":"Problem 6: Authentication schl\u00e4gt fehl","text":"<p>Symptom: WebSocket-Verbindung wird mit 401 abgelehnt.</p> <p>Ursache: JWT/Auth-Header nicht im Upgrade-Request.</p> <p>L\u00f6sung: <pre><code>// Client-seitig: Token in Subprotocol oder Query \u00fcbergeben\nconst ws = new WebSocket('wss://api.example.com/ws/chat', ['access_token', token]);\n\n// Oder Query Parameter\nconst ws = new WebSocket('wss://api.example.com/ws/chat?token=' + token);\n</code></pre></p>"},{"location":"guides/WEBSOCKET/#client-beispiele","title":"Client-Beispiele","text":""},{"location":"guides/WEBSOCKET/#javascript-browser","title":"JavaScript (Browser)","text":"<pre><code>// Basis WebSocket-Verbindung\nconst ws = new WebSocket('wss://api.example.com/ws/chat');\n\nws.onopen = () =&gt; {\n    console.log('WebSocket verbunden');\n    ws.send(JSON.stringify({ type: 'hello', user: 'Alice' }));\n};\n\nws.onmessage = (event) =&gt; {\n    const data = JSON.parse(event.data);\n    console.log('Nachricht erhalten:', data);\n};\n\nws.onerror = (error) =&gt; {\n    console.error('WebSocket Fehler:', error);\n};\n\nws.onclose = () =&gt; {\n    console.log('WebSocket geschlossen');\n};\n\n// Mit Authentication (JWT in Subprotocol)\nconst token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...';\nconst ws = new WebSocket('wss://api.example.com/ws/secure', ['access_token', token]);\n</code></pre>"},{"location":"guides/WEBSOCKET/#python","title":"Python","text":"<pre><code>import asyncio\nimport websockets\n\nasync def chat_client():\n    uri = \"wss://api.example.com/ws/chat\"\n\n    async with websockets.connect(uri) as websocket:\n        # Nachricht senden\n        await websocket.send('{\"type\": \"hello\", \"user\": \"Alice\"}')\n\n        # Nachricht empfangen\n        response = await websocket.recv()\n        print(f\"Antwort: {response}\")\n\nasyncio.run(chat_client())\n</code></pre>"},{"location":"guides/WEBSOCKET/#go","title":"Go","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/gorilla/websocket\"\n)\n\nfunc main() {\n    url := \"wss://api.example.com/ws/chat\"\n\n    conn, _, err := websocket.DefaultDialer.Dial(url, nil)\n    if err != nil {\n        panic(err)\n    }\n    defer conn.Close()\n\n    // Nachricht senden\n    err = conn.WriteMessage(websocket.TextMessage, []byte(`{\"type\":\"hello\",\"user\":\"Alice\"}`))\n    if err != nil {\n        panic(err)\n    }\n\n    // Nachricht empfangen\n    _, message, err := conn.ReadMessage()\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"Antwort: %s\\n\", message)\n}\n</code></pre>"},{"location":"guides/WEBSOCKET/#sicherheit","title":"Sicherheit","text":""},{"location":"guides/WEBSOCKET/#1-immer-wss-websocket-secure-verwenden","title":"1. Immer WSS (WebSocket Secure) verwenden","text":"<pre><code># \u274c Unsicheres WebSocket\nws://api.example.com/ws/chat\n\n# \u2705 Sicheres WebSocket \u00fcber TLS\nwss://api.example.com/ws/chat\n</code></pre>"},{"location":"guides/WEBSOCKET/#2-authentication-obligatorisch","title":"2. Authentication obligatorisch","text":"<pre><code>routes:\n  - path_prefix: /ws/chat\n    authentication:\n      enabled: true\n      type: jwt  # Oder api_key, basic\n</code></pre>"},{"location":"guides/WEBSOCKET/#3-rate-limiting-gegen-dos","title":"3. Rate Limiting gegen DoS","text":"<pre><code>rate_limit:\n  enabled: true\n  requests_per_second: 10\n  key_type: ip_address\n</code></pre>"},{"location":"guides/WEBSOCKET/#4-message-size-limits","title":"4. Message Size Limits","text":"<pre><code>websocket:\n  max_message_size: 1048576  # 1MB - verhindert Memory-Exhaustion\n</code></pre>"},{"location":"guides/WEBSOCKET/#5-cors-policy","title":"5. CORS Policy","text":"<pre><code>cors:\n  enabled: true\n  allowed_origins:\n    - https://app.example.com  # Nur vertrauensw\u00fcrdige Origins\n  allowed_methods:\n    - GET\n  allow_credentials: true\n</code></pre>"},{"location":"guides/WEBSOCKET/#performance-optimierung","title":"Performance-Optimierung","text":""},{"location":"guides/WEBSOCKET/#1-connection-pooling-nginx","title":"1. Connection Pooling (Nginx)","text":"<pre><code>upstream ws_backend {\n    server backend:8080;\n    keepalive 100;  # Connection Pool\n}\n</code></pre>"},{"location":"guides/WEBSOCKET/#2-kompression-aktivieren","title":"2. Kompression aktivieren","text":"<pre><code>websocket:\n  compression: true  # Reduziert Bandbreite um 60-80% (JSON)\n</code></pre>"},{"location":"guides/WEBSOCKET/#3-ping-interval-optimieren","title":"3. Ping Interval optimieren","text":"<pre><code># F\u00fcr niedrige Latenz\nwebsocket:\n  ping_interval: 10s  # Gaming\n\n# F\u00fcr Batterie-Schonung (Mobile/IoT)\nwebsocket:\n  ping_interval: 120s  # IoT-Sensoren\n</code></pre>"},{"location":"guides/WEBSOCKET/#4-load-balancing-algorithm","title":"4. Load Balancing Algorithm","text":"<pre><code># F\u00fcr gleichm\u00e4\u00dfige Verteilung\nupstream:\n  load_balancer:\n    algorithm: least_conn  # Verbindungen auf wenig ausgelastete Server\n\n# F\u00fcr Session-Persistenz\nupstream:\n  load_balancer:\n    algorithm: ip_hash  # Gleicher Client \u2192 gleicher Server\n</code></pre>"},{"location":"guides/WEBSOCKET/#weiterfuhrende-ressourcen","title":"Weiterf\u00fchrende Ressourcen","text":"<ul> <li>RFC 6455: WebSocket Protocol Specification</li> <li>RFC 7692: Compression Extensions for WebSocket</li> <li>MDN WebSocket API: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket</li> <li>Can I use WebSocket: https://caniuse.com/websockets (Browser Support: 98%+)</li> </ul>"},{"location":"guides/WEBSOCKET/#zusammenfassung","title":"Zusammenfassung","text":"<p>WebSocket Support in GAL erm\u00f6glicht: - \u2705 Echtzeitkommunikation f\u00fcr moderne Anwendungen - \u2705 Bidirektionale Push-Nachrichten vom Server - \u2705 Niedrige Latenz durch persistente Verbindungen - \u2705 Volle Provider-Unterst\u00fctzung (alle 6 Provider) - \u2705 Authentication &amp; Rate Limiting f\u00fcr Sicherheit - \u2705 Load Balancing f\u00fcr Hochverf\u00fcgbarkeit - \u2705 Einfache Konfiguration mit YAML</p> <p>Next Steps: 1. Konfiguriere <code>websocket</code> in deinen Routes 2. W\u00e4hle passende Timeouts f\u00fcr deinen Use Case 3. Aktiviere Compression f\u00fcr JSON-Daten 4. Implementiere Client-seitigen Reconnect-Mechanismus 5. Teste mit Load (ab 1000+ gleichzeitige Verbindungen)</p> <p>Version: 1.2.0 Last Updated: 2025-10-18 Author: GAL Development Team</p>"},{"location":"import/apisix/","title":"Feature 3: APISIX Import (JSON/YAML Parser)","text":"<p>Status: \ud83d\udd04 Geplant Aufwand: 1 Woche Release: v1.3.0-alpha2 (Woche 4) Priorit\u00e4t: \ud83d\udfe1 Mittel</p>"},{"location":"import/apisix/#ubersicht","title":"\u00dcbersicht","text":"<p>Import von Apache APISIX-Konfigurationen (YAML/JSON) nach GAL. APISIX wird in alpha2 implementiert, da: - APISIX unterst\u00fctzt sowohl YAML als auch JSON - Moderne API Gateway L\u00f6sung mit wachsender Beliebtheit - \u00c4hnliche Struktur wie Kong, aber mit eigenen Besonderheiten</p>"},{"location":"import/apisix/#implementierung","title":"Implementierung","text":""},{"location":"import/apisix/#providerparse-methode","title":"Provider.parse() Methode","text":"<pre><code>class APISIXProvider(Provider):\n    \"\"\"Apache APISIX Provider with Import Support.\"\"\"\n\n    def parse(self, provider_config: str) -&gt; Config:\n        \"\"\"Parse APISIX YAML/JSON config to GAL format.\n\n        APISIX supports both etcd and standalone (config file) mode.\n        This parser handles standalone config files.\n\n        Args:\n            provider_config: APISIX YAML/JSON configuration string\n\n        Returns:\n            Config: GAL configuration object\n\n        Raises:\n            ValueError: If config is invalid or cannot be parsed\n        \"\"\"\n        try:\n            apisix_config = yaml.safe_load(provider_config)\n        except yaml.YAMLError:\n            try:\n                apisix_config = json.loads(provider_config)\n            except json.JSONDecodeError as e:\n                raise ValueError(f\"Invalid YAML/JSON: {e}\")\n\n        self._import_warnings = []\n\n        # APISIX config structure: routes, services, upstreams, consumers, plugins\n        return Config(\n            version=\"1.0\",\n            provider=\"apisix\",\n            global_config=self._parse_global(apisix_config),\n            services=self._parse_services(apisix_config)\n        )\n\n    def _parse_global(self, apisix_config: dict) -&gt; GlobalConfig:\n        \"\"\"Extract global config from APISIX.\"\"\"\n        # APISIX has deployment config separate from routes\n        deployment = apisix_config.get(\"deployment\", {})\n        admin = deployment.get(\"admin\", {})\n\n        return GlobalConfig(\n            host=\"0.0.0.0\",\n            port=9080,  # APISIX HTTP port\n            timeout=\"60s\"\n        )\n\n    def _parse_services(self, apisix_config: dict) -&gt; List[Service]:\n        \"\"\"Parse APISIX services to GAL services.\"\"\"\n        gal_services = []\n\n        apisix_services = apisix_config.get(\"services\", [])\n        apisix_routes = apisix_config.get(\"routes\", [])\n        apisix_upstreams = apisix_config.get(\"upstreams\", [])\n        apisix_plugins = apisix_config.get(\"global_rules\", [])  # Global plugins\n\n        for apisix_service in apisix_services:\n            service = self._parse_service(\n                apisix_service,\n                apisix_routes,\n                apisix_upstreams\n            )\n            if service:\n                gal_services.append(service)\n\n        return gal_services\n\n    def _parse_service(\n        self,\n        apisix_service: dict,\n        apisix_routes: list,\n        apisix_upstreams: list\n    ) -&gt; Optional[Service]:\n        \"\"\"Convert APISIX service to GAL service.\"\"\"\n        service_id = apisix_service.get(\"id\")\n        name = apisix_service.get(\"name\", f\"service_{service_id}\")\n\n        # Parse upstream\n        upstream_id = apisix_service.get(\"upstream_id\")\n        upstream = self._parse_upstream(upstream_id, apisix_upstreams)\n\n        # Parse routes for this service\n        routes = []\n        for apisix_route in apisix_routes:\n            if apisix_route.get(\"service_id\") == service_id:\n                route = self._parse_route(apisix_route)\n                if route:\n                    routes.append(route)\n\n        return Service(\n            name=name,\n            upstream=upstream,\n            routes=routes\n        )\n\n    def _parse_upstream(\n        self,\n        upstream_id: str,\n        apisix_upstreams: list\n    ) -&gt; Optional[UpstreamConfig]:\n        \"\"\"Parse APISIX upstream to GAL upstream.\"\"\"\n        # Find upstream by ID\n        apisix_upstream = None\n        for upstream in apisix_upstreams:\n            if upstream.get(\"id\") == upstream_id:\n                apisix_upstream = upstream\n                break\n\n        if not apisix_upstream:\n            return None\n\n        # Parse nodes (targets)\n        nodes = apisix_upstream.get(\"nodes\", {})\n        targets = []\n\n        for node_str, weight in nodes.items():\n            # Format: \"host:port\"\n            if \":\" in node_str:\n                host, port_str = node_str.rsplit(\":\", 1)\n                try:\n                    port = int(port_str)\n                except ValueError:\n                    port = 80\n            else:\n                host = node_str\n                port = 80\n\n            targets.append(UpstreamTarget(\n                host=host,\n                port=port,\n                weight=weight\n            ))\n\n        # Parse load balancing type\n        lb_type = apisix_upstream.get(\"type\", \"roundrobin\")\n        algorithm = self._map_lb_algorithm(lb_type)\n\n        # Parse health checks\n        health_check = self._parse_health_check(apisix_upstream)\n\n        return UpstreamConfig(\n            targets=targets,\n            load_balancer=LoadBalancerConfig(algorithm=algorithm),\n            health_check=health_check\n        )\n\n    def _map_lb_algorithm(self, apisix_type: str) -&gt; str:\n        \"\"\"Map APISIX load balancing type to GAL.\"\"\"\n        mapping = {\n            \"roundrobin\": \"round_robin\",\n            \"chash\": \"ip_hash\",\n            \"ewma\": \"least_conn\",\n            \"least_conn\": \"least_conn\"\n        }\n        return mapping.get(apisix_type, \"round_robin\")\n\n    def _parse_health_check(self, apisix_upstream: dict) -&gt; Optional[HealthCheckConfig]:\n        \"\"\"Parse APISIX health checks.\"\"\"\n        checks = apisix_upstream.get(\"checks\", {})\n\n        active = checks.get(\"active\", {})\n        passive = checks.get(\"passive\", {})\n\n        active_hc = None\n        passive_hc = None\n\n        if active and active.get(\"http_path\"):\n            # Active health checks\n            healthy = active.get(\"healthy\", {})\n            unhealthy = active.get(\"unhealthy\", {})\n\n            active_hc = ActiveHealthCheck(\n                enabled=True,\n                http_path=active.get(\"http_path\", \"/\"),\n                interval=f\"{active.get('interval', 10)}s\",\n                timeout=f\"{active.get('timeout', 5)}s\",\n                healthy_threshold=healthy.get(\"successes\", 2),\n                unhealthy_threshold=unhealthy.get(\"http_failures\", 3),\n                healthy_status_codes=healthy.get(\"http_statuses\", [200])\n            )\n\n        if passive:\n            # Passive health checks\n            unhealthy = passive.get(\"unhealthy\", {})\n\n            passive_hc = PassiveHealthCheck(\n                enabled=True,\n                max_failures=unhealthy.get(\"http_failures\", 3)\n            )\n\n        if active_hc or passive_hc:\n            return HealthCheckConfig(active=active_hc, passive=passive_hc)\n\n        return None\n\n    def _parse_route(self, apisix_route: dict) -&gt; Optional[Route]:\n        \"\"\"Parse APISIX route to GAL route.\"\"\"\n        # Parse URI\n        uri = apisix_route.get(\"uri\") or apisix_route.get(\"uris\", [\"/\"])[0]\n\n        # Parse methods\n        methods = apisix_route.get(\"methods\")\n\n        # Parse plugins (route-level)\n        plugins = apisix_route.get(\"plugins\", {})\n\n        rate_limit = None\n        authentication = None\n        headers = None\n        cors = None\n        circuit_breaker = None\n\n        # Parse each plugin\n        if \"limit-req\" in plugins:\n            rate_limit = self._parse_limit_req_plugin(plugins[\"limit-req\"])\n        elif \"limit-count\" in plugins:\n            rate_limit = self._parse_limit_count_plugin(plugins[\"limit-count\"])\n\n        if \"key-auth\" in plugins:\n            authentication = self._parse_key_auth_plugin(plugins[\"key-auth\"])\n        elif \"basic-auth\" in plugins:\n            authentication = self._parse_basic_auth_plugin(plugins[\"basic-auth\"])\n        elif \"jwt-auth\" in plugins:\n            authentication = self._parse_jwt_auth_plugin(plugins[\"jwt-auth\"])\n\n        if \"proxy-rewrite\" in plugins:\n            headers = self._parse_proxy_rewrite_plugin(plugins[\"proxy-rewrite\"])\n\n        if \"response-rewrite\" in plugins:\n            if headers:\n                self._enrich_response_headers(headers, plugins[\"response-rewrite\"])\n            else:\n                headers = self._parse_response_rewrite_plugin(plugins[\"response-rewrite\"])\n\n        if \"cors\" in plugins:\n            cors = self._parse_cors_plugin(plugins[\"cors\"])\n\n        if \"api-breaker\" in plugins:\n            circuit_breaker = self._parse_api_breaker_plugin(plugins[\"api-breaker\"])\n            self._import_warnings.append(\n                f\"Circuit breaker on route {uri} - review configuration\"\n            )\n\n        return Route(\n            path_prefix=uri,\n            methods=methods,\n            rate_limit=rate_limit,\n            authentication=authentication,\n            headers=headers,\n            cors=cors\n        )\n\n    def _parse_limit_req_plugin(self, config: dict) -&gt; RateLimitConfig:\n        \"\"\"Parse APISIX limit-req plugin (leaky bucket).\"\"\"\n        rate = config.get(\"rate\", 100)\n        burst = config.get(\"burst\", 200)\n\n        return RateLimitConfig(\n            enabled=True,\n            requests_per_second=rate,\n            burst=burst,\n            key_type=\"ip_address\"\n        )\n\n    def _parse_limit_count_plugin(self, config: dict) -&gt; RateLimitConfig:\n        \"\"\"Parse APISIX limit-count plugin (fixed window).\"\"\"\n        count = config.get(\"count\", 100)\n        time_window = config.get(\"time_window\", 60)  # seconds\n\n        # Convert to requests per second\n        rps = count // time_window if time_window &gt; 0 else count\n\n        return RateLimitConfig(\n            enabled=True,\n            requests_per_second=rps,\n            burst=count,\n            key_type=\"ip_address\"\n        )\n\n    def _parse_key_auth_plugin(self, config: dict) -&gt; AuthenticationConfig:\n        \"\"\"Parse APISIX key-auth plugin.\"\"\"\n        header = config.get(\"header\", \"apikey\")\n\n        return AuthenticationConfig(\n            enabled=True,\n            type=\"api_key\",\n            api_key_auth=ApiKeyAuth(header_name=header)\n        )\n\n    def _parse_basic_auth_plugin(self, config: dict) -&gt; AuthenticationConfig:\n        \"\"\"Parse APISIX basic-auth plugin.\"\"\"\n        self._import_warnings.append(\n            \"Basic auth users not imported - configure in consumers\"\n        )\n\n        return AuthenticationConfig(\n            enabled=True,\n            type=\"basic\",\n            basic_auth=BasicAuth(users={})\n        )\n\n    def _parse_jwt_auth_plugin(self, config: dict) -&gt; AuthenticationConfig:\n        \"\"\"Parse APISIX jwt-auth plugin.\"\"\"\n        header = config.get(\"header\", \"authorization\")\n        secret = config.get(\"secret\", \"CONFIGURE_MANUALLY\")\n\n        self._import_warnings.append(\n            \"JWT secret not imported - configure manually\"\n        )\n\n        return AuthenticationConfig(\n            enabled=True,\n            type=\"jwt\",\n            jwt_auth=JWTAuth(\n                secret=secret,\n                algorithm=\"HS256\",\n                header_name=header\n            )\n        )\n\n    def _parse_proxy_rewrite_plugin(self, config: dict) -&gt; HeadersConfig:\n        \"\"\"Parse APISIX proxy-rewrite plugin (request headers).\"\"\"\n        headers_config = config.get(\"headers\", {})\n\n        request_add = {}\n        request_remove = []\n\n        for key, value in headers_config.items():\n            if value is None or value == \"\":\n                request_remove.append(key)\n            else:\n                request_add[key] = value\n\n        return HeadersConfig(\n            request_add=request_add if request_add else None,\n            request_remove=request_remove if request_remove else None\n        )\n\n    def _parse_response_rewrite_plugin(self, config: dict) -&gt; HeadersConfig:\n        \"\"\"Parse APISIX response-rewrite plugin (response headers).\"\"\"\n        headers_config = config.get(\"headers\", {})\n\n        response_add = {}\n        response_remove = []\n\n        for key, value in headers_config.items():\n            if value is None or value == \"\":\n                response_remove.append(key)\n            else:\n                response_add[key] = value\n\n        return HeadersConfig(\n            response_add=response_add if response_add else None,\n            response_remove=response_remove if response_remove else None\n        )\n\n    def _enrich_response_headers(self, headers: HeadersConfig, config: dict):\n        \"\"\"Add response headers to existing HeadersConfig.\"\"\"\n        headers_config = config.get(\"headers\", {})\n\n        if not headers.response_add:\n            headers.response_add = {}\n        if not headers.response_remove:\n            headers.response_remove = []\n\n        for key, value in headers_config.items():\n            if value is None or value == \"\":\n                headers.response_remove.append(key)\n            else:\n                headers.response_add[key] = value\n\n    def _parse_cors_plugin(self, config: dict) -&gt; CorsConfig:\n        \"\"\"Parse APISIX cors plugin.\"\"\"\n        origins = config.get(\"allow_origins\", \"*\")\n        methods = config.get(\"allow_methods\", \"*\")\n        headers_str = config.get(\"allow_headers\", \"*\")\n        credentials = config.get(\"allow_credential\", False)\n        max_age = config.get(\"max_age\", 86400)\n\n        # Parse comma-separated strings\n        if isinstance(origins, str):\n            origins = [origins] if origins != \"*\" else [\"*\"]\n\n        if isinstance(methods, str):\n            methods = methods.split(\",\") if methods != \"*\" else [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n\n        headers_list = None\n        if headers_str != \"*\":\n            headers_list = headers_str.split(\",\") if isinstance(headers_str, str) else headers_str\n\n        return CorsConfig(\n            enabled=True,\n            allowed_origins=origins,\n            allowed_methods=methods,\n            allowed_headers=headers_list,\n            allow_credentials=credentials,\n            max_age=str(max_age)\n        )\n\n    def _parse_api_breaker_plugin(self, config: dict) -&gt; dict:\n        \"\"\"Parse APISIX api-breaker plugin (Circuit Breaker).\"\"\"\n        # GAL doesn't have circuit breaker in v1.2.0, store in provider_specific\n        return {\n            \"break_response_code\": config.get(\"break_response_code\", 502),\n            \"max_breaker_sec\": config.get(\"max_breaker_sec\", 300),\n            \"unhealthy\": config.get(\"unhealthy\", {}),\n            \"healthy\": config.get(\"healthy\", {})\n        }\n\n    def get_import_warnings(self) -&gt; List[str]:\n        \"\"\"Return warnings from last import.\"\"\"\n        return getattr(self, '_import_warnings', [])\n</code></pre>"},{"location":"import/apisix/#feature-mapping-matrix","title":"Feature Mapping Matrix","text":"GAL Feature APISIX Config Mapping Service <code>services[].name</code> Direct mapping Upstream Targets <code>upstreams[].nodes</code> \"host:port\" \u2192 UpstreamTarget Load Balancing <code>upstreams[].type</code> roundrobin \u2192 round_robin, chash \u2192 ip_hash Active Health Checks <code>upstreams[].checks.active</code> Direct mapping Passive Health Checks <code>upstreams[].checks.passive</code> Direct mapping Routes <code>routes[].uri</code> Direct mapping Rate Limiting <code>plugins.limit-req</code> or <code>limit-count</code> rate/time_window \u2192 requests_per_second Basic Auth <code>plugins.basic-auth</code> \u2705 (users in consumers) API Key Auth <code>plugins.key-auth</code> \u2705 Direct mapping JWT Auth <code>plugins.jwt-auth</code> \u2705 (secret must be configured) Headers <code>plugins.proxy-rewrite</code>, <code>response-rewrite</code> Direct mapping CORS <code>plugins.cors</code> Direct mapping Circuit Breaker <code>plugins.api-breaker</code> \u26a0\ufe0f Future feature"},{"location":"import/apisix/#beispiel-konvertierung","title":"Beispiel-Konvertierung","text":""},{"location":"import/apisix/#apisix-config-input","title":"APISIX Config (Input)","text":"<pre><code>routes:\n  - id: 1\n    name: api_route\n    uri: /api/*\n    methods:\n      - GET\n      - POST\n    service_id: api_service\n    plugins:\n      limit-req:\n        rate: 100\n        burst: 200\n        key: remote_addr\n      key-auth:\n        header: X-API-Key\n      cors:\n        allow_origins: https://app.example.com\n        allow_methods: GET,POST,PUT,DELETE\n        allow_credential: true\n\nservices:\n  - id: api_service\n    name: api_service\n    upstream_id: api_upstream\n\nupstreams:\n  - id: api_upstream\n    name: api_upstream\n    type: roundrobin\n    nodes:\n      \"api-1.internal:8080\": 1\n      \"api-2.internal:8080\": 1\n    checks:\n      active:\n        http_path: /health\n        interval: 10\n        timeout: 5\n        healthy:\n          successes: 2\n          http_statuses: [200]\n        unhealthy:\n          http_failures: 3\n</code></pre>"},{"location":"import/apisix/#gal-config-output","title":"GAL Config (Output)","text":"<pre><code>version: \"1.0\"\nprovider: apisix\n\nglobal_config:\n  host: 0.0.0.0\n  port: 9080\n  timeout: 60s\n\nservices:\n  - name: api_service\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n          weight: 1\n        - host: api-2.internal\n          port: 8080\n          weight: 1\n\n      load_balancer:\n        algorithm: round_robin\n\n      health_check:\n        active:\n          enabled: true\n          http_path: /health\n          interval: 10s\n          timeout: 5s\n          healthy_threshold: 2\n          unhealthy_threshold: 3\n          healthy_status_codes: [200]\n\n    routes:\n      - path_prefix: /api/*\n        methods:\n          - GET\n          - POST\n\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n          burst: 200\n          key_type: ip_address\n\n        authentication:\n          enabled: true\n          type: api_key\n          api_key_auth:\n            header_name: X-API-Key\n\n        cors:\n          enabled: true\n          allowed_origins:\n            - https://app.example.com\n          allowed_methods:\n            - GET\n            - POST\n            - PUT\n            - DELETE\n          allow_credentials: true\n</code></pre>"},{"location":"import/apisix/#cli-usage","title":"CLI Usage","text":"<pre><code># Import APISIX config\ngal import --provider apisix --input apisix.yaml --output gal-config.yaml\n\n# Validate\ngal validate --config gal-config.yaml\n\n# Generate for different provider\ngal generate --config gal-config.yaml --provider nginx --output nginx.conf\n</code></pre>"},{"location":"import/apisix/#test-cases","title":"Test Cases","text":"<p>20+ Tests abdecken: - Basic import (services, upstreams, routes) - Load balancing algorithms - Health checks (active + passive) - Rate limiting (limit-req, limit-count) - Authentication (key-auth, basic-auth, jwt-auth) - Headers (proxy-rewrite, response-rewrite) - CORS - Circuit breaker (api-breaker) - Round-trip test</p>"},{"location":"import/apisix/#edge-cases","title":"Edge Cases","text":"<ul> <li>etcd Mode: Nicht unterst\u00fctzt, nur standalone config</li> <li>Consumers: Nicht importiert, Warnung</li> <li>Custom Plugins: Nicht gemappt, provider_specific</li> <li>Stream Routes: Nicht unterst\u00fctzt (nur HTTP)</li> </ul>"},{"location":"import/apisix/#akzeptanzkriterien","title":"Akzeptanzkriterien","text":"<ul> <li>\u2705 Import von APISIX YAML/JSON</li> <li>\u2705 Mapping von Services/Upstreams/Routes</li> <li>\u2705 Import von allen Standard-Plugins</li> <li>\u2705 CLI Integration</li> <li>\u2705 20+ Tests, 90%+ Coverage</li> <li>\u2705 Warnings f\u00fcr nicht unterst\u00fctzte Features</li> <li>\u2705 Round-trip Test</li> </ul>"},{"location":"import/apisix/#implementierungs-reihenfolge","title":"Implementierungs-Reihenfolge","text":"<ol> <li>Tag 1-2: parse() + Service/Upstream Parsing</li> <li>Tag 3: Routes + Basic Plugins (rate-limit)</li> <li>Tag 4: Auth Plugins</li> <li>Tag 5: Headers + CORS</li> <li>Tag 6-7: Tests + Documentation</li> </ol>"},{"location":"import/apisix/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<p>Nach Completion: 1. Release als v1.3.0-alpha2 (mit Traefik Import) 2. User Feedback 3. Traefik Import (Feature 4) testen</p>"},{"location":"import/compatibility/","title":"Feature 7: Compatibility Checker","text":"<p>Status: \ud83d\udd04 Geplant Aufwand: 2 Wochen Release: v1.3.0-rc1 (Woche 10) Priorit\u00e4t: \ud83d\udfe1 Mittel</p>"},{"location":"import/compatibility/#ubersicht","title":"\u00dcbersicht","text":"<p>Der Compatibility Checker validiert, ob eine GAL-Konfiguration auf einem Ziel-Provider funktioniert, und zeigt Feature-Kompatibilit\u00e4t f\u00fcr mehrere Provider gleichzeitig an. Dies hilft Nutzern, vor der Migration zu verstehen, welche Features unterst\u00fctzt werden.</p>"},{"location":"import/compatibility/#use-cases","title":"Use Cases","text":"<ol> <li>Pre-Migration Validation: Pr\u00fcfe ob Nginx-Config auf HAProxy portierbar ist</li> <li>Multi-Provider Comparison: Vergleiche Feature-Support f\u00fcr Envoy vs Kong vs Nginx</li> <li>Feature Discovery: Finde heraus, welcher Provider alle ben\u00f6tigten Features unterst\u00fctzt</li> </ol>"},{"location":"import/compatibility/#implementierung","title":"Implementierung","text":""},{"location":"import/compatibility/#cli-commands","title":"CLI Commands","text":"<pre><code># Check if config works on target provider\ngal validate --config gal-config.yaml --target-provider haproxy\n\n# Compare config across multiple providers\ngal compare --config gal-config.yaml --providers envoy,kong,nginx,haproxy\n\n# Generate compatibility report\ngal compatibility-report --config gal-config.yaml --output compatibility.md\n</code></pre>"},{"location":"import/compatibility/#core-komponente-compatibilitychecker","title":"Core Komponente: CompatibilityChecker","text":"<pre><code># gal/compatibility.py\n\nfrom typing import List, Dict, Any, Set\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nfrom gal.config import Config, Service, Route\nfrom gal.provider import Provider\n\nclass CompatibilityLevel(Enum):\n    \"\"\"Compatibility level for a feature.\"\"\"\n    FULL = \"full\"          # \u2705 Full support, no limitations\n    PARTIAL = \"partial\"    # \u26a0\ufe0f Supported with limitations\n    UNSUPPORTED = \"unsupported\"  # \u274c Not supported\n    MANUAL = \"manual\"      # \ud83d\udd27 Requires manual configuration\n\n@dataclass\nclass FeatureCompatibility:\n    \"\"\"Compatibility status for a single feature.\"\"\"\n    feature_name: str\n    level: CompatibilityLevel\n    message: str\n    workaround: Optional[str] = None\n\n@dataclass\nclass ProviderCompatibility:\n    \"\"\"Overall compatibility for a provider.\"\"\"\n    provider_name: str\n    compatible: bool\n    features: List[FeatureCompatibility]\n    warnings: List[str]\n    errors: List[str]\n\nclass CompatibilityChecker:\n    \"\"\"Check config compatibility across providers.\"\"\"\n\n    def __init__(self):\n        # Feature support matrix\n        self.feature_matrix = self._build_feature_matrix()\n\n    def _build_feature_matrix(self) -&gt; Dict[str, Dict[str, CompatibilityLevel]]:\n        \"\"\"Build feature support matrix for all providers.\n\n        Returns:\n            Dict: {feature_name: {provider_name: CompatibilityLevel}}\n        \"\"\"\n        return {\n            \"rate_limiting\": {\n                \"envoy\": CompatibilityLevel.FULL,\n                \"kong\": CompatibilityLevel.FULL,\n                \"apisix\": CompatibilityLevel.FULL,\n                \"traefik\": CompatibilityLevel.FULL,\n                \"nginx\": CompatibilityLevel.FULL,\n                \"haproxy\": CompatibilityLevel.FULL\n            },\n            \"basic_auth\": {\n                \"envoy\": CompatibilityLevel.PARTIAL,  # Requires Lua\n                \"kong\": CompatibilityLevel.FULL,\n                \"apisix\": CompatibilityLevel.FULL,\n                \"traefik\": CompatibilityLevel.FULL,\n                \"nginx\": CompatibilityLevel.FULL,\n                \"haproxy\": CompatibilityLevel.PARTIAL  # Basic support\n            },\n            \"api_key_auth\": {\n                \"envoy\": CompatibilityLevel.PARTIAL,\n                \"kong\": CompatibilityLevel.FULL,\n                \"apisix\": CompatibilityLevel.FULL,\n                \"traefik\": CompatibilityLevel.MANUAL,\n                \"nginx\": CompatibilityLevel.MANUAL,\n                \"haproxy\": CompatibilityLevel.MANUAL\n            },\n            \"jwt_auth\": {\n                \"envoy\": CompatibilityLevel.FULL,\n                \"kong\": CompatibilityLevel.FULL,\n                \"apisix\": CompatibilityLevel.FULL,\n                \"traefik\": CompatibilityLevel.PARTIAL,  # ForwardAuth\n                \"nginx\": CompatibilityLevel.MANUAL,  # OpenResty\n                \"haproxy\": CompatibilityLevel.MANUAL  # Lua\n            },\n            \"active_health_checks\": {\n                \"envoy\": CompatibilityLevel.FULL,\n                \"kong\": CompatibilityLevel.FULL,\n                \"apisix\": CompatibilityLevel.FULL,\n                \"traefik\": CompatibilityLevel.UNSUPPORTED,  # Plus only\n                \"nginx\": CompatibilityLevel.UNSUPPORTED,  # Plus only\n                \"haproxy\": CompatibilityLevel.FULL\n            },\n            \"passive_health_checks\": {\n                \"envoy\": CompatibilityLevel.FULL,\n                \"kong\": CompatibilityLevel.FULL,\n                \"apisix\": CompatibilityLevel.FULL,\n                \"traefik\": CompatibilityLevel.PARTIAL,\n                \"nginx\": CompatibilityLevel.FULL,\n                \"haproxy\": CompatibilityLevel.FULL\n            },\n            \"circuit_breaker\": {\n                \"envoy\": CompatibilityLevel.FULL,\n                \"kong\": CompatibilityLevel.UNSUPPORTED,\n                \"apisix\": CompatibilityLevel.FULL,\n                \"traefik\": CompatibilityLevel.UNSUPPORTED,\n                \"nginx\": CompatibilityLevel.PARTIAL,  # Via Lua\n                \"haproxy\": CompatibilityLevel.PARTIAL  # Via fall/rise\n            },\n            \"cors\": {\n                \"envoy\": CompatibilityLevel.FULL,\n                \"kong\": CompatibilityLevel.FULL,\n                \"apisix\": CompatibilityLevel.FULL,\n                \"traefik\": CompatibilityLevel.FULL,\n                \"nginx\": CompatibilityLevel.FULL,\n                \"haproxy\": CompatibilityLevel.FULL\n            },\n            \"headers\": {\n                \"envoy\": CompatibilityLevel.FULL,\n                \"kong\": CompatibilityLevel.FULL,\n                \"apisix\": CompatibilityLevel.FULL,\n                \"traefik\": CompatibilityLevel.FULL,\n                \"nginx\": CompatibilityLevel.FULL,\n                \"haproxy\": CompatibilityLevel.FULL\n            },\n            \"load_balancing_round_robin\": {\n                \"envoy\": CompatibilityLevel.FULL,\n                \"kong\": CompatibilityLevel.FULL,\n                \"apisix\": CompatibilityLevel.FULL,\n                \"traefik\": CompatibilityLevel.FULL,\n                \"nginx\": CompatibilityLevel.FULL,\n                \"haproxy\": CompatibilityLevel.FULL\n            },\n            \"load_balancing_least_conn\": {\n                \"envoy\": CompatibilityLevel.FULL,\n                \"kong\": CompatibilityLevel.FULL,\n                \"apisix\": CompatibilityLevel.FULL,\n                \"traefik\": CompatibilityLevel.FULL,\n                \"nginx\": CompatibilityLevel.FULL,\n                \"haproxy\": CompatibilityLevel.FULL\n            },\n            \"load_balancing_ip_hash\": {\n                \"envoy\": CompatibilityLevel.FULL,\n                \"kong\": CompatibilityLevel.FULL,\n                \"apisix\": CompatibilityLevel.FULL,\n                \"traefik\": CompatibilityLevel.UNSUPPORTED,\n                \"nginx\": CompatibilityLevel.FULL,\n                \"haproxy\": CompatibilityLevel.FULL\n            },\n            \"sticky_sessions\": {\n                \"envoy\": CompatibilityLevel.FULL,\n                \"kong\": CompatibilityLevel.UNSUPPORTED,\n                \"apisix\": CompatibilityLevel.UNSUPPORTED,\n                \"traefik\": CompatibilityLevel.FULL,\n                \"nginx\": CompatibilityLevel.PARTIAL,\n                \"haproxy\": CompatibilityLevel.FULL\n            }\n        }\n\n    def check_compatibility(\n        self,\n        config: Config,\n        target_provider: str\n    ) -&gt; ProviderCompatibility:\n        \"\"\"Check if config is compatible with target provider.\n\n        Args:\n            config: GAL configuration\n            target_provider: Target provider name (envoy, kong, etc.)\n\n        Returns:\n            ProviderCompatibility: Compatibility report\n        \"\"\"\n        features = []\n        warnings = []\n        errors = []\n\n        # Check each feature used in config\n        used_features = self._extract_features_from_config(config)\n\n        for feature_name in used_features:\n            if feature_name not in self.feature_matrix:\n                # Unknown feature\n                warnings.append(f\"Unknown feature: {feature_name}\")\n                continue\n\n            level = self.feature_matrix[feature_name].get(\n                target_provider,\n                CompatibilityLevel.UNSUPPORTED\n            )\n\n            message = self._get_compatibility_message(feature_name, target_provider, level)\n            workaround = self._get_workaround(feature_name, target_provider, level)\n\n            features.append(FeatureCompatibility(\n                feature_name=feature_name,\n                level=level,\n                message=message,\n                workaround=workaround\n            ))\n\n            # Add to warnings/errors\n            if level == CompatibilityLevel.UNSUPPORTED:\n                errors.append(f\"{feature_name}: Not supported on {target_provider}\")\n            elif level == CompatibilityLevel.PARTIAL:\n                warnings.append(f\"{feature_name}: Limited support on {target_provider}\")\n            elif level == CompatibilityLevel.MANUAL:\n                warnings.append(f\"{feature_name}: Requires manual configuration on {target_provider}\")\n\n        # Overall compatibility\n        compatible = len(errors) == 0\n\n        return ProviderCompatibility(\n            provider_name=target_provider,\n            compatible=compatible,\n            features=features,\n            warnings=warnings,\n            errors=errors\n        )\n\n    def compare_providers(\n        self,\n        config: Config,\n        providers: List[str]\n    ) -&gt; Dict[str, ProviderCompatibility]:\n        \"\"\"Compare config compatibility across multiple providers.\n\n        Args:\n            config: GAL configuration\n            providers: List of provider names\n\n        Returns:\n            Dict: {provider_name: ProviderCompatibility}\n        \"\"\"\n        results = {}\n\n        for provider in providers:\n            results[provider] = self.check_compatibility(config, provider)\n\n        return results\n\n    def _extract_features_from_config(self, config: Config) -&gt; Set[str]:\n        \"\"\"Extract list of features used in config.\"\"\"\n        features = set()\n\n        for service in config.services:\n            # Load balancing\n            if service.upstream and service.upstream.load_balancer:\n                algorithm = service.upstream.load_balancer.algorithm\n                features.add(f\"load_balancing_{algorithm}\")\n\n                if service.upstream.load_balancer.sticky_sessions:\n                    features.add(\"sticky_sessions\")\n\n            # Health checks\n            if service.upstream and service.upstream.health_check:\n                if service.upstream.health_check.active:\n                    features.add(\"active_health_checks\")\n                if service.upstream.health_check.passive:\n                    features.add(\"passive_health_checks\")\n\n            # Routes\n            for route in service.routes:\n                if route.rate_limit and route.rate_limit.enabled:\n                    features.add(\"rate_limiting\")\n\n                if route.authentication and route.authentication.enabled:\n                    auth_type = route.authentication.type\n                    if auth_type == \"basic\":\n                        features.add(\"basic_auth\")\n                    elif auth_type == \"api_key\":\n                        features.add(\"api_key_auth\")\n                    elif auth_type == \"jwt\":\n                        features.add(\"jwt_auth\")\n\n                if route.headers:\n                    features.add(\"headers\")\n\n                if route.cors and route.cors.enabled:\n                    features.add(\"cors\")\n\n                if route.circuit_breaker and route.circuit_breaker.enabled:\n                    features.add(\"circuit_breaker\")\n\n        return features\n\n    def _get_compatibility_message(\n        self,\n        feature_name: str,\n        provider: str,\n        level: CompatibilityLevel\n    ) -&gt; str:\n        \"\"\"Get user-friendly compatibility message.\"\"\"\n        messages = {\n            (CompatibilityLevel.FULL, None): \"\u2705 Fully supported\",\n            (CompatibilityLevel.PARTIAL, \"basic_auth\"): \"\u26a0\ufe0f Supported but users must be configured separately\",\n            (CompatibilityLevel.PARTIAL, \"jwt_auth\"): \"\u26a0\ufe0f Requires external auth service or additional setup\",\n            (CompatibilityLevel.UNSUPPORTED, \"active_health_checks\"): \"\u274c Only available in Plus/Enterprise version\",\n            (CompatibilityLevel.MANUAL, \"api_key_auth\"): \"\ud83d\udd27 Requires manual header validation setup\",\n            (CompatibilityLevel.MANUAL, \"jwt_auth\"): \"\ud83d\udd27 Requires OpenResty/Lua scripting\"\n        }\n\n        key = (level, feature_name)\n        if key in messages:\n            return messages[key]\n\n        key = (level, None)\n        if key in messages:\n            return messages[key]\n\n        return f\"{level.value.title()} support\"\n\n    def _get_workaround(\n        self,\n        feature_name: str,\n        provider: str,\n        level: CompatibilityLevel\n    ) -&gt; Optional[str]:\n        \"\"\"Get workaround suggestion for limited/unsupported features.\"\"\"\n        if level == CompatibilityLevel.FULL:\n            return None\n\n        workarounds = {\n            (\"jwt_auth\", \"nginx\"): \"Use OpenResty with lua-resty-jwt plugin\",\n            (\"jwt_auth\", \"haproxy\"): \"Use HAProxy Lua scripts or external auth service\",\n            (\"active_health_checks\", \"nginx\"): \"Upgrade to Nginx Plus or use passive health checks\",\n            (\"active_health_checks\", \"traefik\"): \"Upgrade to Traefik Enterprise or use passive health checks\",\n            (\"circuit_breaker\", \"kong\"): \"Use rate limiting as alternative or implement in application\",\n            (\"api_key_auth\", \"nginx\"): \"Validate X-API-Key header using Lua or map directive\"\n        }\n\n        return workarounds.get((feature_name, provider))\n\n    def generate_compatibility_report(\n        self,\n        config: Config,\n        providers: List[str]\n    ) -&gt; str:\n        \"\"\"Generate Markdown compatibility report.\n\n        Args:\n            config: GAL configuration\n            providers: List of providers to compare\n\n        Returns:\n            str: Markdown formatted report\n        \"\"\"\n        results = self.compare_providers(config, providers)\n\n        report = [\"# GAL Compatibility Report\\n\"]\n        report.append(f\"**Config:** {config.version}\\n\")\n        report.append(f\"**Providers:** {', '.join(providers)}\\n\\n\")\n\n        # Summary table\n        report.append(\"## Summary\\n\\n\")\n        report.append(\"| Provider | Compatible | Warnings | Errors |\\n\")\n        report.append(\"|----------|------------|----------|--------|\\n\")\n\n        for provider in providers:\n            compat = results[provider]\n            compatible_emoji = \"\u2705\" if compat.compatible else \"\u274c\"\n            report.append(\n                f\"| {provider} | {compatible_emoji} | {len(compat.warnings)} | {len(compat.errors)} |\\n\"\n            )\n\n        # Detailed feature comparison\n        report.append(\"\\n## Feature Support Matrix\\n\\n\")\n\n        # Get all features\n        all_features = set()\n        for compat in results.values():\n            for feature in compat.features:\n                all_features.add(feature.feature_name)\n\n        # Table header\n        report.append(\"| Feature | \" + \" | \".join(providers) + \" |\\n\")\n        report.append(\"|---------|\" + \"|\".join([\"-------\"] * len(providers)) + \"|\\n\")\n\n        # Table rows\n        for feature_name in sorted(all_features):\n            row = f\"| {feature_name} | \"\n\n            for provider in providers:\n                compat = results[provider]\n                feature_compat = next(\n                    (f for f in compat.features if f.feature_name == feature_name),\n                    None\n                )\n\n                if feature_compat:\n                    if feature_compat.level == CompatibilityLevel.FULL:\n                        symbol = \"\u2705\"\n                    elif feature_compat.level == CompatibilityLevel.PARTIAL:\n                        symbol = \"\u26a0\ufe0f\"\n                    elif feature_compat.level == CompatibilityLevel.MANUAL:\n                        symbol = \"\ud83d\udd27\"\n                    else:\n                        symbol = \"\u274c\"\n                    row += f\"{symbol} | \"\n                else:\n                    row += \"- | \"\n\n            report.append(row + \"\\n\")\n\n        # Warnings and errors per provider\n        report.append(\"\\n## Provider Details\\n\\n\")\n\n        for provider in providers:\n            compat = results[provider]\n\n            report.append(f\"### {provider.title()}\\n\\n\")\n\n            if compat.compatible:\n                report.append(f\"\u2705 **Compatible** - Configuration will work on {provider}\\n\\n\")\n            else:\n                report.append(f\"\u274c **Incompatible** - {len(compat.errors)} critical issue(s)\\n\\n\")\n\n            if compat.errors:\n                report.append(\"**Errors:**\\n\\n\")\n                for error in compat.errors:\n                    report.append(f\"- \u274c {error}\\n\")\n                report.append(\"\\n\")\n\n            if compat.warnings:\n                report.append(\"**Warnings:**\\n\\n\")\n                for warning in compat.warnings:\n                    report.append(f\"- \u26a0\ufe0f {warning}\\n\")\n                report.append(\"\\n\")\n\n            # Workarounds\n            features_with_workarounds = [\n                f for f in compat.features\n                if f.workaround\n            ]\n\n            if features_with_workarounds:\n                report.append(\"**Workarounds:**\\n\\n\")\n                for feature in features_with_workarounds:\n                    report.append(f\"- **{feature.feature_name}**: {feature.workaround}\\n\")\n                report.append(\"\\n\")\n\n        return \"\".join(report)\n</code></pre>"},{"location":"import/compatibility/#cli-integration","title":"CLI Integration","text":"<pre><code># gal-cli.py\n\n@cli.command(\"compare\")\n@click.option(\"--config\", required=True, help=\"GAL configuration file\")\n@click.option(\"--providers\", required=True, help=\"Comma-separated provider list\")\n@click.option(\"--output\", help=\"Output report file (Markdown)\")\ndef compare_providers(config, providers, output):\n    \"\"\"Compare config compatibility across providers.\"\"\"\n    # Load config\n    config_obj = load_config(config)\n\n    # Parse providers\n    provider_list = [p.strip() for p in providers.split(\",\")]\n\n    # Check compatibility\n    checker = CompatibilityChecker()\n    report = checker.generate_compatibility_report(config_obj, provider_list)\n\n    if output:\n        with open(output, \"w\") as f:\n            f.write(report)\n        click.echo(f\"\u2705 Compatibility report written to {output}\")\n    else:\n        click.echo(report)\n\n\n@cli.command(\"validate\")\n@click.option(\"--config\", required=True, help=\"GAL configuration file\")\n@click.option(\"--target-provider\", help=\"Target provider for compatibility check\")\ndef validate_config(config, target_provider):\n    \"\"\"Validate GAL configuration.\"\"\"\n    config_obj = load_config(config)\n\n    # Basic validation\n    if not config_obj.services:\n        click.echo(\"\u274c No services defined\", err=True)\n        sys.exit(1)\n\n    click.echo(\"\u2705 Configuration is valid\")\n\n    # Provider-specific validation\n    if target_provider:\n        checker = CompatibilityChecker()\n        compat = checker.check_compatibility(config_obj, target_provider)\n\n        if compat.compatible:\n            click.echo(f\"\u2705 Compatible with {target_provider}\")\n        else:\n            click.echo(f\"\u274c Not compatible with {target_provider}\")\n\n            for error in compat.errors:\n                click.echo(f\"  - {error}\", err=True)\n\n            sys.exit(1)\n\n        if compat.warnings:\n            click.echo(f\"\\n\u26a0\ufe0f  Warnings:\")\n            for warning in compat.warnings:\n                click.echo(f\"  - {warning}\")\n</code></pre>"},{"location":"import/compatibility/#cli-usage","title":"CLI Usage","text":""},{"location":"import/compatibility/#beispiel-1-single-provider-check","title":"Beispiel 1: Single Provider Check","text":"<pre><code>$ gal validate --config gal-config.yaml --target-provider haproxy\n\n\u2705 Configuration is valid\n\u2705 Compatible with haproxy\n\n\u26a0\ufe0f  Warnings:\n  - jwt_auth: Requires manual configuration on haproxy\n  - active_health_checks: Full support\n</code></pre>"},{"location":"import/compatibility/#beispiel-2-multi-provider-comparison","title":"Beispiel 2: Multi-Provider Comparison","text":"<pre><code>$ gal compare --config gal-config.yaml --providers envoy,kong,nginx,haproxy --output comparison.md\n\n\u2705 Compatibility report written to comparison.md\n</code></pre> <p>comparison.md:</p> <pre><code># GAL Compatibility Report\n\n**Config:** 1.0\n**Providers:** envoy, kong, nginx, haproxy\n\n## Summary\n\n| Provider | Compatible | Warnings | Errors |\n|----------|------------|----------|--------|\n| envoy | \u2705 | 0 | 0 |\n| kong | \u2705 | 1 | 0 |\n| nginx | \u274c | 2 | 1 |\n| haproxy | \u2705 | 1 | 0 |\n\n## Feature Support Matrix\n\n| Feature | envoy | kong | nginx | haproxy |\n|---------|-------|------|-------|---------|\n| active_health_checks | \u2705 | \u2705 | \u274c | \u2705 |\n| jwt_auth | \u2705 | \u2705 | \ud83d\udd27 | \ud83d\udd27 |\n| rate_limiting | \u2705 | \u2705 | \u2705 | \u2705 |\n\n## Provider Details\n\n### Nginx\n\n\u274c **Incompatible** - 1 critical issue(s)\n\n**Errors:**\n- \u274c active_health_checks: Not supported on nginx\n\n**Warnings:**\n- \u26a0\ufe0f jwt_auth: Requires manual configuration on nginx\n\n**Workarounds:**\n- **active_health_checks**: Upgrade to Nginx Plus or use passive health checks\n- **jwt_auth**: Use OpenResty with lua-resty-jwt plugin\n</code></pre>"},{"location":"import/compatibility/#test-cases","title":"Test Cases","text":"<p>20+ Tests: - Feature extraction from config - Compatibility checking (single provider) - Multi-provider comparison - Report generation (Markdown) - Edge cases (unknown features, all providers compatible) - CLI integration tests</p>"},{"location":"import/compatibility/#akzeptanzkriterien","title":"Akzeptanzkriterien","text":"<ul> <li>\u2705 Feature-Support-Matrix f\u00fcr alle 6 Provider</li> <li>\u2705 Single-Provider Compatibility Check</li> <li>\u2705 Multi-Provider Comparison</li> <li>\u2705 Markdown Report Generation</li> <li>\u2705 Workaround Suggestions</li> <li>\u2705 CLI Integration (validate, compare)</li> <li>\u2705 20+ Tests, 90%+ Coverage</li> </ul>"},{"location":"import/compatibility/#implementierungs-reihenfolge","title":"Implementierungs-Reihenfolge","text":"<ol> <li>Tag 1-3: CompatibilityChecker + Feature Matrix</li> <li>Tag 4-5: check_compatibility() + compare_providers()</li> <li>Tag 6-7: Report Generation (Markdown)</li> <li>Tag 8-9: CLI Integration</li> <li>Tag 10-12: Tests + Edge Cases + Documentation</li> <li>Tag 13-14: Refinement + User Feedback</li> </ol>"},{"location":"import/compatibility/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<p>Nach Completion: 1. Release als v1.3.0-rc1 2. User Feedback 3. Migration Assistant (Feature 8) beginnen</p>"},{"location":"import/envoy/","title":"Feature 1: Envoy Import (YAML Parser)","text":"<p>Status: \ud83d\udd04 Geplant Aufwand: 1 Woche Release: v1.3.0-alpha1 (Woche 2) Priorit\u00e4t: \ud83d\udd34 Hoch</p>"},{"location":"import/envoy/#ubersicht","title":"\u00dcbersicht","text":"<p>Import von Envoy YAML-Konfigurationen nach GAL. Envoy ist der erste Provider, der implementiert wird, da: - Envoy YAML ist gut strukturiert und dokumentiert - Wir kennen die Envoy-Struktur bereits (haben EnvoyProvider.generate()) - Dient als Referenz-Implementierung f\u00fcr andere YAML-Parser</p>"},{"location":"import/envoy/#implementierung","title":"Implementierung","text":""},{"location":"import/envoy/#providerparse-methode","title":"Provider.parse() Methode","text":"<pre><code>class EnvoyProvider(Provider):\n    \"\"\"Envoy Gateway Provider with Import Support.\"\"\"\n\n    def parse(self, provider_config: str) -&gt; Config:\n        \"\"\"Parse Envoy YAML config to GAL format.\n\n        Args:\n            provider_config: Envoy YAML configuration string\n\n        Returns:\n            Config: GAL configuration object\n\n        Raises:\n            ValueError: If config is invalid or cannot be parsed\n        \"\"\"\n        try:\n            envoy_config = yaml.safe_load(provider_config)\n        except yaml.YAMLError as e:\n            raise ValueError(f\"Invalid YAML: {e}\")\n\n        self._import_warnings = []\n\n        return Config(\n            version=\"1.0\",\n            provider=\"envoy\",\n            global_config=self._parse_global(envoy_config),\n            services=self._parse_services(envoy_config)\n        )\n\n    def _parse_global(self, envoy_config: dict) -&gt; GlobalConfig:\n        \"\"\"Extract global config from Envoy admin section.\"\"\"\n        admin = envoy_config.get(\"admin\", {})\n\n        return GlobalConfig(\n            host=\"0.0.0.0\",  # Envoy binds in listeners\n            port=10000,      # Default admin port\n            timeout=\"30s\"\n        )\n\n    def _parse_services(self, envoy_config: dict) -&gt; List[Service]:\n        \"\"\"Parse Envoy clusters and listeners to GAL services.\"\"\"\n        services = []\n\n        # Parse clusters\n        clusters = envoy_config.get(\"static_resources\", {}).get(\"clusters\", [])\n\n        for cluster in clusters:\n            service = self._parse_cluster(cluster)\n            if service:\n                services.append(service)\n\n        # Parse listeners and routes\n        listeners = envoy_config.get(\"static_resources\", {}).get(\"listeners\", [])\n\n        for listener in listeners:\n            self._enrich_services_from_listener(services, listener)\n\n        return services\n\n    def _parse_cluster(self, cluster: dict) -&gt; Optional[Service]:\n        \"\"\"Convert Envoy cluster to GAL service.\"\"\"\n        name = cluster.get(\"name\")\n        if not name:\n            return None\n\n        # Parse upstream targets\n        targets = []\n        load_assignment = cluster.get(\"load_assignment\", {})\n        endpoints = load_assignment.get(\"endpoints\", [])\n\n        for endpoint_group in endpoints:\n            lb_endpoints = endpoint_group.get(\"lb_endpoints\", [])\n\n            for lb_endpoint in lb_endpoints:\n                endpoint = lb_endpoint.get(\"endpoint\", {})\n                address = endpoint.get(\"address\", {}).get(\"socket_address\", {})\n\n                host = address.get(\"address\")\n                port = address.get(\"port_value\")\n\n                if host and port:\n                    targets.append(UpstreamTarget(\n                        host=host,\n                        port=port\n                    ))\n\n        # Parse load balancing policy\n        lb_policy = cluster.get(\"lb_policy\", \"ROUND_ROBIN\")\n        algorithm = self._map_lb_algorithm(lb_policy)\n\n        # Parse health checks\n        health_check = None\n        health_checks = cluster.get(\"health_checks\", [])\n\n        if health_checks:\n            health_check = self._parse_health_check(health_checks[0])\n\n        # Build upstream config\n        upstream = None\n        if targets:\n            upstream = UpstreamConfig(\n                targets=targets,\n                load_balancer=LoadBalancerConfig(algorithm=algorithm),\n                health_check=health_check\n            )\n\n        return Service(\n            name=name,\n            upstream=upstream,\n            routes=[]  # Routes added later from listeners\n        )\n\n    def _map_lb_algorithm(self, envoy_policy: str) -&gt; str:\n        \"\"\"Map Envoy LB policy to GAL algorithm.\"\"\"\n        mapping = {\n            \"ROUND_ROBIN\": \"round_robin\",\n            \"LEAST_REQUEST\": \"least_conn\",\n            \"RING_HASH\": \"ip_hash\",\n            \"RANDOM\": \"round_robin\",\n            \"MAGLEV\": \"ip_hash\"\n        }\n        return mapping.get(envoy_policy, \"round_robin\")\n\n    def _parse_health_check(self, health_check: dict) -&gt; HealthCheckConfig:\n        \"\"\"Parse Envoy health check to GAL format.\"\"\"\n        http_health_check = health_check.get(\"http_health_check\", {})\n\n        if not http_health_check:\n            # No HTTP health check\n            return None\n\n        interval = health_check.get(\"interval\", \"10s\")\n        timeout = health_check.get(\"timeout\", \"5s\")\n        unhealthy_threshold = health_check.get(\"unhealthy_threshold\", 3)\n        healthy_threshold = health_check.get(\"healthy_threshold\", 2)\n\n        path = http_health_check.get(\"path\", \"/health\")\n\n        return HealthCheckConfig(\n            active=ActiveHealthCheck(\n                enabled=True,\n                http_path=path,\n                interval=interval,\n                timeout=timeout,\n                unhealthy_threshold=unhealthy_threshold,\n                healthy_threshold=healthy_threshold,\n                healthy_status_codes=[200]\n            )\n        )\n\n    def _enrich_services_from_listener(self, services: List[Service], listener: dict):\n        \"\"\"Add routes to services from Envoy listener config.\"\"\"\n        filter_chains = listener.get(\"filter_chains\", [])\n\n        for filter_chain in filter_chains:\n            filters = filter_chain.get(\"filters\", [])\n\n            for filter_config in filters:\n                if filter_config.get(\"name\") != \"envoy.filters.network.http_connection_manager\":\n                    continue\n\n                typed_config = filter_config.get(\"typed_config\", {})\n                route_config = typed_config.get(\"route_config\", {})\n                virtual_hosts = route_config.get(\"virtual_hosts\", [])\n\n                for vhost in virtual_hosts:\n                    routes = vhost.get(\"routes\", [])\n\n                    for route_entry in routes:\n                        self._add_route_to_service(services, route_entry)\n\n    def _add_route_to_service(self, services: List[Service], route_entry: dict):\n        \"\"\"Add route from Envoy route config to matching service.\"\"\"\n        match = route_entry.get(\"match\", {})\n        route = route_entry.get(\"route\", {})\n\n        # Get cluster name (service name)\n        cluster_name = route.get(\"cluster\")\n        if not cluster_name:\n            return\n\n        # Find service\n        service = next((s for s in services if s.name == cluster_name), None)\n        if not service:\n            return\n\n        # Parse path\n        path_prefix = match.get(\"prefix\", \"/\")\n\n        # Parse rate limiting\n        rate_limit_config = None\n        rate_limits = route_entry.get(\"rate_limits\", [])\n\n        if rate_limits:\n            rate_limit_config = self._parse_rate_limit(rate_limits[0])\n\n        # Parse headers\n        request_headers_to_add = route_entry.get(\"request_headers_to_add\", [])\n        response_headers_to_add = route_entry.get(\"response_headers_to_add\", [])\n\n        headers_config = None\n        if request_headers_to_add or response_headers_to_add:\n            headers_config = self._parse_headers(\n                request_headers_to_add,\n                response_headers_to_add\n            )\n\n        # Parse CORS\n        cors_config = None\n        cors = route_entry.get(\"cors\", {})\n        if cors:\n            cors_config = self._parse_cors(cors)\n\n        # Create route\n        gal_route = Route(\n            path_prefix=path_prefix,\n            rate_limit=rate_limit_config,\n            headers=headers_config,\n            cors=cors_config\n        )\n\n        service.routes.append(gal_route)\n\n    def _parse_rate_limit(self, rate_limit: dict) -&gt; RateLimitConfig:\n        \"\"\"Parse Envoy rate limit to GAL format.\"\"\"\n        # Envoy rate limiting is complex, simplified here\n        self._import_warnings.append(\n            \"Rate limiting config simplified - manual review recommended\"\n        )\n\n        return RateLimitConfig(\n            enabled=True,\n            requests_per_second=100,  # Default\n            burst=200\n        )\n\n    def _parse_headers(self, request_headers: list, response_headers: list) -&gt; HeadersConfig:\n        \"\"\"Parse Envoy headers to GAL format.\"\"\"\n        request_add = {}\n        response_add = {}\n\n        for header in request_headers:\n            key = header.get(\"header\", {}).get(\"key\")\n            value = header.get(\"header\", {}).get(\"value\")\n            if key and value:\n                request_add[key] = value\n\n        for header in response_headers:\n            key = header.get(\"header\", {}).get(\"key\")\n            value = header.get(\"header\", {}).get(\"value\")\n            if key and value:\n                response_add[key] = value\n\n        return HeadersConfig(\n            request_add=request_add if request_add else None,\n            response_add=response_add if response_add else None\n        )\n\n    def _parse_cors(self, cors: dict) -&gt; CorsConfig:\n        \"\"\"Parse Envoy CORS to GAL format.\"\"\"\n        return CorsConfig(\n            enabled=True,\n            allowed_origins=cors.get(\"allow_origin_string_match\", []),\n            allowed_methods=cors.get(\"allow_methods\", \"GET,POST,PUT,DELETE\").split(\",\"),\n            allowed_headers=cors.get(\"allow_headers\", \"\").split(\",\") if cors.get(\"allow_headers\") else None,\n            allow_credentials=cors.get(\"allow_credentials\", False),\n            max_age=cors.get(\"max_age\", \"86400\")\n        )\n\n    def get_import_warnings(self) -&gt; List[str]:\n        \"\"\"Return warnings from last import.\"\"\"\n        return getattr(self, '_import_warnings', [])\n</code></pre>"},{"location":"import/envoy/#feature-mapping-matrix","title":"Feature Mapping Matrix","text":"GAL Feature Envoy Config Mapping Service <code>clusters[].name</code> Direct mapping Upstream Targets <code>load_assignment.endpoints</code> socket_address \u2192 host:port Load Balancing <code>lb_policy</code> ROUND_ROBIN \u2192 round_robin, LEAST_REQUEST \u2192 least_conn Active Health Checks <code>health_checks[].http_health_check</code> Direct mapping with interval/timeout Passive Health Checks <code>outlier_detection</code> \u26a0\ufe0f Supported but complex Routes <code>route_config.virtual_hosts[].routes</code> match.prefix \u2192 path_prefix Rate Limiting <code>rate_limits</code> \u26a0\ufe0f Simplified - complex in Envoy Headers <code>request_headers_to_add</code>, <code>response_headers_to_add</code> Direct mapping CORS <code>cors</code> policy Direct mapping Circuit Breaker <code>circuit_breakers</code> \u26a0\ufe0f Not in initial import Authentication <code>jwt_authn</code>, <code>ext_authz</code> \u26a0\ufe0f Not in initial import"},{"location":"import/envoy/#beispiel-konvertierung","title":"Beispiel-Konvertierung","text":""},{"location":"import/envoy/#envoy-config-input","title":"Envoy Config (Input)","text":"<pre><code>admin:\n  address:\n    socket_address:\n      address: 0.0.0.0\n      port_value: 9901\n\nstatic_resources:\n  listeners:\n    - name: listener_0\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 80\n      filter_chains:\n        - filters:\n            - name: envoy.filters.network.http_connection_manager\n              typed_config:\n                \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n                stat_prefix: ingress_http\n                route_config:\n                  name: local_route\n                  virtual_hosts:\n                    - name: backend\n                      domains: [\"*\"]\n                      routes:\n                        - match:\n                            prefix: \"/api\"\n                          route:\n                            cluster: api_service\n                          request_headers_to_add:\n                            - header:\n                                key: X-Gateway\n                                value: Envoy\n                http_filters:\n                  - name: envoy.filters.http.router\n\n  clusters:\n    - name: api_service\n      type: STRICT_DNS\n      lb_policy: ROUND_ROBIN\n      load_assignment:\n        cluster_name: api_service\n        endpoints:\n          - lb_endpoints:\n              - endpoint:\n                  address:\n                    socket_address:\n                      address: api-1.internal\n                      port_value: 8080\n              - endpoint:\n                  address:\n                    socket_address:\n                      address: api-2.internal\n                      port_value: 8080\n      health_checks:\n        - timeout: 5s\n          interval: 10s\n          unhealthy_threshold: 3\n          healthy_threshold: 2\n          http_health_check:\n            path: /health\n</code></pre>"},{"location":"import/envoy/#gal-config-output","title":"GAL Config (Output)","text":"<pre><code>version: \"1.0\"\nprovider: envoy\n\nglobal_config:\n  host: 0.0.0.0\n  port: 10000\n  timeout: 30s\n\nservices:\n  - name: api_service\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n        - host: api-2.internal\n          port: 8080\n\n      load_balancer:\n        algorithm: round_robin\n\n      health_check:\n        active:\n          enabled: true\n          http_path: /health\n          interval: 10s\n          timeout: 5s\n          unhealthy_threshold: 3\n          healthy_threshold: 2\n          healthy_status_codes: [200]\n\n    routes:\n      - path_prefix: /api\n        headers:\n          request_add:\n            X-Gateway: Envoy\n</code></pre>"},{"location":"import/envoy/#cli-usage","title":"CLI Usage","text":"<pre><code># Import Envoy config\ngal import --provider envoy --input envoy.yaml --output gal-config.yaml\n\n# Validate import\ngal validate --config gal-config.yaml\n\n# Generate for different provider\ngal generate --config gal-config.yaml --provider kong --output kong.yaml\n\n# Complete migration workflow\ngal import --provider envoy --input envoy.yaml --output gal.yaml\ngal generate --config gal.yaml --provider haproxy --output haproxy.cfg\n</code></pre>"},{"location":"import/envoy/#test-cases","title":"Test Cases","text":""},{"location":"import/envoy/#test-1-basic-import","title":"Test 1: Basic Import","text":"<pre><code>def test_envoy_import_basic():\n    \"\"\"Test basic Envoy config import.\"\"\"\n    provider = EnvoyProvider()\n\n    envoy_config = \"\"\"\n    static_resources:\n      clusters:\n        - name: test_service\n          type: STATIC\n          load_assignment:\n            cluster_name: test_service\n            endpoints:\n              - lb_endpoints:\n                  - endpoint:\n                      address:\n                        socket_address:\n                          address: 127.0.0.1\n                          port_value: 8080\n    \"\"\"\n\n    config = provider.parse(envoy_config)\n\n    assert len(config.services) == 1\n    assert config.services[0].name == \"test_service\"\n    assert len(config.services[0].upstream.targets) == 1\n    assert config.services[0].upstream.targets[0].host == \"127.0.0.1\"\n    assert config.services[0].upstream.targets[0].port == 8080\n</code></pre>"},{"location":"import/envoy/#test-2-load-balancing","title":"Test 2: Load Balancing","text":"<pre><code>def test_envoy_import_load_balancing():\n    \"\"\"Test LB algorithm mapping.\"\"\"\n    provider = EnvoyProvider()\n\n    envoy_config = \"\"\"\n    static_resources:\n      clusters:\n        - name: lb_service\n          lb_policy: LEAST_REQUEST\n          load_assignment:\n            cluster_name: lb_service\n            endpoints:\n              - lb_endpoints:\n                  - endpoint:\n                      address:\n                        socket_address:\n                          address: server1\n                          port_value: 8080\n    \"\"\"\n\n    config = provider.parse(envoy_config)\n\n    assert config.services[0].upstream.load_balancer.algorithm == \"least_conn\"\n</code></pre>"},{"location":"import/envoy/#test-3-health-checks","title":"Test 3: Health Checks","text":"<pre><code>def test_envoy_import_health_checks():\n    \"\"\"Test health check import.\"\"\"\n    provider = EnvoyProvider()\n\n    envoy_config = \"\"\"\n    static_resources:\n      clusters:\n        - name: hc_service\n          health_checks:\n            - timeout: 3s\n              interval: 5s\n              unhealthy_threshold: 2\n              healthy_threshold: 3\n              http_health_check:\n                path: /status\n          load_assignment:\n            cluster_name: hc_service\n            endpoints:\n              - lb_endpoints:\n                  - endpoint:\n                      address:\n                        socket_address:\n                          address: server1\n                          port_value: 8080\n    \"\"\"\n\n    config = provider.parse(envoy_config)\n\n    hc = config.services[0].upstream.health_check\n    assert hc.active.enabled is True\n    assert hc.active.http_path == \"/status\"\n    assert hc.active.interval == \"5s\"\n    assert hc.active.timeout == \"3s\"\n    assert hc.active.unhealthy_threshold == 2\n    assert hc.active.healthy_threshold == 3\n</code></pre>"},{"location":"import/envoy/#test-4-routes-and-headers","title":"Test 4: Routes and Headers","text":"<pre><code>def test_envoy_import_routes_headers():\n    \"\"\"Test route and header import.\"\"\"\n    provider = EnvoyProvider()\n\n    envoy_config = \"\"\"\n    static_resources:\n      listeners:\n        - name: listener_0\n          filter_chains:\n            - filters:\n                - name: envoy.filters.network.http_connection_manager\n                  typed_config:\n                    route_config:\n                      virtual_hosts:\n                        - name: backend\n                          domains: [\"*\"]\n                          routes:\n                            - match:\n                                prefix: \"/api/v1\"\n                              route:\n                                cluster: api_service\n                              request_headers_to_add:\n                                - header:\n                                    key: X-Version\n                                    value: \"1.0\"\n      clusters:\n        - name: api_service\n          load_assignment:\n            cluster_name: api_service\n            endpoints:\n              - lb_endpoints:\n                  - endpoint:\n                      address:\n                        socket_address:\n                          address: api\n                          port_value: 8080\n    \"\"\"\n\n    config = provider.parse(envoy_config)\n\n    assert len(config.services[0].routes) == 1\n    route = config.services[0].routes[0]\n    assert route.path_prefix == \"/api/v1\"\n    assert route.headers.request_add[\"X-Version\"] == \"1.0\"\n</code></pre>"},{"location":"import/envoy/#test-5-round-trip-import-export","title":"Test 5: Round-trip (Import \u2192 Export)","text":"<pre><code>def test_envoy_import_export_roundtrip():\n    \"\"\"Test import + export produces equivalent config.\"\"\"\n    provider = EnvoyProvider()\n\n    original_envoy_config = load_fixture(\"envoy-sample.yaml\")\n\n    # Import\n    gal_config = provider.parse(original_envoy_config)\n\n    # Export\n    regenerated_envoy_config = provider.generate(gal_config)\n\n    # Validate equivalence (semantically, not byte-for-byte)\n    original_parsed = yaml.safe_load(original_envoy_config)\n    regenerated_parsed = yaml.safe_load(regenerated_envoy_config)\n\n    assert_configs_equivalent(original_parsed, regenerated_parsed)\n</code></pre>"},{"location":"import/envoy/#edge-cases-und-limitationen","title":"Edge Cases und Limitationen","text":""},{"location":"import/envoy/#nicht-unterstutzte-features","title":"Nicht unterst\u00fctzte Features","text":"<ol> <li>JWT Authentication (<code>jwt_authn</code>)</li> <li>Warnung beim Import</li> <li>In <code>provider_specific</code> Section gespeichert</li> <li> <p>Muss manuell gemappt werden</p> </li> <li> <p>External Authorization (<code>ext_authz</code>)</p> </li> <li>Nicht direkt mappbar</li> <li> <p>Warnung + provider_specific</p> </li> <li> <p>Complex Rate Limiting (mit externem Rate Limit Service)</p> </li> <li>Vereinfachung auf einfache Limits</li> <li> <p>Warnung ausgeben</p> </li> <li> <p>Circuit Breaker (<code>circuit_breakers</code>)</p> </li> <li>Zuk\u00fcnftige Erweiterung</li> <li>Aktuell: Warnung</li> </ol>"},{"location":"import/envoy/#nicht-standard-envoy-configs","title":"Nicht-Standard Envoy Configs","text":"<ul> <li>Dynamic Resources (xDS): Nicht unterst\u00fctzt, nur static_resources</li> <li>Filters: Nur http_connection_manager und router unterst\u00fctzt</li> <li>Custom Filters: In provider_specific gespeichert</li> </ul>"},{"location":"import/envoy/#warnings","title":"Warnings","text":"<p>Import gibt Warnungen aus f\u00fcr: - Vereinfachte Rate Limiting Konfiguration - Nicht gemappte Filter - Fehlende Cluster-Definitionen - Nicht unterst\u00fctzte Features</p> <pre><code>warnings = provider.get_import_warnings()\nfor warning in warnings:\n    print(f\"\u26a0\ufe0f  {warning}\")\n</code></pre>"},{"location":"import/envoy/#akzeptanzkriterien","title":"Akzeptanzkriterien","text":"<ul> <li>\u2705 Import von Envoy YAML-Konfigurationen</li> <li>\u2705 Mapping von Clusters \u2192 Services</li> <li>\u2705 Mapping von Load Balancing Policies</li> <li>\u2705 Import von Health Checks (active)</li> <li>\u2705 Import von Routes aus Listeners</li> <li>\u2705 Import von Headers (request/response)</li> <li>\u2705 Import von CORS Policies</li> <li>\u2705 CLI Integration (<code>gal import --provider envoy</code>)</li> <li>\u2705 20+ Tests mit 90%+ Coverage</li> <li>\u2705 Warnings f\u00fcr nicht unterst\u00fctzte Features</li> <li>\u2705 Round-trip Test (Import \u2192 Export \u2192 Import)</li> </ul>"},{"location":"import/envoy/#implementierungs-reihenfolge","title":"Implementierungs-Reihenfolge","text":"<ol> <li>Tag 1-2: Provider.parse() Methode + Cluster Parsing</li> <li>Tag 3: Load Balancing + Health Checks</li> <li>Tag 4: Listener + Route Parsing</li> <li>Tag 5: Headers + CORS Import</li> <li>Tag 6-7: Tests + Documentation</li> </ol>"},{"location":"import/envoy/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<p>Nach Completion: 1. Release als v1.3.0-alpha1 2. User Feedback sammeln 3. Kong Import (Feature 2) beginnen</p>"},{"location":"import/haproxy/","title":"Feature 6: HAProxy Import (Custom Parser)","text":"<p>Status: \ud83d\udd04 Geplant Aufwand: 2 Wochen Release: v1.3.0-beta2 (Woche 8) Priorit\u00e4t: \ud83d\udd34 Hoch</p>"},{"location":"import/haproxy/#ubersicht","title":"\u00dcbersicht","text":"<p>Import von HAProxy haproxy.cfg nach GAL. HAProxy verwendet ein eigenes Konfigurations-Format (\u00e4hnlich nginx.conf), daher ist ein Custom Parser erforderlich. HAProxy ist der de-facto Standard f\u00fcr Load Balancing und daher kritisch.</p>"},{"location":"import/haproxy/#herausforderungen","title":"Herausforderungen","text":"<ul> <li>Eigenes Format: haproxy.cfg hat section-based Syntax (global, defaults, frontend, backend)</li> <li>ACL-Syntax: HAProxy ACLs sind komplex und vielf\u00e4ltig</li> <li>Stick-Tables: Rate limiting via stick-tables (komplex)</li> <li>http-request/http-response: Vielf\u00e4ltige Direktiven</li> <li>Multi-line Syntax: Optionen k\u00f6nnen \u00fcber mehrere Zeilen gehen</li> </ul>"},{"location":"import/haproxy/#implementierung","title":"Implementierung","text":""},{"location":"import/haproxy/#custom-parser-haproxyconfigparser","title":"Custom Parser: HAProxyConfigParser","text":"<pre><code># gal/parsers/haproxy_parser.py\n\nimport re\nfrom typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass SectionType(Enum):\n    GLOBAL = \"global\"\n    DEFAULTS = \"defaults\"\n    FRONTEND = \"frontend\"\n    BACKEND = \"backend\"\n    LISTEN = \"listen\"\n\n@dataclass\nclass HAProxySection:\n    \"\"\"Represents a HAProxy configuration section.\"\"\"\n    type: SectionType\n    name: Optional[str]  # None for global/defaults\n    directives: List[Dict[str, Any]]\n\nclass HAProxyConfigParser:\n    \"\"\"Parser for haproxy.cfg files.\n\n    Parses HAProxy configuration files into structured sections\n    for conversion to GAL.\n    \"\"\"\n\n    def __init__(self):\n        self.lines = []\n        self.pos = 0\n\n    def parse(self, config_text: str) -&gt; List[HAProxySection]:\n        \"\"\"Parse haproxy.cfg into sections.\n\n        Args:\n            config_text: haproxy.cfg content\n\n        Returns:\n            List of HAProxySection objects\n\n        Raises:\n            ValueError: If syntax is invalid\n        \"\"\"\n        # Preprocess\n        lines = self._preprocess(config_text)\n        self.lines = lines\n        self.pos = 0\n\n        sections = []\n        current_section = None\n\n        while self.pos &lt; len(self.lines):\n            line = self.lines[self.pos].strip()\n\n            # Check for section start\n            if line.startswith(\"global\"):\n                if current_section:\n                    sections.append(current_section)\n                current_section = HAProxySection(\n                    type=SectionType.GLOBAL,\n                    name=None,\n                    directives=[]\n                )\n                self.pos += 1\n\n            elif line.startswith(\"defaults\"):\n                if current_section:\n                    sections.append(current_section)\n                current_section = HAProxySection(\n                    type=SectionType.DEFAULTS,\n                    name=None,\n                    directives=[]\n                )\n                self.pos += 1\n\n            elif line.startswith(\"frontend\"):\n                if current_section:\n                    sections.append(current_section)\n                parts = line.split(maxsplit=1)\n                name = parts[1] if len(parts) &gt; 1 else \"unnamed\"\n                current_section = HAProxySection(\n                    type=SectionType.FRONTEND,\n                    name=name,\n                    directives=[]\n                )\n                self.pos += 1\n\n            elif line.startswith(\"backend\"):\n                if current_section:\n                    sections.append(current_section)\n                parts = line.split(maxsplit=1)\n                name = parts[1] if len(parts) &gt; 1 else \"unnamed\"\n                current_section = HAProxySection(\n                    type=SectionType.BACKEND,\n                    name=name,\n                    directives=[]\n                )\n                self.pos += 1\n\n            elif line.startswith(\"listen\"):\n                if current_section:\n                    sections.append(current_section)\n                parts = line.split(maxsplit=1)\n                name = parts[1] if len(parts) &gt; 1 else \"unnamed\"\n                current_section = HAProxySection(\n                    type=SectionType.LISTEN,\n                    name=name,\n                    directives=[]\n                )\n                self.pos += 1\n\n            else:\n                # Directive within current section\n                if current_section:\n                    directive = self._parse_directive(line)\n                    if directive:\n                        current_section.directives.append(directive)\n                self.pos += 1\n\n        if current_section:\n            sections.append(current_section)\n\n        return sections\n\n    def _preprocess(self, config_text: str) -&gt; List[str]:\n        \"\"\"Preprocess config: remove comments.\"\"\"\n        lines = []\n\n        for line in config_text.split('\\n'):\n            # Remove comments\n            if '#' in line:\n                line = line[:line.index('#')]\n\n            line = line.strip()\n\n            if line:\n                lines.append(line)\n\n        return lines\n\n    def _parse_directive(self, line: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Parse a single directive line.\"\"\"\n        parts = line.split(maxsplit=1)\n\n        if not parts:\n            return None\n\n        directive_name = parts[0]\n        directive_value = parts[1] if len(parts) &gt; 1 else \"\"\n\n        return {\n            \"name\": directive_name,\n            \"value\": directive_value\n        }\n</code></pre>"},{"location":"import/haproxy/#providerparse-methode","title":"Provider.parse() Methode","text":"<pre><code>class HAProxyProvider(Provider):\n    \"\"\"HAProxy Provider with Import Support.\"\"\"\n\n    def parse(self, provider_config: str) -&gt; Config:\n        \"\"\"Parse haproxy.cfg to GAL format.\n\n        Args:\n            provider_config: haproxy.cfg content\n\n        Returns:\n            Config: GAL configuration object\n\n        Raises:\n            ValueError: If config is invalid\n        \"\"\"\n        parser = HAProxyConfigParser()\n        sections = parser.parse(provider_config)\n\n        self._import_warnings = []\n\n        return Config(\n            version=\"1.0\",\n            provider=\"haproxy\",\n            global_config=self._parse_global(sections),\n            services=self._parse_services(sections)\n        )\n\n    def _parse_global(self, sections: List[HAProxySection]) -&gt; GlobalConfig:\n        \"\"\"Extract global config from sections.\"\"\"\n        # Defaults section or first frontend bind\n        return GlobalConfig(\n            host=\"0.0.0.0\",\n            port=80,\n            timeout=\"30s\"\n        )\n\n    def _parse_services(self, sections: List[HAProxySection]) -&gt; List[Service]:\n        \"\"\"Parse HAProxy backends to GAL services.\"\"\"\n        services = []\n\n        # Collect backends\n        backends = [s for s in sections if s.type == SectionType.BACKEND]\n\n        # Collect frontends for routing info\n        frontends = [s for s in sections if s.type == SectionType.FRONTEND]\n\n        for backend in backends:\n            service = self._parse_backend(backend, frontends)\n            if service:\n                services.append(service)\n\n        return services\n\n    def _parse_backend(\n        self,\n        backend: HAProxySection,\n        frontends: List[HAProxySection]\n    ) -&gt; Optional[Service]:\n        \"\"\"Parse HAProxy backend to GAL service.\"\"\"\n        name = backend.name\n\n        # Parse servers (targets)\n        servers = []\n        lb_algorithm = \"round_robin\"\n        health_check = None\n        sticky_sessions = False\n        cookie_name = None\n\n        for directive in backend.directives:\n            if directive[\"name\"] == \"server\":\n                server = self._parse_server_directive(directive[\"value\"])\n                if server:\n                    servers.append(server)\n\n            elif directive[\"name\"] == \"balance\":\n                lb_algorithm = self._map_lb_algorithm(directive[\"value\"])\n\n            elif directive[\"name\"] == \"option\":\n                if \"httpchk\" in directive[\"value\"]:\n                    health_check = self._parse_httpchk(directive[\"value\"])\n\n            elif directive[\"name\"] == \"http-check\":\n                # HAProxy 2.0+ health check syntax\n                if not health_check:\n                    health_check = HealthCheckConfig()\n                self._parse_http_check_directive(health_check, directive[\"value\"])\n\n            elif directive[\"name\"] == \"cookie\":\n                # Sticky sessions via cookie\n                cookie_parts = directive[\"value\"].split()\n                if cookie_parts:\n                    cookie_name = cookie_parts[0]\n                    sticky_sessions = True\n\n        # Build upstream\n        targets = []\n        for server in servers:\n            targets.append(UpstreamTarget(\n                host=server[\"host\"],\n                port=server[\"port\"],\n                weight=server.get(\"weight\", 1)\n            ))\n\n        upstream = UpstreamConfig(\n            targets=targets,\n            load_balancer=LoadBalancerConfig(\n                algorithm=lb_algorithm,\n                sticky_sessions=sticky_sessions,\n                cookie_name=cookie_name\n            ),\n            health_check=health_check\n        )\n\n        # Find routes from frontends\n        routes = self._find_routes_for_backend(name, frontends)\n\n        return Service(\n            name=name,\n            upstream=upstream,\n            routes=routes\n        )\n\n    def _parse_server_directive(self, value: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Parse HAProxy server directive.\n\n        Format: server1 host:port [weight N] [check] [inter Xs] [fall N] [rise N]\n        \"\"\"\n        parts = value.split()\n\n        if len(parts) &lt; 2:\n            return None\n\n        server_name = parts[0]\n        address = parts[1]  # host:port\n\n        # Parse host:port\n        if \":\" in address:\n            host, port_str = address.rsplit(\":\", 1)\n            port = int(port_str)\n        else:\n            host = address\n            port = 80\n\n        server = {\n            \"name\": server_name,\n            \"host\": host,\n            \"port\": port\n        }\n\n        # Parse options\n        i = 2\n        while i &lt; len(parts):\n            if parts[i] == \"weight\" and i + 1 &lt; len(parts):\n                server[\"weight\"] = int(parts[i + 1])\n                i += 2\n            elif parts[i] == \"check\":\n                server[\"check\"] = True\n                i += 1\n            elif parts[i] == \"inter\" and i + 1 &lt; len(parts):\n                server[\"inter\"] = parts[i + 1]\n                i += 2\n            elif parts[i] == \"fall\" and i + 1 &lt; len(parts):\n                server[\"fall\"] = int(parts[i + 1])\n                i += 2\n            elif parts[i] == \"rise\" and i + 1 &lt; len(parts):\n                server[\"rise\"] = int(parts[i + 1])\n                i += 2\n            else:\n                i += 1\n\n        return server\n\n    def _map_lb_algorithm(self, value: str) -&gt; str:\n        \"\"\"Map HAProxy balance algorithm to GAL.\"\"\"\n        mapping = {\n            \"roundrobin\": \"round_robin\",\n            \"leastconn\": \"least_conn\",\n            \"source\": \"ip_hash\",\n            \"uri\": \"ip_hash\",  # Hash-based\n            \"hdr\": \"ip_hash\"\n        }\n\n        for haproxy_algo, gal_algo in mapping.items():\n            if value.startswith(haproxy_algo):\n                return gal_algo\n\n        return \"round_robin\"\n\n    def _parse_httpchk(self, value: str) -&gt; HealthCheckConfig:\n        \"\"\"Parse 'option httpchk' directive.\n\n        Format: option httpchk [METHOD] [URI] [VERSION]\n        \"\"\"\n        parts = value.split()\n\n        method = \"GET\"\n        uri = \"/health\"\n\n        if len(parts) &gt; 1:\n            method = parts[1]\n        if len(parts) &gt; 2:\n            uri = parts[2]\n\n        return HealthCheckConfig(\n            active=ActiveHealthCheck(\n                enabled=True,\n                http_path=uri,\n                interval=\"10s\",\n                timeout=\"5s\",\n                healthy_threshold=2,\n                unhealthy_threshold=3,\n                healthy_status_codes=[200]\n            )\n        )\n\n    def _parse_http_check_directive(self, health_check: HealthCheckConfig, value: str):\n        \"\"\"Parse 'http-check' directive (HAProxy 2.0+).\"\"\"\n        if value.startswith(\"expect status\"):\n            # Extract status codes\n            # Format: expect status 200-399\n            status_range = value.split(\"status\")[1].strip()\n\n            # Simplified: just use 200\n            if health_check.active:\n                health_check.active.healthy_status_codes = [200]\n\n    def _find_routes_for_backend(\n        self,\n        backend_name: str,\n        frontends: List[HAProxySection]\n    ) -&gt; List[Route]:\n        \"\"\"Find routes that route to this backend.\"\"\"\n        routes = []\n\n        for frontend in frontends:\n            acls = {}\n            use_backend_rules = []\n            rate_limits = {}\n            headers = {}\n            cors_headers = {}\n\n            for directive in frontend.directives:\n                if directive[\"name\"] == \"acl\":\n                    # Parse ACL\n                    acl = self._parse_acl_directive(directive[\"value\"])\n                    if acl:\n                        acls[acl[\"name\"]] = acl\n\n                elif directive[\"name\"] == \"use_backend\":\n                    # Check if this routes to our backend\n                    parts = directive[\"value\"].split()\n                    target_backend = parts[0] if parts else None\n\n                    if target_backend == backend_name:\n                        # Extract ACL conditions\n                        acl_conditions = parts[1:] if len(parts) &gt; 1 else []\n                        use_backend_rules.append({\n                            \"backend\": target_backend,\n                            \"acls\": acl_conditions\n                        })\n\n                elif directive[\"name\"] == \"http-request\":\n                    # Rate limiting, headers, etc.\n                    if \"deny\" in directive[\"value\"] and \"sc_http_req_rate\" in directive[\"value\"]:\n                        # Rate limiting\n                        rate_limit = self._parse_rate_limit_directive(directive[\"value\"])\n                        if rate_limit:\n                            rate_limits[\"default\"] = rate_limit\n\n                    elif \"set-header\" in directive[\"value\"]:\n                        # Request headers\n                        header = self._parse_set_header_directive(directive[\"value\"])\n                        if header:\n                            headers[header[\"name\"]] = header[\"value\"]\n\n                elif directive[\"name\"] == \"http-response\":\n                    # Response headers (could be CORS)\n                    if \"set-header\" in directive[\"value\"]:\n                        header = self._parse_set_header_directive(directive[\"value\"])\n                        if header and header[\"name\"].startswith(\"Access-Control-\"):\n                            cors_headers[header[\"name\"]] = header[\"value\"]\n\n            # Build route for each use_backend rule\n            for rule in use_backend_rules:\n                # Find matching ACL to get path\n                path_prefix = \"/\"\n                for acl_name in rule[\"acls\"]:\n                    if acl_name.startswith(\"is_\"):\n                        acl = acls.get(acl_name)\n                        if acl and acl.get(\"path\"):\n                            path_prefix = acl[\"path\"]\n                            break\n\n                # Build route config\n                route_config = {\n                    \"path_prefix\": path_prefix\n                }\n\n                if rate_limits:\n                    route_config[\"rate_limit\"] = list(rate_limits.values())[0]\n\n                if headers:\n                    route_config[\"headers\"] = HeadersConfig(\n                        request_add=headers\n                    )\n\n                if cors_headers:\n                    route_config[\"cors\"] = self._build_cors_from_headers(cors_headers)\n\n                routes.append(Route(**route_config))\n\n        return routes\n\n    def _parse_acl_directive(self, value: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Parse ACL directive.\n\n        Format: acl_name path_beg /api\n        \"\"\"\n        parts = value.split(maxsplit=2)\n\n        if len(parts) &lt; 3:\n            return None\n\n        acl_name = parts[0]\n        condition = parts[1]\n        path_value = parts[2]\n\n        acl = {\n            \"name\": acl_name,\n            \"condition\": condition\n        }\n\n        if condition == \"path_beg\":\n            acl[\"path\"] = path_value\n\n        return acl\n\n    def _parse_rate_limit_directive(self, value: str) -&gt; RateLimitConfig:\n        \"\"\"Parse rate limit from http-request deny directive.\n\n        Format: deny deny_status 429 if ... { sc_http_req_rate(0) gt 100 }\n        \"\"\"\n        # Extract rate (simplified)\n        import re\n        match = re.search(r\"gt (\\d+)\", value)\n\n        rps = 100  # Default\n        if match:\n            rps = int(match.group(1))\n\n        return RateLimitConfig(\n            enabled=True,\n            requests_per_second=rps,\n            burst=rps * 2,\n            key_type=\"ip_address\"\n        )\n\n    def _parse_set_header_directive(self, value: str) -&gt; Optional[Dict[str, str]]:\n        \"\"\"Parse http-request/http-response set-header directive.\n\n        Format: set-header Header-Name \"value\"\n        \"\"\"\n        # Extract header name and value\n        import re\n        match = re.search(r'set-header (\\S+) \"(.*?)\"', value)\n\n        if not match:\n            match = re.search(r'set-header (\\S+) (\\S+)', value)\n\n        if match:\n            return {\n                \"name\": match.group(1),\n                \"value\": match.group(2)\n            }\n\n        return None\n\n    def _build_cors_from_headers(self, cors_headers: Dict[str, str]) -&gt; CorsConfig:\n        \"\"\"Build CORS config from Access-Control-* headers.\"\"\"\n        origins = cors_headers.get(\"Access-Control-Allow-Origin\", \"*\").split(\",\")\n        methods_str = cors_headers.get(\"Access-Control-Allow-Methods\", \"GET,POST,PUT,DELETE\")\n        methods = methods_str.split(\",\")\n        headers_str = cors_headers.get(\"Access-Control-Allow-Headers\")\n        headers_list = headers_str.split(\",\") if headers_str else None\n        credentials = cors_headers.get(\"Access-Control-Allow-Credentials\") == \"true\"\n        max_age = cors_headers.get(\"Access-Control-Max-Age\", \"86400\")\n\n        return CorsConfig(\n            enabled=True,\n            allowed_origins=origins,\n            allowed_methods=methods,\n            allowed_headers=headers_list,\n            allow_credentials=credentials,\n            max_age=max_age\n        )\n\n    def get_import_warnings(self) -&gt; List[str]:\n        \"\"\"Return warnings from last import.\"\"\"\n        return getattr(self, '_import_warnings', [])\n</code></pre>"},{"location":"import/haproxy/#feature-mapping-matrix","title":"Feature Mapping Matrix","text":"GAL Feature HAProxy Config Mapping Service <code>backend &lt;name&gt;</code> Direct mapping Upstream Targets <code>server name host:port</code> Direct mapping Load Balancing <code>balance roundrobin/leastconn/source</code> Direct mapping Active Health Checks <code>option httpchk</code>, <code>http-check</code> \u2705 Full support Passive Health Checks <code>server ... fall N rise N</code> \u2705 Full support Sticky Sessions <code>cookie NAME insert</code> \u2705 Direct mapping Routes <code>use_backend</code> + ACLs Extracted from ACL path_beg Rate Limiting <code>stick-table</code> + <code>http-request deny</code> \u26a0\ufe0f Complex stick-table syntax Headers <code>http-request set-header</code>, <code>http-response set-header</code> Direct mapping CORS <code>http-response set-header Access-Control-*</code> Extracted from headers Basic Auth <code>http-request auth</code> \u26a0\ufe0f Limited support"},{"location":"import/haproxy/#beispiel-konvertierung","title":"Beispiel-Konvertierung","text":""},{"location":"import/haproxy/#haproxycfg-input","title":"haproxy.cfg (Input)","text":"<pre><code>global\n    log 127.0.0.1 local0\n    maxconn 4000\n\ndefaults\n    mode http\n    timeout connect 5s\n    timeout client 30s\n    timeout server 30s\n\nfrontend http_frontend\n    bind 0.0.0.0:80\n\n    acl is_api path_beg /api\n    acl is_api_method method GET POST\n\n    http-request track-sc0 src if is_api\n    http-request deny deny_status 429 if is_api { sc_http_req_rate(0) gt 100 }\n\n    http-request set-header X-Gateway \"HAProxy\" if is_api\n    http-response set-header Access-Control-Allow-Origin \"https://app.example.com\" if is_api\n\n    use_backend backend_api_service if is_api is_api_method\n\n    stick-table type ip size 100k expire 30s store http_req_rate(10s)\n\nbackend backend_api_service\n    balance leastconn\n\n    cookie SERVERID insert indirect nocache\n\n    option httpchk GET /health HTTP/1.1\n    http-check expect status 200\n\n    server server1 api-1.internal:8080 check inter 10s fall 3 rise 2 weight 2 cookie server1\n    server server2 api-2.internal:8080 check inter 10s fall 3 rise 2 weight 1 cookie server2\n</code></pre>"},{"location":"import/haproxy/#gal-config-output","title":"GAL Config (Output)","text":"<pre><code>version: \"1.0\"\nprovider: haproxy\n\nglobal_config:\n  host: 0.0.0.0\n  port: 80\n  timeout: 30s\n\nservices:\n  - name: backend_api_service\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n          weight: 2\n        - host: api-2.internal\n          port: 8080\n          weight: 1\n\n      load_balancer:\n        algorithm: least_conn\n        sticky_sessions: true\n        cookie_name: SERVERID\n\n      health_check:\n        active:\n          enabled: true\n          http_path: /health\n          interval: 10s\n          timeout: 5s\n          healthy_threshold: 2\n          unhealthy_threshold: 3\n          healthy_status_codes: [200]\n\n    routes:\n      - path_prefix: /api\n        methods:\n          - GET\n          - POST\n\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n          burst: 200\n          key_type: ip_address\n\n        headers:\n          request_add:\n            X-Gateway: HAProxy\n\n        cors:\n          enabled: true\n          allowed_origins:\n            - https://app.example.com\n</code></pre>"},{"location":"import/haproxy/#cli-usage","title":"CLI Usage","text":"<pre><code># Import haproxy.cfg\ngal import --provider haproxy --input /etc/haproxy/haproxy.cfg --output gal-config.yaml\n\n# Generate for different provider\ngal generate --config gal-config.yaml --provider envoy --output envoy.yaml\n</code></pre>"},{"location":"import/haproxy/#test-cases","title":"Test Cases","text":"<p>30+ Tests: - Parser Tests (sections, directives) - Backend parsing - Server directive parsing - ACL parsing - use_backend routing - Balance algorithms - Health checks (httpchk, http-check) - Sticky sessions (cookie) - Rate limiting (stick-table) - Headers (http-request/http-response) - CORS extraction - Round-trip test</p>"},{"location":"import/haproxy/#edge-cases","title":"Edge Cases","text":"<ul> <li>Stick-tables: Komplex, vereinfachte Mapping</li> <li>ACLs: Vielf\u00e4ltig (path_beg, hdr, method, etc.)</li> <li>Lua Scripts: Nicht mappbar</li> <li>TCP Mode: Nur HTTP unterst\u00fctzt</li> </ul>"},{"location":"import/haproxy/#akzeptanzkriterien","title":"Akzeptanzkriterien","text":"<ul> <li>\u2705 Custom Parser f\u00fcr haproxy.cfg</li> <li>\u2705 Import von backends + frontends</li> <li>\u2705 ACL \u2192 Route Mapping</li> <li>\u2705 Sticky Sessions</li> <li>\u2705 Advanced Health Checks</li> <li>\u2705 Rate Limiting (stick-table based)</li> <li>\u2705 Headers + CORS</li> <li>\u2705 CLI Integration</li> <li>\u2705 30+ Tests, 85%+ Coverage</li> <li>\u2705 Warnings f\u00fcr komplexe Features</li> <li>\u2705 Round-trip Test</li> </ul>"},{"location":"import/haproxy/#implementierungs-reihenfolge","title":"Implementierungs-Reihenfolge","text":"<ol> <li>Tag 1-3: HAProxyConfigParser (Section Parser)</li> <li>Tag 4-5: Backend + Server Parsing</li> <li>Tag 6-7: Frontend + ACL Parsing</li> <li>Tag 8-9: Rate Limiting + Headers</li> <li>Tag 10-12: Sticky Sessions + Health Checks</li> <li>Tag 13-14: Tests + Edge Cases + Documentation</li> </ol>"},{"location":"import/haproxy/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<p>Nach Completion: 1. Release als v1.3.0-beta2 2. User Feedback 3. Compatibility Checker (Feature 7) beginnen</p>"},{"location":"import/kong/","title":"Feature 2: Kong Import (YAML Parser)","text":"<p>Status: \ud83d\udd04 Geplant Aufwand: 1 Woche Release: v1.3.0-alpha1 (Woche 2) Priorit\u00e4t: \ud83d\udd34 Hoch</p>"},{"location":"import/kong/#ubersicht","title":"\u00dcbersicht","text":"<p>Import von Kong Declarative Config (YAML/JSON) nach GAL. Kong wird parallel mit Envoy in alpha1 implementiert, da: - Kong's Declarative Config ist klar strukturiert - Wir kennen die Kong-Struktur bereits (haben KongProvider.generate()) - Kong ist weit verbreitet und wichtig f\u00fcr Adoption</p>"},{"location":"import/kong/#implementierung","title":"Implementierung","text":""},{"location":"import/kong/#providerparse-methode","title":"Provider.parse() Methode","text":"<pre><code>class KongProvider(Provider):\n    \"\"\"Kong API Gateway Provider with Import Support.\"\"\"\n\n    def parse(self, provider_config: str) -&gt; Config:\n        \"\"\"Parse Kong declarative config to GAL format.\n\n        Args:\n            provider_config: Kong YAML/JSON configuration string\n\n        Returns:\n            Config: GAL configuration object\n\n        Raises:\n            ValueError: If config is invalid or cannot be parsed\n        \"\"\"\n        try:\n            # Try YAML first\n            kong_config = yaml.safe_load(provider_config)\n        except yaml.YAMLError:\n            # Try JSON\n            try:\n                kong_config = json.loads(provider_config)\n            except json.JSONDecodeError as e:\n                raise ValueError(f\"Invalid YAML/JSON: {e}\")\n\n        self._import_warnings = []\n\n        return Config(\n            version=\"1.0\",\n            provider=\"kong\",\n            global_config=self._parse_global(kong_config),\n            services=self._parse_services(kong_config)\n        )\n\n    def _parse_global(self, kong_config: dict) -&gt; GlobalConfig:\n        \"\"\"Extract global config from Kong.\"\"\"\n        # Kong doesn't have explicit global config in declarative format\n        # Defaults are used\n        return GlobalConfig(\n            host=\"0.0.0.0\",\n            port=8000,  # Kong proxy port\n            timeout=\"60s\"\n        )\n\n    def _parse_services(self, kong_config: dict) -&gt; List[Service]:\n        \"\"\"Parse Kong services to GAL services.\"\"\"\n        services = []\n\n        kong_services = kong_config.get(\"services\", [])\n        kong_routes = kong_config.get(\"routes\", [])\n        kong_plugins = kong_config.get(\"plugins\", [])\n        kong_upstreams = kong_config.get(\"upstreams\", [])\n        kong_targets = kong_config.get(\"targets\", [])\n\n        for kong_service in kong_services:\n            service = self._parse_service(\n                kong_service,\n                kong_routes,\n                kong_plugins,\n                kong_upstreams,\n                kong_targets\n            )\n            if service:\n                services.append(service)\n\n        return services\n\n    def _parse_service(\n        self,\n        kong_service: dict,\n        kong_routes: list,\n        kong_plugins: list,\n        kong_upstreams: list,\n        kong_targets: list\n    ) -&gt; Optional[Service]:\n        \"\"\"Convert Kong service to GAL service.\"\"\"\n        name = kong_service.get(\"name\")\n        if not name:\n            return None\n\n        # Parse upstream\n        upstream = self._parse_upstream(\n            kong_service,\n            kong_upstreams,\n            kong_targets\n        )\n\n        # Parse routes for this service\n        routes = []\n        for kong_route in kong_routes:\n            if kong_route.get(\"service\", {}).get(\"name\") == name:\n                route = self._parse_route(kong_route, kong_plugins)\n                if route:\n                    routes.append(route)\n\n        return Service(\n            name=name,\n            upstream=upstream,\n            routes=routes\n        )\n\n    def _parse_upstream(\n        self,\n        kong_service: dict,\n        kong_upstreams: list,\n        kong_targets: list\n    ) -&gt; Optional[UpstreamConfig]:\n        \"\"\"Parse Kong upstream to GAL upstream.\"\"\"\n        # Check if service has upstream\n        upstream_name = kong_service.get(\"host\")\n\n        # Find matching upstream\n        kong_upstream = None\n        for upstream in kong_upstreams:\n            if upstream.get(\"name\") == upstream_name:\n                kong_upstream = upstream\n                break\n\n        if kong_upstream:\n            # Service uses upstream with load balancing\n            targets = self._parse_targets(upstream_name, kong_targets)\n\n            # Parse load balancing algorithm\n            algorithm = self._map_lb_algorithm(\n                kong_upstream.get(\"algorithm\", \"round-robin\")\n            )\n\n            # Parse health checks\n            health_check = self._parse_health_check(kong_upstream)\n\n            return UpstreamConfig(\n                targets=targets,\n                load_balancer=LoadBalancerConfig(algorithm=algorithm),\n                health_check=health_check\n            )\n        else:\n            # Direct host:port without upstream\n            host = kong_service.get(\"host\")\n            port = kong_service.get(\"port\", 80)\n\n            if not host:\n                return None\n\n            return UpstreamConfig(\n                targets=[UpstreamTarget(host=host, port=port)],\n                load_balancer=LoadBalancerConfig(algorithm=\"round_robin\")\n            )\n\n    def _parse_targets(self, upstream_name: str, kong_targets: list) -&gt; List[UpstreamTarget]:\n        \"\"\"Parse Kong targets for upstream.\"\"\"\n        targets = []\n\n        for target in kong_targets:\n            if target.get(\"upstream\", {}).get(\"name\") != upstream_name:\n                continue\n\n            target_str = target.get(\"target\")  # Format: \"host:port\"\n            weight = target.get(\"weight\", 1)\n\n            if not target_str:\n                continue\n\n            # Parse host:port\n            if \":\" in target_str:\n                host, port_str = target_str.rsplit(\":\", 1)\n                try:\n                    port = int(port_str)\n                except ValueError:\n                    port = 80\n            else:\n                host = target_str\n                port = 80\n\n            targets.append(UpstreamTarget(\n                host=host,\n                port=port,\n                weight=weight\n            ))\n\n        return targets\n\n    def _map_lb_algorithm(self, kong_algorithm: str) -&gt; str:\n        \"\"\"Map Kong algorithm to GAL.\"\"\"\n        mapping = {\n            \"round-robin\": \"round_robin\",\n            \"least-connections\": \"least_conn\",\n            \"consistent-hashing\": \"ip_hash\",\n            \"latency\": \"least_conn\"\n        }\n        return mapping.get(kong_algorithm, \"round_robin\")\n\n    def _parse_health_check(self, kong_upstream: dict) -&gt; Optional[HealthCheckConfig]:\n        \"\"\"Parse Kong health checks.\"\"\"\n        healthchecks = kong_upstream.get(\"healthchecks\", {})\n\n        active = healthchecks.get(\"active\", {})\n        passive = healthchecks.get(\"passive\", {})\n\n        active_hc = None\n        passive_hc = None\n\n        if active and active.get(\"healthy\", {}).get(\"interval\"):\n            # Active health checks enabled\n            healthy = active.get(\"healthy\", {})\n            unhealthy = active.get(\"unhealthy\", {})\n\n            http_path = active.get(\"http_path\", \"/\")\n            interval = f\"{healthy.get('interval', 10)}s\"\n            timeout = f\"{active.get('timeout', 5)}s\"\n            healthy_threshold = healthy.get(\"successes\", 2)\n            unhealthy_threshold = unhealthy.get(\"http_failures\", 3)\n\n            active_hc = ActiveHealthCheck(\n                enabled=True,\n                http_path=http_path,\n                interval=interval,\n                timeout=timeout,\n                healthy_threshold=healthy_threshold,\n                unhealthy_threshold=unhealthy_threshold,\n                healthy_status_codes=[200, 302]\n            )\n\n        if passive and passive.get(\"healthy\", {}).get(\"successes\"):\n            # Passive health checks enabled\n            unhealthy = passive.get(\"unhealthy\", {})\n            max_failures = unhealthy.get(\"http_failures\", 3)\n\n            passive_hc = PassiveHealthCheck(\n                enabled=True,\n                max_failures=max_failures\n            )\n\n        if active_hc or passive_hc:\n            return HealthCheckConfig(\n                active=active_hc,\n                passive=passive_hc\n            )\n\n        return None\n\n    def _parse_route(self, kong_route: dict, kong_plugins: list) -&gt; Optional[Route]:\n        \"\"\"Parse Kong route to GAL route.\"\"\"\n        # Parse paths\n        paths = kong_route.get(\"paths\", [])\n        if not paths:\n            return None\n\n        path_prefix = paths[0]  # Take first path\n\n        # Parse methods\n        methods = kong_route.get(\"methods\")\n\n        # Parse plugins for this route\n        route_name = kong_route.get(\"name\")\n\n        rate_limit = None\n        authentication = None\n        headers = None\n        cors = None\n\n        for plugin in kong_plugins:\n            # Check if plugin applies to this route\n            plugin_route = plugin.get(\"route\", {}).get(\"name\")\n            if plugin_route != route_name:\n                continue\n\n            plugin_name = plugin.get(\"name\")\n            plugin_config = plugin.get(\"config\", {})\n\n            if plugin_name == \"rate-limiting\":\n                rate_limit = self._parse_rate_limiting_plugin(plugin_config)\n            elif plugin_name == \"key-auth\":\n                authentication = self._parse_key_auth_plugin(plugin_config)\n            elif plugin_name == \"basic-auth\":\n                authentication = self._parse_basic_auth_plugin(plugin_config)\n            elif plugin_name == \"jwt\":\n                authentication = self._parse_jwt_plugin(plugin_config)\n            elif plugin_name == \"request-transformer\":\n                headers = self._parse_request_transformer_plugin(plugin_config)\n            elif plugin_name == \"response-transformer\":\n                if headers:\n                    self._enrich_response_headers(headers, plugin_config)\n                else:\n                    headers = self._parse_response_transformer_plugin(plugin_config)\n            elif plugin_name == \"cors\":\n                cors = self._parse_cors_plugin(plugin_config)\n\n        return Route(\n            path_prefix=path_prefix,\n            methods=methods,\n            rate_limit=rate_limit,\n            authentication=authentication,\n            headers=headers,\n            cors=cors\n        )\n\n    def _parse_rate_limiting_plugin(self, config: dict) -&gt; RateLimitConfig:\n        \"\"\"Parse Kong rate-limiting plugin.\"\"\"\n        # Kong supports minute, hour, day, month, year\n        # We'll use minute and convert to per-second\n        limit_by = config.get(\"limit_by\", \"consumer\")\n        minute = config.get(\"minute\")\n        second = config.get(\"second\")\n\n        if second:\n            rps = second\n        elif minute:\n            rps = minute // 60  # Approximation\n        else:\n            rps = 100  # Default\n\n        key_type = \"ip_address\" if limit_by == \"ip\" else \"header\"\n        key_header = \"X-Consumer-ID\" if limit_by == \"consumer\" else None\n\n        return RateLimitConfig(\n            enabled=True,\n            requests_per_second=rps,\n            burst=rps * 2,\n            key_type=key_type,\n            key_header=key_header\n        )\n\n    def _parse_key_auth_plugin(self, config: dict) -&gt; AuthenticationConfig:\n        \"\"\"Parse Kong key-auth plugin.\"\"\"\n        return AuthenticationConfig(\n            enabled=True,\n            type=\"api_key\",\n            api_key_auth=ApiKeyAuth(\n                header_name=config.get(\"key_names\", [\"apikey\"])[0]\n            )\n        )\n\n    def _parse_basic_auth_plugin(self, config: dict) -&gt; AuthenticationConfig:\n        \"\"\"Parse Kong basic-auth plugin.\"\"\"\n        # Kong stores users separately, we can't import them\n        self._import_warnings.append(\n            \"Basic auth users not imported - configure manually\"\n        )\n\n        return AuthenticationConfig(\n            enabled=True,\n            type=\"basic\",\n            basic_auth=BasicAuth(\n                users={}  # Must be configured manually\n            )\n        )\n\n    def _parse_jwt_plugin(self, config: dict) -&gt; AuthenticationConfig:\n        \"\"\"Parse Kong JWT plugin.\"\"\"\n        key_claim_name = config.get(\"key_claim_name\", \"iss\")\n        secret_is_base64 = config.get(\"secret_is_base64\", False)\n\n        # Extract algorithm (Kong supports multiple)\n        algorithms = config.get(\"algorithm\", \"HS256\")\n\n        self._import_warnings.append(\n            \"JWT keys/secrets not imported - configure manually\"\n        )\n\n        return AuthenticationConfig(\n            enabled=True,\n            type=\"jwt\",\n            jwt_auth=JWTAuth(\n                secret=\"CONFIGURE_MANUALLY\",  # Not in config\n                algorithm=algorithms,\n                header_name=config.get(\"header_names\", [\"authorization\"])[0]\n            )\n        )\n\n    def _parse_request_transformer_plugin(self, config: dict) -&gt; HeadersConfig:\n        \"\"\"Parse Kong request-transformer plugin.\"\"\"\n        add = config.get(\"add\", {}).get(\"headers\", [])\n        remove = config.get(\"remove\", {}).get(\"headers\", [])\n\n        request_add = {}\n        for header_value in add:\n            # Format: \"Header-Name:value\"\n            if \":\" in header_value:\n                key, value = header_value.split(\":\", 1)\n                request_add[key] = value.strip()\n\n        request_remove = remove if remove else None\n\n        return HeadersConfig(\n            request_add=request_add if request_add else None,\n            request_remove=request_remove\n        )\n\n    def _parse_response_transformer_plugin(self, config: dict) -&gt; HeadersConfig:\n        \"\"\"Parse Kong response-transformer plugin.\"\"\"\n        add = config.get(\"add\", {}).get(\"headers\", [])\n        remove = config.get(\"remove\", {}).get(\"headers\", [])\n\n        response_add = {}\n        for header_value in add:\n            if \":\" in header_value:\n                key, value = header_value.split(\":\", 1)\n                response_add[key] = value.strip()\n\n        response_remove = remove if remove else None\n\n        return HeadersConfig(\n            response_add=response_add if response_add else None,\n            response_remove=response_remove\n        )\n\n    def _enrich_response_headers(self, headers: HeadersConfig, config: dict):\n        \"\"\"Add response headers to existing HeadersConfig.\"\"\"\n        add = config.get(\"add\", {}).get(\"headers\", [])\n        remove = config.get(\"remove\", {}).get(\"headers\", [])\n\n        if not headers.response_add:\n            headers.response_add = {}\n\n        for header_value in add:\n            if \":\" in header_value:\n                key, value = header_value.split(\":\", 1)\n                headers.response_add[key] = value.strip()\n\n        if remove and not headers.response_remove:\n            headers.response_remove = remove\n\n    def _parse_cors_plugin(self, config: dict) -&gt; CorsConfig:\n        \"\"\"Parse Kong CORS plugin.\"\"\"\n        origins = config.get(\"origins\", [\"*\"])\n        methods = config.get(\"methods\", [\"GET\", \"POST\", \"PUT\", \"DELETE\"])\n        headers = config.get(\"headers\", [])\n        credentials = config.get(\"credentials\", False)\n        max_age = config.get(\"max_age\", 86400)\n\n        return CorsConfig(\n            enabled=True,\n            allowed_origins=origins,\n            allowed_methods=methods,\n            allowed_headers=headers if headers else None,\n            allow_credentials=credentials,\n            max_age=str(max_age)\n        )\n\n    def get_import_warnings(self) -&gt; List[str]:\n        \"\"\"Return warnings from last import.\"\"\"\n        return getattr(self, '_import_warnings', [])\n</code></pre>"},{"location":"import/kong/#feature-mapping-matrix","title":"Feature Mapping Matrix","text":"GAL Feature Kong Config Mapping Service <code>services[].name</code> Direct mapping Upstream Targets <code>targets[]</code> (if upstream exists) target string \u2192 host:port Load Balancing <code>upstreams[].algorithm</code> round-robin \u2192 round_robin, least-connections \u2192 least_conn Active Health Checks <code>upstreams[].healthchecks.active</code> Direct mapping Passive Health Checks <code>upstreams[].healthchecks.passive</code> Direct mapping Routes <code>routes[]</code> paths[0] \u2192 path_prefix Rate Limiting <code>plugins[].rate-limiting</code> minute/60 \u2192 requests_per_second Basic Auth <code>plugins[].basic-auth</code> \u2705 Supported (users not imported) API Key Auth <code>plugins[].key-auth</code> \u2705 Supported JWT Auth <code>plugins[].jwt</code> \u2705 Supported (secrets not imported) Headers <code>plugins[].request-transformer</code>, <code>response-transformer</code> Direct mapping CORS <code>plugins[].cors</code> Direct mapping Circuit Breaker - \u274c Not available in Kong OSS"},{"location":"import/kong/#beispiel-konvertierung","title":"Beispiel-Konvertierung","text":""},{"location":"import/kong/#kong-config-input","title":"Kong Config (Input)","text":"<pre><code>_format_version: \"3.0\"\n\nservices:\n  - name: api_service\n    url: http://upstream_api\n    protocol: http\n    port: 80\n    retries: 5\n\nroutes:\n  - name: api_route\n    service: api_service\n    paths:\n      - /api\n    methods:\n      - GET\n      - POST\n\nupstreams:\n  - name: upstream_api\n    algorithm: round-robin\n    healthchecks:\n      active:\n        healthy:\n          interval: 10\n          successes: 2\n        unhealthy:\n          interval: 10\n          http_failures: 3\n        http_path: /health\n        timeout: 5\n\ntargets:\n  - upstream: upstream_api\n    target: api-1.internal:8080\n    weight: 100\n  - upstream: upstream_api\n    target: api-2.internal:8080\n    weight: 100\n\nplugins:\n  - name: rate-limiting\n    route: api_route\n    config:\n      minute: 6000\n      policy: local\n\n  - name: key-auth\n    route: api_route\n    config:\n      key_names:\n        - apikey\n\n  - name: cors\n    route: api_route\n    config:\n      origins:\n        - https://app.example.com\n      methods:\n        - GET\n        - POST\n        - PUT\n        - DELETE\n      credentials: true\n</code></pre>"},{"location":"import/kong/#gal-config-output","title":"GAL Config (Output)","text":"<pre><code>version: \"1.0\"\nprovider: kong\n\nglobal_config:\n  host: 0.0.0.0\n  port: 8000\n  timeout: 60s\n\nservices:\n  - name: api_service\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n          weight: 100\n        - host: api-2.internal\n          port: 8080\n          weight: 100\n\n      load_balancer:\n        algorithm: round_robin\n\n      health_check:\n        active:\n          enabled: true\n          http_path: /health\n          interval: 10s\n          timeout: 5s\n          healthy_threshold: 2\n          unhealthy_threshold: 3\n          healthy_status_codes: [200, 302]\n\n    routes:\n      - path_prefix: /api\n        methods:\n          - GET\n          - POST\n\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n          burst: 200\n          key_type: ip_address\n\n        authentication:\n          enabled: true\n          type: api_key\n          api_key_auth:\n            header_name: apikey\n\n        cors:\n          enabled: true\n          allowed_origins:\n            - https://app.example.com\n          allowed_methods:\n            - GET\n            - POST\n            - PUT\n            - DELETE\n          allow_credentials: true\n          max_age: \"86400\"\n</code></pre>"},{"location":"import/kong/#cli-usage","title":"CLI Usage","text":"<pre><code># Import Kong config\ngal import --provider kong --input kong.yaml --output gal-config.yaml\n\n# Import Kong JSON format\ngal import --provider kong --input kong.json --output gal-config.yaml\n\n# Validate import\ngal validate --config gal-config.yaml\n\n# Generate for different provider\ngal generate --config gal-config.yaml --provider envoy --output envoy.yaml\n</code></pre>"},{"location":"import/kong/#test-cases","title":"Test Cases","text":""},{"location":"import/kong/#test-1-basic-import","title":"Test 1: Basic Import","text":"<pre><code>def test_kong_import_basic():\n    \"\"\"Test basic Kong config import.\"\"\"\n    provider = KongProvider()\n\n    kong_config = \"\"\"\n    _format_version: \"3.0\"\n    services:\n      - name: test_service\n        url: http://test-backend:8080\n    \"\"\"\n\n    config = provider.parse(kong_config)\n\n    assert len(config.services) == 1\n    assert config.services[0].name == \"test_service\"\n    assert len(config.services[0].upstream.targets) == 1\n    assert config.services[0].upstream.targets[0].host == \"test-backend\"\n    assert config.services[0].upstream.targets[0].port == 8080\n</code></pre>"},{"location":"import/kong/#test-2-upstream-with-targets","title":"Test 2: Upstream with Targets","text":"<pre><code>def test_kong_import_upstream_targets():\n    \"\"\"Test upstream and targets import.\"\"\"\n    provider = KongProvider()\n\n    kong_config = \"\"\"\n    _format_version: \"3.0\"\n    services:\n      - name: lb_service\n        url: http://lb_upstream\n    upstreams:\n      - name: lb_upstream\n        algorithm: least-connections\n    targets:\n      - upstream: lb_upstream\n        target: server1:8080\n        weight: 2\n      - upstream: lb_upstream\n        target: server2:8080\n        weight: 1\n    \"\"\"\n\n    config = provider.parse(kong_config)\n\n    assert config.services[0].upstream.load_balancer.algorithm == \"least_conn\"\n    assert len(config.services[0].upstream.targets) == 2\n    assert config.services[0].upstream.targets[0].weight == 2\n    assert config.services[0].upstream.targets[1].weight == 1\n</code></pre>"},{"location":"import/kong/#test-3-rate-limiting-plugin","title":"Test 3: Rate Limiting Plugin","text":"<pre><code>def test_kong_import_rate_limiting():\n    \"\"\"Test rate-limiting plugin import.\"\"\"\n    provider = KongProvider()\n\n    kong_config = \"\"\"\n    _format_version: \"3.0\"\n    services:\n      - name: api_service\n        url: http://api:8080\n    routes:\n      - name: api_route\n        service: api_service\n        paths:\n          - /api\n    plugins:\n      - name: rate-limiting\n        route: api_route\n        config:\n          second: 10\n          minute: 600\n    \"\"\"\n\n    config = provider.parse(kong_config)\n\n    route = config.services[0].routes[0]\n    assert route.rate_limit.enabled is True\n    assert route.rate_limit.requests_per_second == 10\n</code></pre>"},{"location":"import/kong/#test-4-authentication-plugins","title":"Test 4: Authentication Plugins","text":"<pre><code>def test_kong_import_authentication():\n    \"\"\"Test authentication plugin import.\"\"\"\n    provider = KongProvider()\n\n    kong_config = \"\"\"\n    _format_version: \"3.0\"\n    services:\n      - name: api_service\n        url: http://api:8080\n    routes:\n      - name: api_route\n        service: api_service\n        paths:\n          - /api\n    plugins:\n      - name: key-auth\n        route: api_route\n        config:\n          key_names:\n            - X-API-Key\n    \"\"\"\n\n    config = provider.parse(kong_config)\n\n    route = config.services[0].routes[0]\n    assert route.authentication.enabled is True\n    assert route.authentication.type == \"api_key\"\n    assert route.authentication.api_key_auth.header_name == \"X-API-Key\"\n</code></pre>"},{"location":"import/kong/#test-5-round-trip-test","title":"Test 5: Round-trip Test","text":"<pre><code>def test_kong_import_export_roundtrip():\n    \"\"\"Test import \u2192 export produces equivalent config.\"\"\"\n    provider = KongProvider()\n\n    original_kong_config = load_fixture(\"kong-sample.yaml\")\n\n    # Import\n    gal_config = provider.parse(original_kong_config)\n\n    # Export\n    regenerated_kong_config = provider.generate(gal_config)\n\n    # Validate equivalence\n    original_parsed = yaml.safe_load(original_kong_config)\n    regenerated_parsed = yaml.safe_load(regenerated_kong_config)\n\n    assert_configs_equivalent(original_parsed, regenerated_parsed)\n</code></pre>"},{"location":"import/kong/#edge-cases-und-limitationen","title":"Edge Cases und Limitationen","text":""},{"location":"import/kong/#nicht-unterstutzte-features","title":"Nicht unterst\u00fctzte Features","text":"<ol> <li>Consumers (User Management)</li> <li>Consumers werden nicht importiert</li> <li>Warnung beim Import</li> <li> <p>Muss manuell konfiguriert werden</p> </li> <li> <p>API Keys/Secrets</p> </li> <li>Secrets werden aus Sicherheitsgr\u00fcnden nicht exportiert</li> <li>Platzhalter in GAL Config</li> <li> <p>Warnung: \"Configure manually\"</p> </li> <li> <p>Custom Plugins</p> </li> <li>Nur Standard-Plugins unterst\u00fctzt</li> <li> <p>Custom Plugins \u2192 provider_specific</p> </li> <li> <p>Service Mesh Mode</p> </li> <li>Nicht unterst\u00fctzt (Kong for Kubernetes)</li> <li>Nur Declarative Config</li> </ol>"},{"location":"import/kong/#besonderheiten","title":"Besonderheiten","text":"<ul> <li>Rate Limiting Units: Kong unterst\u00fctzt second/minute/hour/day/month/year, GAL nur requests_per_second</li> <li>Konvertierung: minute/60 \u2192 requests_per_second</li> <li> <p>Warnung bei Ungenauigkeit</p> </li> <li> <p>Plugin Scope: Kong Plugins k\u00f6nnen auf service/route/consumer angewendet werden</p> </li> <li>Import nur f\u00fcr route-scoped Plugins</li> <li>Service-scoped \u2192 alle Routes bekommen Plugin</li> </ul>"},{"location":"import/kong/#warnings","title":"Warnings","text":"<p>Import gibt Warnungen aus f\u00fcr: - Nicht importierte Consumers - Fehlende API Keys/Secrets - Ungenaue Rate Limit Konvertierung - Nicht unterst\u00fctzte Custom Plugins</p>"},{"location":"import/kong/#akzeptanzkriterien","title":"Akzeptanzkriterien","text":"<ul> <li>\u2705 Import von Kong Declarative Config (YAML/JSON)</li> <li>\u2705 Mapping von Services \u2192 GAL Services</li> <li>\u2705 Mapping von Upstreams + Targets</li> <li>\u2705 Import von Health Checks (active + passive)</li> <li>\u2705 Import von Routes</li> <li>\u2705 Import von Plugins (rate-limiting, auth, cors, headers)</li> <li>\u2705 CLI Integration (<code>gal import --provider kong</code>)</li> <li>\u2705 20+ Tests mit 90%+ Coverage</li> <li>\u2705 Warnings f\u00fcr nicht importierte Secrets</li> <li>\u2705 Round-trip Test</li> </ul>"},{"location":"import/kong/#implementierungs-reihenfolge","title":"Implementierungs-Reihenfolge","text":"<ol> <li>Tag 1-2: Provider.parse() + Service/Upstream Parsing</li> <li>Tag 3: Routes + Basic Plugins</li> <li>Tag 4: Auth Plugins (key-auth, basic-auth, jwt)</li> <li>Tag 5: Headers + CORS Plugins</li> <li>Tag 6-7: Tests + Documentation</li> </ol>"},{"location":"import/kong/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<p>Nach Completion: 1. Release als v1.3.0-alpha1 (zusammen mit Envoy Import) 2. User Feedback sammeln 3. APISIX Import (Feature 3) beginnen</p>"},{"location":"import/migration/","title":"Feature 8: Migration Assistant","text":"<p>Status: \ud83d\udd04 Geplant Aufwand: 2 Wochen Release: v1.3.0 Final (Woche 12) Priorit\u00e4t: \ud83d\udfe1 Mittel</p>"},{"location":"import/migration/#ubersicht","title":"\u00dcbersicht","text":"<p>Der Migration Assistant ist ein interaktiver CLI-Workflow, der Nutzer durch den kompletten Migrations-Prozess von einem Provider zu einem anderen f\u00fchrt. Er kombiniert Import, Compatibility Check und Export mit Schritt-f\u00fcr-Schritt-Anleitung.</p>"},{"location":"import/migration/#use-cases","title":"Use Cases","text":"<ol> <li>Guided Migration: Nginx \u2192 HAProxy Migration mit Anleitung</li> <li>Risk Assessment: Zeige Risiken und Inkompatibilit\u00e4ten vor Migration</li> <li>Rollback Plan: Generiere Rollback-Dokumentation</li> <li>Documentation: Erstelle Migration Report f\u00fcr Team</li> </ol>"},{"location":"import/migration/#implementierung","title":"Implementierung","text":""},{"location":"import/migration/#cli-command","title":"CLI Command","text":"<pre><code># Interactive migration workflow\ngal migrate\n\n# Non-interactive with parameters\ngal migrate --source-provider nginx --source-config nginx.conf \\\n            --target-provider haproxy --output haproxy.cfg \\\n            --report migration-report.md\n</code></pre>"},{"location":"import/migration/#interactive-workflow","title":"Interactive Workflow","text":"<pre><code># gal/migration_assistant.py\n\nimport click\nfrom typing import Optional, Dict, Any\nfrom pathlib import Path\n\nfrom gal.config import Config\nfrom gal.provider import Provider\nfrom gal.providers import get_provider\nfrom gal.compatibility import CompatibilityChecker\n\nclass MigrationAssistant:\n    \"\"\"Interactive migration assistant.\"\"\"\n\n    def __init__(self):\n        self.checker = CompatibilityChecker()\n\n    def run_interactive(self):\n        \"\"\"Run interactive migration workflow.\"\"\"\n        click.echo(\"=\" * 60)\n        click.echo(\"\ud83d\ude80 GAL Migration Assistant\")\n        click.echo(\"=\" * 60)\n        click.echo()\n\n        # Step 1: Source Provider\n        click.echo(\"\ud83d\udccc Step 1: Source Configuration\")\n        click.echo()\n\n        source_provider = self._prompt_provider(\"Select source provider\")\n        source_config_path = click.prompt(\n            \"Path to source configuration file\",\n            type=click.Path(exists=True)\n        )\n\n        # Step 2: Import\n        click.echo()\n        click.echo(\"\ud83d\udce5 Step 2: Importing Configuration...\")\n        click.echo()\n\n        gal_config, import_warnings = self._import_config(\n            source_provider,\n            source_config_path\n        )\n\n        if import_warnings:\n            click.echo(\"\u26a0\ufe0f  Import Warnings:\")\n            for warning in import_warnings:\n                click.echo(f\"  - {warning}\")\n            click.echo()\n\n        # Show imported config summary\n        self._show_config_summary(gal_config)\n\n        # Step 3: Target Provider\n        click.echo()\n        click.echo(\"\ud83d\udccc Step 3: Target Provider\")\n        click.echo()\n\n        target_provider = self._prompt_provider(\n            \"Select target provider\",\n            exclude=[source_provider]\n        )\n\n        # Step 4: Compatibility Check\n        click.echo()\n        click.echo(\"\ud83d\udd0d Step 4: Compatibility Check...\")\n        click.echo()\n\n        compat = self.checker.check_compatibility(gal_config, target_provider)\n\n        self._show_compatibility_result(compat)\n\n        if not compat.compatible:\n            if not click.confirm(\"\\n\u26a0\ufe0f  Configuration is not fully compatible. Continue anyway?\"):\n                click.echo(\"\u274c Migration cancelled.\")\n                return\n\n        # Step 5: Generate Target Config\n        click.echo()\n        click.echo(\"\u2699\ufe0f  Step 5: Generating Target Configuration...\")\n        click.echo()\n\n        output_path = click.prompt(\n            \"Output file path\",\n            default=f\"generated/{target_provider}-config.yaml\"\n        )\n\n        target_config = self._generate_config(gal_config, target_provider)\n\n        # Write output\n        output_file = Path(output_path)\n        output_file.parent.mkdir(parents=True, exist_ok=True)\n        output_file.write_text(target_config)\n\n        click.echo(f\"\u2705 Target configuration written to: {output_path}\")\n\n        # Step 6: Migration Report\n        click.echo()\n        click.echo(\"\ud83d\udcdd Step 6: Migration Report\")\n        click.echo()\n\n        if click.confirm(\"Generate migration report?\", default=True):\n            report_path = click.prompt(\n                \"Report file path\",\n                default=\"migration-report.md\"\n            )\n\n            report = self._generate_migration_report(\n                source_provider,\n                source_config_path,\n                target_provider,\n                output_path,\n                gal_config,\n                compat,\n                import_warnings\n            )\n\n            Path(report_path).write_text(report)\n            click.echo(f\"\u2705 Migration report written to: {report_path}\")\n\n        # Step 7: Next Steps\n        click.echo()\n        click.echo(\"=\" * 60)\n        click.echo(\"\u2705 Migration Complete!\")\n        click.echo(\"=\" * 60)\n        click.echo()\n\n        self._show_next_steps(target_provider, output_path, compat)\n\n    def _prompt_provider(\n        self,\n        prompt_text: str,\n        exclude: Optional[list] = None\n    ) -&gt; str:\n        \"\"\"Prompt user to select a provider.\"\"\"\n        providers = [\"envoy\", \"kong\", \"apisix\", \"traefik\", \"nginx\", \"haproxy\"]\n\n        if exclude:\n            providers = [p for p in providers if p not in exclude]\n\n        click.echo(f\"{prompt_text}:\")\n        for i, provider in enumerate(providers, 1):\n            click.echo(f\"  {i}. {provider}\")\n\n        choice = click.prompt(\n            \"Enter number\",\n            type=click.IntRange(1, len(providers))\n        )\n\n        return providers[choice - 1]\n\n    def _import_config(\n        self,\n        provider_name: str,\n        config_path: str\n    ) -&gt; tuple[Config, list]:\n        \"\"\"Import config from provider.\"\"\"\n        provider = get_provider(provider_name)\n\n        with open(config_path, \"r\") as f:\n            config_text = f.read()\n\n        gal_config = provider.parse(config_text)\n        warnings = provider.get_import_warnings()\n\n        return gal_config, warnings\n\n    def _generate_config(\n        self,\n        config: Config,\n        provider_name: str\n    ) -&gt; str:\n        \"\"\"Generate config for target provider.\"\"\"\n        provider = get_provider(provider_name)\n        return provider.generate(config)\n\n    def _show_config_summary(self, config: Config):\n        \"\"\"Show summary of imported config.\"\"\"\n        click.echo(\"\u2705 Import successful!\\n\")\n        click.echo(f\"\ud83d\udcca Configuration Summary:\")\n        click.echo(f\"  - Services: {len(config.services)}\")\n\n        total_routes = sum(len(s.routes) for s in config.services)\n        total_targets = sum(\n            len(s.upstream.targets) if s.upstream else 0\n            for s in config.services\n        )\n\n        click.echo(f\"  - Routes: {total_routes}\")\n        click.echo(f\"  - Upstream Targets: {total_targets}\")\n\n    def _show_compatibility_result(self, compat):\n        \"\"\"Show compatibility check result.\"\"\"\n        if compat.compatible:\n            click.echo(f\"\u2705 Configuration is compatible with {compat.provider_name}\")\n        else:\n            click.echo(f\"\u274c Configuration is NOT compatible with {compat.provider_name}\")\n            click.echo()\n            click.echo(\"Errors:\")\n            for error in compat.errors:\n                click.echo(f\"  - \u274c {error}\")\n\n        if compat.warnings:\n            click.echo()\n            click.echo(\"Warnings:\")\n            for warning in compat.warnings:\n                click.echo(f\"  - \u26a0\ufe0f {warning}\")\n\n    def _generate_migration_report(\n        self,\n        source_provider: str,\n        source_config: str,\n        target_provider: str,\n        target_config: str,\n        gal_config: Config,\n        compat,\n        import_warnings: list\n    ) -&gt; str:\n        \"\"\"Generate migration report in Markdown.\"\"\"\n        report = []\n\n        # Header\n        report.append(f\"# Migration Report: {source_provider.title()} \u2192 {target_provider.title()}\\n\\n\")\n        report.append(f\"**Date:** {self._get_timestamp()}\\n\")\n        report.append(f\"**GAL Version:** 1.3.0\\n\\n\")\n\n        # Summary\n        report.append(\"## Summary\\n\\n\")\n        report.append(f\"- **Source Provider:** {source_provider}\\n\")\n        report.append(f\"- **Source Config:** {source_config}\\n\")\n        report.append(f\"- **Target Provider:** {target_provider}\\n\")\n        report.append(f\"- **Target Config:** {target_config}\\n\")\n        report.append(f\"- **Status:** {'\u2705 Compatible' if compat.compatible else '\u274c Incompatible'}\\n\\n\")\n\n        # Configuration Details\n        report.append(\"## Configuration Details\\n\\n\")\n        report.append(f\"- **Services:** {len(gal_config.services)}\\n\")\n\n        total_routes = sum(len(s.routes) for s in gal_config.services)\n        total_targets = sum(\n            len(s.upstream.targets) if s.upstream else 0\n            for s in gal_config.services\n        )\n\n        report.append(f\"- **Routes:** {total_routes}\\n\")\n        report.append(f\"- **Upstream Targets:** {total_targets}\\n\\n\")\n\n        # Import Warnings\n        if import_warnings:\n            report.append(\"## Import Warnings\\n\\n\")\n            for warning in import_warnings:\n                report.append(f\"- \u26a0\ufe0f {warning}\\n\")\n            report.append(\"\\n\")\n\n        # Compatibility Check\n        report.append(\"## Compatibility Check\\n\\n\")\n\n        if compat.compatible:\n            report.append(\"\u2705 **All features are compatible**\\n\\n\")\n        else:\n            report.append(\"\u274c **Some features are incompatible**\\n\\n\")\n\n            report.append(\"### Errors\\n\\n\")\n            for error in compat.errors:\n                report.append(f\"- \u274c {error}\\n\")\n            report.append(\"\\n\")\n\n        if compat.warnings:\n            report.append(\"### Warnings\\n\\n\")\n            for warning in compat.warnings:\n                report.append(f\"- \u26a0\ufe0f {warning}\\n\")\n            report.append(\"\\n\")\n\n        # Feature Support\n        report.append(\"### Feature Support\\n\\n\")\n        report.append(\"| Feature | Status | Notes |\\n\")\n        report.append(\"|---------|--------|-------|\\n\")\n\n        for feature in compat.features:\n            if feature.level.value == \"full\":\n                status = \"\u2705 Full\"\n            elif feature.level.value == \"partial\":\n                status = \"\u26a0\ufe0f Partial\"\n            elif feature.level.value == \"manual\":\n                status = \"\ud83d\udd27 Manual\"\n            else:\n                status = \"\u274c Unsupported\"\n\n            notes = feature.workaround or feature.message\n            report.append(f\"| {feature.feature_name} | {status} | {notes} |\\n\")\n\n        report.append(\"\\n\")\n\n        # Next Steps\n        report.append(\"## Next Steps\\n\\n\")\n        report.append(\"1. **Review Generated Configuration**\\n\")\n        report.append(f\"   - Check `{target_config}` for correctness\\n\")\n        report.append(\"   - Validate syntax with target provider's tools\\n\\n\")\n\n        report.append(\"2. **Test in Staging**\\n\")\n        report.append(f\"   - Deploy to staging environment\\n\")\n        report.append(\"   - Run integration tests\\n\")\n        report.append(\"   - Verify all routes work correctly\\n\\n\")\n\n        if compat.warnings or not compat.compatible:\n            report.append(\"3. **Address Warnings/Errors**\\n\")\n            for feature in compat.features:\n                if feature.workaround:\n                    report.append(f\"   - **{feature.feature_name}**: {feature.workaround}\\n\")\n            report.append(\"\\n\")\n\n        report.append(\"4. **Production Deployment**\\n\")\n        report.append(\"   - Create rollback plan\\n\")\n        report.append(\"   - Deploy during low-traffic window\\n\")\n        report.append(\"   - Monitor logs and metrics\\n\\n\")\n\n        # Rollback Plan\n        report.append(\"## Rollback Plan\\n\\n\")\n        report.append(f\"If migration fails, revert to original configuration:\\n\\n\")\n        report.append(f\"```bash\\n\")\n        report.append(f\"# Restore original {source_provider} config\\n\")\n        report.append(f\"cp {source_config}.backup {source_config}\\n\")\n        report.append(f\"# Restart {source_provider}\\n\")\n        report.append(f\"systemctl restart {source_provider}\\n\")\n        report.append(f\"```\\n\\n\")\n\n        # References\n        report.append(\"## References\\n\\n\")\n        report.append(f\"- [GAL Documentation](https://github.com/pt9912/x-gal)\\n\")\n        report.append(f\"- [{target_provider.title()} Documentation](#{target_provider}-docs)\\n\")\n        report.append(f\"- [Migration Guide](docs/guides/MIGRATION.md)\\n\")\n\n        return \"\".join(report)\n\n    def _show_next_steps(self, target_provider: str, output_path: str, compat):\n        \"\"\"Show next steps after migration.\"\"\"\n        click.echo(\"\ud83d\udccb Next Steps:\\n\")\n        click.echo(f\"1. Review generated config: {output_path}\")\n        click.echo(f\"2. Validate syntax:\")\n\n        if target_provider == \"nginx\":\n            click.echo(f\"   nginx -t -c {output_path}\")\n        elif target_provider == \"haproxy\":\n            click.echo(f\"   haproxy -c -f {output_path}\")\n        elif target_provider == \"envoy\":\n            click.echo(f\"   envoy --mode validate -c {output_path}\")\n        else:\n            click.echo(f\"   (Check {target_provider} documentation for validation command)\")\n\n        click.echo(f\"3. Test in staging environment\")\n        click.echo(f\"4. Deploy to production\")\n\n        if not compat.compatible or compat.warnings:\n            click.echo()\n            click.echo(\"\u26a0\ufe0f  Remember to address warnings before production deployment!\")\n\n    def _get_timestamp(self) -&gt; str:\n        \"\"\"Get current timestamp.\"\"\"\n        from datetime import datetime\n        return datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n\n# CLI Integration\n@cli.command(\"migrate\")\n@click.option(\"--source-provider\", help=\"Source provider name\")\n@click.option(\"--source-config\", help=\"Source config file path\")\n@click.option(\"--target-provider\", help=\"Target provider name\")\n@click.option(\"--output\", help=\"Output config file path\")\n@click.option(\"--report\", help=\"Migration report path\")\ndef migrate(source_provider, source_config, target_provider, output, report):\n    \"\"\"Migration assistant (interactive or scripted).\"\"\"\n    assistant = MigrationAssistant()\n\n    if source_provider and source_config and target_provider and output:\n        # Non-interactive mode\n        assistant.run_non_interactive(\n            source_provider,\n            source_config,\n            target_provider,\n            output,\n            report\n        )\n    else:\n        # Interactive mode\n        assistant.run_interactive()\n</code></pre>"},{"location":"import/migration/#workflow-beispiel","title":"Workflow-Beispiel","text":""},{"location":"import/migration/#interaktiver-modus","title":"Interaktiver Modus","text":"<pre><code>$ gal migrate\n\n============================================================\n\ud83d\ude80 GAL Migration Assistant\n============================================================\n\n\ud83d\udccc Step 1: Source Configuration\n\nSelect source provider:\n  1. envoy\n  2. kong\n  3. apisix\n  4. traefik\n  5. nginx\n  6. haproxy\nEnter number: 5\n\nPath to source configuration file: /etc/nginx/nginx.conf\n\n\ud83d\udce5 Step 2: Importing Configuration...\n\n\u2705 Import successful!\n\n\ud83d\udcca Configuration Summary:\n  - Services: 3\n  - Routes: 8\n  - Upstream Targets: 12\n\n\u26a0\ufe0f  Import Warnings:\n  - Rate limiting config simplified - manual review recommended\n  - JWT auth not supported - requires OpenResty\n\n\ud83d\udccc Step 3: Target Provider\n\nSelect target provider:\n  1. envoy\n  2. kong\n  3. apisix\n  4. traefik\n  5. haproxy\nEnter number: 5\n\n\ud83d\udd0d Step 4: Compatibility Check...\n\n\u2705 Configuration is compatible with haproxy\n\nWarnings:\n  - \u26a0\ufe0f JWT auth requires Lua scripting on haproxy\n\n\u2699\ufe0f  Step 5: Generating Target Configuration...\n\nOutput file path [generated/haproxy-config.yaml]: haproxy.cfg\n\n\u2705 Target configuration written to: haproxy.cfg\n\n\ud83d\udcdd Step 6: Migration Report\n\nGenerate migration report? [Y/n]: y\nReport file path [migration-report.md]:\n\n\u2705 Migration report written to: migration-report.md\n\n============================================================\n\u2705 Migration Complete!\n============================================================\n\n\ud83d\udccb Next Steps:\n\n1. Review generated config: haproxy.cfg\n2. Validate syntax:\n   haproxy -c -f haproxy.cfg\n3. Test in staging environment\n4. Deploy to production\n\n\u26a0\ufe0f  Remember to address warnings before production deployment!\n</code></pre>"},{"location":"import/migration/#non-interaktiver-modus","title":"Non-interaktiver Modus","text":"<pre><code>$ gal migrate \\\n    --source-provider nginx \\\n    --source-config /etc/nginx/nginx.conf \\\n    --target-provider haproxy \\\n    --output haproxy.cfg \\\n    --report migration-report.md\n\n\ud83d\udce5 Importing nginx configuration...\n\u2705 Import successful (3 services, 8 routes)\n\n\ud83d\udd0d Checking compatibility with haproxy...\n\u2705 Compatible (1 warning)\n\n\u2699\ufe0f  Generating haproxy configuration...\n\u2705 Written to haproxy.cfg\n\n\ud83d\udcdd Generating migration report...\n\u2705 Written to migration-report.md\n\n\u2705 Migration complete!\n</code></pre>"},{"location":"import/migration/#migration-report-format","title":"Migration Report Format","text":"<pre><code># Migration Report: Nginx \u2192 HAProxy\n\n**Date:** 2025-10-18 14:30:00\n**GAL Version:** 1.3.0\n\n## Summary\n\n- **Source Provider:** nginx\n- **Source Config:** /etc/nginx/nginx.conf\n- **Target Provider:** haproxy\n- **Target Config:** haproxy.cfg\n- **Status:** \u2705 Compatible\n\n## Configuration Details\n\n- **Services:** 3\n- **Routes:** 8\n- **Upstream Targets:** 12\n\n## Import Warnings\n\n- \u26a0\ufe0f Rate limiting config simplified - manual review recommended\n- \u26a0\ufe0f JWT auth not supported - requires OpenResty\n\n## Compatibility Check\n\n\u2705 **All features are compatible**\n\n### Warnings\n\n- \u26a0\ufe0f JWT auth requires Lua scripting on haproxy\n\n### Feature Support\n\n| Feature | Status | Notes |\n|---------|--------|-------|\n| rate_limiting | \u2705 Full | Fully supported |\n| passive_health_checks | \u2705 Full | Fully supported |\n| load_balancing_least_conn | \u2705 Full | Fully supported |\n| jwt_auth | \ud83d\udd27 Manual | Requires Lua scripting |\n\n## Next Steps\n\n1. **Review Generated Configuration**\n   - Check `haproxy.cfg` for correctness\n   - Validate syntax with target provider's tools\n\n2. **Test in Staging**\n   - Deploy to staging environment\n   - Run integration tests\n   - Verify all routes work correctly\n\n3. **Address Warnings/Errors**\n   - **jwt_auth**: Use HAProxy Lua scripts or external auth service\n\n4. **Production Deployment**\n   - Create rollback plan\n   - Deploy during low-traffic window\n   - Monitor logs and metrics\n\n## Rollback Plan\n\nIf migration fails, revert to original configuration:\n\n```bash\n# Restore original nginx config\ncp /etc/nginx/nginx.conf.backup /etc/nginx/nginx.conf\n# Restart nginx\nsystemctl restart nginx\n</code></pre>"},{"location":"import/migration/#references","title":"References","text":"<ul> <li>GAL Documentation</li> <li>HAProxy Documentation</li> <li>Migration Guide ```</li> </ul>"},{"location":"import/migration/#test-cases","title":"Test Cases","text":"<p>15+ Tests: - Interactive mode flow - Non-interactive mode - Provider selection - Config import - Compatibility check - Report generation - Error handling (incompatible config) - Edge cases (no services, empty config)</p>"},{"location":"import/migration/#akzeptanzkriterien","title":"Akzeptanzkriterien","text":"<ul> <li>\u2705 Interactive CLI workflow (step-by-step)</li> <li>\u2705 Non-interactive mode (scripted)</li> <li>\u2705 Provider selection UI</li> <li>\u2705 Config import with warnings</li> <li>\u2705 Compatibility check integration</li> <li>\u2705 Migration report generation (Markdown)</li> <li>\u2705 Next steps guidance</li> <li>\u2705 Rollback plan in report</li> <li>\u2705 CLI Integration</li> <li>\u2705 15+ Tests, 85%+ Coverage</li> </ul>"},{"location":"import/migration/#implementierungs-reihenfolge","title":"Implementierungs-Reihenfolge","text":"<ol> <li>Tag 1-2: MigrationAssistant class + Interactive prompts</li> <li>Tag 3-4: Import + Compatibility Check integration</li> <li>Tag 5-6: Config generation + Output</li> <li>Tag 7-8: Migration report generation</li> <li>Tag 9-10: Non-interactive mode</li> <li>Tag 11-12: Next steps + Rollback plan</li> <li>Tag 13-14: Tests + Refinement + Documentation</li> </ol>"},{"location":"import/migration/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<p>Nach Completion: 1. Release als v1.3.0 Final 2. User Feedback sammeln 3. v1.4.0 Planung (Cloud Providers)</p>"},{"location":"import/nginx/","title":"Feature 5: Nginx Import (Custom Parser)","text":"<p>Status: \ud83d\udd04 Geplant Aufwand: 2 Wochen Release: v1.3.0-beta1 (Woche 6) Priorit\u00e4t: \ud83d\udd34 Hoch</p>"},{"location":"import/nginx/#ubersicht","title":"\u00dcbersicht","text":"<p>Import von Nginx nginx.conf nach GAL. Nginx verwendet ein eigenes Konfigurations-Format (nicht YAML/JSON), daher ist ein Custom Parser erforderlich. Nginx ist sehr weit verbreitet und daher kritisch f\u00fcr Adoption.</p>"},{"location":"import/nginx/#herausforderungen","title":"Herausforderungen","text":"<ul> <li>Eigenes Format: nginx.conf ist kein standardisiertes Format (kein YAML, JSON, TOML)</li> <li>Kontext-Hierarchie: server { location { } } Bl\u00f6cke verschachtelt</li> <li>Direktiven-Vielfalt: Hunderte verschiedene Direktiven</li> <li>Include-Dateien: nginx.conf kann andere Dateien einbinden</li> <li>Variablen: Nginx verwendet $variable Syntax</li> </ul>"},{"location":"import/nginx/#implementierung","title":"Implementierung","text":""},{"location":"import/nginx/#custom-parser-nginxconfigparser","title":"Custom Parser: NginxConfigParser","text":"<pre><code># gal/parsers/nginx_parser.py\n\nimport re\nfrom typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass NginxDirective:\n    \"\"\"Represents a single nginx directive.\"\"\"\n    name: str\n    args: List[str]\n    block: Optional[List['NginxDirective']] = None\n\nclass NginxConfigParser:\n    \"\"\"Parser for nginx.conf files.\n\n    Parses nginx configuration files into a structured format\n    for conversion to GAL.\n    \"\"\"\n\n    def __init__(self):\n        self.lines = []\n        self.pos = 0\n\n    def parse(self, config_text: str) -&gt; List[NginxDirective]:\n        \"\"\"Parse nginx config text into directive tree.\n\n        Args:\n            config_text: nginx.conf content\n\n        Returns:\n            List of top-level NginxDirective objects\n\n        Raises:\n            ValueError: If syntax is invalid\n        \"\"\"\n        # Preprocess: Remove comments, normalize whitespace\n        lines = self._preprocess(config_text)\n        self.lines = lines\n        self.pos = 0\n\n        directives = []\n        while self.pos &lt; len(self.lines):\n            directive = self._parse_directive()\n            if directive:\n                directives.append(directive)\n\n        return directives\n\n    def _preprocess(self, config_text: str) -&gt; List[str]:\n        \"\"\"Preprocess config text: remove comments, normalize.\"\"\"\n        lines = []\n\n        for line in config_text.split('\\n'):\n            # Remove comments\n            if '#' in line:\n                line = line[:line.index('#')]\n\n            # Strip whitespace\n            line = line.strip()\n\n            if line:\n                lines.append(line)\n\n        return lines\n\n    def _parse_directive(self) -&gt; Optional[NginxDirective]:\n        \"\"\"Parse a single directive with optional block.\"\"\"\n        if self.pos &gt;= len(self.lines):\n            return None\n\n        line = self.lines[self.pos]\n\n        # Check if this line starts a block (ends with {)\n        if '{' in line:\n            # Extract directive name and args before {\n            parts = line.split('{')[0].strip().split()\n\n            if not parts:\n                self.pos += 1\n                return None\n\n            name = parts[0]\n            args = parts[1:] if len(parts) &gt; 1 else []\n\n            # Parse block contents\n            self.pos += 1\n            block_directives = []\n\n            while self.pos &lt; len(self.lines):\n                line = self.lines[self.pos]\n\n                if '}' in line:\n                    # End of block\n                    self.pos += 1\n                    break\n\n                directive = self._parse_directive()\n                if directive:\n                    block_directives.append(directive)\n\n            return NginxDirective(name=name, args=args, block=block_directives)\n        else:\n            # Simple directive (ends with ;)\n            if ';' not in line:\n                self.pos += 1\n                return None\n\n            # Remove trailing semicolon\n            line = line.rstrip(';').strip()\n            parts = line.split()\n\n            if not parts:\n                self.pos += 1\n                return None\n\n            name = parts[0]\n            args = parts[1:] if len(parts) &gt; 1 else []\n\n            self.pos += 1\n            return NginxDirective(name=name, args=args, block=None)\n</code></pre>"},{"location":"import/nginx/#providerparse-methode","title":"Provider.parse() Methode","text":"<pre><code>class NginxProvider(Provider):\n    \"\"\"Nginx Provider with Import Support.\"\"\"\n\n    def parse(self, provider_config: str) -&gt; Config:\n        \"\"\"Parse nginx.conf to GAL format.\n\n        Args:\n            provider_config: nginx.conf content\n\n        Returns:\n            Config: GAL configuration object\n\n        Raises:\n            ValueError: If config is invalid\n        \"\"\"\n        parser = NginxConfigParser()\n        directives = parser.parse(provider_config)\n\n        self._import_warnings = []\n\n        return Config(\n            version=\"1.0\",\n            provider=\"nginx\",\n            global_config=self._parse_global(directives),\n            services=self._parse_services(directives)\n        )\n\n    def _parse_global(self, directives: List[NginxDirective]) -&gt; GlobalConfig:\n        \"\"\"Extract global config from nginx directives.\"\"\"\n        # Look for events and http blocks\n        return GlobalConfig(\n            host=\"0.0.0.0\",\n            port=80,  # Default, extracted from server blocks\n            timeout=\"30s\"\n        )\n\n    def _parse_services(self, directives: List[NginxDirective]) -&gt; List[Service]:\n        \"\"\"Parse nginx http.server blocks to GAL services.\"\"\"\n        services = []\n\n        # Find http block\n        http_block = None\n        for directive in directives:\n            if directive.name == \"http\":\n                http_block = directive.block\n                break\n\n        if not http_block:\n            return services\n\n        # Find all upstream blocks (targets)\n        upstreams = {}\n        for directive in http_block:\n            if directive.name == \"upstream\":\n                upstream_name = directive.args[0] if directive.args else None\n                if upstream_name:\n                    upstreams[upstream_name] = self._parse_upstream(directive)\n\n        # Find all server blocks\n        for directive in http_block:\n            if directive.name == \"server\":\n                service = self._parse_server(directive.block, upstreams)\n                if service:\n                    services.append(service)\n\n        return services\n\n    def _parse_upstream(self, upstream_directive: NginxDirective) -&gt; Dict[str, Any]:\n        \"\"\"Parse nginx upstream block.\"\"\"\n        upstream_name = upstream_directive.args[0]\n        servers = []\n        lb_algorithm = \"round_robin\"\n        health_check = None\n\n        for directive in upstream_directive.block:\n            if directive.name == \"server\":\n                # Format: server host:port [weight=N] [max_fails=N] [fail_timeout=Ns]\n                server_str = directive.args[0]\n                weight = 1\n                max_fails = None\n                fail_timeout = None\n\n                # Parse additional args\n                for arg in directive.args[1:]:\n                    if arg.startswith(\"weight=\"):\n                        weight = int(arg.split(\"=\")[1])\n                    elif arg.startswith(\"max_fails=\"):\n                        max_fails = int(arg.split(\"=\")[1])\n                    elif arg.startswith(\"fail_timeout=\"):\n                        fail_timeout = arg.split(\"=\")[1]\n\n                # Parse host:port\n                if \":\" in server_str:\n                    host, port_str = server_str.rsplit(\":\", 1)\n                    port = int(port_str)\n                else:\n                    host = server_str\n                    port = 80\n\n                servers.append({\n                    \"host\": host,\n                    \"port\": port,\n                    \"weight\": weight,\n                    \"max_fails\": max_fails,\n                    \"fail_timeout\": fail_timeout\n                })\n\n            elif directive.name == \"least_conn\":\n                lb_algorithm = \"least_conn\"\n            elif directive.name == \"ip_hash\":\n                lb_algorithm = \"ip_hash\"\n\n        return {\n            \"name\": upstream_name,\n            \"servers\": servers,\n            \"algorithm\": lb_algorithm,\n            \"health_check\": health_check\n        }\n\n    def _parse_server(\n        self,\n        server_block: List[NginxDirective],\n        upstreams: Dict[str, Any]\n    ) -&gt; Optional[Service]:\n        \"\"\"Parse nginx server block to GAL service.\"\"\"\n        # Try to extract service name from server_name or upstream\n        server_name = None\n        proxy_pass = None\n        locations = []\n\n        for directive in server_block:\n            if directive.name == \"server_name\":\n                server_name = directive.args[0] if directive.args else None\n            elif directive.name == \"location\":\n                location = self._parse_location(directive, upstreams)\n                if location:\n                    locations.append(location)\n\n        if not locations:\n            return None\n\n        # Determine service name and upstream\n        # Check if any location uses upstream\n        upstream_name = None\n        for location in locations:\n            if \"upstream_name\" in location:\n                upstream_name = location[\"upstream_name\"]\n                break\n\n        if not upstream_name:\n            # No upstream, use direct proxy_pass\n            self._import_warnings.append(\n                f\"Server '{server_name}' has no upstream - using direct proxy\"\n            )\n            return None\n\n        upstream_config = upstreams.get(upstream_name)\n        if not upstream_config:\n            return None\n\n        service_name = server_name or upstream_name\n\n        # Build upstream\n        targets = []\n        for server in upstream_config[\"servers\"]:\n            targets.append(UpstreamTarget(\n                host=server[\"host\"],\n                port=server[\"port\"],\n                weight=server.get(\"weight\", 1)\n            ))\n\n        # Health check (passive only in Nginx OSS)\n        health_check = None\n        if any(s.get(\"max_fails\") for s in upstream_config[\"servers\"]):\n            health_check = HealthCheckConfig(\n                passive=PassiveHealthCheck(\n                    enabled=True,\n                    max_failures=upstream_config[\"servers\"][0].get(\"max_fails\", 3)\n                )\n            )\n\n        upstream = UpstreamConfig(\n            targets=targets,\n            load_balancer=LoadBalancerConfig(\n                algorithm=upstream_config[\"algorithm\"]\n            ),\n            health_check=health_check\n        )\n\n        # Build routes\n        routes = []\n        for location in locations:\n            route = Route(\n                path_prefix=location[\"path\"],\n                rate_limit=location.get(\"rate_limit\"),\n                authentication=location.get(\"authentication\"),\n                headers=location.get(\"headers\"),\n                cors=location.get(\"cors\")\n            )\n            routes.append(route)\n\n        return Service(\n            name=service_name,\n            upstream=upstream,\n            routes=routes\n        )\n\n    def _parse_location(\n        self,\n        location_directive: NginxDirective,\n        upstreams: Dict[str, Any]\n    ) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Parse nginx location block to route.\"\"\"\n        # Location path\n        path = location_directive.args[0] if location_directive.args else \"/\"\n\n        location_config = {\n            \"path\": path\n        }\n\n        # Parse directives in location block\n        for directive in location_directive.block:\n            if directive.name == \"proxy_pass\":\n                proxy_pass = directive.args[0] if directive.args else None\n\n                # Extract upstream name from proxy_pass\n                # Format: http://upstream_name\n                if proxy_pass and proxy_pass.startswith(\"http://\"):\n                    upstream_name = proxy_pass[7:].rstrip(\"/\")\n                    location_config[\"upstream_name\"] = upstream_name\n\n            elif directive.name == \"limit_req\":\n                # Rate limiting\n                # Format: limit_req zone=mylimit burst=20 nodelay;\n                zone = None\n                burst = None\n\n                for arg in directive.args:\n                    if arg.startswith(\"zone=\"):\n                        zone = arg.split(\"=\")[1]\n                    elif arg.startswith(\"burst=\"):\n                        burst = int(arg.split(\"=\")[1])\n\n                location_config[\"rate_limit\"] = RateLimitConfig(\n                    enabled=True,\n                    requests_per_second=10,  # Extracted from zone definition\n                    burst=burst or 20\n                )\n\n            elif directive.name == \"auth_basic\":\n                # Basic authentication\n                location_config[\"authentication\"] = AuthenticationConfig(\n                    enabled=True,\n                    type=\"basic\",\n                    basic_auth=BasicAuth(users={})\n                )\n\n            elif directive.name == \"add_header\":\n                # Response headers\n                header_name = directive.args[0] if len(directive.args) &gt; 0 else None\n                header_value = directive.args[1] if len(directive.args) &gt; 1 else \"\"\n\n                if not location_config.get(\"headers\"):\n                    location_config[\"headers\"] = HeadersConfig()\n\n                if not location_config[\"headers\"].response_add:\n                    location_config[\"headers\"].response_add = {}\n\n                location_config[\"headers\"].response_add[header_name] = header_value\n\n                # Check for CORS headers\n                if header_name and header_name.startswith(\"Access-Control-\"):\n                    self._extract_cors_from_header(location_config, header_name, header_value)\n\n        return location_config\n\n    def _extract_cors_from_header(\n        self,\n        location_config: Dict[str, Any],\n        header_name: str,\n        header_value: str\n    ):\n        \"\"\"Extract CORS config from Access-Control-* headers.\"\"\"\n        if \"cors\" not in location_config:\n            location_config[\"cors\"] = CorsConfig(enabled=True)\n\n        cors = location_config[\"cors\"]\n\n        if header_name == \"Access-Control-Allow-Origin\":\n            cors.allowed_origins = [header_value]\n        elif header_name == \"Access-Control-Allow-Methods\":\n            cors.allowed_methods = header_value.split(\",\")\n        elif header_name == \"Access-Control-Allow-Headers\":\n            cors.allowed_headers = header_value.split(\",\")\n        elif header_name == \"Access-Control-Allow-Credentials\":\n            cors.allow_credentials = header_value.lower() == \"true\"\n        elif header_name == \"Access-Control-Max-Age\":\n            cors.max_age = header_value\n\n    def get_import_warnings(self) -&gt; List[str]:\n        \"\"\"Return warnings from last import.\"\"\"\n        return getattr(self, '_import_warnings', [])\n</code></pre>"},{"location":"import/nginx/#feature-mapping-matrix","title":"Feature Mapping Matrix","text":"GAL Feature Nginx Config Mapping Service <code>server</code> block + <code>server_name</code> Derived from upstream name Upstream Targets <code>upstream { server host:port; }</code> Direct mapping Load Balancing <code>least_conn</code>, <code>ip_hash</code> Default: round_robin Passive Health Checks <code>server ... max_fails=N fail_timeout=Ns</code> \u2705 Direct mapping Active Health Checks - \u274c Nginx Plus only Routes <code>location /path</code> Direct mapping Rate Limiting <code>limit_req zone=... burst=...</code> \u26a0\ufe0f Requires zone definition Basic Auth <code>auth_basic</code>, <code>auth_basic_user_file</code> \u2705 (users from htpasswd file) Headers <code>add_header</code>, <code>proxy_set_header</code> Direct mapping CORS <code>add_header Access-Control-*</code> Extracted from headers JWT Auth - \u274c Requires OpenResty/Lua"},{"location":"import/nginx/#beispiel-konvertierung","title":"Beispiel-Konvertierung","text":""},{"location":"import/nginx/#nginxconf-input","title":"nginx.conf (Input)","text":"<pre><code>events {\n    worker_connections 1024;\n}\n\nhttp {\n    upstream api_backend {\n        least_conn;\n\n        server api-1.internal:8080 weight=2 max_fails=3 fail_timeout=30s;\n        server api-2.internal:8080 weight=1 max_fails=3 fail_timeout=30s;\n    }\n\n    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;\n\n    server {\n        listen 80;\n        server_name api.example.com;\n\n        location /api {\n            limit_req zone=api_limit burst=20 nodelay;\n\n            proxy_pass http://api_backend;\n\n            proxy_set_header X-Gateway nginx;\n            proxy_set_header X-Real-IP $remote_addr;\n\n            add_header Access-Control-Allow-Origin \"https://app.example.com\";\n            add_header Access-Control-Allow-Methods \"GET, POST, PUT, DELETE\";\n            add_header Access-Control-Allow-Credentials \"true\";\n        }\n\n        location /admin {\n            auth_basic \"Admin Area\";\n            auth_basic_user_file /etc/nginx/.htpasswd;\n\n            proxy_pass http://api_backend;\n        }\n    }\n}\n</code></pre>"},{"location":"import/nginx/#gal-config-output","title":"GAL Config (Output)","text":"<pre><code>version: \"1.0\"\nprovider: nginx\n\nglobal_config:\n  host: 0.0.0.0\n  port: 80\n  timeout: 30s\n\nservices:\n  - name: api.example.com\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n          weight: 2\n        - host: api-2.internal\n          port: 8080\n          weight: 1\n\n      load_balancer:\n        algorithm: least_conn\n\n      health_check:\n        passive:\n          enabled: true\n          max_failures: 3\n\n    routes:\n      - path_prefix: /api\n\n        rate_limit:\n          enabled: true\n          requests_per_second: 10\n          burst: 20\n          key_type: ip_address\n\n        headers:\n          request_add:\n            X-Gateway: nginx\n            X-Real-IP: \"{{client_ip}}\"\n\n        cors:\n          enabled: true\n          allowed_origins:\n            - https://app.example.com\n          allowed_methods:\n            - GET\n            - POST\n            - PUT\n            - DELETE\n          allow_credentials: true\n\n      - path_prefix: /admin\n\n        authentication:\n          enabled: true\n          type: basic\n          basic_auth:\n            users: {}  # From .htpasswd file\n</code></pre>"},{"location":"import/nginx/#cli-usage","title":"CLI Usage","text":"<pre><code># Import nginx.conf\ngal import --provider nginx --input /etc/nginx/nginx.conf --output gal-config.yaml\n\n# Generate for different provider\ngal generate --config gal-config.yaml --provider haproxy --output haproxy.cfg\n</code></pre>"},{"location":"import/nginx/#test-cases","title":"Test Cases","text":"<p>30+ Tests (komplexer wegen Custom Parser): - Parser Tests (directive parsing, blocks, comments) - Upstream parsing - Server block parsing - Location block parsing - Rate limiting (limit_req_zone + limit_req) - Basic auth - Headers (proxy_set_header, add_header) - CORS extraction - Load balancing algorithms - Passive health checks - Include directive handling - Round-trip test</p>"},{"location":"import/nginx/#edge-cases-und-herausforderungen","title":"Edge Cases und Herausforderungen","text":""},{"location":"import/nginx/#parser-spezifisch","title":"Parser-spezifisch","text":"<ul> <li>Include-Dateien: <code>include /etc/nginx/conf.d/*.conf;</code></li> <li>L\u00f6sung: Rekursiver Parser oder Warnung</li> <li>Variablen: <code>$remote_addr</code>, <code>$request_id</code></li> <li>Mapping zu GAL template variables</li> <li>Regex Locations: <code>location ~ ^/api/.*$</code></li> <li>Vereinfachung zu path_prefix</li> <li>If-Direktiven: <code>if ($http_user_agent ~* bot)</code></li> <li>Nicht mappbar, Warnung</li> </ul>"},{"location":"import/nginx/#feature-spezifisch","title":"Feature-spezifisch","text":"<ul> <li>Rate Limiting: Requires <code>limit_req_zone</code> definition au\u00dferhalb location</li> <li>Parser muss zones tracken und zuordnen</li> <li>htpasswd Dateien: Users extern in Datei</li> <li>Nur Platzhalter importiert, manuelle Konfiguration</li> <li>Nginx Plus: Features wie active health checks nicht in OSS</li> <li>Warnung</li> </ul>"},{"location":"import/nginx/#akzeptanzkriterien","title":"Akzeptanzkriterien","text":"<ul> <li>\u2705 Custom Parser f\u00fcr nginx.conf Syntax</li> <li>\u2705 Import von upstream + server + location</li> <li>\u2705 Mapping von Direktiven zu GAL Features</li> <li>\u2705 Rate Limiting (zone-based)</li> <li>\u2705 Basic Auth Import</li> <li>\u2705 Headers + CORS</li> <li>\u2705 Include-Datei Unterst\u00fctzung (oder Warnung)</li> <li>\u2705 CLI Integration</li> <li>\u2705 30+ Tests, 85%+ Coverage (Parser komplex)</li> <li>\u2705 Warnings f\u00fcr nicht unterst\u00fctzte Features</li> <li>\u2705 Round-trip Test</li> </ul>"},{"location":"import/nginx/#implementierungs-reihenfolge","title":"Implementierungs-Reihenfolge","text":"<ol> <li>Tag 1-3: NginxConfigParser (Lexer/Parser)</li> <li>Tag 4-5: Upstream + Server Parsing</li> <li>Tag 6-7: Location + Rate Limiting</li> <li>Tag 8-9: Auth + Headers + CORS</li> <li>Tag 10-12: Tests + Edge Cases + Documentation</li> <li>Tag 13-14: Include Support + Integration</li> </ol>"},{"location":"import/nginx/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<p>Nach Completion: 1. Release als v1.3.0-beta1 2. User Feedback (Parser Robustheit) 3. HAProxy Import (Feature 6) beginnen</p>"},{"location":"import/traefik/","title":"Feature 4: Traefik Import (YAML Parser)","text":"<p>Status: \ud83d\udd04 Geplant Aufwand: 1 Woche Release: v1.3.0-alpha2 (Woche 4) Priorit\u00e4t: \ud83d\udfe1 Mittel</p>"},{"location":"import/traefik/#ubersicht","title":"\u00dcbersicht","text":"<p>Import von Traefik Static/Dynamic Configuration (YAML) nach GAL. Traefik wird in alpha2 mit APISIX implementiert: - Traefik verwendet File Provider f\u00fcr static config - Dynamic Configuration f\u00fcr Services/Routes/Middlewares - Weit verbreitet in Cloud-Native/Kubernetes Umgebungen</p>"},{"location":"import/traefik/#implementierung","title":"Implementierung","text":""},{"location":"import/traefik/#providerparse-methode","title":"Provider.parse() Methode","text":"<pre><code>class TraefikProvider(Provider):\n    \"\"\"Traefik Proxy Provider with Import Support.\"\"\"\n\n    def parse(self, provider_config: str) -&gt; Config:\n        \"\"\"Parse Traefik YAML config to GAL format.\n\n        Traefik has static config (entrypoints, providers) and\n        dynamic config (routers, services, middlewares).\n\n        Args:\n            provider_config: Traefik YAML configuration string (dynamic config)\n\n        Returns:\n            Config: GAL configuration object\n\n        Raises:\n            ValueError: If config is invalid\n        \"\"\"\n        try:\n            traefik_config = yaml.safe_load(provider_config)\n        except yaml.YAMLError as e:\n            raise ValueError(f\"Invalid YAML: {e}\")\n\n        self._import_warnings = []\n\n        # Traefik structure: http.routers, http.services, http.middlewares\n        return Config(\n            version=\"1.0\",\n            provider=\"traefik\",\n            global_config=self._parse_global(traefik_config),\n            services=self._parse_services(traefik_config)\n        )\n\n    def _parse_global(self, traefik_config: dict) -&gt; GlobalConfig:\n        \"\"\"Extract global config from Traefik.\"\"\"\n        # Traefik doesn't have global config in dynamic config\n        # Static config defines entrypoints\n        return GlobalConfig(\n            host=\"0.0.0.0\",\n            port=80,  # Default HTTP entrypoint\n            timeout=\"30s\"\n        )\n\n    def _parse_services(self, traefik_config: dict) -&gt; List[Service]:\n        \"\"\"Parse Traefik services to GAL services.\"\"\"\n        gal_services = []\n\n        http_config = traefik_config.get(\"http\", {})\n        traefik_services = http_config.get(\"services\", {})\n        traefik_routers = http_config.get(\"routers\", {})\n        traefik_middlewares = http_config.get(\"middlewares\", {})\n\n        for service_name, service_config in traefik_services.items():\n            service = self._parse_service(\n                service_name,\n                service_config,\n                traefik_routers,\n                traefik_middlewares\n            )\n            if service:\n                gal_services.append(service)\n\n        return gal_services\n\n    def _parse_service(\n        self,\n        service_name: str,\n        service_config: dict,\n        traefik_routers: dict,\n        traefik_middlewares: dict\n    ) -&gt; Optional[Service]:\n        \"\"\"Convert Traefik service to GAL service.\"\"\"\n        # Parse load balancer config\n        load_balancer = service_config.get(\"loadBalancer\", {})\n\n        if not load_balancer:\n            return None\n\n        # Parse servers (targets)\n        servers = load_balancer.get(\"servers\", [])\n        targets = []\n\n        for server in servers:\n            url = server.get(\"url\")  # Format: \"http://host:port\"\n\n            if not url:\n                continue\n\n            # Parse URL\n            from urllib.parse import urlparse\n            parsed = urlparse(url)\n\n            host = parsed.hostname\n            port = parsed.port or 80\n\n            targets.append(UpstreamTarget(host=host, port=port))\n\n        # Parse health check\n        health_check = self._parse_health_check(load_balancer)\n\n        # Parse sticky sessions\n        sticky = load_balancer.get(\"sticky\", {})\n        sticky_sessions = sticky.get(\"cookie\") is not None\n\n        cookie_name = None\n        if sticky_sessions:\n            cookie_config = sticky.get(\"cookie\", {})\n            cookie_name = cookie_config.get(\"name\", \"lb\")\n\n        # Upstream config\n        upstream = UpstreamConfig(\n            targets=targets,\n            load_balancer=LoadBalancerConfig(\n                algorithm=\"round_robin\",  # Traefik default\n                sticky_sessions=sticky_sessions,\n                cookie_name=cookie_name\n            ),\n            health_check=health_check\n        )\n\n        # Parse routes for this service\n        routes = []\n        for router_name, router_config in traefik_routers.items():\n            if router_config.get(\"service\") == service_name:\n                route = self._parse_router(\n                    router_name,\n                    router_config,\n                    traefik_middlewares\n                )\n                if route:\n                    routes.append(route)\n\n        return Service(\n            name=service_name,\n            upstream=upstream,\n            routes=routes\n        )\n\n    def _parse_health_check(self, load_balancer: dict) -&gt; Optional[HealthCheckConfig]:\n        \"\"\"Parse Traefik health check.\"\"\"\n        health_check = load_balancer.get(\"healthCheck\", {})\n\n        if not health_check:\n            return None\n\n        path = health_check.get(\"path\", \"/health\")\n        interval = health_check.get(\"interval\", \"30s\")\n        timeout = health_check.get(\"timeout\", \"5s\")\n\n        # Traefik only supports passive health checks by default\n        # Active health checks in Traefik Plus\n        self._import_warnings.append(\n            \"Traefik OSS only supports passive health checks - config may be simplified\"\n        )\n\n        return HealthCheckConfig(\n            passive=PassiveHealthCheck(\n                enabled=True,\n                max_failures=3  # Default\n            )\n        )\n\n    def _parse_router(\n        self,\n        router_name: str,\n        router_config: dict,\n        traefik_middlewares: dict\n    ) -&gt; Optional[Route]:\n        \"\"\"Parse Traefik router to GAL route.\"\"\"\n        # Parse rule (Traefik matcher)\n        rule = router_config.get(\"rule\", \"\")\n\n        if not rule:\n            return None\n\n        # Extract path from rule (simplified)\n        # Example: \"PathPrefix(`/api`)\"\n        path_prefix = self._extract_path_from_rule(rule)\n\n        # Parse middlewares\n        middleware_names = router_config.get(\"middlewares\", [])\n\n        rate_limit = None\n        authentication = None\n        headers = None\n        cors = None\n\n        for middleware_name in middleware_names:\n            if middleware_name not in traefik_middlewares:\n                continue\n\n            middleware_config = traefik_middlewares[middleware_name]\n\n            if \"rateLimit\" in middleware_config:\n                rate_limit = self._parse_rate_limit_middleware(\n                    middleware_config[\"rateLimit\"]\n                )\n            elif \"basicAuth\" in middleware_config:\n                authentication = self._parse_basic_auth_middleware(\n                    middleware_config[\"basicAuth\"]\n                )\n            elif \"headers\" in middleware_config:\n                headers = self._parse_headers_middleware(\n                    middleware_config[\"headers\"]\n                )\n            elif \"addPrefix\" in middleware_config or \"stripPrefix\" in middleware_config:\n                # Path manipulation - not directly mappable to GAL\n                self._import_warnings.append(\n                    f\"Path manipulation middleware '{middleware_name}' not imported\"\n                )\n\n        # Check for CORS in headers middleware\n        if headers and headers.response_add:\n            cors = self._extract_cors_from_headers(headers)\n\n        return Route(\n            path_prefix=path_prefix,\n            rate_limit=rate_limit,\n            authentication=authentication,\n            headers=headers,\n            cors=cors\n        )\n\n    def _extract_path_from_rule(self, rule: str) -&gt; str:\n        \"\"\"Extract path from Traefik rule.\"\"\"\n        # Simple extraction for PathPrefix\n        # Example: \"PathPrefix(`/api`)\" \u2192 \"/api\"\n        # Example: \"Host(`example.com`) &amp;&amp; PathPrefix(`/api`)\" \u2192 \"/api\"\n\n        import re\n\n        path_match = re.search(r\"PathPrefix\\(`([^`]+)`\\)\", rule)\n        if path_match:\n            return path_match.group(1)\n\n        path_match = re.search(r\"Path\\(`([^`]+)`\\)\", rule)\n        if path_match:\n            return path_match.group(1)\n\n        # Default\n        return \"/\"\n\n    def _parse_rate_limit_middleware(self, config: dict) -&gt; RateLimitConfig:\n        \"\"\"Parse Traefik rateLimit middleware.\"\"\"\n        average = config.get(\"average\", 100)\n        burst = config.get(\"burst\", 200)\n\n        # Traefik average is per second\n        return RateLimitConfig(\n            enabled=True,\n            requests_per_second=average,\n            burst=burst,\n            key_type=\"ip_address\"\n        )\n\n    def _parse_basic_auth_middleware(self, config: dict) -&gt; AuthenticationConfig:\n        \"\"\"Parse Traefik basicAuth middleware.\"\"\"\n        users = config.get(\"users\", [])\n\n        # Users are hashed in Traefik, cannot import plaintext\n        self._import_warnings.append(\n            \"Basic auth users are hashed - configure manually in GAL\"\n        )\n\n        return AuthenticationConfig(\n            enabled=True,\n            type=\"basic\",\n            basic_auth=BasicAuth(users={})\n        )\n\n    def _parse_headers_middleware(self, config: dict) -&gt; HeadersConfig:\n        \"\"\"Parse Traefik headers middleware.\"\"\"\n        custom_request_headers = config.get(\"customRequestHeaders\", {})\n        custom_response_headers = config.get(\"customResponseHeaders\", {})\n\n        request_add = custom_request_headers if custom_request_headers else None\n        response_add = custom_response_headers if custom_response_headers else None\n\n        return HeadersConfig(\n            request_add=request_add,\n            response_add=response_add\n        )\n\n    def _extract_cors_from_headers(self, headers: HeadersConfig) -&gt; Optional[CorsConfig]:\n        \"\"\"Extract CORS config from response headers.\"\"\"\n        if not headers.response_add:\n            return None\n\n        cors_headers = {}\n        for key, value in headers.response_add.items():\n            if key.startswith(\"Access-Control-\"):\n                cors_headers[key] = value\n\n        if not cors_headers:\n            return None\n\n        # Build CORS config\n        allowed_origins = cors_headers.get(\"Access-Control-Allow-Origin\", \"*\").split(\",\")\n        allowed_methods_str = cors_headers.get(\"Access-Control-Allow-Methods\", \"GET,POST,PUT,DELETE\")\n        allowed_methods = allowed_methods_str.split(\",\")\n        allowed_headers_str = cors_headers.get(\"Access-Control-Allow-Headers\")\n        allowed_headers = allowed_headers_str.split(\",\") if allowed_headers_str else None\n        allow_credentials = cors_headers.get(\"Access-Control-Allow-Credentials\") == \"true\"\n        max_age = cors_headers.get(\"Access-Control-Max-Age\", \"86400\")\n\n        # Remove CORS headers from response_add (they're now in cors config)\n        for key in list(headers.response_add.keys()):\n            if key.startswith(\"Access-Control-\"):\n                del headers.response_add[key]\n\n        return CorsConfig(\n            enabled=True,\n            allowed_origins=allowed_origins,\n            allowed_methods=allowed_methods,\n            allowed_headers=allowed_headers,\n            allow_credentials=allow_credentials,\n            max_age=max_age\n        )\n\n    def get_import_warnings(self) -&gt; List[str]:\n        \"\"\"Return warnings from last import.\"\"\"\n        return getattr(self, '_import_warnings', [])\n</code></pre>"},{"location":"import/traefik/#feature-mapping-matrix","title":"Feature Mapping Matrix","text":"GAL Feature Traefik Config Mapping Service <code>http.services.&lt;name&gt;</code> Direct mapping Upstream Targets <code>loadBalancer.servers[].url</code> URL parsing \u2192 host:port Load Balancing <code>loadBalancer</code> (implicit) Default: round_robin Passive Health Checks <code>loadBalancer.healthCheck</code> \u2705 OSS support Active Health Checks - \u274c Traefik Plus only Sticky Sessions <code>loadBalancer.sticky.cookie</code> \u2705 Direct mapping Routes <code>http.routers.&lt;name&gt;</code> rule \u2192 path_prefix Rate Limiting <code>middlewares.&lt;name&gt;.rateLimit</code> average \u2192 requests_per_second Basic Auth <code>middlewares.&lt;name&gt;.basicAuth</code> \u26a0\ufe0f Users hashed Headers <code>middlewares.&lt;name&gt;.headers</code> customRequestHeaders/customResponseHeaders CORS headers middleware (Access-Control-*) Extracted from headers JWT Auth <code>middlewares.&lt;name&gt;.forwardAuth</code> \u26a0\ufe0f External auth service"},{"location":"import/traefik/#beispiel-konvertierung","title":"Beispiel-Konvertierung","text":""},{"location":"import/traefik/#traefik-config-input","title":"Traefik Config (Input)","text":"<pre><code>http:\n  routers:\n    api-router:\n      rule: \"PathPrefix(`/api`)\"\n      service: api-service\n      middlewares:\n        - api-rate-limit\n        - api-headers\n\n  services:\n    api-service:\n      loadBalancer:\n        servers:\n          - url: \"http://api-1.internal:8080\"\n          - url: \"http://api-2.internal:8080\"\n        healthCheck:\n          path: /health\n          interval: 10s\n          timeout: 5s\n        sticky:\n          cookie:\n            name: traefik-session\n\n  middlewares:\n    api-rate-limit:\n      rateLimit:\n        average: 100\n        burst: 200\n\n    api-headers:\n      headers:\n        customRequestHeaders:\n          X-Gateway: Traefik\n        customResponseHeaders:\n          Access-Control-Allow-Origin: \"https://app.example.com\"\n          Access-Control-Allow-Methods: \"GET,POST,PUT,DELETE\"\n          Access-Control-Allow-Credentials: \"true\"\n</code></pre>"},{"location":"import/traefik/#gal-config-output","title":"GAL Config (Output)","text":"<pre><code>version: \"1.0\"\nprovider: traefik\n\nglobal_config:\n  host: 0.0.0.0\n  port: 80\n  timeout: 30s\n\nservices:\n  - name: api-service\n    upstream:\n      targets:\n        - host: api-1.internal\n          port: 8080\n        - host: api-2.internal\n          port: 8080\n\n      load_balancer:\n        algorithm: round_robin\n        sticky_sessions: true\n        cookie_name: traefik-session\n\n      health_check:\n        passive:\n          enabled: true\n          max_failures: 3\n\n    routes:\n      - path_prefix: /api\n\n        rate_limit:\n          enabled: true\n          requests_per_second: 100\n          burst: 200\n          key_type: ip_address\n\n        headers:\n          request_add:\n            X-Gateway: Traefik\n\n        cors:\n          enabled: true\n          allowed_origins:\n            - https://app.example.com\n          allowed_methods:\n            - GET\n            - POST\n            - PUT\n            - DELETE\n          allow_credentials: true\n</code></pre>"},{"location":"import/traefik/#cli-usage","title":"CLI Usage","text":"<pre><code># Import Traefik config\ngal import --provider traefik --input traefik.yaml --output gal-config.yaml\n\n# Generate for different provider\ngal generate --config gal-config.yaml --provider kong --output kong.yaml\n</code></pre>"},{"location":"import/traefik/#test-cases","title":"Test Cases","text":"<p>20+ Tests: - Basic import (routers, services) - Load balancer servers - Health checks (passive) - Sticky sessions - Rate limiting middleware - Basic auth middleware - Headers middleware - CORS extraction from headers - Path extraction from rules - Round-trip test</p>"},{"location":"import/traefik/#edge-cases","title":"Edge Cases","text":"<ul> <li>Traefik Plus Features: Active health checks nicht in OSS</li> <li>ForwardAuth: External auth services nicht gemappt</li> <li>Path Manipulation: stripPrefix, addPrefix nicht mappbar</li> <li>TCP/UDP: Nur HTTP unterst\u00fctzt</li> <li>Dynamic Providers: Nur File Provider</li> </ul>"},{"location":"import/traefik/#akzeptanzkriterien","title":"Akzeptanzkriterien","text":"<ul> <li>\u2705 Import von Traefik Dynamic Config (YAML)</li> <li>\u2705 Mapping von Services/Routers/Middlewares</li> <li>\u2705 Sticky Sessions Support</li> <li>\u2705 CORS Extraktion aus Headers</li> <li>\u2705 CLI Integration</li> <li>\u2705 20+ Tests, 90%+ Coverage</li> <li>\u2705 Warnings f\u00fcr Traefik Plus Features</li> <li>\u2705 Round-trip Test</li> </ul>"},{"location":"import/traefik/#implementierungs-reihenfolge","title":"Implementierungs-Reihenfolge","text":"<ol> <li>Tag 1-2: parse() + Service/Router Parsing</li> <li>Tag 3: Load Balancer + Sticky Sessions</li> <li>Tag 4: Middlewares (rate-limit, headers)</li> <li>Tag 5: CORS Extraction + Auth</li> <li>Tag 6-7: Tests + Documentation</li> </ol>"},{"location":"import/traefik/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<p>Nach Completion: 1. Release als v1.3.0-alpha2 (mit APISIX) 2. User Feedback 3. Nginx Import (Feature 5) beginnen</p>"}]}