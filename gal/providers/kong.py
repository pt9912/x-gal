"""
Kong API Gateway provider implementation.

Generates Kong declarative configuration (DB-less mode) in YAML format
with support for services, routes, and plugin-based transformations.
"""

from ..provider import Provider
from ..config import Config


class KongProvider(Provider):
    """Kong API Gateway provider.

    Generates declarative configuration for Kong Gateway in DB-less mode.
    Kong is a plugin-based API gateway with extensive enterprise features
    and a rich ecosystem of plugins.

    Output Format:
        YAML file in Kong Declarative Configuration format (v3.0):
        - _format_version: Version identifier
        - services: Service definitions with routes
        - routes: Path-based routing rules
        - plugins: Request transformer and other plugins

    Transformations:
        Implemented using Kong's request-transformer plugin.
        Default values are added as custom headers (x-default-*).
        Note: Computed fields (UUID, timestamp) are not natively supported
        and would require custom plugin development.

    gRPC Support:
        Native support via protocol: grpc in service definitions.
        Automatic HTTP/2 handling by Kong.

    Limitations:
        - Computed fields require custom plugins
        - Defaults added as headers, not body fields
        - Advanced transformations need Lua plugins

    Example:
        >>> provider = KongProvider()
        >>> provider.name()
        'kong'
        >>> config = Config.from_yaml("gateway.yaml")
        >>> output = provider.generate(config)
        >>> "_format_version:" in output
        True

    See Also:
        https://docs.konghq.com/gateway/latest/production/deployment-topologies/db-less-and-declarative-config/
    """

    def name(self) -> str:
        """Return provider name.

        Returns:
            str: "kong"
        """
        return "kong"

    def validate(self, config: Config) -> bool:
        """Validate configuration for Kong.

        Kong has minimal validation requirements. Most configurations
        are accepted and validated by Kong at runtime.

        Args:
            config: Configuration to validate

        Returns:
            True (Kong validates at runtime)

        Example:
            >>> provider = KongProvider()
            >>> config = Config(...)
            >>> provider.validate(config)
            True
        """
        return True

    def generate(self, config: Config) -> str:
        """Generate Kong declarative configuration in YAML format.

        Creates a Kong declarative config file (v3.0) with services,
        routes, and transformation plugins.

        Configuration Structure:
            - _format_version: '3.0'
            - services: Service and route definitions
            - plugins: Global and service-specific plugins

        Args:
            config: Configuration object containing services

        Returns:
            Complete Kong declarative YAML configuration

        Example:
            >>> provider = KongProvider()
            >>> config = Config.from_yaml("config.yaml")
            >>> yaml_output = provider.generate(config)
            >>> "services:" in yaml_output
            True
            >>> "routes:" in yaml_output
            True
        """
        output = []
        output.append("# Kong Declarative Configuration Generated by GAL")
        output.append("_format_version: '3.0'")
        output.append("")
        output.append("services:")
        
        for service in config.services:
            output.append(f"- name: {service.name}")
            if service.type == "grpc":
                output.append("  protocol: grpc")
            else:
                output.append("  protocol: http")
            output.append(f"  host: {service.upstream.host}")
            output.append(f"  port: {service.upstream.port}")
            output.append("  routes:")
            
            for route in service.routes:
                output.append(f"  - name: {service.name}_route")
                output.append("    paths:")
                output.append(f"    - {route.path_prefix}")
                if route.methods:
                    output.append("    methods:")
                    for method in route.methods:
                        output.append(f"    - {method}")
            
            # Add transformation plugin if enabled
            if service.transformation and service.transformation.enabled:
                output.append("  plugins:")
                output.append("  - name: request-transformer")
                output.append("    config:")
                output.append("      add:")
                output.append("        headers:")
                for key, value in service.transformation.defaults.items():
                    output.append(f"        - x-default-{key}: '{value}'")
            
            output.append("")
        
        return "\n".join(output)
