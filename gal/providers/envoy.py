"""
Envoy Proxy provider implementation.

Generates Envoy Proxy static configuration in YAML format with support
for HTTP/2, gRPC, and Lua-based request transformations.
"""

import logging
import os
from typing import Any, Dict, List, Optional, Tuple

import requests
import yaml

from ..config import (
    ActiveHealthCheck,
    AdvancedHeaderMatchRule,
    AdvancedRoutingConfig,
    AdvancedRoutingTarget,
    Config,
    GlobalConfig,
    GeoMatchRule,
    GeoIPFilterConfig,
    GrpcTransformation,
    HealthCheckConfig,
    JWTClaimMatchRule,
    JWTFilterConfig,
    LoadBalancerConfig,
    MirroringConfig,
    PassiveHealthCheck,
    ProtoDescriptor,
    QueryParamMatchRule,
    Route,
    Service,
    TrafficSplitConfig,
    Upstream,
    UpstreamTarget,
)
from ..proto_manager import ProtoManager
from ..provider import Provider
from .envoy_advanced_routing_filters import (
    generate_jwt_authn_filter,
    generate_geoip_ext_authz_filter,
    generate_lua_filter_for_advanced_routing,
    generate_jwks_cluster,
    generate_geoip_cluster,
)

logger = logging.getLogger(__name__)


class EnvoyProvider(Provider):
    """Envoy Proxy gateway provider.

    Generates static configuration for Envoy Proxy, a high-performance
    C++ based edge and service proxy. Supports both REST and gRPC services
    with native HTTP/2 support.

    Output Format:
        YAML file with static_resources configuration including:
        - Listeners with HTTP connection manager
        - Routes with prefix matching
        - Clusters with health checking and load balancing
        - Optional Lua filters for request transformations
        - Admin interface configuration

    Transformations:
        Implemented using Envoy's Lua filter (envoy.filters.http.lua).
        Provides inline Lua code for:
        - Setting default field values
        - Generating computed fields (UUID, timestamp)
        - Request body manipulation

    gRPC Support:
        Automatic HTTP/2 protocol configuration for gRPC services.
        Uses http2_protocol_options on clusters.

    Example:
        >>> provider = EnvoyProvider()
        >>> provider.name()
        'envoy'
        >>> config = Config.from_yaml("gateway.yaml")
        >>> output = provider.generate(config)
        >>> "static_resources:" in output
        True

    See Also:
        https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/overview
    """

    def name(self) -> str:
        """Return provider name.

        Returns:
            str: "envoy"
        """
        return "envoy"

    def validate(self, config: Config) -> bool:
        """Validate configuration for Envoy.

        Ensures that required configuration parameters are present
        and valid for Envoy deployment.

        Args:
            config: Configuration to validate

        Returns:
            True if validation passes

        Raises:
            ValueError: If port is 0 or invalid

        Example:
            >>> provider = EnvoyProvider()
            >>> config = Config(version="1.0", provider="envoy",
            ...                 global_config=GlobalConfig(port=8080),
            ...                 services=[])
            >>> provider.validate(config)
            True
        """
        logger.debug(f"Validating Envoy configuration: {len(config.services)} services")
        if config.global_config.port == 0:
            logger.error("Envoy validation failed: Port must be specified")
            raise ValueError("Port must be specified")
        logger.debug("Envoy validation successful")
        return True

    def generate(self, config: Config) -> str:
        """Generate Envoy static configuration in YAML format.

        Creates a complete Envoy static_resources configuration including
        listeners, routes, clusters, and optional Lua transformation filters.

        Configuration Structure:
            - static_resources:
                - listeners: HTTP connection manager with routes
                - clusters: Upstream service definitions
            - admin: Admin interface configuration

        Args:
            config: Configuration object containing services and settings

        Returns:
            Complete Envoy YAML configuration as string

        Example:
            >>> provider = EnvoyProvider()
            >>> config = Config.from_yaml("config.yaml")
            >>> yaml_output = provider.generate(config)
            >>> "listeners:" in yaml_output
            True
            >>> "clusters:" in yaml_output
            True
        """
        logger.info(f"Generating Envoy configuration for {len(config.services)} services")
        output = []
        output.append("# Envoy Configuration Generated by GAL")
        output.append(f"# Provider: {config.provider}")
        output.append(
            f"# Services: {len(config.services)} ({len(config.get_grpc_services())} gRPC, {len(config.get_rest_services())} REST)"
        )
        output.append("")

        # Static resources
        output.append("static_resources:")
        output.append("  listeners:")
        output.append("  - name: listener_0")
        output.append("    address:")
        output.append("      socket_address:")
        output.append(f"        address: {config.global_config.host}")
        output.append(f"        port_value: {config.global_config.port}")
        output.append("    filter_chains:")
        output.append("    - filters:")
        output.append("      - name: envoy.filters.network.http_connection_manager")
        output.append("        typed_config:")
        output.append(
            "          '@type': type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager"
        )
        output.append("          stat_prefix: ingress_http")
        output.append("          codec_type: AUTO")
        output.append("          route_config:")
        output.append("            name: local_route")
        output.append("            virtual_hosts:")
        output.append("            - name: backend")
        output.append("              domains: ['*']")
        output.append("              routes:")

        # Routes
        for service in config.services:
            for route in service.routes:
                # Check for advanced routing first - it generates multiple route entries
                if route.advanced_routing and route.advanced_routing.enabled:
                    self._generate_advanced_routing_routes(service, route, output)
                else:
                    # Single route entry for non-advanced routing
                    output.append(f"              - match:")
                    output.append(f"                  prefix: '{route.path_prefix}'")
                    if service.type == "grpc":
                        output.append("                  grpc: {}")

                    # Check for traffic splitting
                    if route.traffic_split and route.traffic_split.enabled:
                        self._generate_weighted_clusters(service, route, output)
                    else:
                        output.append("                route:")
                        output.append(f"                  cluster: {service.name}_cluster")

                # Add request mirroring if configured
                if route.mirroring and route.mirroring.enabled:
                    self._generate_request_mirror_policies(service, route, output)

                # Add timeout configuration if specified
                if route.timeout:
                    timeout = route.timeout
                    # Envoy uses timeout on route level for overall request timeout
                    output.append(f"                  timeout: {timeout.read}")
                    # idle_timeout for keep-alive connections
                    output.append(f"                  idle_timeout: {timeout.idle}")

                # Add retry policy if configured
                if route.retry and route.retry.enabled:
                    retry = route.retry
                    output.append("                  retry_policy:")
                    output.append(f"                    num_retries: {retry.attempts}")

                    # Map retry_on conditions to Envoy format
                    retry_conditions = []
                    for condition in retry.retry_on:
                        if condition == "connect_timeout":
                            retry_conditions.append("connect-failure")
                        elif condition == "http_5xx":
                            retry_conditions.append("5xx")
                        elif condition == "http_502":
                            retry_conditions.append("retriable-status-codes")
                        elif condition == "http_503":
                            retry_conditions.append("retriable-status-codes")
                        elif condition == "http_504":
                            retry_conditions.append("retriable-status-codes")
                        elif condition == "retriable_4xx":
                            retry_conditions.append("retriable-4xx")
                        elif condition == "reset":
                            retry_conditions.append("reset")
                        elif condition == "refused":
                            retry_conditions.append("refused-stream")

                    if retry_conditions:
                        output.append(
                            f"                    retry_on: {','.join(set(retry_conditions))}"
                        )

                    # Add retriable status codes if specified
                    retriable_codes = []
                    for condition in retry.retry_on:
                        if condition == "http_502":
                            retriable_codes.append(502)
                        elif condition == "http_503":
                            retriable_codes.append(503)
                        elif condition == "http_504":
                            retriable_codes.append(504)

                    if retriable_codes:
                        output.append("                    retriable_status_codes:")
                        for code in sorted(set(retriable_codes)):
                            output.append(f"                    - {code}")

                    # Add per-try timeout (base_interval for first try)
                    output.append(f"                    per_try_timeout: {retry.base_interval}")

                # Add WebSocket support if configured
                if route.websocket and route.websocket.enabled:
                    ws = route.websocket
                    output.append("                  upgrade_configs:")
                    output.append("                  - upgrade_type: websocket")
                    # Set idle timeout for WebSocket connections
                    output.append(f"                  idle_timeout: {ws.idle_timeout}")
                    # Note: max_message_size and ping_interval are handled at cluster level

                # Add route-level header manipulation
                if route.headers:
                    headers = route.headers
                    # Request headers
                    if headers.request_add or headers.request_set:
                        output.append("                request_headers_to_add:")
                        # Add headers (append: true keeps existing)
                        for key, value in headers.request_add.items():
                            output.append("                - header:")
                            output.append(f"                    key: {key}")
                            output.append(f"                    value: '{value}'")
                            output.append("                  append: true")
                        # Set headers (append: false overwrites existing)
                        for key, value in headers.request_set.items():
                            output.append("                - header:")
                            output.append(f"                    key: {key}")
                            output.append(f"                    value: '{value}'")
                            output.append("                  append: false")
                    if headers.request_remove:
                        output.append("                request_headers_to_remove:")
                        for header_name in headers.request_remove:
                            output.append(f"                - {header_name}")

                    # Response headers
                    if headers.response_add or headers.response_set:
                        output.append("                response_headers_to_add:")
                        # Add headers
                        for key, value in headers.response_add.items():
                            output.append("                - header:")
                            output.append(f"                    key: {key}")
                            output.append(f"                    value: '{value}'")
                            output.append("                  append: true")
                        # Set headers
                        for key, value in headers.response_set.items():
                            output.append("                - header:")
                            output.append(f"                    key: {key}")
                            output.append(f"                    value: '{value}'")
                            output.append("                  append: false")
                    if headers.response_remove:
                        output.append("                response_headers_to_remove:")
                        for header_name in headers.response_remove:
                            output.append(f"                - {header_name}")

                # Add service-level header manipulation if configured
                elif (
                    service.transformation
                    and service.transformation.enabled
                    and service.transformation.headers
                ):
                    headers = service.transformation.headers
                    # Request headers
                    if headers.request_add or headers.request_set:
                        output.append("                request_headers_to_add:")
                        for key, value in headers.request_add.items():
                            output.append("                - header:")
                            output.append(f"                    key: {key}")
                            output.append(f"                    value: '{value}'")
                            output.append("                  append: true")
                        for key, value in headers.request_set.items():
                            output.append("                - header:")
                            output.append(f"                    key: {key}")
                            output.append(f"                    value: '{value}'")
                            output.append("                  append: false")
                    if headers.request_remove:
                        output.append("                request_headers_to_remove:")
                        for header_name in headers.request_remove:
                            output.append(f"                - {header_name}")

                    # Response headers
                    if headers.response_add or headers.response_set:
                        output.append("                response_headers_to_add:")
                        for key, value in headers.response_add.items():
                            output.append("                - header:")
                            output.append(f"                    key: {key}")
                            output.append(f"                    value: '{value}'")
                            output.append("                  append: true")
                        for key, value in headers.response_set.items():
                            output.append("                - header:")
                            output.append(f"                    key: {key}")
                            output.append(f"                    value: '{value}'")
                            output.append("                  append: false")
                    if headers.response_remove:
                        output.append("                response_headers_to_remove:")
                        for header_name in headers.response_remove:
                            output.append(f"                - {header_name}")

                # Add CORS policy if configured
                if route.cors and route.cors.enabled:
                    cors = route.cors
                    output.append("                cors:")
                    output.append("                  allow_origin_string_match:")
                    for origin in cors.allowed_origins:
                        if origin == "*":
                            output.append("                  - safe_regex:")
                            output.append("                      regex: '.*'")
                        else:
                            output.append("                  - exact: '{}'".format(origin))
                    output.append(
                        "                  allow_methods: '{}'".format(
                            ", ".join(cors.allowed_methods)
                        )
                    )
                    output.append(
                        "                  allow_headers: '{}'".format(
                            ", ".join(cors.allowed_headers)
                        )
                    )
                    if cors.expose_headers:
                        output.append(
                            "                  expose_headers: '{}'".format(
                                ", ".join(cors.expose_headers)
                            )
                        )
                    output.append(
                        "                  allow_credentials: {}".format(
                            str(cors.allow_credentials).lower()
                        )
                    )
                    output.append("                  max_age: '{}'".format(cors.max_age))

        # Add WebSocket upgrade support if any route has WebSocket enabled
        has_websocket = any(
            route.websocket and route.websocket.enabled
            for service in config.services
            for route in service.routes
        )
        if has_websocket:
            output.append("          upgrade_configs:")
            output.append("          - upgrade_type: websocket")

        # Access logging
        if config.global_config and config.global_config.logging:
            self._generate_envoy_logging(config.global_config.logging, output)

        # HTTP filters
        output.append("          http_filters:")

        # Add authentication filter if any route has authentication enabled
        has_authentication = any(
            route.authentication and route.authentication.enabled
            for service in config.services
            for route in service.routes
        )
        if has_authentication:
            # Collect authentication configs
            jwt_configs = []
            basic_auth_configs = []
            api_key_configs = []

            for service in config.services:
                for route in service.routes:
                    if route.authentication and route.authentication.enabled:
                        auth = route.authentication
                        if auth.type == "jwt" and auth.jwt:
                            jwt_configs.append(auth.jwt)
                        elif auth.type == "basic" and auth.basic_auth:
                            basic_auth_configs.append(auth.basic_auth)
                        elif auth.type == "api_key" and auth.api_key:
                            api_key_configs.append(auth.api_key)

            # Add JWT authentication filter if needed
            if jwt_configs:
                jwt_config = jwt_configs[0]  # Use first JWT config
                output.append("          - name: envoy.filters.http.jwt_authn")
                output.append("            typed_config:")
                output.append(
                    "              '@type': type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication"
                )
                output.append("              providers:")
                output.append("                jwt_provider:")
                if jwt_config.issuer:
                    output.append(f"                  issuer: '{jwt_config.issuer}'")
                if jwt_config.audience:
                    output.append("                  audiences:")
                    output.append(f"                  - '{jwt_config.audience}'")
                if jwt_config.jwks_uri:
                    output.append("                  remote_jwks:")
                    output.append("                    http_uri:")
                    output.append(f"                      uri: '{jwt_config.jwks_uri}'")
                    output.append("                      cluster: jwks_cluster")
                    output.append("                      timeout: 5s")
                    output.append("                    cache_duration:")
                    output.append("                      seconds: 300")
                output.append("                  from_headers:")
                output.append("                  - name: Authorization")
                output.append("                    value_prefix: 'Bearer '")
                output.append("              rules:")
                output.append("              - match:")
                output.append("                  prefix: /")
                output.append("                requires:")
                output.append("                  provider_name: jwt_provider")

            # Add basic auth or API key validation via Lua filter
            if basic_auth_configs or api_key_configs:
                output.append("          - name: envoy.filters.http.lua")
                output.append("            typed_config:")
                output.append(
                    "              '@type': type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua"
                )
                output.append("              inline_code: |")
                output.append("                function envoy_on_request(request_handle)")

                if basic_auth_configs:
                    basic_config = basic_auth_configs[0]
                    output.append("                  -- Basic Authentication")
                    output.append(
                        "                  local auth_header = request_handle:headers():get('authorization')"
                    )
                    output.append(
                        "                  if auth_header and string.match(auth_header, '^Basic ') then"
                    )
                    output.append("                    -- Validate Basic Auth credentials here")
                    output.append(
                        "                    -- In production, decode base64 and check against user database"
                    )
                    output.append("                  else")
                    output.append("                    request_handle:respond(")
                    output.append("                      {[':status'] = '401',")
                    output.append(
                        f"                       ['www-authenticate'] = 'Basic realm=\"{basic_config.realm}\"'}},"
                    )
                    output.append("                      'Unauthorized')")
                    output.append("                    return")
                    output.append("                  end")

                if api_key_configs:
                    api_key_config = api_key_configs[0]
                    key_name = api_key_config.key_name
                    output.append("                  -- API Key Authentication")
                    output.append(
                        f"                  local api_key = request_handle:headers():get('{key_name.lower()}')"
                    )
                    output.append("                  if not api_key then")
                    output.append("                    request_handle:respond(")
                    output.append("                      {[':status'] = '401'},")
                    output.append("                      'Unauthorized: Missing API Key')")
                    output.append("                    return")
                    output.append("                  end")
                    output.append(
                        "                  -- Validate API key against database/cache here"
                    )

                output.append("                end")

        # Add Advanced Routing filters (JWT + GeoIP) if any route has advanced routing
        has_advanced_routing = any(
            route.advanced_routing and route.advanced_routing.enabled
            for service in config.services
            for route in service.routes
        )
        if has_advanced_routing:
            # Collect JWT and GeoIP filter configs
            jwt_filter_config = None
            geoip_filter_config = None

            for service in config.services:
                for route in service.routes:
                    if route.advanced_routing and route.advanced_routing.enabled:
                        ar_config = route.advanced_routing

                        # JWT Filter - check both rules AND explicit config
                        if ar_config.jwt_filter and ar_config.jwt_filter.enabled:
                            jwt_filter_config = ar_config.jwt_filter
                        elif ar_config.jwt_claim_rules and not jwt_filter_config:
                            # Auto-enable JWT filter if JWT rules exist but no config provided
                            logger.warning("JWT claim rules found but no jwt_filter config - skipping JWT filter")

                        # GeoIP Filter - check both rules AND explicit config
                        if ar_config.geoip_filter and ar_config.geoip_filter.enabled:
                            geoip_filter_config = ar_config.geoip_filter
                        elif ar_config.geo_rules and not geoip_filter_config:
                            logger.warning("Geo rules found but no geoip_filter config - skipping GeoIP filter")

            # Generate JWT Authentication filter
            if jwt_filter_config and jwt_filter_config.enabled:
                generate_jwt_authn_filter(jwt_filter_config, output)

            # Generate GeoIP External Authorization filter
            if geoip_filter_config and geoip_filter_config.enabled:
                generate_geoip_ext_authz_filter(geoip_filter_config, output)

            # Generate Lua filter for JWT claim and GeoIP metadata extraction
            # Collect all JWT and Geo rules
            all_jwt_rules = []
            all_geo_rules = []
            for service in config.services:
                for route in service.routes:
                    if route.advanced_routing and route.advanced_routing.enabled:
                        all_jwt_rules.extend(route.advanced_routing.jwt_claim_rules)
                        all_geo_rules.extend(route.advanced_routing.geo_rules)

            # Generate Lua filter if rules exist OR if filters are explicitly configured
            if ((all_jwt_rules or all_geo_rules) and jwt_filter_config) or (jwt_filter_config or geoip_filter_config):
                # Use empty lists if no rules but filters are configured
                generate_lua_filter_for_advanced_routing(
                    all_jwt_rules,
                    all_geo_rules,
                    jwt_filter_config or JWTFilterConfig(enabled=False),
                    output
                )

        # Add rate limiting filter if any route has rate limiting enabled
        has_rate_limits = any(
            route.rate_limit and route.rate_limit.enabled
            for service in config.services
            for route in service.routes
        )
        if has_rate_limits:
            # Find the first rate limit config to use as defaults
            first_rate_limit = None
            for service in config.services:
                for route in service.routes:
                    if route.rate_limit and route.rate_limit.enabled:
                        first_rate_limit = route.rate_limit
                        break
                if first_rate_limit:
                    break

            output.append("          - name: envoy.filters.http.local_ratelimit")
            output.append("            typed_config:")
            output.append(
                "              '@type': type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit"
            )
            output.append("              stat_prefix: http_local_rate_limiter")
            output.append("              token_bucket:")
            output.append(f"                max_tokens: {first_rate_limit.burst}")
            output.append(
                f"                tokens_per_fill: {first_rate_limit.requests_per_second}"
            )
            output.append("                fill_interval: 1s")
            output.append("              filter_enabled:")
            output.append("                runtime_key: local_rate_limit_enabled")
            output.append("                default_value:")
            output.append("                  numerator: 100")
            output.append("                  denominator: HUNDRED")
            output.append("              filter_enforced:")
            output.append("                runtime_key: local_rate_limit_enforced")
            output.append("                default_value:")
            output.append("                  numerator: 100")
            output.append("                  denominator: HUNDRED")
            output.append("              response_headers_to_add:")
            output.append("                - append: false")
            output.append("                  header:")
            output.append("                    key: x-local-rate-limit")
            output.append("                    value: 'true'")
            output.append(f"              status_code: {first_rate_limit.response_status}")

        # Add gRPC transformation filter if any route has gRPC transformation enabled
        has_grpc_transformations = any(
            route.grpc_transformation and route.grpc_transformation.enabled
            for service in config.services
            for route in service.routes
        )
        if has_grpc_transformations:
            # Initialize ProtoManager and register descriptors
            proto_manager = ProtoManager()
            for descriptor in config.proto_descriptors:
                proto_manager.register_descriptor(descriptor)

            # Generate gRPC transformation Lua filter
            self._generate_grpc_transformation_envoy(config, proto_manager, output)

        # Add body transformation filter if any route has body transformation enabled
        has_body_transformations = any(
            route.body_transformation and route.body_transformation.enabled
            for service in config.services
            for route in service.routes
        )
        if has_body_transformations:
            output.append("          - name: envoy.filters.http.lua")
            output.append("            typed_config:")
            output.append(
                "              '@type': type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua"
            )
            output.append("              inline_code: |")
            output.append("                local cjson = require('cjson')")
            output.append("")
            output.append("                -- Helper function to generate UUID")
            output.append("                function generate_uuid()")
            output.append("                  local random = math.random")
            output.append(
                "                  local template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'"
            )
            output.append("                  return string.gsub(template, '[xy]', function (c)")
            output.append(
                "                    local v = (c == 'x') and random(0, 0xf) or random(8, 0xb)"
            )
            output.append("                    return string.format('%x', v)")
            output.append("                  end)")
            output.append("                end")
            output.append("")
            output.append("                -- Helper function to get current timestamp")
            output.append("                function get_timestamp()")
            output.append("                  return os.date('%Y-%m-%dT%H:%M:%SZ')")
            output.append("                end")
            output.append("")
            output.append("                -- Helper function to transform request body")
            output.append(
                "                function transform_request_body(body_json, add_fields, remove_fields, rename_fields)"
            )
            output.append("                  -- Add fields")
            output.append("                  if add_fields then")
            output.append("                    for key, value in pairs(add_fields) do")
            output.append("                      -- Replace template variables")
            output.append("                      if value == '{{uuid}}' then")
            output.append("                        body_json[key] = generate_uuid()")
            output.append(
                "                      elseif value == '{{now}}' or value == '{{timestamp}}' then"
            )
            output.append("                        body_json[key] = get_timestamp()")
            output.append("                      else")
            output.append("                        body_json[key] = value")
            output.append("                      end")
            output.append("                    end")
            output.append("                  end")
            output.append("")
            output.append("                  -- Remove fields")
            output.append("                  if remove_fields then")
            output.append("                    for _, field_name in ipairs(remove_fields) do")
            output.append("                      body_json[field_name] = nil")
            output.append("                    end")
            output.append("                  end")
            output.append("")
            output.append("                  -- Rename fields")
            output.append("                  if rename_fields then")
            output.append("                    for old_name, new_name in pairs(rename_fields) do")
            output.append("                      if body_json[old_name] ~= nil then")
            output.append("                        body_json[new_name] = body_json[old_name]")
            output.append("                        body_json[old_name] = nil")
            output.append("                      end")
            output.append("                    end")
            output.append("                  end")
            output.append("")
            output.append("                  return body_json")
            output.append("                end")
            output.append("")
            output.append("                -- Helper function to transform response body")
            output.append(
                "                function transform_response_body(body_json, filter_fields, add_fields)"
            )
            output.append("                  -- Filter (remove) sensitive fields")
            output.append("                  if filter_fields then")
            output.append("                    for _, field_name in ipairs(filter_fields) do")
            output.append("                      body_json[field_name] = nil")
            output.append("                    end")
            output.append("                  end")
            output.append("")
            output.append("                  -- Add metadata fields")
            output.append("                  if add_fields then")
            output.append("                    for key, value in pairs(add_fields) do")
            output.append("                      -- Replace template variables")
            output.append("                      if value == '{{uuid}}' then")
            output.append("                        body_json[key] = generate_uuid()")
            output.append(
                "                      elseif value == '{{now}}' or value == '{{timestamp}}' then"
            )
            output.append("                        body_json[key] = get_timestamp()")
            output.append("                      else")
            output.append("                        body_json[key] = value")
            output.append("                      end")
            output.append("                    end")
            output.append("                  end")
            output.append("")
            output.append("                  return body_json")
            output.append("                end")
            output.append("")
            output.append("                -- Request transformation")
            output.append("                function envoy_on_request(request_handle)")
            output.append("                  local path = request_handle:headers():get(':path')")
            output.append("")

            # Generate route-specific transformation logic
            for service in config.services:
                for route in service.routes:
                    if route.body_transformation and route.body_transformation.enabled:
                        bt = route.body_transformation
                        if bt.request:
                            output.append(
                                f"                  -- Body transformation for {service.name} {route.path_prefix}"
                            )
                            output.append(
                                f"                  if string.find(path, '{route.path_prefix}') then"
                            )
                            output.append("                    local body = request_handle:body()")
                            output.append("                    if body and body:length() > 0 then")
                            output.append(
                                "                      local success, body_json = pcall(cjson.decode, body:getBytes(0, body:length()))"
                            )
                            output.append("                      if success then")

                            # Generate add_fields table
                            if bt.request.add_fields:
                                output.append("                        local add_fields = {")
                                for key, value in bt.request.add_fields.items():
                                    if isinstance(value, str):
                                        output.append(
                                            f"                          {key} = '{value}',"
                                        )
                                    else:
                                        output.append(f"                          {key} = {value},")
                                output.append("                        }")
                            else:
                                output.append("                        local add_fields = nil")

                            # Generate remove_fields table
                            if bt.request.remove_fields:
                                output.append("                        local remove_fields = {")
                                for field in bt.request.remove_fields:
                                    output.append(f"                          '{field}',")
                                output.append("                        }")
                            else:
                                output.append("                        local remove_fields = nil")

                            # Generate rename_fields table
                            if bt.request.rename_fields:
                                output.append("                        local rename_fields = {")
                                for old_name, new_name in bt.request.rename_fields.items():
                                    output.append(
                                        f"                          {old_name} = '{new_name}',"
                                    )
                                output.append("                        }")
                            else:
                                output.append("                        local rename_fields = nil")

                            output.append("")
                            output.append(
                                "                        body_json = transform_request_body(body_json, add_fields, remove_fields, rename_fields)"
                            )
                            output.append(
                                "                        local new_body = cjson.encode(body_json)"
                            )
                            output.append(
                                "                        request_handle:body():setBytes(new_body)"
                            )
                            output.append("                      end")
                            output.append("                    end")
                            output.append("                  end")
                            output.append("")

            output.append("                end")
            output.append("")
            output.append("                -- Response transformation")
            output.append("                function envoy_on_response(response_handle)")
            output.append("                  local path = response_handle:headers():get(':path')")
            output.append("")

            # Generate response transformation logic
            for service in config.services:
                for route in service.routes:
                    if route.body_transformation and route.body_transformation.enabled:
                        bt = route.body_transformation
                        if bt.response:
                            output.append(
                                f"                  -- Response transformation for {service.name} {route.path_prefix}"
                            )
                            output.append(
                                f"                  if string.find(path, '{route.path_prefix}') then"
                            )
                            output.append("                    local body = response_handle:body()")
                            output.append("                    if body and body:length() > 0 then")
                            output.append(
                                "                      local success, body_json = pcall(cjson.decode, body:getBytes(0, body:length()))"
                            )
                            output.append("                      if success then")

                            # Generate filter_fields table
                            if bt.response.filter_fields:
                                output.append("                        local filter_fields = {")
                                for field in bt.response.filter_fields:
                                    output.append(f"                          '{field}',")
                                output.append("                        }")
                            else:
                                output.append("                        local filter_fields = nil")

                            # Generate add_fields table
                            if bt.response.add_fields:
                                output.append("                        local add_fields = {")
                                for key, value in bt.response.add_fields.items():
                                    if isinstance(value, str):
                                        output.append(
                                            f"                          {key} = '{value}',"
                                        )
                                    else:
                                        output.append(f"                          {key} = {value},")
                                output.append("                        }")
                            else:
                                output.append("                        local add_fields = nil")

                            output.append("")
                            output.append(
                                "                        body_json = transform_response_body(body_json, filter_fields, add_fields)"
                            )
                            output.append(
                                "                        local new_body = cjson.encode(body_json)"
                            )
                            output.append(
                                "                        response_handle:body():setBytes(new_body)"
                            )
                            output.append("                      end")
                            output.append("                    end")
                            output.append("                  end")
                            output.append("")

            output.append("                end")

        output.append("          - name: envoy.filters.http.router")
        output.append("            typed_config:")
        output.append(
            "              '@type': type.googleapis.com/envoy.extensions.filters.http.router.v3.Router"
        )
        output.append("")

        # Clusters
        output.append("  clusters:")
        for service in config.services:
            # Check if any route has advanced routing enabled
            has_advanced_routing = any(
                route.advanced_routing and route.advanced_routing.enabled
                for route in service.routes
            )

            # Check if any route has traffic splitting enabled
            has_traffic_split = any(
                route.traffic_split and route.traffic_split.enabled for route in service.routes
            )

            # Check if any route has mirroring enabled
            has_mirroring = any(
                route.mirroring and route.mirroring.enabled for route in service.routes
            )

            if has_advanced_routing:
                # Generate clusters for each advanced routing target
                for route in service.routes:
                    if route.advanced_routing and route.advanced_routing.enabled:
                        for target in route.advanced_routing_targets:
                            self._generate_advanced_routing_cluster(service, target, output)
                            output.append("")
                # Also generate default cluster as fallback
                self._generate_envoy_cluster(service, output)
                output.append("")
            elif has_traffic_split:
                # Generate separate clusters for each traffic split target
                for route in service.routes:
                    if route.traffic_split and route.traffic_split.enabled:
                        for target in route.traffic_split.targets:
                            self._generate_traffic_split_cluster(service, target, output)
                            output.append("")
            else:
                # Generate single cluster for the service
                self._generate_envoy_cluster(service, output)
                output.append("")

            # Generate mirror clusters if mirroring is enabled
            if has_mirroring:
                for route in service.routes:
                    if route.mirroring and route.mirroring.enabled:
                        for target in route.mirroring.targets:
                            self._generate_mirror_cluster(service, target, output)
                            output.append("")

        # Add JWKS cluster if JWT authentication is configured
        if has_authentication:
            jwt_configs = []
            for svc in config.services:
                for route in svc.routes:
                    if (
                        route.authentication
                        and route.authentication.enabled
                        and route.authentication.type == "jwt"
                    ):
                        if route.authentication.jwt and route.authentication.jwt.jwks_uri:
                            jwt_configs.append(route.authentication.jwt)

            if jwt_configs:
                jwt_config = jwt_configs[0]
                # Extract host and port from JWKS URI
                import re

                jwks_match = re.match(r"https?://([^:/]+)(?::(\d+))?", jwt_config.jwks_uri)
                if jwks_match:
                    jwks_host = jwks_match.group(1)
                    jwks_port = jwks_match.group(2) or (
                        "443" if jwt_config.jwks_uri.startswith("https") else "80"
                    )

                    output.append("  - name: jwks_cluster")
                    output.append("    type: STRICT_DNS")
                    output.append("    lb_policy: ROUND_ROBIN")
                    output.append("    load_assignment:")
                    output.append("      cluster_name: jwks_cluster")
                    output.append("      endpoints:")
                    output.append("      - lb_endpoints:")
                    output.append("        - endpoint:")
                    output.append("            address:")
                    output.append("              socket_address:")
                    output.append(f"                address: {jwks_host}")
                    output.append(f"                port_value: {jwks_port}")
                    if jwt_config.jwks_uri.startswith("https"):
                        output.append("    transport_socket:")
                        output.append("      name: envoy.transport_sockets.tls")
                        output.append("      typed_config:")
                        output.append(
                            "        '@type': type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext"
                        )
                        output.append("        sni: " + jwks_host)
                    output.append("")

        # Add Advanced Routing filter clusters (JWKS and GeoIP)
        if has_advanced_routing:
            jwt_filter_config = None
            geoip_filter_config = None

            for service in config.services:
                for route in service.routes:
                    if route.advanced_routing and route.advanced_routing.enabled:
                        if route.advanced_routing.jwt_filter:
                            jwt_filter_config = route.advanced_routing.jwt_filter
                        if route.advanced_routing.geoip_filter:
                            geoip_filter_config = route.advanced_routing.geoip_filter

            # Generate JWKS cluster for JWT filter
            if jwt_filter_config and jwt_filter_config.enabled:
                generate_jwks_cluster(jwt_filter_config, output)
                output.append("")

            # Generate GeoIP cluster for GeoIP filter
            if geoip_filter_config and geoip_filter_config.enabled:
                generate_geoip_cluster(geoip_filter_config, output)
                output.append("")

        # Admin
        output.append("admin:")
        output.append("  address:")
        output.append("    socket_address:")
        output.append(f"      address: {config.global_config.host}")
        output.append(f"      port_value: {config.global_config.admin_port}")

        # Metrics export (Prometheus/OpenTelemetry)
        if config.global_config and config.global_config.metrics:
            self._generate_envoy_metrics(config.global_config.metrics, output)

        result = "\n".join(output)
        logger.info(
            f"Envoy configuration generated: {len(result)} bytes, {len(config.services)} services"
        )
        return result

    def _generate_envoy_logging(self, logging_config, output: list):
        """Generate Envoy access logging configuration.

        Args:
            logging_config: LoggingConfig object
            output: Output list to append YAML lines to
        """
        output.append("          access_log:")
        output.append("          - name: envoy.access_loggers.file")
        output.append("            typed_config:")
        output.append(
            "              '@type': type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog"
        )
        output.append(f"              path: {logging_config.access_log_path}")

        # Log format (JSON or text)
        if logging_config.format == "json":
            output.append("              json_format:")
            output.append('                request_id: "%REQ(X-REQUEST-ID)%"')
            output.append('                method: "%REQ(:METHOD)%"')
            output.append('                path: "%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%"')
            output.append('                protocol: "%PROTOCOL%"')
            output.append('                response_code: "%RESPONSE_CODE%"')
            output.append('                bytes_received: "%BYTES_RECEIVED%"')
            output.append('                bytes_sent: "%BYTES_SENT%"')
            output.append('                duration: "%DURATION%"')
            output.append(
                '                upstream_service_time: "%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%"'
            )
            output.append('                x_forwarded_for: "%REQ(X-FORWARDED-FOR)%"')

            # Include configured headers
            for header in logging_config.include_headers:
                safe_header = header.replace("-", "_").lower()
                output.append(f'                {safe_header}: "%REQ({header})%"')

            # Custom fields
            for key, value in logging_config.custom_fields.items():
                output.append(f'                {key}: "{value}"')
        else:
            # Text format
            output.append("              log_format:")
            output.append("                text_format_source:")
            output.append(
                '                  inline_string: "[%START_TIME%] %REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL% %RESPONSE_CODE% %BYTES_RECEIVED% %BYTES_SENT% %DURATION%\\n"'
            )

        # Sampling (if sample_rate < 1.0)
        if logging_config.sample_rate < 1.0:
            sample_percent = int(logging_config.sample_rate * 100)
            output.append("              filter:")
            output.append("                runtime_filter:")
            output.append("                  runtime_key: access_log_sampling")
            output.append("                  percent_sampled:")
            output.append(f"                    numerator: {sample_percent}")
            output.append("                    denominator: HUNDRED")

        output.append("")

    def _generate_envoy_metrics(self, metrics_config, output: list):
        """Generate Envoy metrics export configuration.

        Args:
            metrics_config: MetricsConfig object
            output: Output list to append YAML lines to
        """
        if metrics_config.exporter in ("prometheus", "both"):
            # Prometheus stats endpoint (via admin interface)
            output.append("")
            output.append("# Prometheus metrics available at admin interface")
            output.append(f"# http://<admin_host>:<admin_port>/stats/prometheus")
            logger.info(
                f"Prometheus metrics enabled on admin interface at port {metrics_config.prometheus_port}"
            )

        if metrics_config.exporter in ("opentelemetry", "both"):
            # OpenTelemetry exporter
            if metrics_config.opentelemetry_endpoint:
                output.append("")
                output.append("stats_sinks:")
                output.append("- name: envoy.stat_sinks.open_telemetry")
                output.append("  typed_config:")
                output.append(
                    "    '@type': type.googleapis.com/envoy.extensions.stat_sinks.open_telemetry.v3.SinkConfig"
                )
                output.append("    grpc_service:")
                output.append("      envoy_grpc:")
                output.append("        cluster_name: opentelemetry_collector")
                logger.info(
                    f"OpenTelemetry metrics export enabled to {metrics_config.opentelemetry_endpoint}"
                )

    def _generate_weighted_clusters(self, service: Service, route: Route, output: list) -> None:
        """Generate Envoy weighted_clusters configuration for traffic splitting.

        Implements A/B testing and canary deployments using Envoy's weighted_clusters feature.
        Supports weight-based routing, header-based routing, and cookie-based routing.

        Args:
            service: Service with traffic splitting configuration
            route: Route with traffic_split configuration
            output: Output list to append YAML lines to

        Side Effects:
            Appends weighted_clusters configuration to output list
        """
        traffic_split = route.traffic_split

        # Check if we have routing rules (header/cookie based)
        has_routing_rules = traffic_split.routing_rules and (
            traffic_split.routing_rules.header_rules or traffic_split.routing_rules.cookie_rules
        )

        if has_routing_rules:
            # Use route_configuration with per_filter_config for header/cookie matching
            # This requires Lua filter for advanced routing logic
            output.append("                route:")
            output.append("                  weighted_clusters:")
            output.append("                    clusters:")

            # Add all targets with weights
            for target in traffic_split.targets:
                cluster_name = f"{service.name}_{target.name}_cluster"
                output.append(f"                    - name: {cluster_name}")
                output.append(f"                      weight: {target.weight}")

            output.append("                    total_weight: 100")

            # Add Lua filter for header/cookie routing (will be added to http_filters)
            # This is handled in the main generate() method by detecting routing_rules
        else:
            # Simple weight-based routing (no header/cookie rules)
            output.append("                route:")
            output.append("                  weighted_clusters:")
            output.append("                    clusters:")

            for target in traffic_split.targets:
                cluster_name = f"{service.name}_{target.name}_cluster"
                output.append(f"                    - name: {cluster_name}")
                output.append(f"                      weight: {target.weight}")

            output.append("                    total_weight: 100")

    def _generate_request_mirror_policies(
        self, service: Service, route: Route, output: list
    ) -> None:
        """Generate Envoy request_mirror_policies for request mirroring/shadowing.

        Implements shadow traffic by duplicating requests to mirror targets while
        returning responses from the primary backend. Supports:
        - Multiple shadow targets
        - Sampling percentage per target
        - Custom headers per mirror target
        - Timeout configuration

        Args:
            service: Service with request mirroring
            route: Route with mirroring configuration
            output: Output list to append YAML lines to

        Side Effects:
            Appends request_mirror_policies to the route configuration

        Envoy Docs:
            https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#config-route-v3-routeaction-requestmirrorpolicy
        """
        mirroring = route.mirroring

        for target in mirroring.targets:
            mirror_cluster_name = f"{service.name}_{target.name}_mirror_cluster"

            output.append("                  request_mirror_policies:")
            output.append("                  - cluster: " + mirror_cluster_name)

            # Runtime fraction for sampling (percentage)
            if target.sample_percentage < 100.0:
                output.append("                    runtime_fraction:")
                output.append("                      default_value:")
                output.append(
                    f"                        numerator: {int(target.sample_percentage * 10000)}"
                )
                output.append("                        denominator: MILLION")

            # Custom headers for mirror requests
            if target.headers:
                output.append("                    request_headers_to_add:")
                for key, value in target.headers.items():
                    output.append("                    - header:")
                    output.append(f"                        key: {key}")
                    output.append(f"                        value: '{value}'")
                    output.append("                      append: false")

    def _generate_mirror_cluster(self, service: Service, target, output: list) -> None:
        """Generate Envoy cluster for a single mirror target.

        Creates a cluster configuration for a shadow/mirror backend target.

        Args:
            service: Service with request mirroring
            target: MirrorTarget with upstream configuration
            output: Output list to append YAML lines to

        Side Effects:
            Appends mirror cluster configuration to output list
        """
        cluster_name = f"{service.name}_{target.name}_mirror_cluster"
        output.append(f"  - name: {cluster_name}")
        output.append("    type: STRICT_DNS")
        output.append("    lb_policy: ROUND_ROBIN")

        # Parse timeout (default 5s)
        timeout = target.timeout if target.timeout else "5s"
        output.append(f"    connect_timeout: {timeout}")

        # gRPC support
        if service.type == "grpc":
            output.append("    http2_protocol_options: {}")

        # Configure load assignment (single endpoint from target)
        output.append("    load_assignment:")
        output.append(f"      cluster_name: {cluster_name}")
        output.append("      endpoints:")
        output.append("      - lb_endpoints:")
        output.append("        - endpoint:")
        output.append("            address:")
        output.append("              socket_address:")
        output.append(f"                address: {target.upstream.host}")
        output.append(f"                port_value: {target.upstream.port}")

    def _generate_traffic_split_cluster(self, service: Service, target, output: list) -> None:
        """Generate Envoy cluster for a single traffic split target.

        Creates a cluster configuration for a specific backend target in a traffic split.

        Args:
            service: Service with traffic splitting
            target: SplitTarget with upstream configuration
            output: Output list to append YAML lines to

        Side Effects:
            Appends cluster configuration to output list
        """
        cluster_name = f"{service.name}_{target.name}_cluster"
        output.append(f"  - name: {cluster_name}")
        output.append("    type: STRICT_DNS")
        output.append("    lb_policy: ROUND_ROBIN")
        output.append("    connect_timeout: 5s")

        # gRPC support
        if service.type == "grpc":
            output.append("    http2_protocol_options: {}")

        # Configure load assignment (single endpoint from target)
        output.append("    load_assignment:")
        output.append(f"      cluster_name: {cluster_name}")
        output.append("      endpoints:")
        output.append("      - lb_endpoints:")
        output.append("        - endpoint:")
        output.append("            address:")
        output.append("              socket_address:")
        output.append(f"                address: {target.upstream.host}")
        output.append(f"                port_value: {target.upstream.port}")

    def _generate_advanced_routing_routes(self, service: Service, route: Route, output: list) -> None:
        """Generate Envoy advanced routing configuration.

        Creates sophisticated routing rules based on headers, JWT claims, geo-location,
        and query parameters using Envoy's route matching and Lua scripting.

        Args:
            service: Service with advanced routing
            route: Route with advanced routing configuration
            output: Output list to append YAML lines to

        Side Effects:
            Generates multiple route entries with specific matchers
        """
        if not route.advanced_routing or not route.advanced_routing.enabled:
            return

        config = route.advanced_routing
        targets = route.advanced_routing_targets

        if not targets:
            logger.warning(f"No advanced routing targets defined for {service.name}")
            return

        # Build target map for quick lookup
        target_map = {t.name: t for t in targets}

        # Generate individual route entries for each rule
        # Header-based routes
        for rule in config.header_rules:
            if rule.target_name not in target_map:
                logger.warning(f"Target {rule.target_name} not found for header rule")
                continue

            target = target_map[rule.target_name]
            cluster_name = f"{service.name}_{target.name}_cluster"

            output.append("              - match:")
            output.append(f"                  prefix: '{route.path_prefix}'")
            output.append("                  headers:")
            output.append(f"                  - name: {rule.header_name}")

            # Generate header matcher based on match_type
            if rule.match_type == "exact":
                output.append(f"                    exact_match: '{rule.header_value}'")
            elif rule.match_type == "prefix":
                output.append(f"                    prefix_match: '{rule.header_value}'")
            elif rule.match_type == "contains":
                output.append(f"                    contains_match: '{rule.header_value}'")
            elif rule.match_type == "regex":
                output.append(f"                    safe_regex_match:")
                output.append("                      google_re2: {}")
                output.append(f"                      regex: '{rule.header_value}'")

            output.append("                route:")
            output.append(f"                  cluster: {cluster_name}")

        # Query parameter routes
        for rule in config.query_param_rules:
            if rule.target_name not in target_map:
                logger.warning(f"Target {rule.target_name} not found for query param rule")
                continue

            target = target_map[rule.target_name]
            cluster_name = f"{service.name}_{target.name}_cluster"

            output.append("              - match:")
            output.append(f"                  prefix: '{route.path_prefix}'")
            output.append("                  query_parameters:")

            if rule.match_type == "exact":
                output.append(f"                  - name: {rule.param_name}")
                output.append(f"                    string_match:")
                output.append(f"                      exact: '{rule.param_value}'")
            elif rule.match_type == "exists":
                output.append(f"                  - name: {rule.param_name}")
                output.append("                    present_match: true")
            elif rule.match_type == "regex":
                output.append(f"                  - name: {rule.param_name}")
                output.append(f"                    string_match:")
                output.append(f"                      safe_regex:")
                output.append("                        google_re2: {}")
                output.append(f"                        regex: '{rule.param_value}'")

            output.append("                route:")
            output.append(f"                  cluster: {cluster_name}")

        # JWT and Geo routing would require Lua scripting - add as comments for now
        if config.jwt_claim_rules:
            output.append("              # JWT claim-based routing requires Lua filter")
            for rule in config.jwt_claim_rules:
                output.append(f"              # - {rule.claim_name}={rule.claim_value} -> {rule.target_name}")

        if config.geo_rules:
            output.append("              # Geo-based routing requires GeoIP database and Lua filter")
            for rule in config.geo_rules:
                output.append(f"              # - {rule.match_type}={rule.match_value} -> {rule.target_name}")

        # Fallback route (default)
        fallback_cluster = f"{service.name}_cluster"
        if config.fallback_target and config.fallback_target in target_map:
            target = target_map[config.fallback_target]
            fallback_cluster = f"{service.name}_{target.name}_cluster"

        output.append("              - match:")
        output.append(f"                  prefix: '{route.path_prefix}'")
        output.append("                route:")
        output.append(f"                  cluster: {fallback_cluster}")

    def _generate_first_match_routes(self, service: Service, route: Route,
                                      config: AdvancedRoutingConfig,
                                      targets: List[AdvancedRoutingTarget],
                                      output: list) -> None:
        """Generate first-match routing rules for Envoy.

        Creates individual route entries for each rule with specific matchers.
        """
        # Build target map for quick lookup
        target_map = {t.name: t for t in targets}

        # We need to generate the route with all conditions
        # Envoy evaluates routes in order, so we generate specific matches first

        # Header-based routes
        for rule in config.header_rules:
            if rule.target_name not in target_map:
                logger.warning(f"Target {rule.target_name} not found for header rule")
                continue

            target = target_map[rule.target_name]
            cluster_name = f"{service.name}_{target.name}_cluster"

            # Generate header matcher based on match_type
            if rule.match_type == "exact":
                output.append("                match:")
                output.append(f"                  prefix: '{route.path_prefix}'")
                output.append("                  headers:")
                output.append(f"                  - name: {rule.header_name}")
                output.append(f"                    exact_match: '{rule.header_value}'")
            elif rule.match_type == "prefix":
                output.append("                match:")
                output.append(f"                  prefix: '{route.path_prefix}'")
                output.append("                  headers:")
                output.append(f"                  - name: {rule.header_name}")
                output.append(f"                    prefix_match: '{rule.header_value}'")
            elif rule.match_type == "contains":
                output.append("                match:")
                output.append(f"                  prefix: '{route.path_prefix}'")
                output.append("                  headers:")
                output.append(f"                  - name: {rule.header_name}")
                output.append(f"                    contains_match: '{rule.header_value}'")
            elif rule.match_type == "regex":
                output.append("                match:")
                output.append(f"                  prefix: '{route.path_prefix}'")
                output.append("                  headers:")
                output.append(f"                  - name: {rule.header_name}")
                output.append(f"                    safe_regex_match:")
                output.append("                      google_re2: {}")
                output.append(f"                      regex: '{rule.header_value}'")

            output.append("                route:")
            output.append(f"                  cluster: {cluster_name}")
            output.append("")  # Add spacing between routes

        # Query parameter routes
        for rule in config.query_param_rules:
            if rule.target_name not in target_map:
                logger.warning(f"Target {rule.target_name} not found for query param rule")
                continue

            target = target_map[rule.target_name]
            cluster_name = f"{service.name}_{target.name}_cluster"

            output.append("                match:")
            output.append(f"                  prefix: '{route.path_prefix}'")
            output.append("                  query_parameters:")

            if rule.match_type == "exact":
                output.append(f"                  - name: {rule.param_name}")
                output.append(f"                    string_match:")
                output.append(f"                      exact: '{rule.param_value}'")
            elif rule.match_type == "exists":
                output.append(f"                  - name: {rule.param_name}")
                output.append("                    present_match: true")
            elif rule.match_type == "regex":
                output.append(f"                  - name: {rule.param_name}")
                output.append(f"                    string_match:")
                output.append(f"                      safe_regex:")
                output.append("                        google_re2: {}")
                output.append(f"                        regex: '{rule.param_value}'")

            output.append("                route:")
            output.append(f"                  cluster: {cluster_name}")
            output.append("")

        # JWT and Geo routing require Lua scripting
        if config.jwt_claim_rules or config.geo_rules:
            self._generate_lua_based_routing(service, route, config, targets, output)

        # Fallback route
        if config.fallback_target:
            if config.fallback_target in target_map:
                target = target_map[config.fallback_target]
                cluster_name = f"{service.name}_{target.name}_cluster"
            else:
                cluster_name = f"{service.name}_cluster"  # Use default
        else:
            cluster_name = f"{service.name}_cluster"

        output.append("                match:")
        output.append(f"                  prefix: '{route.path_prefix}'")
        output.append("                route:")
        output.append(f"                  cluster: {cluster_name}")

    def _generate_all_match_routes(self, service: Service, route: Route,
                                    config: AdvancedRoutingConfig,
                                    targets: List[AdvancedRoutingTarget],
                                    output: list) -> None:
        """Generate all-match routing rules requiring multiple conditions.

        Uses Lua script to evaluate multiple conditions together.
        """
        # For all_match, we use Lua script to evaluate all conditions
        self._generate_lua_based_routing(service, route, config, targets, output, all_match=True)

    def _generate_lua_based_routing(self, service: Service, route: Route,
                                     config: AdvancedRoutingConfig,
                                     targets: List[AdvancedRoutingTarget],
                                     output: list, all_match: bool = False) -> None:
        """Generate Lua-based routing for JWT claims and geo-location.

        Creates Lua filter for complex routing logic that Envoy can't handle natively.
        """
        # This requires adding a Lua filter in the HTTP filter chain
        # The actual Lua script would be generated separately
        logger.info(f"Generating Lua-based advanced routing for {service.name}")

        # Add Lua HTTP filter configuration
        # This would be added in the http_filters section (not shown in this snippet)
        # For now, we'll add a comment indicating where Lua routing would go
        output.append("                # Lua-based routing for JWT claims and geo-location")
        output.append("                # Requires Lua HTTP filter configuration")

        # Generate clusters for all advanced routing targets
        # These are added later in the clusters section

    def _generate_advanced_routing_cluster(self, service: Service,
                                            target: AdvancedRoutingTarget,
                                            output: list) -> None:
        """Generate Envoy cluster for an advanced routing target.

        Creates a cluster configuration for a specific backend target.

        Args:
            service: Service with advanced routing
            target: AdvancedRoutingTarget with upstream configuration
            output: Output list to append YAML lines to

        Side Effects:
            Appends cluster configuration to output list
        """
        cluster_name = f"{service.name}_{target.name}_cluster"
        output.append(f"  - name: {cluster_name}")
        output.append("    type: STRICT_DNS")
        output.append("    lb_policy: ROUND_ROBIN")
        output.append("    connect_timeout: 5s")

        # gRPC support
        if service.type == "grpc":
            output.append("    http2_protocol_options: {}")

        # Configure load assignment
        output.append("    load_assignment:")
        output.append(f"      cluster_name: {cluster_name}")
        output.append("      endpoints:")
        output.append("      - lb_endpoints:")
        output.append("        - endpoint:")
        output.append("            address:")
        output.append("              socket_address:")
        output.append(f"                address: {target.upstream.host}")
        output.append(f"                port_value: {target.upstream.port}")

        if target.description:
            output.append(f"    # {target.description}")

    def _generate_envoy_cluster(self, service, output: list):
        """Generate Envoy cluster configuration with health checks and load balancing.

        Creates Envoy cluster configuration supporting:
        - Multiple endpoints with load balancing
        - Active health checks (HTTP/TCP/gRPC)
        - Passive health checks (Outlier Detection)
        - Load balancing policies

        Args:
            service: Service object with upstream configuration
            output: Output list to append YAML lines to
        """
        output.append(f"  - name: {service.name}_cluster")
        output.append("    type: STRICT_DNS")

        # Configure load balancing policy
        lb_policy = "ROUND_ROBIN"  # Default
        if service.upstream.load_balancer:
            algorithm = service.upstream.load_balancer.algorithm
            # Envoy policies: ROUND_ROBIN, LEAST_REQUEST, RING_HASH, RANDOM, MAGLEV
            envoy_lb_map = {
                "round_robin": "ROUND_ROBIN",
                "least_conn": "LEAST_REQUEST",
                "ip_hash": "RING_HASH",
                "weighted": "ROUND_ROBIN",  # Weighted uses ROUND_ROBIN with endpoint weights
            }
            lb_policy = envoy_lb_map.get(algorithm, "ROUND_ROBIN")

        output.append(f"    lb_policy: {lb_policy}")

        # Configure timeout (default connect timeout for cluster)
        # Route-specific timeouts can override this
        default_timeout = "5s"
        for route in service.routes:
            if route.timeout:
                default_timeout = route.timeout.connect
                break
        output.append(f"    connect_timeout: {default_timeout}")

        # Configure ring hash for IP-based hashing
        if service.upstream.load_balancer and service.upstream.load_balancer.algorithm == "ip_hash":
            output.append("    ring_hash_lb_config:")
            output.append("      minimum_ring_size: 1024")

        # gRPC support
        if service.type == "grpc":
            output.append("    http2_protocol_options: {}")

        # Configure health checks
        if service.upstream.health_check:
            hc = service.upstream.health_check

            # Active health checks
            if hc.active and hc.active.enabled:
                active = hc.active
                output.append("    health_checks:")
                output.append("    - timeout: " + active.timeout)
                output.append("      interval: " + active.interval)
                output.append(f"      unhealthy_threshold: {active.unhealthy_threshold}")
                output.append(f"      healthy_threshold: {active.healthy_threshold}")
                output.append("      http_health_check:")
                output.append(f"        path: {active.http_path}")
                output.append("        expected_statuses:")
                for status_code in active.healthy_status_codes:
                    output.append(f"        - start: {status_code}")
                    output.append(f"          end: {status_code + 1}")

            # Passive health checks (Outlier Detection)
            if hc.passive and hc.passive.enabled:
                passive = hc.passive
                output.append("    outlier_detection:")
                output.append(f"      consecutive_5xx: {passive.max_failures}")
                output.append("      interval: 10s")
                output.append("      base_ejection_time: 30s")
                output.append("      max_ejection_percent: 50")
                output.append("      enforcing_consecutive_5xx: 100")
                output.append("      success_rate_minimum_hosts: 5")
                output.append("      success_rate_request_volume: 10")
                output.append("      enforcing_success_rate: 100")

        # Check if any route has circuit breaker enabled (for backward compatibility)
        circuit_breaker = None
        for route in service.routes:
            if route.circuit_breaker and route.circuit_breaker.enabled:
                circuit_breaker = route.circuit_breaker
                break

        if circuit_breaker and not (
            service.upstream.health_check and service.upstream.health_check.passive
        ):
            # Only add if not already added via passive health check
            output.append("    outlier_detection:")
            output.append(f"      consecutive_5xx: {circuit_breaker.max_failures}")
            output.append("      interval: 10s")
            timeout_value = circuit_breaker.timeout.rstrip("s")
            output.append(f"      base_ejection_time: {timeout_value}s")
            output.append("      max_ejection_percent: 50")
            output.append("      enforcing_consecutive_5xx: 100")
            output.append(f"      success_rate_minimum_hosts: {circuit_breaker.half_open_requests}")
            output.append("      success_rate_request_volume: 10")
            output.append("      enforcing_success_rate: 100")

        # Configure load assignment (endpoints)
        output.append("    load_assignment:")
        output.append(f"      cluster_name: {service.name}_cluster")
        output.append("      endpoints:")
        output.append("      - lb_endpoints:")

        if service.upstream.targets:
            # Multiple targets mode
            for target in service.upstream.targets:
                output.append("        - endpoint:")
                output.append("            address:")
                output.append("              socket_address:")
                output.append(f"                address: {target.host}")
                output.append(f"                port_value: {target.port}")
                if (
                    service.upstream.load_balancer
                    and service.upstream.load_balancer.algorithm == "weighted"
                ):
                    output.append("          load_balancing_weight:")
                    output.append(f"            value: {target.weight}")
        else:
            # Simple mode (single host/port)
            output.append("        - endpoint:")
            output.append("            address:")
            output.append("              socket_address:")
            output.append(f"                address: {service.upstream.host}")
            output.append(f"                port_value: {service.upstream.port}")

    def _generate_grpc_transformation_envoy(
        self, config: Config, proto_manager: ProtoManager, output: list
    ) -> None:
        """Generate Envoy Lua filter for gRPC transformations.

        Creates Envoy HTTP Lua filter with lua-protobuf library for decoding/encoding
        gRPC messages and applying transformations (add/remove/rename fields).

        Args:
            config: Configuration with gRPC transformations
            proto_manager: ProtoManager with registered descriptors
            output: Output list to append YAML lines to

        Side Effects:
            Appends Lua filter configuration to output list
        """
        output.append("          - name: envoy.filters.http.lua")
        output.append("            typed_config:")
        output.append(
            "              '@type': type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua"
        )
        output.append("              inline_code: |")
        output.append("                -- gRPC Transformation Filter")
        output.append("                local pb = require('pb')")
        output.append("")
        output.append("                -- Proto Descriptors (lazy loading)")
        output.append("                local _proto_loaded = {}")
        output.append("")

        # Helper functions
        output.append("                -- Load proto descriptor (cached)")
        output.append("                function load_proto(desc_path, proto_name)")
        output.append("                  if not _proto_loaded[proto_name] then")
        output.append("                    local file = io.open(desc_path, 'rb')")
        output.append("                    if file then")
        output.append("                      local content = file:read('*all')")
        output.append("                      file:close()")
        output.append("                      pb.load(content)")
        output.append("                      _proto_loaded[proto_name] = true")
        output.append("                    end")
        output.append("                  end")
        output.append("                end")
        output.append("")
        output.append("                -- Generate UUID (Envoy request ID)")
        output.append("                function generate_uuid(request_handle)")
        output.append(
            "                  return request_handle:headers():get('x-request-id') or 'unknown'"
        )
        output.append("                end")
        output.append("")
        output.append("                -- Get timestamp")
        output.append("                function get_timestamp()")
        output.append("                  return os.time()")
        output.append("                end")
        output.append("")

        # Request transformation
        output.append("                -- Request transformation")
        output.append("                function envoy_on_request(request_handle)")
        output.append("                  local path = request_handle:headers():get(':path')")
        output.append("")

        # Generate transformation logic per route
        for service in config.services:
            for route in service.routes:
                if route.grpc_transformation and route.grpc_transformation.enabled:
                    grpc_t = route.grpc_transformation

                    # Get descriptor path
                    descriptor = proto_manager.get_descriptor(grpc_t.proto_descriptor)
                    if not descriptor:
                        logger.warning(
                            f"Proto descriptor '{grpc_t.proto_descriptor}' not found for route {route.path_prefix}"
                        )
                        continue

                    output.append(
                        f"                  -- gRPC transformation for {service.name} {route.path_prefix}"
                    )
                    output.append(
                        f"                  if string.find(path, '{route.path_prefix}') then"
                    )

                    # Load proto descriptor
                    output.append(
                        f"                    load_proto('{descriptor.path}', '{grpc_t.proto_descriptor}')"
                    )

                    # Get body
                    output.append("                    local body = request_handle:body()")
                    output.append("                    if body and body:length() > 5 then")
                    output.append(
                        "                      -- Skip gRPC 5-byte header (compression flag + message length)"
                    )
                    output.append("                      local grpc_header = body:getBytes(0, 5)")
                    output.append(
                        "                      local pb_bytes = body:getBytes(5, body:length() - 5)"
                    )
                    output.append("")

                    # Decode message
                    full_request_type = f"{grpc_t.package}.{grpc_t.request_type}"
                    output.append("                      -- Decode protobuf message")
                    output.append(
                        f"                      local msg = pb.decode('{full_request_type}', pb_bytes)"
                    )
                    output.append("                      if msg then")

                    # Apply transformations
                    if grpc_t.request_transform:
                        transform_lua = self._generate_request_transform_lua_grpc(
                            grpc_t.request_transform
                        )
                        for line in transform_lua.split("\n"):
                            output.append(f"                        {line}")

                    # Re-encode
                    output.append("")
                    output.append("                        -- Re-encode protobuf message")
                    output.append(
                        f"                        local new_pb = pb.encode('{full_request_type}', msg)"
                    )
                    output.append("                        local new_body = grpc_header .. new_pb")
                    output.append(
                        "                        request_handle:body():setBytes(new_body)"
                    )
                    output.append("                      else")
                    output.append(
                        "                        request_handle:logErr('Failed to decode gRPC message')"
                    )
                    output.append("                      end")
                    output.append("                    end")
                    output.append("                  end")
                    output.append("")

        output.append("                end")
        output.append("")

        # Response transformation
        output.append("                -- Response transformation")
        output.append("                function envoy_on_response(response_handle)")
        output.append("                  local path = response_handle:headers():get(':path')")
        output.append("")

        # Generate response transformation logic per route
        for service in config.services:
            for route in service.routes:
                if route.grpc_transformation and route.grpc_transformation.enabled:
                    grpc_t = route.grpc_transformation

                    descriptor = proto_manager.get_descriptor(grpc_t.proto_descriptor)
                    if not descriptor:
                        continue

                    if grpc_t.response_transform:
                        output.append(
                            f"                  -- gRPC response transformation for {service.name} {route.path_prefix}"
                        )
                        output.append(
                            f"                  if string.find(path, '{route.path_prefix}') then"
                        )

                        # Load proto
                        output.append(
                            f"                    load_proto('{descriptor.path}', '{grpc_t.proto_descriptor}')"
                        )

                        # Get body
                        output.append("                    local body = response_handle:body()")
                        output.append("                    if body and body:length() > 5 then")
                        output.append(
                            "                      local grpc_header = body:getBytes(0, 5)"
                        )
                        output.append(
                            "                      local pb_bytes = body:getBytes(5, body:length() - 5)"
                        )

                        # Decode
                        full_response_type = f"{grpc_t.package}.{grpc_t.response_type}"
                        output.append(
                            f"                      local msg = pb.decode('{full_response_type}', pb_bytes)"
                        )
                        output.append("                      if msg then")

                        # Apply transformations
                        transform_lua = self._generate_response_transform_lua_grpc(
                            grpc_t.response_transform
                        )
                        for line in transform_lua.split("\n"):
                            output.append(f"                        {line}")

                        # Re-encode
                        output.append("")
                        output.append(
                            f"                        local new_pb = pb.encode('{full_response_type}', msg)"
                        )
                        output.append(
                            "                        local new_body = grpc_header .. new_pb"
                        )
                        output.append(
                            "                        response_handle:body():setBytes(new_body)"
                        )
                        output.append("                      end")
                        output.append("                    end")
                        output.append("                  end")
                        output.append("")

        output.append("                end")

    def _generate_request_transform_lua_grpc(self, transform) -> str:
        """Generate Lua code for gRPC request transformations.

        Args:
            transform: RequestBodyTransformation config

        Returns:
            Lua code string for transforming protobuf messages
        """
        lua_lines = []

        # Add fields
        if transform.add_fields:
            lua_lines.append("-- Add fields")
            for key, value in transform.add_fields.items():
                if value == "{{uuid}}":
                    lua_lines.append(f"msg['{key}'] = generate_uuid(request_handle)")
                elif value in ["{{timestamp}}", "{{now}}"]:
                    lua_lines.append(f"msg['{key}'] = get_timestamp()")
                else:
                    # Static value
                    if isinstance(value, str):
                        lua_lines.append(f"msg['{key}'] = '{value}'")
                    else:
                        lua_lines.append(f"msg['{key}'] = {value}")

        # Remove fields
        if transform.remove_fields:
            if lua_lines:
                lua_lines.append("")
            lua_lines.append("-- Remove fields")
            for field in transform.remove_fields:
                lua_lines.append(f"msg['{field}'] = nil")

        # Rename fields
        if transform.rename_fields:
            if lua_lines:
                lua_lines.append("")
            lua_lines.append("-- Rename fields")
            for old_name, new_name in transform.rename_fields.items():
                lua_lines.append(f"if msg['{old_name}'] ~= nil then")
                lua_lines.append(f"  msg['{new_name}'] = msg['{old_name}']")
                lua_lines.append(f"  msg['{old_name}'] = nil")
                lua_lines.append("end")

        return "\n".join(lua_lines)

    def _generate_response_transform_lua_grpc(self, transform) -> str:
        """Generate Lua code for gRPC response transformations.

        Args:
            transform: ResponseBodyTransformation config

        Returns:
            Lua code string for transforming protobuf messages
        """
        lua_lines = []

        # Filter (remove) fields
        if transform.filter_fields:
            lua_lines.append("-- Filter (remove) sensitive fields")
            for field in transform.filter_fields:
                lua_lines.append(f"msg['{field}'] = nil")

        # Add fields
        if transform.add_fields:
            if lua_lines:
                lua_lines.append("")
            lua_lines.append("-- Add metadata fields")
            for key, value in transform.add_fields.items():
                if value == "{{uuid}}":
                    lua_lines.append(f"msg['{key}'] = generate_uuid(response_handle)")
                elif value in ["{{timestamp}}", "{{now}}"]:
                    lua_lines.append(f"msg['{key}'] = get_timestamp()")
                else:
                    if isinstance(value, str):
                        lua_lines.append(f"msg['{key}'] = '{value}'")
                    else:
                        lua_lines.append(f"msg['{key}'] = {value}")

        return "\n".join(lua_lines)

    def deploy(
        self, config: Config, output_file: Optional[str] = None, admin_url: Optional[str] = None
    ) -> bool:
        """Deploy Envoy configuration.

        Deploys configuration via file-based approach. Optionally triggers
        hot-reload via Envoy Admin API if admin_url is provided.

        Deployment Methods:
            1. File-based (default): Write config to file for Envoy to load
            2. Hot-reload (optional): Trigger config reload via Admin API

        Args:
            config: Configuration to deploy
            output_file: Path to write config file (default: envoy.yaml)
            admin_url: Envoy Admin API URL (default: http://localhost:9901)

        Returns:
            True if deployment successful

        Raises:
            IOError: If file write fails
            requests.RequestException: If Admin API call fails

        Example:
            >>> provider = EnvoyProvider()
            >>> config = Config.from_yaml("config.yaml")
            >>> # File-based deployment
            >>> provider.deploy(config, output_file="/etc/envoy/envoy.yaml")
            True
            >>> # With hot-reload
            >>> provider.deploy(config, admin_url="http://envoy:9901")
            True
        """
        logger.info(f"Deploying Envoy configuration to file: {output_file or 'envoy.yaml'}")
        # Generate configuration
        generated_config = self.generate(config)

        # Determine output file
        if output_file is None:
            output_file = "envoy.yaml"

        # Write configuration to file
        try:
            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(output_file) or ".", exist_ok=True)

            with open(output_file, "w") as f:
                f.write(generated_config)

            logger.info(f"Envoy configuration successfully written to {output_file}")
            print(f"✓ Envoy configuration written to {output_file}")
        except IOError as e:
            logger.error(f"Failed to write Envoy config file to {output_file}: {e}")
            print(f"✗ Failed to write config file: {e}")
            return False

        # Optionally trigger hot-reload via Admin API
        if admin_url:
            admin_url = admin_url.rstrip("/")
            logger.debug(f"Checking Envoy Admin API at {admin_url}")
            try:
                # Check if Envoy is reachable
                response = requests.get(f"{admin_url}/ready", timeout=5)

                if response.status_code == 200:
                    logger.info(f"Envoy Admin API is reachable at {admin_url}")
                    print(f"✓ Envoy Admin API is reachable at {admin_url}")
                    print("  Note: File-based config requires Envoy restart or --drain-strategy")
                    print(f"  To reload: docker restart <envoy-container>")
                else:
                    logger.warning(f"Envoy Admin API returned status {response.status_code}")
                    print(f"⚠ Envoy Admin API returned status {response.status_code}")

            except requests.RequestException as e:
                logger.warning(f"Could not reach Envoy Admin API at {admin_url}: {e}")
                print(f"⚠ Could not reach Envoy Admin API: {e}")
                print(f"  Config written to {output_file}, but manual reload required")

        logger.info("Envoy deployment completed successfully")
        return True

    def parse(self, provider_config: str) -> Config:
        """Parse Envoy YAML configuration to GAL format.

        Converts Envoy static_resources configuration into GAL Config model.
        Extracts clusters, listeners, routes, health checks, and load balancing.

        Args:
            provider_config: Envoy YAML configuration string

        Returns:
            GAL Config object

        Raises:
            ValueError: If parsing fails or configuration is invalid

        Example:
            >>> provider = EnvoyProvider()
            >>> envoy_yaml = '''
            ... static_resources:
            ...   clusters:
            ...   - name: api_cluster
            ...     connect_timeout: 5s
            ... '''
            >>> config = provider.parse(envoy_yaml)
        """
        logger.info("Parsing Envoy configuration to GAL format")

        try:
            envoy_config = yaml.safe_load(provider_config)
        except yaml.YAMLError as e:
            raise ValueError(f"Invalid Envoy YAML: {e}")

        if not isinstance(envoy_config, dict):
            raise ValueError("Envoy config must be a YAML dictionary")

        static_resources = envoy_config.get("static_resources", {})
        clusters = static_resources.get("clusters", [])
        listeners = static_resources.get("listeners", [])

        # Parse clusters → Services
        services = []
        cluster_map = {}  # name → Service mapping

        for cluster in clusters:
            service = self._parse_cluster(cluster)
            if service:
                services.append(service)
                cluster_map[cluster.get("name")] = service

        # Parse listeners/routes and map to services
        for listener in listeners:
            self._parse_listener_routes(listener, cluster_map)

        # Create global config
        global_config = GlobalConfig(
            host="0.0.0.0",
            port=10000,  # Default Envoy admin port
        )

        config = Config(
            version="1.0",
            provider="envoy",
            global_config=global_config,
            services=services,
        )

        logger.info(
            f"Successfully parsed Envoy config: {len(services)} services, "
            f"{sum(len(s.routes) for s in services)} routes"
        )
        return config

    def _parse_cluster(self, cluster: Dict[str, Any]) -> Optional[Service]:
        """Parse Envoy cluster to GAL Service."""
        cluster_name = cluster.get("name", "")
        if not cluster_name:
            logger.warning("Skipping cluster without name")
            return None

        # Remove common suffixes to get service name
        service_name = cluster_name.replace("_cluster", "").replace("-cluster", "")

        # Parse load assignment (endpoints)
        targets = []
        load_assignment = cluster.get("load_assignment", {})
        endpoints = load_assignment.get("endpoints", [])

        for endpoint_group in endpoints:
            lb_endpoints = endpoint_group.get("lb_endpoints", [])
            for lb_endpoint in lb_endpoints:
                endpoint = lb_endpoint.get("endpoint", {})
                address = endpoint.get("address", {})
                socket_address = address.get("socket_address", {})

                host = socket_address.get("address")
                port = socket_address.get("port_value")

                if host and port:
                    weight = lb_endpoint.get("load_balancing_weight", {}).get("value", 1)
                    targets.append(UpstreamTarget(host=host, port=port, weight=weight))

        if not targets:
            logger.warning(f"Cluster {cluster_name} has no valid endpoints")
            return None

        # Parse health checks
        health_checks = cluster.get("health_checks", [])
        active_hc = None
        passive_hc = None

        if health_checks:
            hc = health_checks[0]  # Take first health check
            timeout = hc.get("timeout", "")
            interval = hc.get("interval", "")
            unhealthy_threshold = hc.get("unhealthy_threshold", 3)
            healthy_threshold = hc.get("healthy_threshold", 2)

            # Check if it's HTTP health check
            http_hc = hc.get("http_health_check", {})
            if http_hc:
                path = http_hc.get("path", "/health")
                active_hc = ActiveHealthCheck(
                    enabled=True,
                    http_path=path,
                    interval=interval or "10s",
                    timeout=timeout or "5s",
                    unhealthy_threshold=unhealthy_threshold,
                    healthy_threshold=healthy_threshold,
                )

        # Parse outlier detection (passive health checks)
        outlier_detection = cluster.get("outlier_detection", {})
        if outlier_detection:
            consecutive_5xx = outlier_detection.get("consecutive_5xx", 5)
            passive_hc = PassiveHealthCheck(enabled=True, max_failures=consecutive_5xx)

        # Parse load balancing policy
        lb_policy = cluster.get("lb_policy", "ROUND_ROBIN")
        lb_algorithm = self._map_envoy_lb_policy(lb_policy)

        # Create upstream
        health_check = None
        if active_hc or passive_hc:
            health_check = HealthCheckConfig(active=active_hc, passive=passive_hc)

        upstream = Upstream(
            targets=targets,
            health_check=health_check,
            load_balancer=LoadBalancerConfig(algorithm=lb_algorithm),
        )

        # Create service with empty routes (filled by listener parsing)
        service = Service(
            name=service_name,
            type="rest",  # Default to REST
            protocol="http",
            upstream=upstream,
            routes=[],
        )

        return service

    def _map_envoy_lb_policy(self, lb_policy: str) -> str:
        """Map Envoy LB policy to GAL algorithm."""
        mapping = {
            "ROUND_ROBIN": "round_robin",
            "LEAST_REQUEST": "least_conn",
            "RING_HASH": "ip_hash",
            "RANDOM": "round_robin",  # Fallback
            "MAGLEV": "ip_hash",  # Consistent hashing
        }
        return mapping.get(lb_policy, "round_robin")

    def _parse_listener_routes(
        self, listener: Dict[str, Any], cluster_map: Dict[str, Service]
    ) -> None:
        """Parse listener routes and add them to corresponding services."""
        filter_chains = listener.get("filter_chains", [])

        for filter_chain in filter_chains:
            filters = filter_chain.get("filters", [])

            for filter_config in filters:
                if filter_config.get("name") != "envoy.filters.network.http_connection_manager":
                    continue

                typed_config = filter_config.get("typed_config", {})

                # Parse HTTP filters (JWT, GeoIP, Lua)
                http_filters = typed_config.get("http_filters", [])
                jwt_config, geoip_config = self._parse_http_filters(http_filters)

                route_config = typed_config.get("route_config", {})
                virtual_hosts = route_config.get("virtual_hosts", [])

                for vhost in virtual_hosts:
                    routes = vhost.get("routes")
                    if routes is None:
                        continue

                    for route in routes:
                        match = route.get("match", {})
                        route_action = route.get("route", {})

                        # Extract path
                        path_prefix = match.get("prefix", "/")

                        # Extract cluster
                        cluster_name = route_action.get("cluster", "")
                        if cluster_name in cluster_map:
                            service = cluster_map[cluster_name]

                            # Create GAL route
                            gal_route = Route(path_prefix=path_prefix)

                            # If JWT or GeoIP filters are present, attach them to the route
                            if jwt_config or geoip_config:
                                # Create basic AdvancedRoutingConfig
                                # (We detect actual routing rules from route configs separately)
                                adv_routing = AdvancedRoutingConfig(
                                    enabled=True,
                                    evaluation_strategy="first_match",
                                    header_rules=[],
                                    query_param_rules=[],
                                    jwt_claim_rules=[],
                                    geo_rules=[],
                                    jwt_filter=jwt_config,
                                    geoip_filter=geoip_config
                                )
                                gal_route.advanced_routing = adv_routing

                            service.routes.append(gal_route)

                            logger.debug(f"Mapped route {path_prefix} → service {service.name}")

    def _parse_http_filters(self, http_filters: List[dict]) -> Tuple[Optional[JWTFilterConfig], Optional[GeoIPFilterConfig]]:
        """Parse JWT and GeoIP filters from http_filters list.

        Args:
            http_filters: List of Envoy HTTP filter configurations

        Returns:
            Tuple of (JWTFilterConfig, GeoIPFilterConfig) or (None, None)
        """
        jwt_config = None
        geoip_config = None

        for filter_dict in http_filters:
            filter_name = filter_dict.get('name', '')

            # Parse JWT Authentication filter
            if filter_name == 'envoy.filters.http.jwt_authn':
                jwt_config = self._parse_jwt_filter(filter_dict)
                logger.debug(f"Parsed JWT filter: issuer={jwt_config.issuer if jwt_config else 'none'}")

            # Parse GeoIP External Authorization filter
            elif filter_name == 'envoy.filters.http.ext_authz':
                geoip_config = self._parse_geoip_filter(filter_dict)
                logger.debug(f"Parsed GeoIP filter: service={geoip_config.geoip_service_uri if geoip_config else 'none'}")

        return jwt_config, geoip_config

    def _parse_jwt_filter(self, filter_dict: dict) -> Optional[JWTFilterConfig]:
        """Parse JWT Authentication filter configuration.

        Args:
            filter_dict: Envoy jwt_authn filter configuration

        Returns:
            JWTFilterConfig object or None
        """
        typed_config = filter_dict.get('typed_config', {})
        providers = typed_config.get('providers', {})

        if not providers:
            return None

        # Get first provider (usually 'jwt_provider')
        provider_name = list(providers.keys())[0]
        provider_config = providers[provider_name]

        # Extract configuration
        issuer = provider_config.get('issuer', '')
        audiences = provider_config.get('audiences', [])
        audience = audiences[0] if audiences else ''

        # Extract JWKS URI
        remote_jwks = provider_config.get('remote_jwks', {})
        http_uri = remote_jwks.get('http_uri', {})
        jwks_uri = http_uri.get('uri', '')
        jwks_cluster = http_uri.get('cluster', 'jwks_cluster')

        # Extract metadata configuration
        payload_in_metadata = provider_config.get('payload_in_metadata', 'jwt_payload')
        forward_payload_header = provider_config.get('forward_payload_header', '')

        return JWTFilterConfig(
            enabled=True,
            issuer=issuer,
            audience=audience,
            jwks_uri=jwks_uri,
            jwks_cluster=jwks_cluster,
            payload_in_metadata=payload_in_metadata,
            forward_payload_header=forward_payload_header
        )

    def _parse_geoip_filter(self, filter_dict: dict) -> Optional[GeoIPFilterConfig]:
        """Parse GeoIP External Authorization filter configuration.

        Args:
            filter_dict: Envoy ext_authz filter configuration

        Returns:
            GeoIPFilterConfig object or None
        """
        typed_config = filter_dict.get('typed_config', {})
        http_service = typed_config.get('http_service', {})

        if not http_service:
            return None

        # Extract GeoIP service URI
        server_uri = http_service.get('server_uri', {})
        geoip_service_uri = server_uri.get('uri', '')
        geoip_cluster = server_uri.get('cluster', 'geoip_service')

        # Extract timeout
        timeout_str = server_uri.get('timeout', '0.5s')
        timeout_ms = int(float(timeout_str.rstrip('s')) * 1000)

        # Extract failure mode
        failure_mode_allow = typed_config.get('failure_mode_allow', True)

        return GeoIPFilterConfig(
            enabled=True,
            geoip_service_uri=geoip_service_uri,
            geoip_cluster=geoip_cluster,
            timeout_ms=timeout_ms,
            failure_mode_allow=failure_mode_allow
        )
